<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.igiven.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more">
<meta property="og:type" content="article">
<meta property="og:title" content="Converting between Structs and Byte Arrays">
<meta property="og:url" content="http://www.igiven.com/dotnet-2021-05-01-Converting-between-Structs-and-Byte-Arrays/index.html">
<meta property="og:site_name" content="IGiven">
<meta property="og:description" content="In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-01T00:00:00.000Z">
<meta property="article:modified_time" content="2021-06-26T09:35:06.839Z">
<meta property="article:author" content="zhepama">
<meta property="article:tag" content="Win">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="GitHub">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.igiven.com/dotnet-2021-05-01-Converting-between-Structs-and-Byte-Arrays/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Converting between Structs and Byte Arrays | IGiven</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="IGiven" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="IGiven" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">IGiven</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">李九仙的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">139</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-留言">

    <a href="/guestbook/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>留言</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>RSS</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2021-05-01-Converting-between-Structs-and-Byte-Arrays/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://secure.gravatar.com/avatar/0930091f05ac4d1044c02dbd3d619cfe?s=80&d=identicon&r=g">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Converting between Structs and Byte Arrays<a href="https://github.com/zhepama/igiven.github.io/edit/master/source/_posts/dotnet/2021-05-01-Converting%20between%20Structs%20and%20Byte%20Arrays.md" class="post-edit-link" title="编辑" rel="noopener" target="_blank"><i class="fa fa-pencil-alt"></i></a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-01 08:00:00" itemprop="dateCreated datePublished" datetime="2021-05-01T08:00:00+08:00">2021-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-26 17:35:06" itemprop="dateModified" datetime="2021-06-26T17:35:06+08:00">2021-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more information through inheritance, attributes, and more.</p>
<p>However, sometimes we need to extract the data contained in these types – for example for sending network messages, or saving to disk. In this post we will look into converting between structs and byte arrays, to make exactly this possible.</p>
<p>We will compare different ways of doing so, and analyse them for performance and easy of use.</p>
<h2 id="Why-byte-arrays"><a href="#Why-byte-arrays" class="headerlink" title="Why byte arrays?"></a>Why byte arrays?</h2><p>The reason we will be looking into serialising our data into byte arrays is because these are essentially the most fundamental data storage format. We can easily write them to a network buffer or stream, or to a file.</p>
<p>There are many alternatives and none of them will be right for every single use case. For example, I like to use JSON files to store settings, scripts, and text-based assets, as well as asset meta data.</p>
<p>In those cases performance is not the most important consideration. Instead it is more valuable to be able to edit and review files easily inside a text editor.</p>
<p>In situations where performance is important however – such as the mentioned networking or compact file storage – serialising only the relevant data itself and skipping the encoding and formatting inherent to clear text files can be key.</p>
<h2 id="Why-structures"><a href="#Why-structures" class="headerlink" title="Why structures?"></a>Why structures?</h2><p>There are several reasons for why we are talking about structures specifically.</p>
<p>First, I want to make a clear distinction between data and behaviour, by using a type that contains exactly the data we are interested in serialising.</p>
<p>Secondly, structures are much more reliable and controllable when it comes to binary data layout. We will see how this is important for our last method of serialisation.</p>
<p>Overall, we can use structures to directly represent the data that will be written into our byte array. For our example of networking this means that we have a clear one to one correspondence between our structures and our network messages.</p>
<h2 id="BinaryFormatter"><a href="#BinaryFormatter" class="headerlink" title="BinaryFormatter"></a><code>BinaryFormatter</code></h2><p>In our first method of converting between structs and byte arrays, we will make use of .NET’s <a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx" target="_blank" rel="noopener">BinaryFormatter</a> class.</p>
<p>The entire purpose of that class is to serialise an object into binary format (i.e. a byte array) – as well as deserialising the same back into objects.</p>
<p>The class offers a lot of functionality – most of which we are not interested in here. Of interest to us are only two methods: <code>Serialize()</code> and <code>Deserialize()</code>.</p>
<p>These methods allow us to read/write our data to any stream. In many cases we could use this to write to a network – or file – buffer or stream directly. For our purpose – and for ease of testing, we will use the <code>MemoryStream</code> class which is little more than a stream wrapper around a byte array in the first place.</p>
<p>Here are two generic methods that do exactly this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] Serialize&lt;T&gt;(T data)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var formatter &#x3D; new BinaryFormatter();</span><br><span class="line">    var stream &#x3D; new MemoryStream();</span><br><span class="line">    formatter.Serialize(stream, data);</span><br><span class="line">    return stream.ToArray();</span><br><span class="line">&#125;</span><br><span class="line">public static T Deserialize&lt;T&gt;(byte[] array)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var stream &#x3D; new MemoryStream(array);</span><br><span class="line">    var formatter &#x3D; new BinaryFormatter();</span><br><span class="line">    return (T)formatter.Deserialize(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>These methods can now be easily used like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Serializable] &#x2F;&#x2F; BinaryFormatter needs this attribute</span><br><span class="line">struct MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; some fields here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data &#x3D; new MyStruct();</span><br><span class="line">var bytes &#x3D; Serialize(data);</span><br><span class="line">var data2 &#x3D; Deserialize&lt;MyStruct&gt;(bytes);</span><br><span class="line">&#x2F;&#x2F; data and data2 now contain the same values</span><br></pre></td></tr></table></figure>

<p>This looks great!</p>
<p>It seems that we have found a solution that is both easy to use, and requires almost no work if we want to expand it. Allowing for the conversion of new structs simple requires the addition of the <code>Serializable</code> attribute, while we have to do nothing at all if we modify our structures to include more, less, or different data.</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>How about performance?</p>
<p>I wrote a little test that both serialises and deserialises hundreds of thousands of times, and repeats that process several times to make sure we get accurate results. You can find the full code of it <a href="https://github.com/amulware/genericgamedev-tests/tree/master/src/StructByteArrayConversion" target="_blank" rel="noopener">on my GitHub</a></p>
<p>Here are the results:</p>
<p>Using <code>BinaryFormatter</code>,<br>– converting a 16 byte structs to an array one million times takes 4.86 seconds;<br>– converting an array to a 16 byte struct one million times takes 3.85 seconds.</p>
<p>This means that a single call to either of our methods takes less than 5 microseconds.</p>
<p>That is pretty good!</p>
<p>With this performance we can easily write and read thousands of networking messages per second before we will notice the performance impact. That is easily enough for most games and other real-time applications.</p>
<p>There is another kind of performance measurement that is important however – and especially so when it comes to networking: Bandwidth.</p>
<p>The struct I ran the tests with consisted of exactly 16 bytes. That means that in principle we should be able to write it into a byte array with length 16. The BinaryFormatter however – and this is related to the other features it has – writes a total of 218 bytes to the array.</p>
<p>Suffice it to say: That is a whole lot more.</p>
<p>The advantage of this is, that the object that is deserialised will actually be of the correct type. I merely made the method generic so that we could perform the cast and return the structure boxed in the result of <code>BinaryFormatter.Deserialize()</code>.</p>
<p>There are cases were we care less about the amount of data, and prefer to handle our data in this way. For this post however, I want to find a method that results in an array as small as possible.</p>
<h2 id="BinaryWriter-BinaryReader"><a href="#BinaryWriter-BinaryReader" class="headerlink" title="BinaryWriter/BinaryReader"></a><code>BinaryWriter</code>/<code>BinaryReader</code></h2><p>Our second case study will be two other .NET classes: <a href="https://msdn.microsoft.com/en-us/library/system.io.binaryreader(v=vs.110).aspx" target="_blank" rel="noopener">BinaryWriter</a> and <a href="https://msdn.microsoft.com/en-us/library/system.io.binarywriter(v=vs.110).aspx" target="_blank" rel="noopener">BinaryReader</a></p>
<p>These classes are much simpler. They do little more than allowing us to write and read primitive types like integers and booleans to and from an arbitrary stream.</p>
<p>This means that we cannot write the entire structure to our stream with just a single line of code any more. Instead we need to write and read all fields manually:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    int anInteger;</span><br><span class="line">    float aFloat;</span><br><span class="line">    long aLong;</span><br><span class="line"></span><br><span class="line">    public byte[] ToArray()</span><br><span class="line">    &#123;</span><br><span class="line">        var stream &#x3D; new MemoryStream();</span><br><span class="line">        var writer &#x3D; new BinaryWriter(stream);</span><br><span class="line"></span><br><span class="line">        writer.Write(this.anInteger);</span><br><span class="line">        writer.Write(this.aFloat);</span><br><span class="line">        writer.Write(this.aLong);</span><br><span class="line"></span><br><span class="line">        return stream.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyStruct FromArray(byte[] bytes)</span><br><span class="line">    &#123;</span><br><span class="line">        var reader &#x3D; new BinaryReader(new MemoryStream(bytes));</span><br><span class="line"></span><br><span class="line">        var s &#x3D; default(MyStruct);</span><br><span class="line"></span><br><span class="line">        s.anInteger &#x3D; reader.ReadInt32();</span><br><span class="line">        s.aFloat &#x3D; reader.ReadSingle();</span><br><span class="line">        s.aLong &#x3D; reader.ReadInt64();</span><br><span class="line"></span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using these methods is similarly easy to the ones above:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data &#x3D; new MyStruct();</span><br><span class="line">var array &#x3D; data.ToArray();</span><br><span class="line">var data2 &#x3D; MyStruct.FromArray(array);</span><br></pre></td></tr></table></figure>

<p>In this case, the returned array is indeed exactly 16 bytes long.</p>
<h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><p>But how does this manual approach measure up in performance?</p>
<p>Very well!</p>
<p>In my test, the times for serialising and deserialising went from 4.86 and 3.85 down to 0.50 and 0.20 seconds respectively (again for one million conversions each).</p>
<p>It turns out this approach is not only space efficient, but it is also around ten times faster than the previous one – seemingly no reason to look back!</p>
<p>In fact, there is an optimisation we can make to increase performance even further: We do not have to create new <code>MemoryStream</code>s and <code>BinaryReader</code>/<code>BinaryWriter</code>s for each method call. Instead we can reuse them – either by having static ones (watch out for thread-safety!) or by keeping them in whatever object manages for example our network traffic.</p>
<p>Doing so drops my measured time down to 0.14 and 0.11 seconds respectively.</p>
<p>Note that the same optimisation can be applied to the first method. However – while positive – the performance increase is much less than in this case, relative to the overall much worse time.</p>
<h3 id="Some-concerns"><a href="#Some-concerns" class="headerlink" title="Some concerns"></a>Some concerns</h3><p>If we do look back to the code however, note how if we add another structure that we would like to serialise, we have to add the two methods to it, and adapt them to its fields.</p>
<p>Further, if we change one of our structures, we have to make sure to reflect that change in both of these methods. We are bound to forget – especially when adding a new field – which could easily result in a small debugging nightmare.</p>
<p>Ideally we can find a solution that is fast, uses little space, and does not require us to continuously maintain our serialisation code.</p>
<h2 id="Marshalling"><a href="#Marshalling" class="headerlink" title="Marshalling"></a>Marshalling</h2><p>The last approach we will take a look at is that of marshalling.</p>
<p>Marshalling refers to using both managed and unmanaged data and the transfer between them. By default, any object created in C# lives in managed memory, which has a lot of advantages – such as automatic garbage collection. Using unmanaged memory on the other hand is more difficult in C#, and requires us to allocate and free space manually. If we forget to do so, we may cause memory leaks that will eventually cause our application to crash.</p>
<p>All of the functionality we are interested in can be found in the static <a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal(v=vs.100).aspx" target="_blank" rel="noopener">Marshal</a> class.</p>
<p>Specifically, we will use:</p>
<ul>
<li><code>Marshal.SizeOf()</code><br>to determine the byte size of our structs;</li>
<li><code>Marshal.AllocHGlobal()</code><br>to allocate unmanaged memory;</li>
<li><code>Marshal.StructureToPtr()</code><br>to marshal (copy) our structure to the allocated unmanaged memory;</li>
<li><code>Marshal.PtrToStructure()</code><br>to marshal (copy) from unmanaged memory back to our structure;</li>
<li><code>Marshal.Copy()</code><br>to copy between the unmanaged memory and our byte array;</li>
<li><code>Marshal.FreeHGlobal()</code><br>to free the allocated memory;</li>
</ul>
<p>Using these methods we can construct the following methods:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static byte[] Serialize&lt;T&gt;(T s)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var size &#x3D; Marshal.SizeOf(typeof(T));</span><br><span class="line">    var array &#x3D; new byte[size];</span><br><span class="line">    var ptr &#x3D; Marshal.AllocHGlobal(size);</span><br><span class="line">    Marshal.StructureToPtr(s, ptr, true);</span><br><span class="line">    Marshal.Copy(ptr, array, 0, size);</span><br><span class="line">    Marshal.FreeHGlobal(ptr);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static T Deserialize&lt;T&gt;(byte[] array)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var size &#x3D; Marshal.SizeOf(typeof(T));</span><br><span class="line">    var ptr &#x3D; Marshal.AllocHGlobal(size);</span><br><span class="line">    Marshal.Copy(array, 0, ptr, size);</span><br><span class="line">    var s &#x3D; (T)Marshal.PtrToStructure(ptr, typeof(T));</span><br><span class="line">    Marshal.FreeHGlobal(ptr);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that due to the unsafety of using unmanaged memory, we may want to use a <a href="https://msdn.microsoft.com/en-us/library/zwc8s4fz.aspx" target="_blank" rel="noopener">try – finally</a> block to make sure the memory will always be freed, even if something goes wrong. For brevity, this is left out here.</p>
<p>When testing our code, which again is as easy to use as before – in fact the method signatures are exactly the same as our first pair – we see that it indeed works as we hope.</p>
<p>Without any code inside our structures and completely generic methods there is no need to write or maintain any code when adding or modifying structures.</p>
<p>Further the resulting array is the expected 16 bytes long.</p>
<h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><p>When running these methods through the tests, converting structs to byte arrays and vice versa takes a mere 0.47 and 0.60 seconds respectively (again for one million calls).</p>
<h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p>Here is a table with the results from the performance tests:</p>
<table>
<thead>
<tr>
<th align="left">16 byte struct</th>
<th align="left">struct to array</th>
<th align="left">array to struct</th>
</tr>
</thead>
<tbody><tr>
<td align="left">binary formatter (218 byte array!)</td>
<td align="left">4.86s</td>
<td align="left">3.85s</td>
</tr>
<tr>
<td align="left">binary writer/reader</td>
<td align="left">0.50s</td>
<td align="left">0.20s</td>
</tr>
<tr>
<td align="left"><strong>binary w/r (singleton)</strong></td>
<td align="left"><strong>0.14s</strong></td>
<td align="left"><strong>0.11s</strong></td>
</tr>
<tr>
<td align="left">marshalling</td>
<td align="left">0.47s</td>
<td align="left">0.60s</td>
</tr>
</tbody></table>
<p>Clearly, if what we care about most is performance, writing and reading our data manually, using shared <code>BinaryWriter</code> and <code>BinaryReader</code> objects is the fastest method.</p>
<p>On the other hand, the <code>BinaryFormatter</code> and <code>Marshal</code> methods allow for much easier reuse and make our code significantly more robust to change since there is no code to update and maintain.</p>
<p>To provide some more data, here are the results from the same test, but this time with a 128 byte structure:</p>
<table>
<thead>
<tr>
<th align="left">128 byte struct</th>
<th align="left">struct to array</th>
<th align="left">array to struct</th>
</tr>
</thead>
<tbody><tr>
<td align="left">binary formatter (218 byte array!)</td>
<td align="left">17.32s</td>
<td align="left">14.47s</td>
</tr>
<tr>
<td align="left">binary writer/reader</td>
<td align="left">1.48s</td>
<td align="left">0.66s</td>
</tr>
<tr>
<td align="left"><strong>binary w/r (singleton)</strong></td>
<td align="left"><strong>0.78s</strong></td>
<td align="left"><strong>0.56s</strong></td>
</tr>
<tr>
<td align="left">marshalling</td>
<td align="left">0.84s</td>
<td align="left">0.75s</td>
</tr>
</tbody></table>
<p>We can see that the relative ordering of the different measurements is still the same. However, note how the <code>BinaryWriter</code> and <code>BinaryReader</code> measurements are getting significantly closer to the <code>Marshal</code> ones.</p>
<p>While I would not necessarily encourage structures of this size, I would argue that marshalling is the best approach for large structures in almost every case. The slightly slower performance is easily justified by the much more maintainable code.</p>
<p>In fact, I would go as far and say that even for small structures the ease of using marshalling is still top advantageous despite the lower performance.</p>
<p>In the end, binary serialization is unlikely to ever be a bottleneck, and unless it is, we should choose the option that fulfils our requirements of small array size and ease of use.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We took a look at three – and a half – different ways of converting between structs and byte arrays.</p>
<p>Judging by memory usage, performance, and ease of use, there is no clear winner – only a clear loser unless we specifically need the additional functionality of <code>BinaryFormatter</code>.</p>
<p>However, in marshalling we found a method that is reasonably fast, while acing our other requirements.</p>
<p>While in extremely performance critical code we may want to write our data manually, marshalling is likely the best alternative in the vast majority of cases.</p>
<p>Feel free to let me know if you agree with this analysis, or if you have other methods of achieving the same result that may be worth looking into.</p>
<p>Enjoy the pixels!</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Win/" rel="tag"># Win</a>
              <a href="/tags/C/" rel="tag"># C</a>
              <a href="/tags/C/" rel="tag"># C#</a>
              <a href="/tags/GitHub/" rel="tag"># GitHub</a>
              <a href="/tags/JS/" rel="tag"># JS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/unity-2021-04-11-render-texture/" rel="prev" title="Unity RenderTexture的应用">
      <i class="fa fa-chevron-left"></i> Unity RenderTexture的应用
    </a></div>
      <div class="post-nav-item">
    <a href="/tool-2021-05-06-dns/" rel="next" title="一些常用的dns服务器">
      一些常用的dns服务器 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="zhepama/igiven.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Why-byte-arrays"><span class="nav-number">1.</span> <span class="nav-text">Why byte arrays?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Why-structures"><span class="nav-number">2.</span> <span class="nav-text">Why structures?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BinaryFormatter"><span class="nav-number">3.</span> <span class="nav-text">BinaryFormatter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance"><span class="nav-number">3.1.</span> <span class="nav-text">Performance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BinaryWriter-BinaryReader"><span class="nav-number">4.</span> <span class="nav-text">BinaryWriter&#x2F;BinaryReader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance-1"><span class="nav-number">4.1.</span> <span class="nav-text">Performance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Some-concerns"><span class="nav-number">4.2.</span> <span class="nav-text">Some concerns</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Marshalling"><span class="nav-number">5.</span> <span class="nav-text">Marshalling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance-2"><span class="nav-number">5.1.</span> <span class="nav-text">Performance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparison"><span class="nav-number">6.</span> <span class="nav-text">Comparison</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conclusion"><span class="nav-number">7.</span> <span class="nav-text">Conclusion</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zhepama"
      src="https://secure.gravatar.com/avatar/0930091f05ac4d1044c02dbd3d619cfe?s=80&d=identicon&r=g">
  <p class="site-author-name" itemprop="name">zhepama</p>
  <div class="site-description" itemprop="description">一个不专业的程序员,写着专业的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhepama" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhepama" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhepama@gmail.com" title="E-Mail → mailto:zhepama@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.godgodgame.com/" title="http:&#x2F;&#x2F;www.godgodgame.com" rel="noopener" target="_blank">GODGODGAME</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.igiven.com/" title="https:&#x2F;&#x2F;www.igiven.com">IGIVEN</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zhepama.github.io/C-Sharp-Playground/zh/" title="https:&#x2F;&#x2F;zhepama.github.io&#x2F;C-Sharp-Playground&#x2F;zh&#x2F;" rel="noopener" target="_blank">数据结构与算法</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhepama</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
