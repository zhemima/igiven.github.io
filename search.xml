<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux部署dotnetcore记录</title>
    <url>/dotnet-2019-06-05-linux-dotnet-daemon/</url>
    <content><![CDATA[<h2 id="Daemon"><a href="#Daemon" class="headerlink" title="Daemon"></a>Daemon</h2><p>Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等…</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;KestrelDemoSer.service</span><br></pre></td></tr></table></figure>
<p>修改配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;KestrelDemo running on CentOS</span><br><span class="line">[Service]</span><br><span class="line">WorkingDirectory&#x3D;&#x2F;cusD&#x2F;wwwroot&#x2F;KesPublish</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">User&#x3D;root</span><br><span class="line">Group&#x3D;root</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dotnet &#x2F;cusD&#x2F;wwwroot&#x2F;KesPublish&#x2F;KestrelDemo.dll</span><br><span class="line">Restart&#x3D;always</span><br><span class="line"># Restart service after 10 seconds if the dotnet service crashes:</span><br><span class="line">RestartSec&#x3D;10</span><br><span class="line">SyslogIdentifier&#x3D;dotnet-example</span><br><span class="line">Environment&#x3D;ASPNETCORE_ENVIRONMENT&#x3D;Production</span><br><span class="line">Environment&#x3D;DOTNET_PRINT_TELEMETRY_MESSAGE&#x3D;false</span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable KestrelDemoSer.service</span><br><span class="line">systemctl start KestrelDemoSer.service</span><br><span class="line">systemctl status KestrelDemoSer.service</span><br><span class="line">sudo journalctl -fu KestrelDemoSer.service  &#x2F;&#x2F;查看日志</span><br></pre></td></tr></table></figure>

<h2 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop edu</span><br><span class="line">sudo dotnet publish -c Release $&#123;WORKSPACE&#125;/src/Edu.Web/Edu.Web.csproj -o /usr/local/src/edu</span><br><span class="line">sudo systemctl start edu</span><br></pre></td></tr></table></figure>

<h3 id="efcore-update"><a href="#efcore-update" class="headerlink" title="efcore update"></a>efcore update</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dotnet ef database update --context Edu.EntityFrameworkCore.EduMigrationsDbContext --startup-project ./src/Edu.Web/Edu.Web.csproj --project ./src/Edu.EntityFrameworkCore.DbMigrations/Edu.EntityFrameworkCore.DbMigrations.csproj   -v</span><br></pre></td></tr></table></figure>

<p>不能使用sudo的解决办法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line"></span><br><span class="line">jenkins ALL&#x3D;(ALL) NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure>

<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>从windows迁移到linux时..mysql数据库的表明可能会有大小写敏感的问题<br>修改mysql配置my.ini</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lower_case_table_names &#x3D; 0 &#x2F;&#x2F;mysql会根据表名直接操作，大小写敏感。 </span><br><span class="line">lower_case_table_names &#x3D; 1 &#x2F;&#x2F;mysql会先把表名转为小写，再执行操作。</span><br></pre></td></tr></table></figure>



<h1 id="windows下绝对路径启动问题"><a href="#windows下绝对路径启动问题" class="headerlink" title="windows下绝对路径启动问题"></a>windows下绝对路径启动问题</h1><p>注册成services后.他的启动目录是C:\Windows\System32..所以需要手动设置下contentRoot</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F:\DotHass.Blog\aspnet-core\src\DotHass.Blog.Web\bin\Release\publish\DotHass.Blog.Web.exe --contentRoot F:\DotHass.Blog\aspnet-core\src\DotHass.Blog.Web\bin\Release\publish</span><br></pre></td></tr></table></figure>

<p>如果启动失败..先查看错误日志..最好是用文件存储</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>shell</tag>
        <tag>windows</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>时间轮的引入</title>
    <url>/dotnet-2019-10-29-time-wheel/</url>
    <content><![CDATA[<p>问题引入：在mmorpg游戏中，群战的时候，玩家释放技能，这时候会出现技能冷却时间，每一个技能都是一个定时器，或者在slg游戏中，玩家修建房屋，创建基地，都会产生一个延时操作，等到了指定时间后，完成房屋修建等任务！！！！！</p>
<p>轮询的尴尬：使用一个定时器，定时遍历多个链表，判定链表里面的任务是否到期！ 效率低下,每一次遍历都需要筛选定时器，时间复杂度O（n）.</p>
<p>多定时器的尴尬：同时创建多个定时器，每个定时器绑定到期任务，多定时器，会加大cpu的负荷，且任务的到期时间不同，必定会产生更多的定时器。</p>
<p>解决方案：时间轮的引入</p>
<p> <img src="../../assets/images/2019-10-29-time-wheel/20180817103356853.png" alt="img"> </p>
<p>如果所示：将同一时间的任务放在一起，组成一个链表，图中每个格子分别指向这样一个链表，定时器每到期一次，图中的指针移动一格，如此循环往复，当指针指向某个格子，代表这个链表里面的定时器可能到期（注意，这里是可能，因为时间轮是一个循环的圈，比如运行一圈需要时间50s,那么一个100s的定时器，虽然在槽位1的链表中，但是需要时间轮运行两圈，这个定时器才到期）</p>
<h2 id="A-full-example"><a href="#A-full-example" class="headerlink" title="A full example"></a>A full example</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Task fired repeatedly</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">class IntervalTimerTask : TimerTask</span><br><span class="line">&#123;</span><br><span class="line">    public void Run(Timeout timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;IntervalTimerTask is fired at &#123;DateTime.UtcNow.Ticks &#x2F; 10000000L&#125;&quot;);</span><br><span class="line">        timeout.Timer.NewTimeout(this, TimeSpan.FromSeconds(2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Task only be fired for one time</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">class OneTimeTask : TimerTask</span><br><span class="line">&#123;</span><br><span class="line">    readonly string _userData;</span><br><span class="line">    public OneTimeTask(string data)</span><br><span class="line">    &#123;</span><br><span class="line">        _userData &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Run(Timeout timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;&#123;_userData&#125; is fired at &#123;DateTime.UtcNow.Ticks &#x2F; 10000000L&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    HashedWheelTimer timer &#x3D; new HashedWheelTimer( tickDuration: TimeSpan.FromSeconds(1)</span><br><span class="line">        , ticksPerWheel: 100000</span><br><span class="line">        , maxPendingTimeouts: 0);</span><br><span class="line"></span><br><span class="line">    timer.NewTimeout(new OneTimeTask(&quot;A&quot;), TimeSpan.FromSeconds(5));</span><br><span class="line">    timer.NewTimeout(new OneTimeTask(&quot;B&quot;), TimeSpan.FromSeconds(4));</span><br><span class="line">    var timeout &#x3D; timer.NewTimeout(new OneTimeTask(&quot;C&quot;), TimeSpan.FromSeconds(3));</span><br><span class="line">    timer.NewTimeout(new OneTimeTask(&quot;D&quot;), TimeSpan.FromSeconds(2));</span><br><span class="line">    timer.NewTimeout(new OneTimeTask(&quot;E&quot;), TimeSpan.FromSeconds(1));</span><br><span class="line"></span><br><span class="line">    timeout.Cancel();</span><br><span class="line"></span><br><span class="line">    timer.NewTimeout(new IntervalTimerTask(), TimeSpan.FromSeconds(5));</span><br><span class="line">    Console.WriteLine($&quot;&#123;DateTime.UtcNow.Ticks &#x2F; 10000000L&#125; : Started&quot;);</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The output of the sample is something like</p>
<p><img src="../../assets/images/2019-10-29-time-wheel/console.png" alt=""></p>
<p>c# 的实现</p>
<ul>
<li><a href="https://github.com/wangjia184/HashedWheelTimer" target="_blank" rel="noopener">https://github.com/wangjia184/HashedWheelTimer</a> </li>
<li><a href="https://github.com/fanrice123/HashedWheelTimer.NET" target="_blank" rel="noopener">https://github.com/fanrice123/HashedWheelTimer.NET</a> </li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>帧同步的相关问题</title>
    <url>/dotnet-2019-11-01-lock-step/</url>
    <content><![CDATA[<h2 id="Lock-Step"><a href="#Lock-Step" class="headerlink" title="Lock-Step"></a>Lock-Step</h2><ol>
<li><p>我们把游戏的前进分为一帧帧，这里的帧和游戏的渲染帧率并不是一个，只是借鉴了帧的概念，自定义的帧，我们称为turn。游戏的过程就是每一个turn不断向前推进，每一个玩家的turn推进速度一致。</p>
</li>
<li><p>每一帧只有当服务器集齐了所有玩家的操作指令，也就是输入确定了之后，才可以进行计算，进入下一个turn，否则就要等待最慢的玩家。之后再广播给所有的玩家。如此才能保证帧一致。</p>
</li>
<li><p>Lockstep的游戏是严格按照turn向前推进的，如果有人延迟比较高，其他玩家必须等待该玩家跟上之后再继续计算，不存在某个玩家领先或落后其他玩家若干个turn的情况。使用Lockstep同步机制的游戏中，每个玩家的延迟都等于延迟最高的那个人。</p>
</li>
<li><p>由于大家的turn一致，以及输入固定，所以每一步所有客户端的计算结果都一致的。</p>
</li>
</ol>
<p>我们来看看具体的执行流程:</p>
<p><img src="../../assets/images/2019-11-01-lock-step/113252_S4Vd_1859679.png" alt="img"></p>
<p>上图中我们可以明显看到，这种囚徒模式的帧同步，在第二帧的时候，因为玩家1有延迟，而导致第二帧的同步时间发生延迟，从而导致所有玩家都在等待，出现卡顿现象</p>
<h2 id="Bucket-Synchronization-乐观锁"><a href="#Bucket-Synchronization-乐观锁" class="headerlink" title="Bucket Synchronization(乐观锁)"></a>Bucket Synchronization(乐观锁)</h2><p>囚徒模式的帧同步，有一个致命的缺陷就是，若联网的玩家有一个网速慢了，势必会影响其他玩家的体验，因为服务器要等待所有输入达到之后再同步到所有的c端。另外如果中途有人掉线了，游戏就会无法继续或者掉线玩家无法重连，因为在严格的帧同步的情况下，中途加入游戏是从技术上来讲是非常困难的。因为你重新进来之后，你的初始状态和大家不一致，而且你的状态信息都是丢失状态的，比如，你的等级，随机种子，角色的属性信息等。 比如玩过早期的冰封王座都知道，一旦掉线基本这局就废了，需要重开，至于为何没有卡顿的现象，因为那时都是解决方案都是采用局域网的方式，所以基本是没有延迟问题的。</p>
<p>后期为了解决这个问题，如今包括王者荣耀，服务器会保存玩家当场游戏的游戏指令以及状态信息，在玩家断线重连的时候，能够恢复到断线前的状态。不过这个还是无法解决帧同步的问题，因为严格的帧同步，是要等到所有玩家都输入之后，再去通知广播client更新，如果A服务器一直没有输入同步过来，大家是要等着的，那么如何解决这个问题？</p>
<p>采用“定时不等待”的乐观方式在每次Interval时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新。如此帧率的时钟在由服务器控制，当客户端有操作的时候及时的发送服务器，然后服务端每秒钟20-50次向所有客户端发送更新消息。如下图:</p>
<p><img src="../../assets/images/2019-11-01-lock-step/113303_rNd5_1859679.png" alt="img"></p>
<p>上图中，我们看到服务器不会再等到搜集完所有用户输入再进行下一帧，而是按照固定频率来同步玩家的输入信息到每一个c端，如果有玩家网络延迟，服务器的帧步进是不会等待的，比如上图中，在第二帧的时候，玩家A的网速慢，那么他这个时候，会被网速快的玩家给秒了（其他游戏也差不多）。但是网速慢的玩家不会卡到快的玩家，只会感觉自己操作延迟而已。</p>
<p>Bucket Synchronization 是 Lock-Step 的改良算法. 算法流程可以参考下图:</p>
<p><img src="../../assets/images/2019-11-01-lock-step/bucket.png" alt="img"></p>
<p>Bucket Synchronization 算法应用于网状网络, 网络中有一个 master 节点(也是 client).</p>
<p>master 在启动之初, 会对所有 client 做网络对时, 计算网络包的超时时间.</p>
<p>master 会设置一个 bucket 时间, 在每个 bucket 时间节点, master 执行收集到的所有 step 指令, 并将更新推送到所有的 client 上. (上图的例子是一个简化流程, 只有俩 client, 没有 master 推送)</p>
<p>master 对收集到的 step 包做超时校验机制, 如果收到的 step 指令包的时间戳, 延迟超过了预设的阈值, 就当作超时包丢弃.</p>
<p>与 Lock-Step 相比, Bucket Synchronization 改进的是: 设置了 bucket 的概念, 执行每一帧的时间是固定的 bucket 时间节点, 而不必等到收到所有的 client step 指令, 从而网络不再受最差的 client 限制.</p>
<h2 id="TimeWrap-Synchronization"><a href="#TimeWrap-Synchronization" class="headerlink" title="TimeWrap Synchronization"></a><strong>TimeWrap Synchronization</strong></h2><p> 它是一个基于某些状态支持回滚(rollback)的同步算法。有点类似HL的做法。<br> 简言之，就是对每个操作指令的执行后保存一个状态快照(snapshot)，<br>各个peer按照自己的预测先行显示，但在发生一致性冲突的情况下，<br>回滚到上一个状态，并重新将指令序列在基于回滚后的快照的基础上再<br>执行一次，以获得正确的当前状态。 </p>
<h2 id="Trailing-State-Synchronization"><a href="#Trailing-State-Synchronization" class="headerlink" title="Trailing State Synchronization"></a><strong>Trailing State Synchronization</strong></h2><p>对TimeWrap Synchronization的一种改进。TimeWrap方案中建立snapshot是<br>以指令数量(1或少量几个指令)间隔为单位；而TSS方案则以某种延迟值(100ms)<br>间隔为单位对游戏做snapshot(比如100ms前做一个，200ms前做一个…)。<br>当发生一致性冲突时，寻找最远需要开始计算的snapshot，并将该snapshot到<br>现在为止的时间内的指令重新执行，得到正确的最新状态。</p>
<h2 id="State-Hash"><a href="#State-Hash" class="headerlink" title="State Hash"></a>State Hash</h2><p> 在实现中客户端需要计算一些关键信息的hash值，提供给服务器以便发现游戏中的同步问题，例如玩家的位置信息，各个客户端计算结果是否一致等等。</p>
<p>客户端执行完每个逻辑帧后，会根据游戏的状态计算出一个Hash值，用其标定一个具体的游戏状态。不同客户端通过对比这个值，即可判断客户端之间是否保持同步，平常也可用于不同步Debug。</p>
<p>游戏外挂的种类有很多，这里所谈的外挂仅指会更改游戏逻辑执行或数值的外挂，应该也是题主最关心的类型。对于帧同步防外挂，因为游戏逻辑执行在本地，假如某个客户端使用了外挂的话，那么必然会导致其计算出的State Hash与其他客户端不一致。</p>
<p>1、 客户端自验证（PVP 3人及以上）</p>
<p>PVP3人及以上的战斗中，客户端上报服务器各自计算的State Hash，服务器可以通过对比State Hash判断具体哪一个客户端发生了不同步。当然，不同步也可能是客户端BUG，不同步也不一定就结算不一致。根绝不同的需求，你也可以在发现不同步后马上中断游戏。这个方法的缺点主要在于3人以下或者单机模式的话就没法使用了。</p>
<p>2、客户端分布式验证</p>
<p>假如客户端的核心逻辑写得足够干净和独立的话，服务器可以将某一场战斗的数据下发给一个空闲客户端，令其新起一个线程慢慢地计算验证，再将结果上报至服务器。能做到这一点的话，任何战斗模式都可以进行验证了。</p>
<p>3、服务器验证</p>
<p>与客户端分布式验证相同，客户端逻辑如果足够干净和独立，那么服务器也可以自己验算战斗结果。</p>
<p>4、服务器统计与运营策略</p>
<p>非单机模式下，服务器都根据客户端的State Hash对战斗的同步情况进行记录。将经常发生不同步的客户端标记出来，然后进一步处理。运营可以为玩家每日不同步可结算的次数设定一个阈值，超过则当日之后的战斗结算均无效。</p>
<p>1和4是任何帧同步游戏都可以做的，2与3对游戏的框架要求比较高。我们的游戏因为是从单机版改造过来的，所以也只做了1和4。</p>
<ul>
<li><strong>游戏逻辑的回滚</strong></li>
</ul>
<p>回滚逻辑，就是我们解决问题的方案。可以这样理解，客户端的时间，领先服务器，客户端不需要服务器确认帧返回才执行指令，而是玩家输入，立刻执行（其他玩家的输入，按照其最近一个输入做预测，或者其他更优化的预测方案），然后将指令发送给服务器，服务器收到后给客户端确认，客户端收到确认后，如果服务确认的操作，和之前执行的一样（自己和其他玩家预测的操作），将不做任何改变，如果不一样（预测错误），就会将游戏整体逻辑回滚到最后一次服务器确认的正确帧，然后再追上当前客户端的帧。</p>
<p>此处逻辑较为复杂，我尝试举个例子说明下。</p>
<p>当前客户端（A，B）执行到100帧，服务器执行到97帧。在100帧的时候，A执行了移动，B执行了攻击，A和B都通知服务器：我已经执行到100帧，我的操作是移动（A），攻击（B）。服务器在自己的98帧或99帧收到了A，B的消息，存在对应帧的操作数据中，等服务器执行到100帧的时候（或提前），将这个数据广播给AB。</p>
<p>然后A和B立刻开始执行100帧，A执行移动，预测B不执行操作。而B执行攻击，预测A执行攻击（可能A的99帧也是攻击），A和B各自预测对方的操作。</p>
<p>在A和B执行完100帧后，他们会各自保存100帧的状态快照，以及100帧各自的操作（包括预测的操作），以备万一预测错误，做逻辑回滚。</p>
<p>执行几帧后，A，B来到了103帧，服务器到了100帧，他开始广播数据给AB，在一定延迟后，AB收到了服务器确认的100帧的数据，这时候，AB可能已经执行到104了。A和B各自去核对服务器的数据和自己预测的数据是否相同。例如A核对后，100帧的操作，和自己预测的一样，A不做任何处理，继续往前。而B核对后，发现在100帧，B对A的预测，和服务器确认的A的操作，是不一样的（B预测的是攻击，而实际A的操作是移动），B就回滚到上一个确认一样的帧，即99帧，然后根据确认的100帧操作去执行100帧，然后快速执行101<del>103的帧逻辑，之后继续执行104帧，其中（101</del>104）还是预测的逻辑帧。</p>
<p>因为客户端对当前操作的立刻执行，这个操作手感，是完全和pve（不联网状态）是一样的，不存在任何delay。所以，能做到绝佳的操作手感。当预测不一样的时候，做逻辑回滚，快速追回当前操作。</p>
<p>这样，对于网络好的玩家，和网络不好的玩家，都不会互相影响，不会像lockstep一样，网络好的玩家，会被网络不好的玩家lock住。也不会被网络延迟lock住，客户端可以一直往前预测。</p>
<p>对于网络好的玩家（A），可以动态调整（根据动态的latency），让客户端领先服务器少一些，尽量减少预测量，就会尽量减少回滚，例如网络好的，可能客户端只领先2~3帧。</p>
<p>对于网络不好的玩家（B），动态调整，领先服务器多一些，根据latency调整，例如领先5帧。</p>
<p>那么，A可能预测错的情况，只有2~3帧，而网络不好的B，可能预测错误的帧有5帧。通过优化的预测技术，和消息通知的优化，可以进一步减少A和B的预测错误率。对于A而言，战斗是顺畅的，手感很好，少数情况的回滚，优化好了，并不会带来卡顿和延迟感。</p>
<p>重点优化的是B，即网络不好的玩家，他的操作体验。因为客户端不等待服务器确认，就执行操作，所以B的操作手感，和A是一致的，区别只在于，B因为延迟，预测了比较多的帧，可能导致预测错，回滚会多一些。比如按照B的预测，应该在100帧击中A，但是因为预测错误A的操作，回滚重新执行后，B可能在100帧不会击中A。这对于B来说，通过插值和一些平滑方式，B的感受是不会有太大区别的，因为B看自己，操作自己都是及时反馈的，他感觉自己是平滑的。</p>
<p>这种方式，保证了网络不好的B的操作手感，和A一致。回滚导致的一些轻微的抖动，都是B看A的抖动，通过优化（插值，平滑等），进一步减少这些后，B的感受是很好的。我们测试在200~300毫秒随机延迟的情况下，B的操作手感良好。</p>
<p>这里，客户端提前服务器的方式，并且在延迟增大的情况下，客户端将加速，和<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/cOGn8-rHWLIxdDz-R3pXDg">守望先锋的处理方式</a>是一样的。当然，他们肯定比我做得好很多。</p>
<p>希望我已经大致讲清楚了这个逻辑，大家参看几篇链接的文章，能体会更深。</p>
<p>这里，我要强调的一点是，我们这里的预测执行，是真实逻辑的预测，和很多介绍帧同步文章提到的预测是不同的。有些文章介绍的预测执行，只是view层面的预测，例如前摇动作和位移，但是逻辑是不会提前执行的，还是要等服务器的返回。这两种预测执行（View的预测执行，和真实逻辑的预测执行）是完全不是一个概念的，这里需要仔细地区分。</p>
<p>这里有很多的可以优化的点，我就不一一介绍了，以后可能零散地再谈。</p>
<ul>
<li><strong>游戏逻辑的快照（snapshot）</strong></li>
</ul>
<p>我们的逻辑之所以能回滚，都是基于对每一帧状态可以处理快照，存储下每一帧的状态，并可以回滚到任何一帧的状态。在<a href="https://link.zhihu.com/?target=http%3A//mauve.mizuumi.net/2012/07/05/understanding-fighting-game-networking/">Understanding Fighting Game Networking</a> 文章和<a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/cOGn8-rHWLIxdDz-R3pXDg">守望先锋网络</a> 文章中，都一笔带过了快照的说明。他们说的快照，可能略有不同，但是思路，都是能保存下每一帧的状态。如果去处理快照（Understanding那篇文章做的是模拟器游戏，可以方便地以内存快照的方式来做），是一个难点，这也是我<a href="https://zhuanlan.zhihu.com/p/38280972" target="_blank" rel="noopener">前面文章</a>提到ECS在这个方式下的应用，云风的解释：</p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-253646290632dd9ed3ca6453c4b754b5_1440w.jpg" alt="img">云风博客截图，地址<a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html" target="_blank" rel="noopener">https://blog.codingnow.com/2017/06/overwatch_ecs.html</a></p>
<p>ECS是一个好的处理方式，并且我找到<a href="https://link.zhihu.com/?target=https%3A//www.kisence.com/2017/11/12/guan-yu-zheng-tong-bu-de-xie-xin-de/">一篇文章</a>，也这样做了（我看过他开源的demo，做得还不够好，应该还是demo阶段，不太像是一个成型的项目）。这篇文章的思路是很清晰的，并且也点到了一些实实在在的痛点，解决思路也基本是正确的，可以参看。</p>
<p>这块，我做得比较早了，当时守望先锋的文章还没出，我的战斗也没有基于ECS，所以，在处理快照上，只有自己理顺逻辑来做了。</p>
<p>我的思路是，通过一个回滚接口，需要数据回滚的部分，实现接口，各自处理自己的保存快照和回滚。就像我们序列化一个复杂的配置，每个配置各自序列化自己的部分，最终合并成一个序列化好的文件。</p>
<p>首先，定义接口，和快照数据的reader和writer</p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-5052de9e1c12b7e87d2f452b29fdef61_1440w.jpg" alt="img"></p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-b666f214abd2a804e885237c5bcc119b_1440w.jpg" alt="img"></p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-2f49a68d6fd54381d8e7bdf3ffdfb283_1440w.jpg" alt="img"></p>
<p>然后，就是每个模块，自己去处理自己的takeSnapshot和rollback，例如：</p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-96bb5917e8a766ef79323613179f404d_1440w.jpg" alt="img">简单的数值回滚</p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-1573d2a9eeec5b5d8e7e663a8e06f487_1440w.jpg" alt="img">复制的列表回滚和调用子模块回滚</p>
<p>思路理顺以后，就可以很方便地处理了，注意write和read的顺序，注意处理好list，就解决了大部分问题。当然，在实现逻辑的过程中，时刻要注意，一个模块如何回滚（例如获取随机数也需要回滚）。</p>
<p>有一个更简单的方式，就是给属性打Attribute，然后写通用的方法。例如，我早<strong>期的实现方案</strong>：</p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-05fee97a51c743b54d8dca8074fe042f_1440w.jpg" alt="img">给属性打标签</p>
<p>根据标签，通用的读写方法，通过反射来读写，就不需要每个模块自己去实现自己的方法了：</p>
<p><img src="../../assets/images/2019-11-01-lock-step/v2-c27132db564887adc282fe621f2357e3_1440w.jpg" alt="img">部分代码</p>
<p>这种方法，能很好地解决大部分问题，甚至前面提到的<a href="https://link.zhihu.com/?target=https%3A//github.com/suzuke/TrueSync/tree/master/Assets/TrueSync/Engine/Math">Truesync</a>，也是用的这种方式来做。</p>
<p>但是这种方法有个难以回避的问题，就是GC，因为基于反射，当我们调用field的GetValue和SetValue的时候，GC难以避免。并且，因为全自动，不方便处理一些特殊逻辑，调试优化也不方便，最后改成了现有的方式，虽然看起来笨重一些，但是可控性更强，我后续做的很多优化，都方便很多。</p>
<p>关于快照，也有很多可以优化的点，无论是GC内存上的，还是运行效率上的，都需要优化好，否则，可能带来性能问题。这块优化，有空另辟文章再细谈吧。</p>
<p>当我们有了快照，就可以支持回滚，甚至跳转。例如我们要看战斗录像，如果没有快照，我们要跳到1000帧，就需要从第一帧，根据保存的操作指令，一直快速执行到1000帧，而有了快照，可以直接跳到1000帧，不需要执行中间的过程，如果需要在不同的帧之间切换，只需要跳转即可，这将带来巨大的帮助。</p>
<p>参考文章：</p>
<ul>
<li>Minimization of Latency in Cheat-Proof Real-Time Gaming by Trusting Time-Stamp Servers</li>
<li>End-to-end transmission control mechanisms for multiparty interactive applicatins on the Internet</li>
<li>Dead Reckoning: Latency Hiding for Networked Games</li>
<li>An Efficient Synchronization Mechanism for Mirrored Game Architectures</li>
<li><a href="https://gameinstitute.qq.com/community/detail/117819" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/117819</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/38468615" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38468615</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>sync</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>状态同步的相关问题</title>
    <url>/dotnet-2019-11-01-state-sync-npc/</url>
    <content><![CDATA[<h2 id="怪物状态同步"><a href="#怪物状态同步" class="headerlink" title="怪物状态同步"></a>怪物状态同步</h2><p>在一个地图当中，玩家的状态同步之后，则需要同步地图中怪物的位置信息，怪物的位置信息同步方式一般有两种实现方式</p>
<h3 id="基于客户端的状态同步"><a href="#基于客户端的状态同步" class="headerlink" title="基于客户端的状态同步"></a>基于客户端的状态同步</h3><p>一个地图中的怪物状态，实际上是由地图中玩家所决定的，当玩家施加攻击、使用技能，都会改变怪物的状态。在MapleStroy的设计当中，怪物的位置计算是属于离线计算，这也就是说，服务器不参与怪物的状态，这样的好处是节约流量、减缓服务器压力，但是坏处是，会出现怪物静止、吸怪等外挂手段。在移植MapleStroy的过程中，为了同步官方和考虑移动平台流量问题，因此采用此种手段。</p>
<p>实现策略：</p>
<p>怪物的位置由第一个进入该地图的玩家决定。这也就是说，当第一个玩家进入该地图之后，控制着当前地图中所有怪物的移动状态。当第二个玩家进入该地图之后，第一个玩家会广播当前所有怪物的状态，第二个玩家根据这些数据包进行改变。当然其他玩家发生了攻击，或者激怒怪物的操作后，也会广播这个消息。</p>
<p>同时怪物的移动也是采用基于预言的状态同步，大体实现和玩家移动相似。</p>
<p> 　怪物的同步在传统的端游里，是完全由服务器的怪物AI系统触发，客户端只是纯粹的接受服务器下发的怪物状态数据。对于手机游戏里，由于手机上很难出现像PC里那样的外挂，所以怪物的AI可以考虑放在客户端触发，同时减少怪物的状态同步。详细说明如下：</p>
<h4 id="a-怪物的随机移动不同步"><a href="#a-怪物的随机移动不同步" class="headerlink" title="a) 怪物的随机移动不同步"></a>a) 怪物的随机移动不同步</h4><p>　　在地图上，怪物都会有一个固定的位置。怪物没有进入战斗状态时，就会在这个固定位置的周围走来走去，随机的移动。这个随机的移动设定由每个客户端自己控制，这样怪物的随机移动，就不用消息广播进行同步了。</p>
<p>　　由于客户端自己控制怪物的随机走动，所以会出现不同客户端里，怪物位置不一样的问题。但由于怪物随机移动的范围较小，所以这个问题不是很明显，在手机上是可以接受的。角色打怪时，是扇形的伤害范围，所以即使怪物坐标在不同的客户端有点不一致，打怪的效果也可以接受。</p>
<h4 id="b-怪物的行为同步"><a href="#b-怪物的行为同步" class="headerlink" title="b) 怪物的行为同步"></a>b) 怪物的行为同步</h4><p>　　当有角色攻击被动怪物，或者进入主动怪物的视野范围内时，怪物的AI就被这个角色所在的客户端锁定了，同时怪物进入攻击状态。攻击的判断完全由锁定怪物AI的客户端进行处理，同时这个客户端会将这个怪物的行为上发到服务器，由服务器广播给周围的其他玩家。</p>
<p>　　怪物的AI锁定，使用抢占式，即谁最先发消息给服务器申请怪物的AI锁定，谁就获得了怪物的控制权，直到怪物死亡或脱离战斗状态。</p>
<p>　　怪物可以每进行一次攻击，客户端就发一个消息给服务器。这样做，消息还是有点多，特别是一群怪围着几个角色进行攻击时，消息广播还是有点多。所以可以将状态的概念向上扩大，只同步怪物在攻击哪个玩家，而不同步每一次的攻击，然后由每个客户端根据怪物固定的攻击速度各自去表现。这样一个怪去攻击一个玩家，就只会有一次消息广播了。</p>
<h4 id="c-精英怪和BOSS怪的AI"><a href="#c-精英怪和BOSS怪的AI" class="headerlink" title="c) 精英怪和BOSS怪的AI"></a>c) 精英怪和BOSS怪的AI</h4><p>　　精英怪和BOSS怪由于数量较少，而且比较重要，所以不能由客户端来申请AI控制权，而是服务器根据某种策略来控制。所使用的策略可以考虑角色的伤害值、防御值、角色与BOSS的距离远近等，根据这些因素，服务器计算出BOSS怪当前最适合攻击的对象（比如血量最少的玩家，最脆弱的法师等），然后将AI控制权发给那个客户端，由那个客户端控制攻击行为，同时通过消息让服务器同步给其他玩家。</p>
<p>　　总结：怪物的同步方式的选择，就是尽量减少消息的广播，同时让游戏效果在可接受的范围内。怪物AI的这个处理方式，实际上是同时省去了游戏服务器的怪物AI模块（端游一般是专门用的一个进程或者另外一台物理服务器来进行怪物AI的计算），从而简化了MMO游戏的开发难度，同时保证了较好的游戏体验。 </p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://www.jianshu.com/p/5dbdf81c4e69" target="_blank" rel="noopener">https://www.jianshu.com/p/5dbdf81c4e69</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>同步</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>状态同步--技能系统的同步机制分析</title>
    <url>/dotnet-2019-11-02-state-sync-skill/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/sevenyuan/p/6678317.html" target="_blank" rel="noopener">https://www.cnblogs.com/sevenyuan/p/6678317.html</a></p>
<p><a href="https://www.lt-tree.com/2019/09/21/联网战斗同步实现/" target="_blank" rel="noopener">https://www.lt-tree.com/2019/09/21/%E8%81%94%E7%BD%91%E6%88%98%E6%96%97%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0/</a></p>
<p><a href="https://blog.csdn.net/best789248/article/details/78434114" target="_blank" rel="noopener">https://blog.csdn.net/best789248/article/details/78434114</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/49482294" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49482294</a></p>
<p><a href="https://gameinstitute.qq.com/course/detail/10098" target="_blank" rel="noopener">https://gameinstitute.qq.com/course/detail/10098</a></p>
<p><a href="https://gameinstitute.qq.com/course/detail/10099" target="_blank" rel="noopener">https://gameinstitute.qq.com/course/detail/10099</a></p>
<p><a href="https://gameinstitute.qq.com/course/detail/10112" target="_blank" rel="noopener">https://gameinstitute.qq.com/course/detail/10112</a></p>
<p><a href="https://gameinstitute.qq.com/course/detail/10100" target="_blank" rel="noopener">https://gameinstitute.qq.com/course/detail/10100</a></p>
<p><a href="https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven:zh-cn" target="_blank" rel="noopener">https://developer.valvesoftware.com/wiki/Dota_2_Workshop_Tools:zh-cn/Scripting:zh-cn/Abilities_Data_Driven:zh-cn</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/38326478" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38326478</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/38605352" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38605352</a></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Creating a Quartz.NET hosted service with ASP.NET Core</title>
    <url>/dotnet-2019-11-05-quartz/</url>
    <content><![CDATA[<p>In this post I describe how to run Quartz.NET jobs using an <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2" target="_blank" rel="noopener">ASP.NET Core hosted service</a>. I show how to create a simple <code>IJob</code>, a custom <code>IJobFactory</code>, and a <code>QuartzHostedService</code> that runs jobs while your application is running. I’ll also touch on some of the issues to aware of, namely of using scoped services inside singleton classes.</p>
<h2 id="Introduction-what-is-Quartz-NET"><a href="#Introduction-what-is-Quartz-NET" class="headerlink" title="Introduction - what is Quartz.NET?"></a>Introduction - what is Quartz.NET?<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#introduction-what-is-quartz-net-" target="_blank" rel="noopener"><img src="../../assets/images/2019-11-05-quartz/icons-link.svg" alt="img"></a></h2><p>As per <a href="https://www.quartz-scheduler.net/" target="_blank" rel="noopener">their website</a>:</p>
<blockquote>
<p>Quartz.NET is a full-featured, open source job scheduling system that can be used from smallest apps to large scale enterprise systems.</p>
</blockquote>
<p>It’s an old staple of many ASP.NET developers, used as a way of running background tasks on a timer, in a reliable, clustered, way. Using Quartz.NET with ASP.NET Core is pretty similar - Quartz.NET supports .NET Standard 2.0, so you can easily use it in your applications.</p>
<p>Quartz.NET has two main concepts:</p>
<ul>
<li>A <strong>job</strong>. This is the background tasks that you want to run on some sort of schedule.</li>
<li>A <strong>scheduler</strong>. This is responsible for running jobs based on triggers, on a time-based schedule.</li>
</ul>
<p>ASP.NET Core has good support for running “background tasks” via way of <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services" target="_blank" rel="noopener">hosted services</a>. Hosted services are started when your ASP.NET Core app starts, and run in the background for the lifetime of the application. By creating a Quartz.NET hosted service, you can use a standard ASP.NET Core application for running your tasks in the background.</p>
<blockquote>
<p>This sort of non-HTTP scenario is also possible with the “generic host”, <a href="https://andrewlock.net/the-asp-net-core-generic-host-namespace-clashes-and-extension-methods/" target="_blank" rel="noopener">but for various reasons</a> I generally don’t use those at the moment. This should hopefully improve in ASP.NET Core 3.0 with the extra investment going into these non-HTTP scenarios.</p>
</blockquote>
<p>While it’s possible to create <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.2#timed-background-tasks" target="_blank" rel="noopener">a “timed” background service</a>, (that runs a tasks every 10 minutes, for example), Quartz.NET provides a far more robust solution. You can ensure tasks only run at specific times of the day (e.g. 2:30am), or only on specific days, or any combination by using a <a href="https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html" target="_blank" rel="noopener">Cron trigger</a>. It also allows you to run multiple instances of your application in a clustered fashion, so that only a single instance can run a given task at any one time.</p>
<p>In this post I’ll show the basics of creating a Quartz.NET job and scheduling it to run on a timer in a hosted service.</p>
<h2 id="Installing-Quartz-NET"><a href="#Installing-Quartz-NET" class="headerlink" title="Installing Quartz.NET"></a>Installing Quartz.NET<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#installing-quartz-net" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>Quartz.NET is a .NET Standard 2.0 NuGet package, so it should be easy to install in your application. For this test I created an ASP.NET Core project and chose the Empty template. You can install the Quartz.NET package using <code>dotnet add package Quartz</code>. If you view the <em>.csproj</em> for the project, it should look something like this:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">"Microsoft.NET.Sdk.Web"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netcoreapp2.2<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AspNetCoreHostingModel</span>&gt;</span>InProcess<span class="tag">&lt;/<span class="name">AspNetCoreHostingModel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Microsoft.AspNetCore.App"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">"Quartz"</span> <span class="attr">Version</span>=<span class="string">"3.0.7"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Creating-an-IJob"><a href="#Creating-an-IJob" class="headerlink" title="Creating an IJob"></a>Creating an IJob<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-an-ijob" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>For the actual background work we are scheduling, we’re just going to use a “hello world” implementation that writes to an <code>ILogger&lt;&gt;</code> (and hence to the console). You should implement the Quartz interface <code>IJob</code> which contains a single asynchronous <code>Execute()</code> method. Note that we’re using dependency injection here to inject the logger into the constructor.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Logging;</span><br><span class="line"><span class="keyword">using</span> Quartz;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">[<span class="meta">DisallowConcurrentExecution</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorldJob</span> : <span class="title">IJob</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;HelloWorldJob&gt; _logger;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldJob</span>(<span class="params">ILogger&lt;HelloWorldJob&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger = logger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Execute</span>(<span class="params">IJobExecutionContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _logger.LogInformation(<span class="string">"Hello world!"</span>);</span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I also decorated the job with the <code>[DisallowConcurrentExecution]</code> attribute. This attribute <a href="https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/more-about-jobs.html#job-state-and-concurrency" target="_blank" rel="noopener">prevents Quartz.NET from trying to run the same job concurrently</a>.</p>
<h2 id="Creating-an-IJobFactory"><a href="#Creating-an-IJobFactory" class="headerlink" title="Creating an IJobFactory"></a>Creating an IJobFactory<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-an-ijobfactory" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>Next, we need to tell Quartz how it should create instances of <code>IJob</code>. By default, Quartz will try and “new-up” instances of the job using <code>Activator.CreateInstance</code>, effectively calling <code>new HelloWorldJob()</code>. Unfortunately, as we’re using constructor injection, that won’t work. Instead, we can provide a custom <code>IJobFactory</code> that hooks into the ASP.NET Core dependency injection container (<code>IServiceProvider</code>):</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Quartz;</span><br><span class="line"><span class="keyword">using</span> Quartz.Spi;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingletonJobFactory</span> : <span class="title">IJobFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _serviceProvider;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SingletonJobFactory</span>(<span class="params">IServiceProvider serviceProvider</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _serviceProvider = serviceProvider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IJob <span class="title">NewJob</span>(<span class="params">TriggerFiredBundle bundle, IScheduler scheduler</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _serviceProvider.GetRequiredService(bundle.JobDetail.JobType) <span class="keyword">as</span> IJob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReturnJob</span>(<span class="params">IJob job</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This factory takes an <code>IServiceProvider</code> in the constructor, and implements the <code>IJobFactory</code> interface. The important method is the <code>NewJob()</code> method, in which the factory has to return the <code>IJob</code> requested by the Quartz scheduler. In this implementation we delegate directly to the <code>IServiceProvider</code>, and let the DI container find the required instance. The cast to <code>IJob</code> at the end is required because the non-generic version of <code>GetRequiredService</code> returns an <code>object</code>.</p>
<p>The <code>ReturnJob</code> method is where the scheduler tries to return (i.e. destroy) a job that was created by the factory. Unfortunately, there’s no mechanism for doing so with the built-in <code>IServiceProvider</code>. We can’t create a new <code>IScopeService</code> that fits into the required Quartz API, so we’re stuck only being able to create singleton jobs.</p>
<blockquote>
<p>This is important. With the above implementation, it is only safe to create <code>IJob</code> implementations that are <strong>Singletons</strong> (or transient).</p>
</blockquote>
<h2 id="Configuring-the-Job"><a href="#Configuring-the-Job" class="headerlink" title="Configuring the Job"></a>Configuring the Job<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#configuring-the-job" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>I’m only showing a single <code>IJob</code> implementation here, but we want the Quartz hosted service to be a generic implementation that works for any number of jobs. To help with that, we create a simple DTO called <code>JobSchedule</code> that we’ll use to define the timer schedule for a given job type:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">JobSchedule</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JobSchedule</span>(<span class="params">Type jobType, <span class="keyword">string</span> cronExpression</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        JobType = jobType;</span><br><span class="line">        CronExpression = cronExpression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Type JobType &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> CronExpression &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>JobType</code> is the .NET type of the job (<code>HelloWorldJob</code> for our example), and <code>CronExpression</code> is a <a href="https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html" target="_blank" rel="noopener">Quartz.NET Cron expression</a>. Cron expressions allow complex timer scheduling so you can set rules like “fire every half hour between the hours of 8 am and 10 am, on the 5th and 20th of every month”. Just be sure to <a href="https://www.quartz-scheduler.net/documentation/quartz-3.x/tutorial/crontriggers.html" target="_blank" rel="noopener">check the documentation</a> for examples as not all Cron expressions used by different systems are interchangeable.</p>
<p>We’ll add the job to DI and configure its schedule in <code>Startup.ConfigureServices()</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Hosting;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.DependencyInjection;</span><br><span class="line"><span class="keyword">using</span> Quartz;</span><br><span class="line"><span class="keyword">using</span> Quartz.Impl;</span><br><span class="line"><span class="keyword">using</span> Quartz.Spi;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Add Quartz services</span></span><br><span class="line">    services.AddSingleton&lt;IJobFactory, SingletonJobFactory&gt;();</span><br><span class="line">    services.AddSingleton&lt;ISchedulerFactory, StdSchedulerFactory&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add our job</span></span><br><span class="line">    services.AddSingleton&lt;HelloWorldJob&gt;();</span><br><span class="line">    services.AddSingleton(<span class="keyword">new</span> JobSchedule(</span><br><span class="line">        jobType: <span class="keyword">typeof</span>(HelloWorldJob),</span><br><span class="line">        cronExpression: <span class="string">"0/5 * * * * ?"</span>)); <span class="comment">// run every 5 seconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This code adds four things as singletons to the DI container:</p>
<ul>
<li>The <code>SingletonJobFactory</code> shown earlier, used for creating the job instances.</li>
<li>An implementation of <code>ISchedulerFactory</code>, the built-in <code>StdSchedulerFactory</code>, which handles scheduling and managing jobs</li>
<li>The <code>HelloWorldJob</code> job itself</li>
<li>An instance of <code>JobSchedule</code> for the <code>HelloWorldJob</code> with a Cron expression to run every 5 seconds.</li>
</ul>
<p>There’s only one piece missing now that brings them all together, the <code>QuartzHostedService</code>.</p>
<h2 id="Creating-the-QuartzHostedService"><a href="#Creating-the-QuartzHostedService" class="headerlink" title="Creating the QuartzHostedService"></a>Creating the QuartzHostedService<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#creating-the-quartzhostedservice" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>The <code>QuartzHostedService</code> is an implementation of <code>IHostedService</code> that sets up the Quartz scheduler, and starts it running in the background. Due to the design of Quartz, we can implement <code>IHostedService</code> directly, instead of the <a href="https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/background-tasks-with-ihostedservice" target="_blank" rel="noopener">more common approach of deriving from the base <code>BackgroundService</code> class</a>. The full code for the service is listed below, and I’ll discuss it afterwards.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Threading;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"><span class="keyword">using</span> Microsoft.Extensions.Hosting;</span><br><span class="line"><span class="keyword">using</span> Quartz;</span><br><span class="line"><span class="keyword">using</span> Quartz.Spi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QuartzHostedService</span> : <span class="title">IHostedService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ISchedulerFactory _schedulerFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IJobFactory _jobFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IEnumerable&lt;JobSchedule&gt; _jobSchedules;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QuartzHostedService</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        ISchedulerFactory schedulerFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        IJobFactory jobFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">        IEnumerable&lt;JobSchedule&gt; jobSchedules</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _schedulerFactory = schedulerFactory;</span><br><span class="line">        _jobSchedules = jobSchedules;</span><br><span class="line">        _jobFactory = jobFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> IScheduler Scheduler &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Scheduler = <span class="keyword">await</span> _schedulerFactory.GetScheduler(cancellationToken);</span><br><span class="line">        Scheduler.JobFactory = _jobFactory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> jobSchedule <span class="keyword">in</span> _jobSchedules)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> job = CreateJob(jobSchedule);</span><br><span class="line">            <span class="keyword">var</span> trigger = CreateTrigger(jobSchedule);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> Scheduler.ScheduleJob(job, trigger, cancellationToken);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Scheduler.Start(cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">await</span> Scheduler?.Shutdown(cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IJobDetail <span class="title">CreateJob</span>(<span class="params">JobSchedule schedule</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> jobType = schedule.JobType;</span><br><span class="line">        <span class="keyword">return</span> JobBuilder</span><br><span class="line">            .Create(jobType)</span><br><span class="line">            .WithIdentity(jobType.FullName)</span><br><span class="line">            .WithDescription(jobType.Name)</span><br><span class="line">            .Build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ITrigger <span class="title">CreateTrigger</span>(<span class="params">JobSchedule schedule</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerBuilder</span><br><span class="line">            .Create()</span><br><span class="line">            .WithIdentity(<span class="string">$"<span class="subst">&#123;schedule.JobType.FullName&#125;</span>.trigger"</span>)</span><br><span class="line">            .WithCronSchedule(schedule.CronExpression)</span><br><span class="line">            .WithDescription(schedule.CronExpression)</span><br><span class="line">            .Build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>QuartzHostedService</code> has three dependencies: the <code>ISchedulerFactory</code> and <code>IJobFactory</code> we configured in <code>Startup</code>, and an <code>IEnumerable</code>. We only added a single <code>JobSchedule</code> to the DI container (for the <code>HelloWorldJob</code>), but if you register more job schedules with the DI container they’ll all be injected here.</p>
<p><code>StartAsync</code> is called when the application starts up and is where we configure Quartz. We start by creating an instance of <code>IScheduler</code>, assigning it to a property for use later, and setting the <code>JobFactory</code> for the scheduler to the injected instance:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scheduler = <span class="keyword">await</span> _schedulerFactory.GetScheduler(cancellationToken);</span><br><span class="line">    Scheduler.JobFactory = _jobFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Next, we loop through the injected job schedules, and create a Quartz <code>IJobDetail</code> and <code>ITrigger</code> for each one using the <code>CreateJob</code> and <code>CreateTrigger</code> helper methods at the end of the class. If you don’t like how this part works, or need more control over the configuration, you can easily customise it by extending the <code>JobSchedule</code> DTO as you see fit.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StartAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> jobSchedule <span class="keyword">in</span> _jobSchedules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> job = CreateJob(jobSchedule);</span><br><span class="line">        <span class="keyword">var</span> trigger = CreateTrigger(jobSchedule);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Scheduler.ScheduleJob(job, trigger, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IJobDetail <span class="title">CreateJob</span>(<span class="params">JobSchedule schedule</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jobType = schedule.JobType;</span><br><span class="line">    <span class="keyword">return</span> JobBuilder</span><br><span class="line">        .Create(jobType)</span><br><span class="line">        .WithIdentity(jobType.FullName)</span><br><span class="line">        .WithDescription(jobType.Name)</span><br><span class="line">        .Build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ITrigger <span class="title">CreateTrigger</span>(<span class="params">JobSchedule schedule</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TriggerBuilder</span><br><span class="line">        .Create()</span><br><span class="line">        .WithIdentity(<span class="string">$"<span class="subst">&#123;schedule.JobType.FullName&#125;</span>.trigger"</span>)</span><br><span class="line">        .WithCronSchedule(schedule.CronExpression)</span><br><span class="line">        .WithDescription(schedule.CronExpression)</span><br><span class="line">        .Build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Finally, once all the jobs are scheduled, you call <code>Scheduler.Start()</code> to actually start the Quartz.NET scheduler processing in the background. When the app shuts down, the framework will call <code>StopAsync()</code>, at which point you can call <code>Scheduler.Stop()</code> to safely shut down the scheduler process.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">StopAsync</span>(<span class="params">CancellationToken cancellationToken</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Scheduler?.Shutdown(cancellationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can register the hosted service using the <code>AddHostedService()</code> extension method in <code>Startup.ConfigureServices</code>:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    services.AddHostedService&lt;QuartzHostedService&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you run the application, you should see the background task running every 5 seconds and writing to the Console (or wherever you have logging configured)</p>
<p><img src="../../assets/images/2019-11-05-quartz/quartz_service.png" alt="Background service writing Hello World to console repeatedly"></p>
<h2 id="Using-scoped-services-in-jobs"><a href="#Using-scoped-services-in-jobs" class="headerlink" title="Using scoped services in jobs"></a>Using scoped services in jobs<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#using-scoped-services-in-jobs" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>There’s one big problem with the implementation as described in this post: you can only create Singleton or Transient jobs. That means you can’t use any dependencies that are registered as Scoped services. For example, you can’t inject an EF Core <code>DatabaseContext</code> into your <code>IJob</code> implementation, as you’ll have a <a href="http://blog.ploeh.dk/2014/06/02/captive-dependency/" target="_blank" rel="noopener">captive dependency</a> problem.</p>
<p>Working around this isn’t a big issue: you can inject an <code>IServiceProvider</code> and create your own scope, <a href="https://andrewlock.net/the-dangers-and-gotchas-of-using-scoped-services-when-configuring-options-in-asp-net-core/#3-creating-a-new-scope-in-iconfigureoptions" target="_blank" rel="noopener">similar to the solution for a similar problem in a previous post</a>. For example, if you need to use a scoped service in your <code>HelloWorldJob</code>, you could use something like the following:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorldJob</span> : <span class="title">IJob</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Inject the DI provider</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> IServiceProvider _provider;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldJob</span>(<span class="params"> IServiceProvider provider</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _provider = provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Task <span class="title">Execute</span>(<span class="params">IJobExecutionContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Create a new scope</span></span><br><span class="line">        <span class="keyword">using</span>(<span class="keyword">var</span> scope = _provider.CreateScope())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Resolve the Scoped service</span></span><br><span class="line">            <span class="keyword">var</span> service = scope.ServiceProvider.GetService&lt;IScopedService&gt;();</span><br><span class="line">            _logger.LogInformation(<span class="string">"Hello world!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This ensures a new scope is created every time the job runs, so you can retrieve (and dispose) scoped services inside the <code>IJob</code>. Unfortunately things do get a little messy. In the next post I’ll show a variation on this approach that is a little cleaner.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary<a href="https://andrewlock.net/creating-a-quartz-net-hosted-service-with-asp-net-core/#summary" target="_blank" rel="noopener"><img src="https://andrewlock.net/assets/img/icons-link.svg" alt="img"></a></h2><p>In this post I introduced Quartz.NET and showed how you could use it to schedule background jobs to run in ASP.NET Core using <code>IHostedService</code>. The example shown in this post is best for singleton or transient jobs, which isn’t ideal, as consuming scoped services is clumsy. In the next post, I’ll show a variation on this approach that makes using scoped services easier.</p>
<ul>
<li><a href="https://github.com/andrewlock/blog-examples/tree/master/QuartzHostedService" target="_blank" rel="noopener">Example source code for this post</a></li>
<li><a href="https://github.com/HangfireIO/Cronos" target="_blank" rel="noopener">https://github.com/HangfireIO/Cronos</a> </li>
<li><a href="https://github.com/HangfireIO/Hangfire" target="_blank" rel="noopener">https://github.com/HangfireIO/Hangfire</a> </li>
<li><a href="https://github.com/quartznet/quartznet" target="_blank" rel="noopener">https://github.com/quartznet/quartznet</a> </li>
</ul>
<h3 id="Hangfire-与quartz-net对比"><a href="#Hangfire-与quartz-net对比" class="headerlink" title="Hangfire 与quartz.net对比"></a>Hangfire 与quartz.net对比</h3><p>在项目没有引入Hangfire之前，一直使用的是Quartz.net。个人认为Quartz.net在定时任务处理方面优势如下：</p>
<ul>
<li>支持秒级单位的定时任务处理，但是Hangfire只能支持分钟及以上的定时任务处理</li>
</ul>
<p>原因在于Hangfire用的是开源的<a href="https://github.com/atifaziz/NCrontab" target="_blank" rel="noopener">NCrontab</a>组件，跟linux上的crontab指令相似。</p>
<ul>
<li>更加复杂的触发器，日历以及任务调度处理</li>
<li>可配置的定时任务</li>
</ul>
<p>但是为什么要换Hangfire? 很大的原因在于项目需要一个后台可监控的应用，不用每次都要从服务器拉取日志查看，在没有ELK的时候相当不方便。Hangfire控制面板不仅提供监控，也可以手动的触发执行定时任务。如果在定时任务处理方面没有很高的要求，比如一定要5s定时执行，Hangfire值得拥有。抛开这些，Hangfire优势太明显了：</p>
<ul>
<li>持久化保存任务、队列、统计信息</li>
<li>重试机制</li>
<li>多语言支持</li>
<li>支持任务取消</li>
<li>支持按指定<code>Job Queue</code>处理任务</li>
<li>服务器端工作线程可控，即job执行并发数控制</li>
<li>分布式部署，支持高可用</li>
<li>良好的扩展性，如支持IOC、Hangfire Dashboard授权控制、Asp.net Core、持久化存储等</li>
</ul>
<p>说了这么多的优点，我们可以有个案例，例如秒杀场景：用户下单-&gt;订单生成-&gt;扣减库存，Hangfire对于这种分布式的应用处理也是适用的，最后会给出实现。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>sync</tag>
      </tags>
  </entry>
  <entry>
    <title>DatetimeOffset和Datetime的区别</title>
    <url>/dotnet-2019-12-01-datetimeoffset/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Fact]</span><br><span class="line">      public void TestDatetimeoffset2()</span><br><span class="line">      &#123;</span><br><span class="line">          var a &#x3D; DateTimeOffset.Now;</span><br><span class="line">          var b &#x3D; a.ToLocalTime();</span><br><span class="line">          var c &#x3D; a.ToUniversalTime();</span><br><span class="line"></span><br><span class="line">          Assert.Equal(b, c);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>上面的abc都是一个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Fact]</span><br><span class="line">    public void TestDatetimeoffset3()</span><br><span class="line">    &#123;</span><br><span class="line">        var a &#x3D; DateTime.Now;</span><br><span class="line">        var b &#x3D; a.ToLocalTime();</span><br><span class="line">        var c &#x3D; a.ToUniversalTime();</span><br><span class="line"></span><br><span class="line">        Assert.Equal(b, c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的值是不等的</p>
<p>datetimeoffset使用efcore存储到datetime字段都是0时区的…取出来后如果显示再web可以toLocalTime</p>
<p>如果是游戏中使用,除非是发送给用户显示..否则不需要toLocalTime..</p>
<p>1，DateTime</p>
<p>表示时间上的一刻，通常以日期和当天时间来表示。</p>
<p>2， DateTimeOffset</p>
<p>表示一个时间点，通常以相对于协调世界时（UTC）的日期和时间来表示</p>
<p> <a href="https://docs.microsoft.com/en-us/dotnet/standard/datetime/performing-arithmetic-operations" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/dotnet/standard/datetime/performing-arithmetic-operations</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">public enum TimeComparison</span><br><span class="line">&#123;</span><br><span class="line">   EarlierThan &#x3D; -1,</span><br><span class="line">   TheSameAs &#x3D; 0,</span><br><span class="line">   LaterThan &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DateManipulation</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line">      DateTime localTime &#x3D; DateTime.Now;</span><br><span class="line">      DateTime utcTime &#x3D; DateTime.UtcNow;</span><br><span class="line">      </span><br><span class="line">      Console.WriteLine(&quot;Difference between &#123;0&#125; and &#123;1&#125; time: &#123;2&#125;:&#123;3&#125; hours&quot;, </span><br><span class="line">                        localTime.Kind.ToString(), </span><br><span class="line">                        utcTime.Kind.ToString(), </span><br><span class="line">                        (localTime - utcTime).Hours, </span><br><span class="line">                        (localTime - utcTime).Minutes);</span><br><span class="line">      Console.WriteLine(&quot;The &#123;0&#125; time is &#123;1&#125; the &#123;2&#125; time.&quot;, </span><br><span class="line">                        localTime.Kind.ToString(), </span><br><span class="line">                        Enum.GetName(typeof(TimeComparison), localTime.CompareTo(utcTime)), </span><br><span class="line">                        utcTime.Kind.ToString());  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; If run in the U.S. Pacific Standard Time zone, the example displays </span><br><span class="line">&#x2F;&#x2F; the following output to the console:</span><br><span class="line">&#x2F;&#x2F;    Difference between Local and Utc time: -7:0 hours</span><br><span class="line">&#x2F;&#x2F;    The Local time is EarlierThan the Utc time.      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class DateTimeOffsetManipulation</span><br><span class="line">&#123;</span><br><span class="line">   public static void Main()</span><br><span class="line">   &#123;</span><br><span class="line">      DateTimeOffset localTime &#x3D; DateTimeOffset.Now;</span><br><span class="line">      DateTimeOffset utcTime &#x3D; DateTimeOffset.UtcNow;</span><br><span class="line">      </span><br><span class="line">      Console.WriteLine(&quot;Difference between local time and UTC: &#123;0&#125;:&#123;1:D2&#125; hours&quot;, </span><br><span class="line">                        (localTime - utcTime).Hours, </span><br><span class="line">                        (localTime - utcTime).Minutes);</span><br><span class="line">      Console.WriteLine(&quot;The local time is &#123;0&#125; UTC.&quot;, </span><br><span class="line">                        Enum.GetName(typeof(TimeComparison), localTime.CompareTo(utcTime)));  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Regardless of the local time zone, the example displays </span><br><span class="line">&#x2F;&#x2F; the following output to the console:</span><br><span class="line">&#x2F;&#x2F;    Difference between local time and UTC: 0:00 hours.</span><br><span class="line">&#x2F;&#x2F;    The local time is TheSameAs UTC.</span><br></pre></td></tr></table></figure>

<p> 从实例中可以看出，DateTimeOffset是取相对于UTC的日期和时间来表示的，所以DateTimeOffset.Now和DateTimeOffset.UtcNow的值是一样的。而DateTime不同，是以日期和当前时间来显示的。 </p>
<p>就是说..如果你用DateTime进行加减运算要么只用DateTime.Now..要么只用DateTime.UtcNow..混用会出现不可预期的错误</p>
<p>而DateTimeOffset的无论是用now还是utcnow加减都一样,因为他代表的是一个时间点…如果是为了客户端显示使用可以转换成本地时间再tostring</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>大小端字节序(Big Endian和Little Endian)</title>
    <url>/dotnet-2020-01-05-big-little-endian/</url>
    <content><![CDATA[<h1 id="那么何为字节序（Endia）呢？"><a href="#那么何为字节序（Endia）呢？" class="headerlink" title="那么何为字节序（Endia）呢？"></a>那么何为字节序（Endia）呢？</h1><p>Big Endian是指低地址存放最高有效字节（MSB），而Little Endian则是低地址存放最低有效字节（LSB）。</p>
<p><strong>大端模式</strong></p>
<p>所谓的大端模式（Big-endian），是指数据的高字节，保存在内存的低地址中，而数据的低字节，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000</span><br><span class="line"></span><br><span class="line">0000440: b484 6c4e 004e ed00 0000 0000 0100 0000</span><br></pre></td></tr></table></figure>

<p>在大端模式下，前32位应该这样读:<code>e6 84 6c 4e</code> ( 假设int占4个字节)</p>
<p>记忆方法: <code>地址的增长顺序与值的增长顺序相反</code></p>
<p><strong>小端模式</strong></p>
<p>所谓的小端模式（Little-endian），是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000430: e684 6c4e 0100 1800 53ef 0100 0100 0000</span><br><span class="line"></span><br><span class="line">0000440: b484 6c4e 004e ed00 0000 0000 0100 0000</span><br></pre></td></tr></table></figure>

<p>在小端模式下，前32位应该这样读: <code>4e 6c 84 e6</code>( 假设int占4个字节)</p>
<p>记忆方法: <code>地址的增长顺序与值的增长顺序相同</code></p>
<p>有图有真相，举个例子，数字 <strong>0x12345678</strong> 在两种不同字节序CPU中的存储顺序如下图</p>
<p><img src="../../assets/images/2020-01-05-big-little-endian/20160414225024808" alt="pic1"></p>
<h2 id="为什么会有这样的情况呢？"><a href="#为什么会有这样的情况呢？" class="headerlink" title="为什么会有这样的情况呢？"></a>为什么会有这样的情况呢？</h2><p>这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</p>
<ul>
<li>Motorola的<strong>PowerPC</strong>系列CPU采用Big Endian方式存储数据。</li>
<li>Intel的<strong>x86</strong>系列CPU采用Little Endian方式存储数据。</li>
<li>ARM既可以工作在大端模式，也可以工作在小端模式。</li>
</ul>
<p><strong>再来说说，一些我所收集到的情况吧。</strong></p>
<ul>
<li>Windos(x86,x64)和Linux(x86,x64)都是<strong>Little Endian</strong>操作系统</li>
<li>在ARM上，我见到的都是用<strong>Little Endian</strong>方式存储数据。</li>
<li>C/C++语言编写的程序里数据存储顺序是跟编译平台<strong>所在的CPU相关</strong>的。</li>
<li>JAVA编写的程序则唯一采用<strong>Big Endian</strong>方式来存储数据。</li>
<li>所有网络协议也都是采用<strong>Big Endian</strong>的方式来传输数据的。所以有时我们也会把<strong>Big Endian</strong>方式称之为<strong>网络字节序</strong>。</li>
</ul>
<h2 id="为什么要注意字节序的问题呢？"><a href="#为什么要注意字节序的问题呢？" class="headerlink" title="为什么要注意字节序的问题呢？"></a>为什么要注意字节序的问题呢？</h2><p>你可能这么问。当然，如果你写的程序只在单机环境下面运行，并且不和别人的程序打交道，那么你完全可以忽略字节序的存在。但是，如果你的程序要跟别人的程序产生交互呢？尤其是当你把你在微机上运算的结果运用到计算机群上去的话。在这里我想说说两种语言。C/C++语言编写的程序里数据存储顺序是跟编译平台所在的CPU相关的，而JAVA编写的程序则唯一采用big endian方式来存储数据。试想，如果你用C/C++语言在x86平台下编写的程序跟别人的JAVA程序互通时会产生什么结果？就拿上面的 0x12345678来说，你的程序传递给别人的一个数据，将指向0x12345678的指针传给了JAVA程序，由于JAVA采取big endian方式存储数据，很自然的它会将你的数据翻译为0x78563412。什么？竟然变成另外一个数字了？是的，就是这种后果。因此，在你的C程序传给JAVA程序之前有必要进行字节序的转换工作。</p>
<h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><h2 id="一、在进行网络通信时是否需要进行字节序转换？"><a href="#一、在进行网络通信时是否需要进行字节序转换？" class="headerlink" title="一、在进行网络通信时是否需要进行字节序转换？"></a>一、在进行网络通信时是否需要进行字节序转换？</h2><p>   相同字节序的平台在进行网络通信时可以不进行字节序转换，但是跨平台进行网络数据通信时必须进行字节序转换。</p>
<p>   原因如下：网络协议规定接收到得第一个字节是高字节，存放到低地址，所以发送时会首先去低地址取数据的高字节。小端模式的多字节数据在存放时，低地址存放的是低字节，而被发送方网络协议函数发送时会首先去低地址取数据（想要取高字节，真正取得是低字节），接收方网络协议函数接收时会将接收到的第一个字节存放到低地址（想要接收高字节，真正接收的是低字节），所以最后双方都正确的收发了数据。而相同平台进行通信时，如果双方都进行转换最后虽然能够正确收发数据，但是所做的转换是没有意义的，造成资源的浪费。而不同平台进行通信时必须进行转换，不转换会造成错误的收发数据，字节序转换函数会根据当前平台的存储模式做出相应正确的转换，如果当前平台是大端，则直接返回不进行转换，如果当前平台是小端，会将接收到得网络字节序进行转换。</p>
<h2 id="二、网络字节序"><a href="#二、网络字节序" class="headerlink" title="二、网络字节序"></a><strong>二、网络字节序</strong></h2><p>​    网络上传输的数据都是字节流,对于一个多字节数值,在进行网络传输的时候,先传递哪个字节?也就是说,当接收端收到第一个字节的时候,它将这个字节作为高位字节还是低位字节处理,是一个比较有意义的问题; UDP/TCP/IP协议规定:把接收到的第一个字节当作高位字节看待,这就要求发送端发送的第一个字节是高位字节;而在发送端发送数据时,发送的第一个字节是该数值在内存中的起始地址处对应的那个字节,也就是说,该数值在内存中的起始地址处对应的那个字节就是要发送的第一个高位字节(即:高位字节存放在低地址处);由此可见,多字节数值在发送之前,在内存中因该是以大端法存放的; 所以说,网络字节序是大端字节序; 比如,我们经过网络发送整型数值0x12345678时,在80X86平台中,它是以小端发存放的,在发送之前需要使用系统提供的字节序转换函数htonl()将其转换成大端法存放的数值;</p>
<h1 id="c-大端转换"><a href="#c-大端转换" class="headerlink" title="c# 大端转换"></a>c# 大端转换</h1><p>c#在windows平台上是小端字节序(Windos(x86,x64)和Linux(x86,x64)都是<strong>Little Endian</strong>操作系统,不止是c#)。网络发送字节流是按大端序发送，也就是从左到右发送，和c#的小端序相反，造成网关不能正常识别协议。所以需要转换</p>
<p><strong>大小端转换</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int x &#x3D; 439041118;  &#x2F;&#x2F; 十六进制为 1A2B3C5E</span><br><span class="line"></span><br><span class="line">string s &#x3D; null;</span><br><span class="line"></span><br><span class="line">byte[] b &#x3D; BitConverter.GetBytes( x );</span><br><span class="line"></span><br><span class="line">s &#x3D; BitConverter.ToString( b ); &#x2F;&#x2F; 小端模式</span><br><span class="line">Console.WriteLine( s ); &#x2F;&#x2F; 小端输出 为 5E-3C-2B-1A</span><br><span class="line"></span><br><span class="line">Array.Reverse( b ); &#x2F;&#x2F; 反转</span><br><span class="line"></span><br><span class="line">s &#x3D; BitConverter.ToString( b ); &#x2F;&#x2F; 大端模式</span><br><span class="line">Console.WriteLine( &quot;&#123;0:x&#125;&quot;, s ); &#x2F;&#x2F; 大端输出 为 1A-2B-3C-5E</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>

<p><strong>C# 判断数据在此计算机结构中存储时的字节顺序（“Endian”性质），即大端还是小端</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int data &#x3D; 439041118; &#x2F;&#x2F; 十六进制为 1A2B3C5E</span><br><span class="line">byte[] bData &#x3D; BitConverter.GetBytes( data );</span><br><span class="line">            </span><br><span class="line">if (BitConverter.IsLittleEndian) &#x2F;&#x2F; 若为 小端模式</span><br><span class="line">&#123;</span><br><span class="line">   Array.Reverse( bData ); &#x2F;&#x2F; 转换为 大端模式               </span><br><span class="line">&#125;</span><br><span class="line">string s &#x3D; BitConverter.ToString( bData );</span><br><span class="line"></span><br><span class="line">Console.WriteLine(s);</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure>

<p> <strong>一些封装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;翻转byte数组</span><br><span class="line">public static void ReverseBytes(byte[] bytes)</span><br><span class="line">&#123;</span><br><span class="line">    byte tmp;</span><br><span class="line">    int len &#x3D; bytes.Length;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; len &#x2F; 2; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        tmp &#x3D; bytes[len - 1 - i];</span><br><span class="line">        bytes[len - 1 - i] &#x3D; bytes[i];</span><br><span class="line">        bytes[i] &#x3D; tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;规定转换起始位置和长度</span><br><span class="line"> public static void ReverseBytes(byte[] bytes, int start, int len)</span><br><span class="line"> &#123;</span><br><span class="line">     int end &#x3D; start + len - 1;</span><br><span class="line">     byte tmp;</span><br><span class="line">     int i &#x3D; 0;</span><br><span class="line">     for (int index &#x3D; start; index &lt; start + len&#x2F;2; index++,i++)</span><br><span class="line">     &#123;</span><br><span class="line">         tmp &#x3D; bytes[end - i];</span><br><span class="line">         bytes[end - i] &#x3D; bytes[index];</span><br><span class="line">         bytes[index] &#x3D; tmp;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 翻转字节顺序 (16-bit)</span><br><span class="line">public static UInt16 ReverseBytes(UInt16 value)</span><br><span class="line">&#123;</span><br><span class="line">  return (UInt16)((value &amp; 0xFFU) &lt;&lt; 8 | (value &amp; 0xFF00U) &gt;&gt; 8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 翻转字节顺序 (32-bit)</span><br><span class="line">public static UInt32 ReverseBytes(UInt32 value)</span><br><span class="line">&#123;</span><br><span class="line">  return (value &amp; 0x000000FFU) &lt;&lt; 24 | (value &amp; 0x0000FF00U) &lt;&lt; 8 |</span><br><span class="line">         (value &amp; 0x00FF0000U) &gt;&gt; 8 | (value &amp; 0xFF000000U) &gt;&gt; 24;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 翻转字节顺序 (64-bit)</span><br><span class="line">public static UInt64 ReverseBytes(UInt64 value)</span><br><span class="line">&#123;</span><br><span class="line">  return (value &amp; 0x00000000000000FFUL) &lt;&lt; 56 | (value &amp; 0x000000000000FF00UL) &lt;&lt; 40 |</span><br><span class="line">         (value &amp; 0x0000000000FF0000UL) &lt;&lt; 24 | (value &amp; 0x00000000FF000000UL) &lt;&lt; 8 |</span><br><span class="line">         (value &amp; 0x000000FF00000000UL) &gt;&gt; 8 | (value &amp; 0x0000FF0000000000UL) &gt;&gt; 24 |</span><br><span class="line">         (value &amp; 0x00FF000000000000UL) &gt;&gt; 40 | (value &amp; 0xFF00000000000000UL) &gt;&gt; 56;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外c#直接提供了网络字节序转换方法。</p>
<p><code>System.Net.IPAddress.HostToNetworkOrder</code>（本机到网络转换）</p>
<p><code>System.Net.IPAddress.NetworkToHostOrder</code>(网络字节转成本机)</p>
<p>推荐使用这种方法，简单有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">short x &#x3D; 6;</span><br><span class="line">short b &#x3D; System.Net.IPAddress.HostToNetworkOrder(x); &#x2F;&#x2F;把x转成相应的大端字节数</span><br><span class="line">byte[] bb &#x3D; System.BitConverter.GetBytes(b);&#x2F;&#x2F;这样直接取到的就是大端字节序字节数组。</span><br></pre></td></tr></table></figure>





<h2 id="对于字符串型："><a href="#对于字符串型：" class="headerlink" title="对于字符串型："></a>对于字符串型：</h2><p>使用 System.Text.Encoding.Default.GetBytes();直接取字串对应字节数组。</p>
<p>不知道为什么这个方法取到的直接就是大端字节数组。不用转换。</p>
<p>后来查了一下，关于字串的字节序问题，因为gbk和utf-8都是以单个字节表示数字的，所以不存在字节序问题，在多个不同系统架构都用。对于utf-16，则是以双字节表示一个整数，所以为会有字节序问题，分大小端unicode。</p>
<p>System.Text.Encoding.Default.GetBytes();在我的简体中文系统上是以gb2312的编码，也就是单个字来进行编码的，所以也不会有字节序问题。</p>
<p>补充：“<strong>对于任何字符编码，编码单元的顺序是由编码方案指定的，与endian无关。</strong>例如GBK的编码单元是字节，用两个字节表示一个汉字。这两个字节的顺序是固定的，不受CPU字节序的影响。UTF-16的编码单元是word（双字节），word之间的顺序是编码方案指定的，word内部的字节排列才会受到endian的影响。”，</p>
<p>所以utf-8也没有字节序的问题。字节序问题之存在于需要使用两个字节以上来表示整数。而UTF-8只是一串字节流，不存在字节序问题，不过将这些字节流翻译成Unicode比其他的传输方式复杂。以字节为单位编码的，无论一个汉字是多少个字节，都无字节序问题。</p>
<p>你注意，字节序问题不是指多个字节传输的先后，这个是固定的无异议的。而是指一个多字节编码在机器中的表示方式问题。<br><code>char str[] = &quot;abaksdkakskasklasflk&quot;；</code></p>
<p>这个无字节序问题。但<br><code>int  str[] = {0x11223344, 2, 3 }</code></p>
<p>就有字节序问题了。因为str[0]同样数值不同机器中表示不同。</p>
<p>而剩下的， 就是字符编码内部的字节序了。比如UTF-16是用两个字节表示一个字符，但是这两个字节内部如何排序，系统并不知道，所以必须指定字节序。但是UTF-8由于几个字节表示并不相同，一定要从那个表示长度的字节开始读，相当于一开始就知道该从哪里是队头队尾，所以不存在字节序问题。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>dll文件的加载</title>
    <url>/dotnet-2020-01-06-dll-load/</url>
    <content><![CDATA[<p>程序的运行要去加载所需要的dll文件，在程序运行的时候往往会遇到dll找不到的问题，或者不能确定所加载的dll文件是否是自己所需要的dll，遇到dll出问题的时候往往会不知所措，但是一旦知道了dll的加载顺序，按这个去查找解决就会方便和得心应手了。</p>
<p>(1)先搜索可执行文件所在路径，再搜索系统路径：%PATH%（环境变量所配置的路径）</p>
<p>一般Path中的值为：%SystemRoot%\system32;%SystemRoot%;  </p>
<p>(2)然后按下列顺序搜索 DLL： </p>
<p>1、当前进程的可执行模块所在的目录。</p>
<p>2、当前目录。</p>
<p>3、Windows 系统目录。GetSystemDirectory 函数检索此目录的路径。</p>
<p>4、Windows 目录。GetWindowsDirectory 函数检索此目录的路径。</p>
<p>5、PATH 环境变量中列出的目录。</p>
<p>有时候确定了加载的dll文件确实是自己所想加载的dll文件，但是还会发生错误的可能原因，就是dll文件被损坏，此时需要重新替换现有的dll文件；或者dll文件和所用的头文件（.h文件）不匹配，即是头文件中的函数，在dll文件中没有实现，这样的话，找到对应的dll文件就ok了。</p>
<p><strong>AssemblyLoadContext</strong></p>
<p>基本上AssemblyLoadContext是AppDomain的继承者，它提供相同而且更多的功能-除了安全边界（隔离）。最小的安全边界是进程，因此你将需要使用进程间通信来正确隔离数据和代码执行。</p>
<p>官网文档中提到Appdomain已经过时了，为了兼容旧的版本，提供了部分功能。建议在.NET Core3.0及更高的版本使用AssemblyLoadContext。</p>
<p><strong>从AppDomain迁移到AssemblyLoadContext</strong></p>
<p>也许你仍在应用程序中使用AppDomain。现在，以下代码显示如何用AssemblyLoadContext的相应方法去替换掉AppDomain方法：</p>
<ul>
<li>获取所有程序集</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var assembliesInAppDomain &#x3D; AppDomain.CurrentDomain.GetAssemblies();</span><br><span class="line">var assembliesInAssemblyLoadContext &#x3D; AssemblyLoadContext.Default.Assemblies;</span><br></pre></td></tr></table></figure>

<ul>
<li>加载一个程序集</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppDomain.CurrentDomain.Load(AssemblyName.GetAssemblyName(&quot;path&quot;));</span><br><span class="line">AssemblyLoadContext.Default.LoadFromAssemblyName(AssemblyName.GetAssemblyName(&quot;path&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>加载一个程序集 路径或者字节数组:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppDomain.CurrentDomain.Load(File.ReadAllBytes(&quot;path&quot;));</span><br><span class="line">AssemblyLoadContext.Default.LoadFromStream(File.OpenRead(&quot;path&quot;));&#x2F;&#x2F; orAssemblyLoadContext.Default.LoadFromAssemblyPath(&quot;path&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>测试封装的获取程序集方法GetAssemblies</li>
</ul>
<p>准备工作：</p>
<ol>
<li><p>创建一个控制台程序</p>
</li>
<li><p>添加一个类库项目，命名为AA.Service</p>
<p>在控制台应用程序，添加一个类TypeFinder代码如下：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TypeFinder</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 获取物理路径 </span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;\bin\Debug\netcoreapp3.0&lt;&#x2F;returns&gt;</span><br><span class="line">        public virtual string GetBinDirectory()</span><br><span class="line">        &#123;</span><br><span class="line">            return AppContext.BaseDirectory;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 获取程序集</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">        public IList&lt;Assembly&gt; GetAssemblies()</span><br><span class="line">        &#123;</span><br><span class="line">            var binPath &#x3D; GetBinDirectory();</span><br><span class="line">            var addedAssemblyNames &#x3D; new List&lt;string&gt;();</span><br><span class="line">            var assemblies &#x3D; new List&lt;Assembly&gt;();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a&#x3D;&gt;IsNotSysAssembly(a.FullName)))</span><br><span class="line">            &#123;</span><br><span class="line">                if (addedAssemblyNames.Contains(assembly.FullName))</span><br><span class="line">                    continue;</span><br><span class="line">                addedAssemblyNames.Add(assembly.FullName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            foreach (var dllPath in Directory.GetFiles(binPath, &quot;*.dll&quot;,</span><br><span class="line">                 SearchOption.TopDirectoryOnly))</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    var an &#x3D; AssemblyName.GetAssemblyName(dllPath);</span><br><span class="line">                    if (!addedAssemblyNames.Contains(an.FullName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        AssemblyLoadContext.Default.LoadFromAssemblyName(an);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                catch (BadImageFormatException ex)</span><br><span class="line">                &#123;</span><br><span class="line">                    Trace.TraceError(ex.ToString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            foreach (var assembly in AssemblyLoadContext.Default.Assemblies.Where(a &#x3D;&gt; IsNotSysAssembly(a.FullName)))</span><br><span class="line">            &#123;</span><br><span class="line">                if (addedAssemblyNames.Contains(assembly.FullName))</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                assemblies.Add(assembly);</span><br><span class="line">            &#125;</span><br><span class="line">            return assemblies;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; 排除系统程序集</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;assemblyName&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">        private bool IsNotSysAssembly(string assemblyName) </span><br><span class="line">        &#123;</span><br><span class="line">            return !assemblyName.StartsWith(&quot;Microsoft.&quot;)</span><br><span class="line">                      &amp;&amp; !assemblyName.StartsWith(&quot;System.&quot;)</span><br><span class="line">                      &amp;&amp; !assemblyName.StartsWith(&quot;Newtonsoft.&quot;)</span><br><span class="line">                      &amp;&amp; assemblyName !&#x3D; &quot;netstandard&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在控制台应用程序添加引用AA.Service类库，生成查看bin文件，出现了AA.Service.dll</p>
<p><img src="../../assets/images/2020-01-06-dll-load/640.webp" alt="img"></p>
<p>调用代码输出(排除系统dll以Microsoft、system开头的)程序集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var assemblies&#x3D; new TypeFinder().GetAssemblies();        </span><br><span class="line">foreach (var a in assemblies)             </span><br><span class="line">&#123;                </span><br><span class="line">Console.WriteLine(a.FullName);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<p><img src="../../assets/images/2020-01-06-dll-load/640.webp" alt="img"></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟补偿和对时的相关总结</title>
    <url>/dotnet-2020-02-02-Latency-Compensating-rtt/</url>
    <content><![CDATA[<p>国内的网络游戏多是客户端/服务器方式，而对于游戏实时性要求比较高的网游，如 果采用客户端发送时间包给服务器，服务器校验后再下发给客户端表现的话，网络延时 和抖动都会恶化游戏体验。对于客户端和服务器的同步问题， 一般有两种算法解决：</p>
<p>① 、客户端和服务器之间进行对时后，客户端发送数据包给服务器，服务器根据收 到的客户端数据包先后进行排序，先到达的服务器端的事件包被判定为先发生，后到达 服务器的事件包被判定为后发生。在此情况下，往往网络延时较大的客户端先发送了游 戏事件包，但由于网络延时和抖动的影响，后到达服务器，而被判定为后发生时间，这 样对该客户端就不公平了。</p>
<p>② 、客户端和服务器进行对时后，客户端预测服务器收到客户端数据包的时间，并 把该时间写入数据包中发送给服务器，在网络抖动比较大的情况下，这种情况可以保证一定的公平性。但是还是出现了上述的情况，网络延时大的数据包预测的到达时间也就 更晚，依然会出现先发生的事件被服务器判定为后发生，同样不能保证游戏的公平性。</p>
<p>因此，在现有的解决网络实时性较差问题的技术方案中，当采用TimeWarp同步机制 时，则需要保存数量较多的快照，同时也会使回滚的次数较多，导致过多的消耗内存和 CPU资源，以及降低游戏体验；对于国内网络游戏采用的网络时间同步机制，无论服务器 根据客户端数据包到达的时间进行排序，或客户端预测服务器收到客户端数据包的时间 并把该时间写入数据包中发送给服务器，对于网络延时越大的玩家同样会降低游戏体 验。</p>
<h2 id="网络对时"><a href="#网络对时" class="headerlink" title="网络对时"></a>网络对时</h2><p>大部分的强交互网游会做对时, 使 client 和 server 保持时间基本一致.</p>
<p><img src="../../assets/images/2020-02-02-Latency_Compensating-rtt/iyeruicpsm.png" alt="img"></p>
<ol>
<li>client 带上本地时间 t0 向 server 发送对时请求.</li>
<li>server 回复当前自己的系统时间 t1.</li>
<li>client ack 收到 server 回复时的本地时间 t2.</li>
</ol>
<p>如果只有 client 关心对时结果, 这时可以优化到<strong>只做1,2步甚至只做第2步</strong>, 相当于 client 主动发起 ping;</p>
<p>同样, 如果只有 server 关心对时结果, sever 主动发起 ping (第2,3步)即可.</p>
<p>单次对时往往会受到网络波动的影响, 所以一般还需要做多次统计一个比较合理的时间偏移.</p>
<p>网络对时, 一般在进游戏之初做. 如果在游戏过程中发现有网络波动过大的情况(在下行协议包中带上 server 的时间, 很容易检查到提前或者滞后), 也需要重新发起对时.</p>
<p>考虑到反外挂(比如加速齿轮, 或者减速器)的因素, server 端需要对主动发起的client对时请求做一些安全校验, 例如时间递增, 是否满足阈值等等.</p>
<p>光从对时的角度来看, UDP 协议比 TCP 更合适一些, 不过取决于项目需要.</p>
<h2 id="服务器和客户端时间差算法-st0-st2-2ct1-2"><a href="#服务器和客户端时间差算法-st0-st2-2ct1-2" class="headerlink" title="服务器和客户端时间差算法 (st0+st2-2ct1)/2"></a>服务器和客户端时间差算法 <strong>(st0+st2-2ct1)/2</strong></h2><p> <img src="../../assets/images/2020-02-02-Latency_Compensating-rtt/image-20200221152318844.png" alt="image-20200221152318844"></p>
<h3 id="两种理解方式"><a href="#两种理解方式" class="headerlink" title="两种理解方式"></a>两种理解方式</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p><code>ct1-st0 = &amp;0 +(ct1-st1)</code>  延迟+ 时间差(同一时刻下客户端减去服务端的时间差)</p>
<p><code>st2-ct1 = &amp;1+(st2-ct2)</code>  延迟+ 时间差(同一时刻下服务端减去客户端的时间差)</p>
<p>我们需要的就是<code>st2-ct2</code> 由上可以转换为<code>-(ct1-st1) = st2-ct2</code>  </p>
<p>现假设 <code>o = st2-ct2</code>同时假设延迟相等 <code>p = &amp;0 = &amp;1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ct1-st0 &#x3D; p - o</span><br><span class="line"></span><br><span class="line">st2-ct1 &#x3D; p + o</span><br><span class="line"></span><br><span class="line">ct1-st0-st2+ct1 &#x3D; -2o</span><br><span class="line"></span><br><span class="line">o &#x3D;(st0+st2-2ct1)&#x2F;2</span><br></pre></td></tr></table></figure>

<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p><code>&amp;0 = &amp;1 = (st2-st0)/2</code>    我们知道<code>(st2-st0)/2</code>是单次延迟 即</p>
<p><code>st2-ct1 = &amp;1+(st2-ct2)</code>  延迟+ 时间差(同一时刻下服务端减去客户端的时间差)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st2-ct1 &#x3D; (st2-st0)&#x2F;2 + o</span><br><span class="line"></span><br><span class="line">2st2-2ct1 &#x3D; st2-st0 + 2o</span><br><span class="line"></span><br><span class="line">o &#x3D; (st0+st2-2ct1)&#x2F;2</span><br></pre></td></tr></table></figure>


<p><a href="https://patents.google.com/patent/CN101577715A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN101577715A/zh</a></p>
<p>服务器获得服务器与客户端的时间差值后，与服务器接收到来自客户端的数据包的时间做差值可以获得客户端在游 戏过程中实际向服务器发送数据包的时间，<strong>并通过客户端在游戏过程 中实际向服务器发送数据包的时间来判定在游戏时间中事件发生的实际顺序</strong>， 从而较好的保持了游戏的公平性，提高了游戏玩家的游戏体验。</p>
<h4 id="检查安全性"><a href="#检查安全性" class="headerlink" title="检查安全性"></a>检查安全性</h4><ol>
<li><p>第一次连接的对时..时差不该查过三分钟.</p>
</li>
<li><p>校验包客户端有没有修改时间,能够求得发包的时间,对比服务器接收到包的时间以及延迟</p>
</li>
</ol>
<h2 id="移动的延迟补偿"><a href="#移动的延迟补偿" class="headerlink" title="移动的延迟补偿."></a>移动的延迟补偿.</h2><p>使用了客户端预测的话,客户端的移动位置要优先于服务端的,因为有来回两次延迟..</p>
<p>由于状态同步以服务端为准,使用服务器校对不会出什么问题.</p>
<p>所以这里的补偿是补偿从客户端到服务端这段延迟.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class move</span><br><span class="line">&#123;</span><br><span class="line">	DatetimeOffset clientTime</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; xxx;&#x2F;&#x2F;服务端和客户端的时间差</span><br><span class="line">var startMoveTime &#x3D;   move.clientTime+o;</span><br><span class="line">var delay &#x3D; DateTimeOffset.Now()-startMoveTime;&#x2F;&#x2F;延迟时间</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;todo:将延迟时间参与到pos的计算当中</span><br></pre></td></tr></table></figure>

<p>如果使用了服务器校对不补偿也并没有什么太大的问题,因为最终仍然是以服务器为准的.</p>
<p>但是补偿了之后减少了延迟,会更平缓一点.</p>
<p><a href="https://patents.google.com/patent/CN102404279A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN102404279A/zh</a></p>
<h2 id="boss攻击的延迟补偿"><a href="#boss攻击的延迟补偿" class="headerlink" title="boss攻击的延迟补偿."></a>boss攻击的延迟补偿.</h2><p><img src="../../assets/images/2020-02-02-Latency_Compensating-rtt/image-20200221164609309.png" alt="image-20200221164609309"></p>
<p>玩家ct2的时候开始移动,但是服务器收到的时候已经是st4</p>
<p>而服务器st2的时候boss发动了攻击.这个时候.玩家在服务器的位置是在ct3</p>
<p>需要boss把攻击作为关键事件…直到客户端有ct4事件出来时再执行st2,</p>
<p>可以使用时间轮算法触发关键事件</p>
<h2 id="玩家-的延迟补偿"><a href="#玩家-的延迟补偿" class="headerlink" title="玩家 的延迟补偿"></a>玩家 的延迟补偿</h2><p>这是由于客户端使用了插值算法造成的</p>
<p>比如fps游戏,玩家看到的敌人的位置永远是过去的,当你开枪的时候,那个人其实已不在那个位置</p>
<p>所以需要记录游戏的世界状态..找到子弹打出时那一刻的世界状态.然后判定</p>
<p><a href="https://patents.google.com/patent/CN102739608A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN102739608A/zh</a></p>
<h2 id="一些模拟恶劣网络环境工具"><a href="#一些模拟恶劣网络环境工具" class="headerlink" title="一些模拟恶劣网络环境工具"></a>一些模拟恶劣网络环境工具</h2><ul>
<li><a href="http://jagt.github.io/clumsy/cn/index.html" target="_blank" rel="noopener">http://jagt.github.io/clumsy/cn/index.html</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>延迟补偿在C/S架构游戏协议设计和优化中的应用</title>
    <url>/dotnet-2020-02-02-Latency-Compensating-Methods-in-ClientServer-In-game-Protocol-Design-and-Optimization/</url>
    <content><![CDATA[<h1 id="1-综述"><a href="#1-综述" class="headerlink" title="1.综述"></a>1.综述</h1><p>第一人称角色网络游戏的设计是一项很有挑战性的工作。网络环境下的健壮性，是动作游戏能否成功的一个重要因素。另外，PC上面的开发者需要考虑到玩家层次不齐的机器配置以及网络状况，很多用户的硬件配置跟网络跟当前最好的配置跟网络有一定差距。</p>
<p>宽带网络的出现有利于在线游戏开发，但是开发者还是需要考虑网络延迟和其它网络特性。而且宽带网络在美国被广泛采用还需要一段时间，在世界上其它国家可能需要更长的一段时间。另外，很多宽带网络质量很差，用户虽然偶尔能够享受到高带宽，但更多的时候他们不得不面对高延迟和高丢包率。</p>
<p>我们应该提供给玩家良好的游戏。本篇文章讨论了如何提供给玩家顶尖的操作体验；介绍了很多在线动作游戏中采用的C/S架构背景。此外，我们还讨论了如何通过一个预测模型来掩饰延迟带来的影响。文章的最后描述了一个叫做延迟补偿的机制，弥补了因为网络质量不好带来的负面影响</p>
<h1 id="2-C-S游戏的基本架构"><a href="#2-C-S游戏的基本架构" class="headerlink" title="2.C/S游戏的基本架构"></a>2.C/S游戏的基本架构</h1><p>网络上可玩的大部分动作游戏都是C/S结构游戏基础上修改完成的，比如半条命以及其修改版反恐精英、军团要塞，以及一些基于quake3引擎和虚幻引擎的游戏。这类游戏都有一个用来执行游戏逻辑的服务器以及连接到这个服务器的多个客户端。客户端仅仅是用来接收玩家的操作并发给服务器，服务器对这些操作作出响应，移动玩家周围物体，并将游戏世界的信息发给客户端显示出来。当然世界的游戏系统有更多组件，我们这样简化有利于分析预测和延迟补偿。</p>
<p>基于这种考虑，典型的C/S游戏引擎通常看起来是这样的</p>
<p><img src="../../assets/images/2020-02-02-Latency_Compensating_Methods_in_ClientServer_In-game_Protocol_Design_and_Optimization/Lagcomp1.png" alt="General Client / Server Architecture"></p>
<p>为了便于讨论，我们假定客户端跟服务器之间已经建立连接；客户端的每一帧循环如下：</p>
<ol>
<li><p>获取帧开始时间</p>
</li>
<li><p>采集用户输入</p>
</li>
<li><p>根据模拟时间将移动命令打包发送给服务器</p>
</li>
<li><p>获取处理服务器传过来的数据包</p>
</li>
<li><p>根据服务器数据包的内容决定可见物体及其状态</p>
</li>
<li><p>渲染场景</p>
</li>
<li><p>获取帧结束时间</p>
</li>
<li><p>结束时间减去开始时间就是下一帧的模拟时间</p>
</li>
</ol>
<p>客户端每完成一个帧循环，就用“frametime”来决定下一帧需要多少时间，如果帧率恒定，“frametime”就是准确的，否则就没办法获得准确的“frametime”（因为在没一帧开始你不可能知道这一帧需要多长时间）</p>
<p>服务器的循环大同小异：</p>
<ol>
<li><p>获取帧开始时间</p>
</li>
<li><p>读取客户端发过来的操作信息</p>
</li>
<li><p>根据客户端操作执行逻辑运算</p>
</li>
<li><p>采用上一个循环得到的模拟时间来模拟服务器控制的物体移动状态</p>
</li>
<li><p>对每一个连接的客户端，发送打包相应的物体/世界状态</p>
</li>
<li><p>获取帧结束时间</p>
</li>
<li><p>结束时间减去开始时间就是下一帧的模拟时间</p>
</li>
</ol>
<p>在这个模型中，非玩家物体完全由服务器控制其状态，每个玩家根据服务器发过来的数据包控制自己的移动。这是一种很自然的方法，当然还有其它的方法也可以完成这个功能。</p>
<h1 id="3-用户消息的内容"><a href="#3-用户消息的内容" class="headerlink" title="3.用户消息的内容"></a>3.用户消息的内容</h1><p>基于half-life引擎的游戏用户消息都很简单，只需要封装在一个包含几个关键成员的结构中：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">usercmd_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Interpolation time on client</span></span><br><span class="line">    short lerp_msec;  </span><br><span class="line">    <span class="comment">// Duration in ms of command</span></span><br><span class="line">    <span class="keyword">byte</span> msec;    </span><br><span class="line">    <span class="comment">// Command view angles.</span></span><br><span class="line">    <span class="keyword">vec3_t</span> viewangles;  </span><br><span class="line">    <span class="comment">// intended velocities</span></span><br><span class="line">    <span class="comment">// Forward velocity.</span></span><br><span class="line">    <span class="keyword">float</span> forwardmove;  </span><br><span class="line">    <span class="comment">// Sideways velocity.</span></span><br><span class="line">    <span class="keyword">float</span> sidemove;   </span><br><span class="line">    <span class="comment">// Upward velocity.</span></span><br><span class="line">    <span class="keyword">float</span> upmove;  </span><br><span class="line">    <span class="comment">// Attack buttons</span></span><br><span class="line">    <span class="keyword">unsigned</span> short buttons; </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Additional fields omitted...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">usercmd_t</span>;</span><br></pre></td></tr></table></figure>

<p>结构中最关键的变量时msec,viewangles,forward,side,upmove和buttons。msec表示这个命令执行对应的毫秒数（也就是上面提到的“frametime”）。viewangles是一个三维向量，表示玩家的朝向。forward,side和upmove表示玩家是否通过键盘、鼠标或控制杆控制移动。最后，buttons这个字段包含一个或多个比特，标志玩家是否按着某些按键。</p>
<p>基于C/S架构的游戏采用以上数据结构运行如下：客户端创建命令并发送到服务器，服务器响应这些命令并把更新了的世界和物体位置信息发回客户端，客户端收到以后进行渲染。这种方式非常简单，但是在实际应用中效果差强人意，用户会感觉到网络连接带来的明显延迟。这主要是由于客户端完全没有逻辑操作，发出消息以后就等待服务器响应。如果客户端跟服务器有500ms的延迟，客户端执行了操作到看到操作的结果就需要500ms，这种延迟在局域网通常可以接受（因为通常延迟比较小），但在因特网上是没法接受的</p>
<h1 id="4-客户端预测"><a href="#4-客户端预测" class="headerlink" title="4.客户端预测"></a>4.客户端预测</h1><p>有一种方法可以改善这种情况：客户端本地即时执行移动操作，假定服务器即时通知客户端可以执行操作，这种方法可以称为客户端预测。</p>
<p>采用客户端运动预测以后，客户端就不再是一个“小型客户端”，不再单单响应服务器命令；但也不是说客户端可以像没有中央服务器的p2p游戏完全自治。服务器仍然在运行并保证在客户端跟服务器运行结果不一致的情况下纠正客户端错误的模拟。由于网络延迟，修正在一个网络传输周期以后才会执行，这个时候纠正信息通常已经过期，这样会导致明显的位置漂移，因为客户端收到的修正信息是过去某个时间的。</p>
<p>为了使客户端运动预测有效，我们采用以下方法：还是客户端采样并生成命令发送到服务器，但是每个包含生成时间的命令在客户端本地存起来并在预测算法中使用。</p>
<p>预测的过程中，我们把服务器确认的移动信息作为开始，这样客户端就可以确定服务器执行上次命令以后游戏中玩家的准确信息（比如位置）。如果网络有延迟，这个确认命令也会有一定延迟。假设客户端运行帧率为50fps，网络延时为100ms，这样在客户端收到服务器的确认命令的时候，本地命令队列中已经有5条信息，这5条信息被用来执行客户端预测。假设执行完全预测【1】客户端在收到来自服务器的最新信息后，就开始按照与服务器相同的逻辑执行本地消息队列中的5个命令。这些命令执行以后得到当前状态（最重要的是位置），然后根据玩家的状态信息渲染当前帧。</p>
<p>在半条命这个游戏中，客户端跟服务器采用相同的代码来计算移动，这样可以减小客户端预测跟服务器之间的误差。这些代码位于HLSDK中的pm_shared/（意思是“player movement shared”）。这段代码的输入是玩家操作和客户端的初始状态，输出是玩家操作以后的状态。客户端算法大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;from state&quot; &lt;- state after last user command acknowledged by the server;</span><br><span class="line"></span><br><span class="line">&quot;command&quot; &lt;- first command after last user command acknowledged by server;</span><br><span class="line"></span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    run &quot;command&quot; on &quot;from state&quot; to generate &quot;to state&quot;;</span><br><span class="line">    if (this was the most up to date &quot;command&quot;)</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">    &quot;from state&quot; &#x3D; &quot;to state&quot;;</span><br><span class="line">    &quot;command&quot; &#x3D; next &quot;command&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>玩家的初始状态和预测结果用来渲染场景。命令的执行过程就是：将玩家状态复制到共享数据结构中，执行玩家操作（执行hlsdk中pm_shared中的共用代码），然后将结果复制到目标状态（to state）</p>
<p>这个系统中有几个需要注意的地方，首先，由于网络延迟，客户端又在不停地以一定速度（客户端帧率）生成命令，一个命令通常会被客户端多次执行，知道得到服务器的确定以后将其从命令列表中删除（这就是半条命中的滑动窗口）。首先要考虑的是如何处理共享代码中生成的声效和动画效果。因为命令可能会被多次执行，预测位置的过程被多次执行的时候要注意避免重声等不正确的效果。另外，服务器也要避免客户端意见预测的效果。然而，客户端必须重新运行旧的命令，否则就没法根据服务器来纠正客户端的预测错误。解决方法很简单：客户端将没有执行的客户端命令进行标记，如果这些命令在客户端第一次执行，则播放相应的效果。</p>
<p>另外需要注意的是服务器不处理，只有客户端才有的一些数据；如果没有这种类型的数据，我们可以如上面所述，以服务器第一条消息作为起点进行预测得到下一帧状态（包括用来渲染的位置信息）。然而，如果有些逻辑是纯客户端的，服务器不会处理（比如玩家蹲下来眼睛的位置-然而这也不是纯客户端信息，因为服务器也会处理这个数据），这种情况下我们需要将预测的中间结果存起来。可以用一个滑动窗口完成这项工作，其中“开始状态”是开始，以后每次执行一个玩家命令预测完成后，填写窗口中的下一个状态；当服务器通知某个命令被接受并执行以后，从窗口中查找服务器处理的是哪条命令并将相应的数据传到下一个帧的“起始状态”</p>
<p>到此为止，我们描述了客户端的运动预测。quakeworld2中采用了这种类型的预测</p>
<h1 id="5-开火过程中的客户端预测"><a href="#5-开火过程中的客户端预测" class="headerlink" title="5.开火过程中的客户端预测"></a>5.开火过程中的客户端预测</h1><p>上面描述的系统可以很自然地用于武器开火效果预测。客户端玩家需要记录一些状态，比如身上有哪些武器，正在使用的是哪一个，每把武器都还剩多少弹药。有了这些信息，开火逻辑可以建立在运动逻辑上面，只需要在客户端和服务器使用的命令里面加上玩家开火的按键信息。在半条命中，为了简单，武器开火逻辑代码也跟运动代码一样也作为“共享代码”。所有会影响到武器状态的变量，比如弹药、下次可开火时间、正在播放那个武器动画，都作为服务器的状态，这些状态会通知给客户端用来预测武器状态。</p>
<p>客户端武器开火预测包括预测武器切换、部署、手枪皮套。这样，玩家会感觉游戏中的移动和武器状态100%受他控制。这在减小网络延迟给玩家带来的不爽上面迈出了一大步。</p>
<h1 id="6-一些工作"><a href="#6-一些工作" class="headerlink" title="6.一些工作"></a>6.一些工作</h1><p>服务器需要将必要的字段发给客户端，并且处理很多中间状态，有人可能有这样的疑问，为什么不把服务器逻辑取消，让客户端广播自己的位置，也就是将所有的移动、开火逻辑放在客户端。这样，客户端就会给服务器发送类似这样的结果报告：“我在X位置，我爆了玩家2的脑袋”。如果客户端可信的话，这样做是可以的，很多军方仿真系统就是这样做的（他们是一个封闭系统，所有客户端都可信）。点对点的游戏也是这么做的。对于半条命来说不可以这样做，因为客户端可能“欺骗”服务器。如果我们以这种方法封装状态数据，就会诱导玩家破解客户端【3】。对于我们的游戏来说这样做奉献太大，我们还是选择采用服务器模式来做校验。</p>
<p>客户端进行运动和武器效果预测是非常可行的。例如quake3就支持这样的预测。这个系统需要注意一点，在判断目标的时候需要考虑到延迟（比如即时射击武器）。换句话说，虽然你看到自己用\即时\武器进行了射击，你自己的位置也是最新的，射击结果仍然跟延迟有关。例如，如果你射击一个玩家，这个玩家沿与你实现垂直的方向奔跑，假设你客户端延迟为100ms，玩家奔跑速度是500单位每秒，这样你需要瞄准玩家前方50单位才能准确击中。延迟越大，就需要更大的提前量。靠感觉弥补延迟太困难了。为了减轻这种效果，quake3对你的射击播放一个短音来进行确定。这样，玩家可以算出快速发射武器的时候需要多大的提前量，同时调整提前量直到听到稳定的音调串。如果延迟比较大，而你的对手又在不断躲避，就很难获得足够的反馈判断。如果延迟也不断变化，就更难了。</p>
<h1 id="7-目标的显示"><a href="#7-目标的显示" class="headerlink" title="7.目标的显示"></a>7.目标的显示</h1><p>影响玩家游戏体验的另一个重要方面是客户端如何渲染其它玩家。两种基本的判断机制是：外推法和内插法【4】</p>
<p>外推法把其它玩家/物体看作一个点，这个点开始的位置、方向、速度已知，沿着自己的弹道向前移动。因此，假设延时是100ms，最新的协议通知客户端这个玩家奔跑速度是500单位每秒，方向垂直于玩家视线，客户端就可以假设事实上这个玩家当前实际的位置已经向前移动了50个单位。客户端可以在这个外推的位置渲染这个玩家，这样本地玩家就差不多可以正确瞄准。</p>
<p>外推法的最大缺点是玩家的移动并不是完全弹道的，而是不确定的并且高”jerk”【5】。大部分FPS游戏采用非现实的玩家系统，玩家可以随时转弯，可以在任意角度作用不现实的加速度，因此外推法得到的结果经常是错误地。开发者可以通过限制外推时间来减轻外推误差（比如quake限制不能超过100ms）。这种限制使得在客户端收到玩家正确位置以后，纠错不至于太大。当前大部分玩家的网络延迟高于150ms，玩家必须对游戏中的其他玩家进行外推以便正确击中。如果别的玩家因为外推错误，被服务器拉回，游戏体验将非常差。</p>
<p>另一种方法叫插值法。插值法可以这样理解：客户端物体实际移动位置总是滞后一段时间。举个例子，如果服务器每秒同步10次世界信息，客户端渲染的时候会有100ms滞后。这样，每一帧渲染的时候，我们通过最新收到的位置信息和前100ms的位置信息（或者上一帧渲染位置）进行差值得到结果。我们每收到一个物体位置的更新信息，（每秒10个更新意味着每100ms收到一个更新）接下来的100ms我们就可以朝这个新的位置移动。</p>
<p>如果一个更新包没有收到，有2种处理方法：第一、用上面介绍的外推法（有可能产生较大误差）；第二、保持玩家位于当前位置直到收到下一个更新包（会导致玩家移动顿挫）</p>
<p>内插法的大致过程如下：</p>
<ol>
<li><p>每个更新包包含生成的服务器时间戳【6】</p>
</li>
<li><p>根据客户端当前时间，客户端通过减去时间差（100ms）计算 一个目标时间</p>
</li>
<li><p>如果计算得到的目标时间在上一个更新时间和上上个更新时间之间，这些时间戳可以决定目标时间在过去的时间间隙中的情况</p>
</li>
<li><p>目标时间情况用来通过插值计算结果（如位置、角度）</p>
</li>
</ol>
<p>上面提到的插值法，本质上是客户端缓存了接下来100ms的数据。对于每一个周围的玩家，他们都位于过去某个时间的位置，根据每一个具体的时间点进行插值。如果偶尔发生丢包，我们就将插值时间延长到200ms。这样我们就可以忽略一次更新（假设同步频率还是10次每秒），玩家还可以移动到合理的目标位置，这样进行插值通常不会有什么问题。当然，插值多少时间需要权衡，因为这种方法是用延时（玩家更难击中）来换取平滑。</p>
<p>另外，上述插值方法（客户端通过2个更新信息插值并且朝最新更新位置移动）需要服务器更新信息间隔固定。对于所谓的“视觉效果因素”，这种方式很难处理，“视觉效果因素”是这样的：假设我们插值的物体是弹球（这种模型可以准确描述某些玩家）。极端情况下，球或者在空中，或者正在碰地板。然而，通常情况下球在这两种状态之间。如果我们只插值上一个位置，这个位置可能既不在地面上，也不是最高点，这样，弹球弹的效果就被平滑掉了，好像永远没有弹到地面一样。这是一个经典问题，增加采样率可以减轻这种影响，但是仍然有可能我们采样不到球在地面的点跟最高点，这些点会给平滑掉。</p>
<p>另外，不同用户网络状况不同，强迫每个用户都以固定速度更新（比如每秒10次）效果不是很好，在半条命中，用户每秒可以请求任意数量的更新包（没有限制）。这样，高速网络用户可以每秒更新50次，只要用户愿意。半条命的默认设置是每秒每个用户（以及游戏中其它物体）发送20次更新，以100ms为时间窗口进行插值。【7】</p>
<p>为了避免“反弹球”平滑问题，我们在插值的过程中采用了一个不同的算法，这种算法中我们对每一个可能插值的物体记录了一个完整的“历史位置”信息。</p>
<p>历史位置信息记录了物体的时间戳、远点、角度（以及其它我们需要插值计算的数据）。我们每收到一个服务器的更新，我们就创建一条包含时间戳的记录，其中包含原始位置、角度信息。在插值过程中，我们用上面的方法计算目标时间，然后搜索位置历史信息，找到包含目标时间的记录区间。然后用找到的信息插值计算当前帧的位置。这样我们就可以平滑跟踪到包含所有采样点的曲线。如果客户端帧率比服务器更新频率大，我们就可以将采样点平滑处理，减小上面提到的平滑处理带来的问题（当然没法避免，因为采用频率限制，而世界本身是连续的）。</p>
<p>需要注意的是，上面提到的插值方法使用的时候，物体有时候会被服务器拉回，而不是快速移动。当然我们也可以平滑地将物体移动一段较长的距离，这样看起来物体移动很快。更新的过程中我们可以设一个标志表示不插值或清除历史记录，或者如果起始点与目标点距离过长，我们就认为数据不正常。这种情况我们就将物体直接拉过去。并以这个位置为起始点进行插值。</p>
<h1 id="8-延迟补偿"><a href="#8-延迟补偿" class="headerlink" title="8.延迟补偿"></a>8.延迟补偿</h1><p>插值也会带来延迟，所以考虑延迟补偿的过程中需要理解插值过程。玩家看到的别的物体是经过插值计算出来的，所以插值过程中需要考虑在服务器上玩家的目标是否正确。</p>
<p>延迟补偿是服务器执行的一种策略，当服务器收到客户端命令并执行的过程中，根据客户端的具体情况进行归一。延迟补偿可以看做服务器处理用户命令的时候回退一段时间，退到客户端发送命令时候的准确时间。算法流程如下：</p>
<ol>
<li><p>服务器执行客户端命令之前执行以下操作：</p>
<ol>
<li>计算玩家正确的延迟</li>
<li>对每个玩家，从服务器历史信息中找到发送给玩家信息和收到玩家响应的信息。</li>
<li>对于每一个玩家，将其拉回到这个更新时间（插值得到的精确时间）中执行用户命令。这个回退时间需要考虑到命令执行的时候的网络延时和插值量【8】</li>
</ol>
</li>
<li><p>执行玩家命令（包括武器开火等。）</p>
</li>
<li><p>将所有移动的、错位的玩家移动到他们当前正确位置。</p>
</li>
</ol>
<p>注意：我们把时间往后推算的时候，需要考虑那个时候玩家的状态，比如玩家是或者还是已经已经死掉，玩家是否处于躲避状态。执行运动补偿以后，玩家就可以直接瞄准目标进行设计，而不需要计算一个提前量。当然，这种方案是游戏中的权衡设计。</p>
<h1 id="9-游戏涉及中延迟补偿的使用"><a href="#9-游戏涉及中延迟补偿的使用" class="headerlink" title="9.游戏涉及中延迟补偿的使用"></a>9.游戏涉及中延迟补偿的使用</h1><p>采用延迟补偿以后，每个玩家游戏的过程中感觉不到明显延迟。在这里需要理解可能会产生一些矛盾和不一致。当然，验证服务器和无逻辑的客户端老系统也会有自相矛盾的情况。最后，这个这种事游戏设计决定的。对于半条命，我们相信采用延迟补偿是正确的游戏决定。</p>
<p>老系统的一个问题是，由于网络延迟，目标需要有一个提前量。瞄准敌人进行射击几乎总是不能击中。这种不一致导致射击很不真实，响应也不可控制。</p>
<p>采用延迟补偿以后带来的是另一种形式的不一致。对于大部分玩家，他们只需要专注于得到更多的射击技能来武装他们（当然他们也是需要瞄准的）。延时补偿使得玩家只需要直接瞄准他的目标并按下开火按钮即可（对于即时击中武器【9】）。不一致也时有发生，但是是在击中以后。</p>
<p>例如，如果一个延时比较大的玩家击中一个延时比较小的玩家并且得到一分，低延时的玩家会感觉高延时玩家“在角落里被击中”【10】。这种情况下，低延迟玩家可能已经从角落里冲出，而高延时玩家看到的是过去的信息。每一个有延迟的玩家都有一个朝向别的玩家的直的视线，直的视线指向一个瞄准点然后开火。这个时候，低延时的玩家可能已经跑到角落里并且蹲在一个箱子后面，如果高延迟玩家延迟比较大，比如500ms，这是经常发生的；这样当高延时玩家的命令传到服务器的时候，已经隐藏起来的玩家需要取一个历史位置并计算是否击中，在这种极端情况下，低延时玩家会觉得他再角落里被击中了。然而，对于高延时玩家来说，他是正对着别的玩家开火的。从游戏设计的角度来讲，我们需要这样决定：让每个玩家即时与世界交互并开火。</p>
<p>此外，在正常战斗中，上面提到的不一致并不明显。对于第一人称射击游戏，有两种典型情况。第一、考虑两个玩家直线跑向对方并且开火；这种情况下，延时补偿只会把玩家在移动直线上往后拉。被击中的玩家看他的射击者在前方，这样就不会有“子弹拐到角落里”的情况发生。</p>
<p>第二种情况是两个玩家中的一个射击，另外一个玩家在垂直于第一个玩家视线的方向冲锋。这种情况下的解决问题的原理与刚才不同。刚才提到的冲锋的玩家视野差不多是90°（至少第一人称射击游戏是这样），因此，这个玩家看不到正在射击他的那个人。因此他被击中也不会感觉奇怪或者错误（谁让你在空旷区域狂奔呢，活该）。当然，如果你开发的是一个坦克游戏，或者在你的游戏中玩家朝一个方向跑的时候可以看到别的方向，错误可能就会比较明显，你可能发现玩家设计方向不对。</p>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h1><p>延迟补偿是当前动作游戏改善延迟影响的一种方法。是否采用这种方法取决于游戏设计者，因为如何设计直接影响到游戏的体验。对于把那条命、军团要塞、cs这样的游戏，延迟补偿所带来的效果提升显著大于其带来的错误。</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>【1】在半条命引擎中，预测的过程中允许一定的延迟，但不能容忍实际网络延迟这么大的延迟。通过调整参数，我们可以控制预测过程中的延迟，这个参数pushlatency是一个负数，以毫秒为单位表示预测过程中的延迟。如果这个值大于（绝对值）实际网络延迟，这时预测就是完全的预测（译注：客户端服务器完全同步）。这种情况下玩家感觉不到任何延迟。实际应用中，一些人错误地认为参数pushlatency应该设为实际网络延迟的一半，这种情况下玩家移动仍然有网络延迟一半的延迟（感觉类似于冰面移动）。基于这个原因，实际应用总应该总是采用完全预测，pushlatency这个变量应该从半条命引擎中移除</p>
<p>【2】<a href="http://www.quakeforge.net/files/q1source.zip" target="_blank" rel="noopener">http://www.quakeforge.net/files/q1source.zip</a> (Return)</p>
<p>【3】关于作弊和反作弊的问题超出了本篇文章讨论的范围</p>
<p>【4】虽然混合纠正方法也可以使用</p>
<p>【5】“jerk”用来度量使玩家改变加速度的作用的快慢</p>
<p>【6】本文假设计算连接延时的时候客户端与服务器完全同步，也就是说，每次更新的时候客户端收到服务器发过来的时间被直接当做客户端的时间使用。这样，客户端跟服务器完全匹配，只是客户端稍微晚一点（晚多少取决于延时多少）。平滑客户端时钟差值可以有很多方法。</p>
<p>【7】更新时间间隔没必要是固定的。因为对于剧烈运动的游戏，如果带宽不够，很有可能客户端发过来的数据超过了处理能力。如果采用固定更新间隔，在发完一个更新包以后就需要等待一个固定更新周期时间以后再发下一个包。这种逻辑不能很好地使用带宽。因此，服务器发给每个客户端数据包以后，应该自己决定下一个包什么时候发，决定的依据是用户的带宽、用户设置的每秒更新频率。如果用户要求更新20次每秒，那么需要等待50ms以后下个更新包才能发送。如果激活了带宽限制（而服务器帧率又足够高），我们可能就需要等待比如61ms（或其他值）以后发送下一个更新包。因此，半条命游戏数据包发送间隔是随机的。基于服务器的这种情况，将启动点作为一个变量，移动到最新目标点进行插值这种方法效果欠佳。</p>
<p>【8】半条命代码中usercmd_t结构中变量lerp_msec前面描述过。</p>
<p>【9】对于发射导弹的武器，延迟补偿有更多需要解决的问题。假如\导弹是由服务器处理的，那么导弹应该位于哪个时间区间？每次导弹准备发射的时候，是否需要把每个玩家往后拉一段时间的？如果是这样，那么需要往后拉多少？这些问题是需要考虑的。在半条命中，为了避免这种问题，我们对导弹不进行延迟补偿（这并不意味着客户端不进行声音预测，只是实际的导弹不进行延迟补偿）。</p>
<p>【10】用户社区通常采用这种情况来描述不一致性。</p>
<ul>
<li><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>同步</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>起源引擎网络同步模型</title>
    <url>/dotnet-2020-02-02-Source-Multiplayer-Networking/</url>
    <content><![CDATA[<p>Source引擎的多人游戏使用基于UDP通信的C/S架构。游戏以服务器逻辑作为世界权威，客户端和服务器通过UDP协议(20~30packet/s）通信。客户端从服务器接收信息并基于当前世界状态渲染画面和输出音频。客户端以固定频率发送操作输入到服务器。客户端仅与游戏服务器，而不是彼此之间通信。多人游戏必须处理基于网络消息同步所带来的一系列问题。</p>
<p>网络的带宽是有限的，所以服务器不能为每一个世界的变化发送新的更新数据包发送到所有客户端。相反，服务器以固定的频率取当前世界状态的快照并广播这些快照到客户端。网络数据包需要一定的时间量的客户端和服务器（RTT的一半）来往。这意味着客户端时间相对服务器时间总是稍有滞后。此外，客户端输入数据包同步到服务器也有一定网络传输时间，所以服务器处理客户端输入也存在延迟的。不同的客户端因为网络带宽和通信线路不同也会存在不同的网络延时。随着服务器和客户端之间的这些网络延迟增大, 网络延迟可能会导致逻辑问题。比如在快节奏的动作游戏中，在几毫秒的延迟甚至就会导致游戏卡顿的感觉，玩家会觉得很难打到对方玩家或运动的物体。此外除了带宽限制和网络延迟还要考虑网络传输中会有消息丢失的情况。</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175512800-299175149.png" alt="img"></p>
<p>为了解决网络通信引入的一系列问题，Source引擎在服务器同步时采用了数据压缩和延迟补偿的逻辑，客户端采用了预测运行和插值平滑处理等技术来获得更好的游戏体验。</p>
<h3 id="基本网络模型"><a href="#基本网络模型" class="headerlink" title="基本网络模型"></a>基本网络模型</h3><p>服务器以一个固定的时间间隔更新模拟游戏世界。默认情况下，时间步长为15ms，以66.66次每秒的频率更新模拟游戏世界，但不同游戏可以指定更新频率。在每个更新周期内服务器处理传入的用户命令，运行物理模拟步，检查游戏规则，并更新所有的对象状态。每一次模拟更新tick之后服务器会决定是否更新当前时间快照以及每个客户端当前是否需更新。较高的tickrate增加了模拟精度，需要服务器和客户端都有更多可用的CPU和带宽资源。客户通常只能提供有限的带宽。在最坏的情况下，玩家的调制解调器连接不能获得超过5-7KB /秒的流量。如果服务器的数据更新发送频率超过了客户端的带宽处理限制，丢包是不可避免的。因此客户端可以通过在控制台设置接受带宽限制，以告诉服务器其收到的带宽容量。这是客户最重要的网络参数，想要获得最佳的游戏体验的话必须正确的设置此参数。客户端可以通过设置cl_updaterate（默认20）来改变获得快照平的频率，但服务器永远不会发送比tickerate更多的更新或超过请求的客户端带宽限制。服务器管理员可以通过sv_minrate和sv_maxrate(byte/s)限制客户端的上行请求频率。当然快照更新同步频率都受到sv_minupdaterate和sv_maxupdaterate（快照/秒）的限制。</p>
<p>客户端使用与服务端tickrate一样的频率采样操作输入创建用户命令。用户命令基本上是当前的键盘和鼠标状态的快照。客户端不会把每个用户命令都立即发送到服务器而是以每秒（通常是30）的速率发送命令包。这意味着两个或更多个用户的命令在同一包内传输。客户可以增加与的cl_cmdrate命令速率。这可以提高响应速度，但需要更多的出口带宽。</p>
<p>游戏数据使用增量更新压缩来减少网络传输。服务器不会每次都发送一个完整的世界快照，而只会更新自上次确认更新(通过ACK确认)之后所发生的变化（增量快照)。客户端和服务器之间发送的每个包都会带有ACK序列号来跟踪网络数据流。当游戏开始时或客户端在发生非常严重的数据包丢失时, 客户可以要求全额快照同步。</p>
<p>用户操作的响应速度(操作到游戏世界中的可视反馈之间的时间)是由很多因素决定的，包括服务器/客户端的CPU负载，更新频率，网络速率和快照更新设置，但主要是由网络包的传输时间确定。从客户端发送命令到服务器响应, 再到客户端接收此命令对应的服务器响应被称为延迟或ping（或RTT）。低延迟在玩多人在线游戏时有显著的优势。客户端本地预测和服务器的延迟补偿技术可以尽量为网络较差的游戏玩家提供相对公平的体验。如果有良好的带宽和CPU可用，可以通过调整网络设置以获得更好的体验, 反之我们建议保持默认设置，因为不正确的更改可能导致负面影响大于实际效益。</p>
<h3 id="Enitiy插值平滑"><a href="#Enitiy插值平滑" class="headerlink" title="Enitiy插值平滑"></a>Enitiy插值平滑</h3><p>通常情况下客户端接收每秒约20个快照更新。如果世界中的对象（实体）直接由服务器同步的位置呈现，物体移动和动画会看起来很诡异。网络通信的丢包也将导致明显的毛刺。解决这个问题的关键是要延迟渲染，玩家位置和动画可以在两个最近收到快照之间的连续插值。以每秒20快照为例，一个新的快照更新到达时大约每50毫秒。如果客户端渲染延迟50毫秒，客户端收到一个快照，并在此之前的快照之间内插(Source默认为100毫秒的插补周期)；这样一来，即使一个快照丢失，总是可以在两个有效快照之间进行平滑插值。如下图显示传入世界快照的到达时间：</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175529456-2030374817.png" alt="img"></p>
<p>在客户端接收到的最后一个快照是在tick 344或10.30秒。客户的时间将继续在此快照的基础上基于客户端的帧率增加。下一个视图帧渲染时间是当前客户端的时间10.32减去0.1秒的画面插值延迟10.20。在我们的例子下一个渲染帧的时间是10.22和所有实体及其动画都可以基于快照340和342做正确的插值处理。</p>
<p>既然我们有一个100毫秒的延迟插值，如果快照342由于丢包缺失，插值可以使用快照340和344来进行平滑处理。如果连续多个快照丢失，插值处理可能表现不会很好，因为插值是基于缓冲区的历史快照进行的。在这种情况下，渲染器会使用外推法（cl_extrapolate 1），并尝试基于其已知的历史，为实体做一个基于目前为止的一个简单线性外推。外推只会快照更新包连续丢失（cl_extrapolate_amount）0.25秒才会触发，因为该预测之后误差将变得太大。实体内会插导致100毫秒默认（cl_interp 0.1）的恒定视图“滞后”，就算你在listenserver（服务器和客户端在同一台机器上）上玩游戏。这并不是说你必须提前预判动画去瞄准射击，因为服务器端的滞后补偿知道客户端实体插值并纠正这个误差。</p>
<p>最近Source引擎的游戏有cl_interp_ratioCVaR的。有了这个，你可以轻松，安全地通过设置cl_interp为0，那么增加的cl_updaterate的值（这同时也会受限于服务器tickrate）来减少插补周期。你可以用net_graph 1检查您的最终线性插值。</p>
<p>如果打开sv_showhitboxes，你会看到在服务器时间绘制的玩家包围盒，这意味着他们在前进的线性插值时期所呈现的播放器模式。</p>
<h3 id="输入预测"><a href="#输入预测" class="headerlink" title="输入预测"></a>输入预测</h3><p>让我们假设一个玩家有150毫秒的网络延迟，并开始前进。前进键被按下的信息被存储在用户命令，并发送至服务器。用户命令是由移动代码逻辑处理，玩家的角色将在游戏世界中向前行走。这个世界状态的变化传送到所有客户端的下一个快照的更新。因此玩家看到自己开始行动的响应会有150毫秒延迟，这种延迟对于高频动作游戏(体育，设计类游戏)会有明显的延迟感。玩家输入和相应的视觉反馈之间的延迟会产生一种奇怪的，不自然的感觉，使得玩家很难移动或精确瞄准。客户端的输入预测（cl_predict 1）执行是一种消除这种延迟的方法，让玩家的行动感到更即时。与其等待服务器来更新自己的位置，在本地客户端只是预测自己的用户命令的结果。因此，客户端准确运行相同的代码和规则服务器将使用来处理用户命令。预测完成后，当地的玩家会移动到新位置，而服务器仍然可以看到他在老地方。150毫秒后，客户会收到包含基于他早期预测用户命令更改服务器的快照。客户端会将预测位置同服务器的位置对比。如果它们是不同的，则发生了预测误差。这表明，在客户端没有关于其他实体的正确信息和环境时，它处理用户命令。然后，客户端必须纠正自己的位置，因为服务器拥有客户端预测最终决定权。如果cl_showerror 1开启，客户端可以看到，当预测误差发生。预测误差校正可以是相当明显的，并且可能导致客户端的视图不规则跳动。通过在一定时间（cl_smoothtime）逐渐纠正这个错误，错误可以顺利解决。预测误差平滑处理可以通过设置cl_smooth 0来关闭。预测只对本地玩家以及那些只收它影响的实体有效，因为预测的工作原理是使用客户端的操作来预测的。对于其他玩家没法做有效预测, 因为没有办法立即从他们身上得到操作信息。</p>
<h3 id="延迟补偿"><a href="#延迟补偿" class="headerlink" title="延迟补偿"></a>延迟补偿</h3><p>​    比方说，一个玩家在10.5s的时刻射击了一个目标。射击信息被打包到用户命令，该命令通过网络的方式发送至服务器。服务器持续模拟游戏世界，目标可能已经移动到一个不同的位置。用户命令到达服务器时间10.6时服务器就无法检测到射击命中，即使玩家已经在目标准确瞄准。这个错误需要由服务器侧进行延迟补偿校正。延迟补偿系统使所有玩家最近位置的历史一秒。如果在执行用户的命令，服务器预计在命令创建什么时间如下：</p>
<p>命令执行时间=当前服务器时间 - 数据包延迟 - 客户端查看插值</p>
<p>然后服务器会将所有其他玩家回溯到命令执行时的位置，他们在命令执行时间。用户指令被执行，并正确地检测命中。用户命令处理完成后，玩家将会恢复到原来的位置。由于实体插值包含在公式中，可能会导致意外的结果。服务器端可以启用sv_showimpacts 1，显示服务器和客户端射击包围盒位置差异：</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175552144-269867355.jpg" alt="img"></p>
<p>该画面在主机上设置延迟200毫秒(net_fakelag设置)时获取的，射击真实命中玩家。红色命中包围盒显示了客户端那里是100毫秒+插补周期前的目标位置。此后，目标继续向左移动，而用户命令被行进到服务器。用户命令到达后，服务器恢复基于所述估计的命令执行时间目标位置（蓝色击中盒）。服务器回溯演绎，并确认命中（客户端看到流血效果）。</p>
<p>因为在时间测量精度的误差客户端和服务器命中包围盒不完全匹配。对于快速移动的物体甚至几毫秒的误差也会导致几英寸的误差。多人游戏击中检测不是基于像素的完美匹配，此外基于tickrate模拟的运动物体的速度也有精度的限制。</p>
<p>既然击中检测服务器上的逻辑如此复杂为什么不把命中检查放在客户端呢？如果在客户端进行命中检查, 玩家位置和像素命中处理检测都可以精准的进行。客户端将只告诉服务器用“打”的消息一直打到什么样的玩家。因为游戏服务器不能信任客户端这种重要决定。因为即使客户端是“干净”的，并通过了Valve反作弊保护，但是报文可以被截获修改然后发送到游戏服务器。这些“作弊代理”可以注入“打”的消息到网络数据包而不被VAC被检测。</p>
<p>网络延迟和滞后补偿可能会引起真实的世界不可能的逻辑。例如，您可能被你看不到的目标所击中。服务器移到你的命中包围盒时光倒流，你仍然暴露给了攻击者。这种不一致问题不能通过一般化的防范解决，因为相对网络包传输的速度。在现实世界中，因为光传播如此之快，你，每个人都在你身边看到同一个世界，所以你才你没有注意到这个问题。</p>
<h3 id="网络视图NET-Graph"><a href="#网络视图NET-Graph" class="headerlink" title="网络视图NET_Graph"></a>网络视图NET_Graph</h3><p>Source引擎提供了一些工具来检查您的客户端连接速度和质量。使用net_graph 2可以启用相关的视图。下面的曲线图中，第一行显示每秒当前的渲染的帧，您的平均延迟时间，以及的cl_updaterate的当前值。第二行显示在最后进来的数据包（快照），平均传入带宽和每秒接收的数据包的字节大小。第三行显示刚刚传出的数据包（用户命令）相同的数据。</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175609190-66628227.jpg" alt="img"></p>
<p>默认的网络设置是专门为通过互联网连接的游戏服务器设计的。可以适用大多数客户机/服务器的硬件和网络配置工作。对于网络游戏，应该在客户端上进行调整，唯一的控制台变量是“rate”，它定义客户端可用的字节/网络连接带宽。</p>
<p>在一个良好的网络环境中，服务器和所有客户端都具有必要的硬件资源可用，可以调整带宽和更新频率设置，来获得更多的游戏精度。增加tickrate通常可以提高运动和射击精度，但会消耗更多的服务器CPU资源。tickrate 100运行的服务器的负载大概是tickrate 66运行时的约1.5倍, 因此如果CPU性能不足可能会导致严重的计算滞后，尤其是在玩家数量比较多的时候。建议对具有更高tickrate超的游戏服务器预留必要的CPU资源。</p>
<p>如果游戏服务器使用较高tickrate运行时，客户端可以在带宽可用的情况下增加他们的快照更新率（的cl_updaterate）和用户命令速率（的cl_cmdrate）。快照更新速率由服务器tickrate限制，一台服务器无法发送每个时钟周期的一个以上的更新。因此，对于一个tickrate66服务器，为的cl_updaterate最高的客户价值，将是66。如果你增加快照率遇到，你必须再次打开它。与增加的cl_updaterate你也可以降低画面插值延迟（cl_interp）。默认的插值延迟为0.1秒(默认的cl_updaterate为20) 视图内插延迟会导致移动的玩家会比静止不动的玩家更早发现对方。这种效果是不可避免的，但可以通过减小视图内插值延迟来减小。如果双方玩家正在移动，画面滞后会延迟影响双方玩家,双方玩家都不能获利。快照速率和视图延迟插值之间的关系如下：</p>
<p>插补周期= MAX(cl_interp，cl_interp_ratio /cl_updaterate)</p>
<p>可以设置cl_interp为0，仍然有插值的安全量。也可以把cl_updaterate增加，进一步降低你的插补周期，但不会超过更新tickrate(66)或客户端的网络处理能力。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>不要瞎改终端配置除非你完全确定你在干嘛</p>
<p>​    如果客户端和服务器没有足够CPU和网络资源，绝大多数所所谓高性能优化都是起负面作用</p>
<p>不要关闭画面插值和延迟补偿</p>
<p>​    这样并不能代理移动和设计精准度提升</p>
<p>优化设置可能不会对每个客户端都有效</p>
<p>如果是你是在游戏里或者SourceTv里第一视角观看你看到的画面和玩家可能不一样</p>
<p>观战者的画面没有延迟补偿</p>
<p><a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking" target="_blank" rel="noopener">https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking</a></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>同步</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>快节奏多人游戏同步(1)-ClientServer架构</title>
    <url>/dotnet-2020-02-02-net-sync-client-server-game-architecture/</url>
    <content><![CDATA[<h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>本文是关于探索快节奏多人游戏的技术和算法系列的第一篇，因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论。。。</p>
<p>任何类型的游戏开发都是某种挑战，然而在多人游戏中我们还有更多全新的问题函待解决～最最 Interesting 的地方在于其核心问题其实是人类和物理！- - 好吧其实是作弊和地理限制造成的网络延时。。</p>
<h2 id="PART-2-反作弊"><a href="#PART-2-反作弊" class="headerlink" title="PART 2 反作弊"></a>PART 2 反作弊</h2><p>所有的一切的起源都是作弊。</p>
<p>作为一个游戏开发者，你一般不会去担心有人在你的单人游戏中去作弊 - 因为他的行为不会给其他人带来影响，一个作弊的玩家可能并不会按你设计的套路去进行游戏，但是游戏是他的，他们有权利去选择怎么去玩。</p>
<p>多人游戏则不同。在任何的有竞争关系的游戏中，一个作弊玩家不仅仅给自己带来了更好的体验，他也毁了其他的玩家的游戏。作为开发者，你可能希望避免出现这样的情况，因为这会让玩家流失。</p>
<p>为了防止作弊，有很多事可以去做，但是最重要最（可能也是唯一有意义的）的事非常简单：不要相信玩家。就做最坏的打算：所有玩家都想要作弊。</p>
<h2 id="PART-3-权威服务器和静默客户端"><a href="#PART-3-权威服务器和静默客户端" class="headerlink" title="PART 3 权威服务器和静默客户端"></a>PART 3 权威服务器和静默客户端</h2><p>有一个非常简单的解决方案 - 你将游戏中所有的逻辑都放在你控制的服务器来做，而客户端只是游戏的旁观者，换句话说，你游戏的客户端把输入（按键，命令）发送到服务器，服务器来运行这个游戏，然后你把结果返回给客户端。这就是常说的权威服务器，因为游戏世界中发生的一切都在服务器中进行。</p>
<p>当然，你的服务器还是可能被发现漏洞，但是这就不属于我们要谈论的范围了。使用权威服务器可以防止很多的漏洞，比如，服务器不信任玩家的在客户端的血量，客户端想要作弊，把本地的血量调到10000%，但服务器知道血量只有10% - 当玩家被攻击的时候它还是会死掉，不管客户端的血量是多少。</p>
<p>服务器同样不信任玩家的位置。你可能会这样做，在这一秒你告诉服务器“我在（10，10）”，然而下一秒你告诉服务器“我在（20，10）”，这样就可以穿过一堵墙或者超快速的移动。但是，权威服务器知道玩家在（10，10），当客户端告知服务器他要往右动一格的时候，客户端的位置会由服务器来处理，将位置更新为（11，10），然后告知玩家“你在（11，10）”。如下图所示:</p>
<p><img src="../../assets/images/2020-02-02-client-server-game-architecture/fpm1-01.png" alt="A simple client-server interaction."></p>
<p>总的来说，游戏的状态由服务器独自管理。客户端将动作发送给服务器，服务器来周期性地更新游戏状态，然后将新的游戏状态发送给客户端，客户端对结果进行渲染呈现。。</p>
<h2 id="PART-4-考虑网络问题"><a href="#PART-4-考虑网络问题" class="headerlink" title="PART 4 考虑网络问题"></a>PART 4 考虑网络问题</h2><p>上面的处理方式对于回合制的游戏非常适合，比如策略游戏或者棋牌类的游戏。它在LAN中也能工作的很好，在这种情况下，通信是瞬发的。但是对于一些对实时性要求很高的游戏，而且在internet环境中，这种解决方案就会出问题了。</p>
<p>下面来谈一些物理的问题。假如你在旧金山，连接了一个在纽约的服务器，两地相距4000km或者2500英里（大概是里斯本到莫斯科的距离）。任何东西都不能比光快吧，即使是Internet上的数据（数据传播的底层可能是光的脉冲，线缆中的电子，或者是电磁波），光传播的速度大概是300000km/s，所以传播4000km需要13ms。</p>
<p>这听起来可能很快，但这实际是最乐观的情况 - 假设数据传播的速度是光速，沿着直线传播，这些通常是不可能的。在真实情况下，数据是由无数个路由经过一系列的跳（在计算机网络里的属于叫做hops）进行传播的，而且大部分的传播速度都达不到光速；路由在传播的时候也会产生一些延迟，因为包必须被打包，检查和分发。</p>
<p>所以保险起见，我们假设数据从客户端到服务器需要50ms，这接近最好的场景了 - 当你在纽约而服务器在东京呢？假设网络因为什么原因发生阻塞了呢？100ms，200ms，500ms的延迟也是有可能的。</p>
<p>回到我们的例子，你的客户端将输入“我按下了向右的按键”发给服务器，服务器在50ms之后获取了数据，现在假设服务器能够立即响应并且将结果返回，那么客户端在50ms之后获得新的游戏状态“你现在在（1，0）”。</p>
<p>从你的视角来看，情况是这样的：你按下了向右的按键，但是什么事都没发生，直到一百年后你的角色向右移动了一格。这样的延迟是显而易见的，当然延迟半秒不仅仅是显而易见，它让整个游戏没法玩了。</p>
<h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>通过网络连接的多人游戏是超级有趣的，但是引入了一系列的难题和挑战。权威服务器架构能够防止很多的作弊，但是直接用这种方法会让游戏的响应变得迟缓。</p>
<p>在下面的文章，我们会介绍我们怎么围绕权威服务器来建立一个系统，能够最小的减少玩家的延迟体验，就像在玩单机游戏一样顺畅。</p>
<ul>
<li><a href="http://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/client-server-game-architecture.html</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>同步</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>快节奏多人游戏同步(2)-客户端预测与服务器校对</title>
    <url>/dotnet-2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/</url>
    <content><![CDATA[<h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在第一篇文章中，我们介绍了一种权威服务器的C-S模型，在这种模型中，客户端只将输入发送到服务器中，当收到来自服务器的游戏状态更新的时候再将结果渲染出来。</p>
<p>单纯地依赖这种模型会导致玩家输入命令和画面更新之间的延迟感，比如，当玩家按下向右的按钮，然后玩家等了半秒钟才开始移动，因为首先客户端需要把输入传给服务器，然后服务器处理了出入之后计算出新的游戏状态，然后再将新的游戏状态传回给客户端。</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-01.png" alt="Effect of network delays."></p>
<p>在实际的网络环境中，延迟可能会达到零点几秒，这时游戏就有点感觉延迟了，最坏的情况是直接没法玩了。在这篇文章中，我们将找到减小这种延迟感的方法，甚至能够消除这种延迟。</p>
<h2 id="PART-2-客户端预测"><a href="#PART-2-客户端预测" class="headerlink" title="PART 2 客户端预测"></a>PART 2 客户端预测</h2><p>虽然存在着作弊的玩家，但是大部分时候服务器是处理有效访问的（来自非作弊玩家的），这也意味着服务器收到大部分的输入都是有效的，而且游戏状态的更新也是按照预期的，也即是说：如果你的角色在（10，10），然后方向键右被按下了，那么你的角色就会移动到（11，10）。</p>
<p>我们可以利用这一点，如果游戏世界的确定性足够（给定一个游戏状态和一些列的输入，得到的结果是完全可预测的）。</p>
<p>现在假设有100ms的延迟，角色移动一格需要花费100ms，使用之前说的实现方式，那么整个动作完成需要花费200ms:</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-02.png" alt="Network delay + animation."></p>
<p>因为游戏世界是确定的，我们假设传送到服务器的输入都能够成功执行。在这种假设下，客户端能够预测游戏世界在接受输入后的状态，并且绝大部分情况下，结果是正确的。</p>
<p>与之前说的将客户端的输入发送到客户端然后等待服务器的响应再在客户端做出反应，我们可以将两者同时进行，即当在发送输入信息的时候，就当作它们已经正确执行，通常服务器返回的结果和客户端的执行的结果是一致的:</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-03.png" alt="Animation plays while the server confirms the action."></p>
<p>现在玩家输入和运行结果之间就没有任何延迟存在了，同时服务器还是权威服务器。（如果有作弊的客户端发送无用的消息，他可以把角色放在他想要的任何地方，但这并不会影响到服务器，也就是其他玩家也不会受到他的影响）。</p>
<h2 id="PART-3-同步问题"><a href="#PART-3-同步问题" class="headerlink" title="PART 3 同步问题"></a>PART 3 同步问题</h2><p>在上面的例子里，我选用了一些比较特例的数字来让所有事情看起都很完美，现在假设另一种情况，假设现在服务器延时250ms，移动一格花费100ms，现在玩家按了两下方向键右，想要往右移动两格。</p>
<p>使用之前我们说的技术，情况如下图所示</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-04.png" alt="Predicted state and authoritative state mismatch."></p>
<p>于是我们在 <strong>t = 250 ms</strong> 的时候就会面临一个非常 interesting 的问题，当接收到新的游戏状态时，客户端预测的位置已经到达 <strong>x = 12</strong>，但是服务器认为最新的坐标是 <strong>x = 11</strong>，因为权威服务器的缘故，客户端必须将角色移回 <strong>x = 11</strong>，但是紧接着，新的 <strong>x = 12</strong> 的状态在 <strong>t = 350</strong> 的时间到达，因此角色的位置又顺移回去了。。</p>
<p>从玩家的角度来看，他按下两次向右按钮后，角色向右移动两格，原地停留50ms后，向左顺移一格，又原地停留100ms再向右顺移一格，很明显这种情况令人难以接受。</p>
<h2 id="PART-4-服务器校对"><a href="#PART-4-服务器校对" class="headerlink" title="PART 4 服务器校对"></a>PART 4 服务器校对</h2><p>解决上面说的问题的办法就是你得意识到，客户端所看到的世界是当前的，但是因为延迟，客户端得到的游戏状态都是过去的，当服务器在发送更新的时候，它并没有把客户端发来的所有的命令都处理掉。</p>
<p>这并不是一个非常严重的问题，首先，客户端在每次请求的时候加上一个编号，在我们的例子中，第一次按键请求编号为 #1，第二次按键的请求编号为 #2。服务器回复的时候将其处理过最后一个请求的编号包含在消息中。</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-05.png" alt="Client-side prediction + server reconciliation."></p>
<p>当t = 250的时候，服务器说“基于#1的输入请求，你的位置是11”.因为服务器是权威的，所以角色的位置是x=11， 现在假设客户端保存了一份发送到服务器的请求，基于新的游戏状态，它知道服务器已经处理了请求 #1，所以他将这个备份丢弃掉，但是客户端知道服务器还需要将#2请求的回复发过来，所以再一次进行客户端预测，客户端可以基于上次服务器发来的状态和#2输入来计算当前的状态。</p>
<p>所以当t=250ms的时候，客户端得到“经过#1的输入之后，x=11”，它将#1输入的拷贝丢弃掉，但是还有一份并没有得到服务器返回的#2的拷贝，客户端将内部游戏状态更新为服务器所发来的游戏状态，也就是x=11，然后将所有未收到回复但已经发送给服务器的输入用于预测，在上面的例子，输入就是向右移动，最终状态就是x=12，这是正确的。当t=350的时候，一个新的游戏状态从服务器获得；这种情况它说“基于#2输入，x=12”。在这是，客户端将#2请求之前的请求都丢弃，然后将游戏状态更新为x=12，没有需要预测的输入，所以不需要预测，现在得到的结果都是正确的。</p>
<p>客户端具体如何处理，这里有一个统一的处理方式：</p>
<ul>
<li>根据server的new state更新#1里的缓存状态</li>
<li>回滚input到#1，将#1之后的所有缓存的操作都应用到#1的new state中进行计算，得到最新的结果</li>
<li>客户端根据最新的结果进行更新</li>
<li>将#1的状态和input 从缓存buffer里删除</li>
</ul>
<h2 id="PART-5-误差"><a href="#PART-5-误差" class="headerlink" title="PART 5 误差"></a>PART 5 误差</h2><p>上面讨论的例子里只讨论了移动，但是这个方法在其他方面也可以使用。比如，在一个回合制的游戏里，当玩家攻击其他玩家的时候，你可以播放飙血的特效和伤害值，但是你不应该在收到服务器回复之前直接更新玩家的血量。</p>
<p>因为游戏状态的复杂性，它并不能保证是绝对可逆的，你也许希望只有再收到服务器确认的时候才将一个玩家杀死，即使这个玩家的血量降到负的了。（但假象一种情况，一个玩家实际上已经死了，但是在没有收到服务器确认之前他使用了药包，这个时候你该怎么处理？）</p>
<p>这又带来了一个有趣的问题，即使世界是绝对的确定的，并且没有玩家在作弊，还是有客户端的预测和服务器不吻合的情况。上面说的情况在单人游戏中不会出现，但是在多人接入同一个服务器的时候就会发生，这个问题会在下面的文章中进行讨论。</p>
<h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>当使用权威服务器的时候，你需要给玩家即时的响应，即使是当在等待服务器处理出入。为了达到这样的目的，客户端模拟出输入的结果，当收到服务器的回复时，客户端的游戏状态需要通过服务器的回复和还未处理的输入进行重新计算。</p>
<ul>
<li><a href="http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>sync</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>快节奏多人游戏同步(3)-Entity插值</title>
    <url>/dotnet-2020-02-02-net-sync-entity-interpolation/</url>
    <content><![CDATA[<h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在本系列的「第一篇文章」中，我们介绍了关于权威服务器及其反作弊特性，然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题。在「第二篇文章」中，我们提出了「客户端预测」的方案来克服这个困难。</p>
<p>以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下，可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术。</p>
<p>在本文中，我们将会讨论在在同一台服务器上有「其他玩家控制的角色」的情况。</p>
<h2 id="PART-2-服务器-time-step"><a href="#PART-2-服务器-time-step" class="headerlink" title="PART 2 服务器 time step"></a>PART 2 服务器 time step</h2><p>在之前的文章中，我们的服务器的实现非常简单，它负责处理客户端的输入并更新游戏状态，最后将结果发送回客户端。如果有多个玩家在一起玩，那服务端主循环的逻辑有所不同了。<br>在接下来的场景中，几个客户端玩家会同时发送数据，玩家发出操作指令会非常频繁（高APM的玩家，一秒钟可能发出10个以上的操作指令），如果服务端每收到某个玩家的一条指令，就去执行input逻辑，然后广播游戏状态，这样的性能是非常差的，会消耗很多的cpu和bandwidth。<br>一个更好的办法是，利用一个queue，将客户端的输入信息缓存起来，在服务端，游戏状态以一定的频率(例如100ms一次)进行更新，每次更新的时间间隔(100ms)，就被称之为time step。<br>在每个更新循环迭代中，服务端处理queue里面所有的input，然后逐个进行计算，将最后计算的结果更新到所有客户端。<br>总体来说，整个游戏世界的更新和客户端的输入频率、数量是相对独立的，它的更新频率也是可控的。</p>
<h2 id="PART-3-低频更新处理"><a href="#PART-3-低频更新处理" class="headerlink" title="PART 3 低频更新处理"></a>PART 3 低频更新处理</h2><p>从客户端来看，这个方法运行的很平滑，客户端的预测行为独立于服务端的更新，所以它依然可以使用预测技术。不过，由于真个游戏世界的状态以一个比较低的频率进行更新，那么本地客户端对其他玩家知道的信息就很少了，信息越少的话，其他玩家的行为动作要模拟的话，就不会很准确。<br>本地客户端收到其他玩家更新坐标的消息，如何进行处理呢，有一个最简单的办法就是，每次直接使用收到的坐标进行更新，但这样看起来会有抖动，每100ms更新一次坐标，就得抖动一次，如下图所示：</p>
<p><img src="../../assets/images/2020-02-02-net-sync-entity-interpolation/fpm3-01.png" alt="Client 1 as seen by Client 2."></p>
<p>对Client2来说，Client1的位置最开始再p(10,10)，不一会直接跳到p(11,10)，100ms后又跳到(12,0)，这样的体验是很差的。那么，如何改善游戏体验呢？ 针对不同的游戏，有不同的处理方式，一般来说，客户端的行为越方便预测，就越容易做平滑处理。</p>
<h2 id="PART-4-航位推测法"><a href="#PART-4-航位推测法" class="headerlink" title="PART 4 航位推测法"></a>PART 4 航位推测法</h2><p>假设你在玩赛车游戏。一辆速度非常快的汽车是可以预测的——例如，如果它以每秒100米的速度行驶，一秒钟后，它将比它开始行驶的地方提前大约100米。</p>
<p>为什么是大约呢？在那一秒内，汽车可能加速或减速了一点，或者向右或向左转了一点——这里的关键词是“一点”。汽车的机动性是这样的：在高速行驶时，无论玩家实际做什么，其在任何时间点的位置都高度依赖于其先前的位置、速度和方向。换句话说，赛车不能立即进行180度转弯。</p>
<p>对于每100毫秒发送一次更新的服务器，这是如何工作的？客户端接收到服务器发送来的每个其他车的速度和行驶方向；在接下来的100毫秒内，它不会接收到任何新信息，但仍需要显示它们的运行情况。要做的最简单的事情是假设汽车的航向和加速度在100毫秒内保持不变，并使用该参数在本地运行汽车物理。然后，100毫秒后，当服务器更新到达时，汽车的位置被修正。</p>
<p>根据许多因素，校正可以是大的或相对小的。如果玩家把车保持在直线上，并且不改变车速，那么预测的位置将与修正的位置完全相同。另一方面，如果玩家撞到什么东西，预测的位置将是非常错误的。</p>
<p>请注意，推算定位可以应用于低速情况，例如战列舰。实际上，“dead reckoning”一词起源于航海。</p>
<h2 id="PART-5-实体插值"><a href="#PART-5-实体插值" class="headerlink" title="PART 5 实体插值"></a>PART 5 实体插值</h2><p>有许多情况航位推是没法处理的 - 对于玩家的方向和速度可以瞬间改变的都不行，比如3D射击，玩家经常快速跑动，停下，快速转向等，在这种情况下，航位推算法就非常无力了。因为位置和速度和前面的数据无关。</p>
<p>你可以选择在接到服务器的请求的时候直接更新玩家的位置，而客户端看到的就是网上其他的玩家每100ms跳一下，感觉会非常奇怪。</p>
<p>你现在拥有的是每100ms由服务器传送过来的权威数据，现在要做的是如何在这100ms内让网络角色看起来非常自然，解决问题的关键就是将网络玩家显示在过去的某个时刻。</p>
<p>假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。</p>
<p><img src="../../assets/images/2020-02-02-net-sync-entity-interpolation/fpm3-02.png" alt="Client 2 renders Client 1 in the past, interpolating last known positions."></p>
<p>用来插值的t=900和t=1000的数据依赖于游戏。插值通常都可以处理得很好。如果不是这种方法，你可能需要服务器发送更加详细的移动信息了 - 比如更多的位置采样点，或者每10ms发送一次(你不必发十倍的数据 - 因为你发的微小的位移数据，在这种情况下数据的格式可以很好的优化一下)。</p>
<p>当使用这种技术的时候，每一个玩家都和游戏世界有一点点不同步，因为每个玩家看到自己的世界是当前的，但是其他的玩家都是过去的。但即使是快速的游戏，这100ms的延迟都不是那么明显。</p>
<p>有一种情况除外 - 当你需要时间和空间的准确性的时候，比如一个玩家射击另一个玩家的时候，因为其他的玩家都是存在于过去的某个时候，你的瞄准其实是有100ms的延迟的 - 也就是说，你设计的目标是100ms的某个目标！ 这个问题我们下一篇会进行讨论。</p>
<h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>在权威服务器的环境中，有着不确定的服务器更新和网络延迟，在这种情况下你还要给玩家平滑的移动。在第二篇中，我们展示了一种客户端预测和服务器调和的技术，来实现实时的角色控制，这样的方案让玩家能够得到即时的反馈，移除了致命的延迟。</p>
<p>其他玩家的同步还是一个问题，但是，在这篇文章中，我们提出了两种解决方案。</p>
<p>第一种是航位推技术，这种模拟需要entity的位置能够通过前一个时候的位置，速度，加速度来推算出来，当不满足这种情况的时候，航位推就没用了。</p>
<p>第二种是插值技术，不预测将来的位置，只是使用服务器传来的数据，这种就会造成显示的entity总是过去的某个时刻。最后的结果就是玩家的角色总是当前时刻，而其他看到的entity都是过去的某个时刻，这种情况可以产生一种难以置信的无缝体验。</p>
<p>但是，当游戏需要高速离散的准确性的时候，比如射击或者移动物体，美景就破灭了：你看其他玩家的位置和服务器的位置不一致，别的玩家看你的位置也不是正确的，这样爆头就不可能发生了！很多游戏都有爆头这一说，我们将在下面的文章中来讨论这个问题。</p>
<ul>
<li><a href="http://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/entity-interpolation.html</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>sync</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>快节奏多人游戏同步(4)-延时补偿</title>
    <url>/dotnet-2020-02-02-net-sync-lag-compensation/</url>
    <content><![CDATA[<h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些：</p>
<ul>
<li>服务器从客户端收到带有时间戳的输入信息；</li>
<li>服务器处理输入并且更新世界状态；</li>
<li>服务器向所有客户端发送游戏世界的快照</li>
<li>客户端发送输入并且模拟游戏的结果；</li>
<li>客户端获取世界更新<ul>
<li>将自身预测的状态和服务器发送来的状态进行同步；</li>
<li>将其他客户端控制的实体插值到过去的状态</li>
</ul>
</li>
</ul>
<p>从玩家的角度来看，以上行为会导致两个重要的结果：</p>
<ul>
<li>玩家看到 <strong>自己</strong> 处于 <strong>现在</strong></li>
<li>玩家看到 <strong>其他玩家</strong> 处于 <strong>过去</strong></li>
</ul>
<p>这其实并没有什么大不了的问题，但是对于时间和空间非常敏感的事件就会造成很大的问题；比如在射击游戏中爆掉敌人的头！</p>
<h2 id="PART-2-延时补偿"><a href="#PART-2-延时补偿" class="headerlink" title="PART 2 延时补偿"></a>PART 2 延时补偿</h2><p>假设你正用狙击枪完美的瞄准目标的头部，此时射击绝对万无一失。</p>
<p>然而却没打到。。。</p>
<p>为什么会发生这种事情。。</p>
<p>因为我们之前解释过的 client-server 架构，你瞄准的是 100ms 之前的玩家的头，而不是开枪的时候的玩家的头。。。</p>
<p>在某种程度上相当于你在一个光速非常非常慢的宇宙中进行游戏，你瞄准的是敌人过去的位置，当你扣下扳机的时候他早就走远了。。</p>
<p>比较幸运的是有一个相对简单的解决方案，对几乎所有的玩家都是友好的，下面来解释一下它的工作流程：</p>
<ul>
<li>开火的时候，客户端发送开火指令到服务器，同时包含开火的一瞬间确切的时间和方向。</li>
<li>这是关键的一步。由于服务器获取所有带有时间戳的输入，因此它可以在过去的任何时刻重构世界。特别是，它可以在任何时间点按照任何客户端眼中的样子重建世界。</li>
<li>这意味着服务器可以准确地知道你开枪的那一刻你的武器瞄准了什么。这是你的敌人过去的头部位置，但服务器知道这是他的头部在你当前客户端所在的位置。</li>
<li>服务器在该时间点处理快照，并更新客户端。</li>
</ul>
<p>于是皆大欢喜～</p>
<p>服务器很开心是因为他是服务器，他永远都很开心。。。哦好冷啊</p>
<p>你很开心是因为你瞄准目标头部并射击，完成了一记漂亮的爆头</p>
<p>你的敌人可能是唯一不完全开心的哪个，如果他站在原地被你爆头那就是他的问题，但是如果他在移动的话，只能说明你是特别厉害的狙击手。</p>
<p>但是如果他在掩体附近，然后移动到掩体内部的安全位置后才被命中了呢？</p>
<p>好吧这的确有可能发生，但这就是你要为此付出的代价，因为你可以射击「过去的他」，他可能在进入掩体后几毫秒被射击。</p>
<p>从某种程度上来说这是不公平的，但这是大家接受程度最高的解决方案了，明明瞄准开枪最后却 miss 问题更大～</p>
<h2 id="PART-3-总结"><a href="#PART-3-总结" class="headerlink" title="PART 3 总结"></a>PART 3 总结</h2><p>这篇文章是快节奏多人游戏同步这个系列的最后一篇了，虽然这类问题很难得到完美解答，但是对相关概念有了清晰理解以后再看也并不是那么困难。</p>
<p>虽然本文的读者都是游戏开发者，但依然有着另一部分读者对此很感兴趣，那就是玩家们。对玩家来说去理解诸如此类问题依然是一件很有趣的事情。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>以下是一些参考资料包括文章和源码之类的，可以帮助大家更方便的理解相关概念。</p>
<p>与本文相关性最高的文章如下 </p>
<p><a href="http://www.gabrielgambetta.com/lag-compensation.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/lag-compensation.html</a></p>
<p><a href="http://www.gabrielgambetta.com/client-side-prediction-live-demo.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/client-side-prediction-live-demo.html</a></p>
<p><a href="http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/" target="_blank" rel="noopener">What Every Programmer Needs to Know About Game Networking</a></p>
<p> <a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</a>.</p>
<p><a href="https://link.springer.com/article/10.1007/s00530-012-0271-3#Sec17" target="_blank" rel="noopener">https://link.springer.com/article/10.1007/s00530-012-0271-3#Sec17</a></p>
<p><a href="https://github.com/search?l=C%23&amp;q=lag+compensation&amp;type=Repositories" target="_blank" rel="noopener">https://github.com/search?l=C%23&amp;q=lag+compensation&amp;type=Repositories</a></p>
<p><a href="https://github.com/search?l=C%23&amp;p=1&amp;q=Fast-Paced+Multiplayer&amp;type=Repositories" target="_blank" rel="noopener">https://github.com/search?l=C%23&amp;p=1&amp;q=Fast-Paced+Multiplayer&amp;type=Repositories</a></p>
<p><a href="https://github.com/JoaoBorks/unity-fastpacedmultiplayer" target="_blank" rel="noopener">https://github.com/JoaoBorks/unity-fastpacedmultiplayer</a></p>
<p><a href="https://github.com/gamestdio/timeline" target="_blank" rel="noopener">https://github.com/gamestdio/timeline</a></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>守望先锋等FPS游戏的网络同步</title>
    <url>/dotnet-2020-02-02-overwatch-a-guide-to-understanding-netcode/</url>
    <content><![CDATA[<p>在一个采用C/S架构的游戏中，客户端和服务端的游戏状态有差异是不可避免的。客户端和服务端各自都维护了一份游戏状态。这两份游戏状态依赖网络包通信保持同步。但由于各客户端到服务端的时延具有不确定性，游戏状态同步变得非常困难。通常服务端在游戏拓扑中承载的是状态仲裁者的角色，客户端玩家看到的“经验证”的有效游戏状态总是延后于服务端的游戏状态。</p>
<p>网络时延是必然存在的，所以游戏状态的不同步也是必然存在的。但我们可以通过技术手段尽量减轻不同步问题对用户体验带来的影响。</p>
<p>技术术语：</p>
<p>1）<strong>Latency</strong>：Latency指的是数据包从客户端发送到服务端再收到服务端回包所用的时间，通常被称为RTT。虽然单程的数据包传输时间并不总是等于RTT/2，但是简单起见我们可以认为两者是相等的。下文说到Latency都是说一个RTT时间，单程Latency则是指RTT/2。</p>
<p>80年代有个工具叫ping使用ICMP echo测试延迟，所以人们常把RTT和ping联系起来。ping这个指令现在还在用。</p>
<p>2）<strong>Hit Box</strong>：角色的3D模型代表了哪些区域是参与到“命中”计算的。你看不到hit box，你只能看到模型。hit box可能比模型大，也可能比模型小，也有可能很不精确，这都取决于具体的实现。我们知道，tick rate会影响命中判定，但是hit box不精确可能对玩家在是否命中方面的感受影响更大。</p>
<p>3）<strong>Tick Rate</strong>：Tick Rate指游戏服务端更新游戏状态的频率。单位是hertz。如果服务器的Tick Rate是64，这就意味着服务端每秒钟最多向客户端发送64次数据包。这些同步数据包包括了游戏状态更新，比如player和场景对象位置等。一次tick的长度就是其持续时间，单位为ms。</p>
<p>比如，64 rate时tick长度是15.6ms，20 rate时是50ms，10 rate时是100ms</p>
<p>4）<strong>Client Update Rate</strong>：这是客户端接收服务端更新的频率。比如说，如果client update rate是20，而服务器tick rate是64，那么从体验上来说，这个客户端实际是在和一个tick rate为20的服务器联机。通常这个是配在客户端本地的，也有可能是写死的。</p>
<p>5）<strong>Framerate</strong>：这个是指客户端每秒最多可以渲染多少帧，通常被称为FPS</p>
<p>6）<strong>Refresh Rate</strong>：显示设备每秒钟刷新多少次。单位为hertz。如果framerate是30，一个显示频率为60的设备将把每个画面显示两次。反过来，如果framerate是120，但是显示频率为60，那么显示设备只能显示每秒60帧。显示设备的频率比framerate大，提升framerate才有意义。大多数显示设备频率是60或120。</p>
<p>7）<strong>Interpolation</strong>：这是一种平滑场景对象移动的技术。实际上内插值所做的就是在场景对象的两个位置之间做插值，以让运动过程平滑。插值延迟通常是2tick，也不尽然。举个内插值的例子，如果一个玩家沿着一条直线移动，在tick1的时候位置在0.5m，在tick2的时候位置在1m，内插值的作用就是让客户端看起来是平滑的从0.5m移到1m。但是服务器实际看到的是离散的位置，要么在0.5m或1m，不可能在中间的某个位置。如果没有插值，游戏的抖动将非常明显，特别是在从服务端更新了一个运动对象的位置后。内插值只在客户端做，实际上减慢了将整个游戏状态绘制到屏幕上的速率。</p>
<p>8）<strong>Extrapolation</strong>：这是客户端补偿延迟的另一种技术。客户端将场景对象的位置做外插值，这样就不会导致绘制的时候没有更新到新数据。通常优先使用内插值，特别是FPS游戏，因为玩家的移动是不可预期的，外插值的结果可能通常是错的。</p>
<p>9）<strong>Lag Compensation</strong>：延迟补偿是服务端减小客户端延迟影响的一种方法。如果没有延迟补偿，或者延迟补偿做的不好，由于客户端看到的是经过延迟后的游戏状态，玩家要命中目标就必须使用一些预判技巧。实际上，延迟补偿所做的，就是当服务器从客户端收到操作（比如开枪）后，将操作发生时间往回调一个单向时延的时间。服务端游戏状态和客户端游戏状态的时间差异（也被称为”Client Delay”）可用下式给出：</p>
<p>ClientDelay = (1/2 * Latency) + InterpolationDelay</p>
<p>延迟补偿的实际操作步骤：</p>
<ol>
<li>Player A看到Player B向一个角落跑去</li>
<li>Player A开枪，其客户端把这个操作发送给服务器</li>
<li>假定A的延迟的一半是Xms，那么Xms后服务器将收到Player A的操作</li>
<li>服务器从记录的历史信息中找到A开枪时B所在的位置。一般情况下，服务器应该往回看 (Xms + Player A’s interpolation delay) 来回滚到A开枪时的游戏状态。但是这个时间是可以调的，取决于开发者希望延迟补偿算法如何工作。</li>
<li>服务器判定这次的开枪是否命中。如果子弹的轨迹和目标模型的hit box相交，就认为是命中了。在这个例子中，我们假定命中了。在Player B看来，他觉得自己已经躲到墙后面了。但是Player B看到的游戏状态所处的时间和Server认定的开枪时间是有差异的，可以表示为：<br>(1/2 * PlayerALatency + 1/2 * PlayerBLatency + TimeSinceLastTick)</li>
<li>在下一次tick中，服务器使用计算结果更新所有客户端：Player A看到自己命中了目标，Player B看到自己掉血或挂掉了。</li>
</ol>
<p>需要注意的是，如果两个玩家对射，而且都命中了，游戏如何处理就取决于实现了。比如说在CS:GO中，如果先收到的射击操作命中了目标玩家，那么后续收到的那个玩家的射击就会被丢弃。这样就避免了两个玩家的射击请求在同一帧，然后都命中，都挂掉。在Overwatch中，这种情况是可能的。这里是有取舍的。</p>
<p>按照CS:GO的做法，网络较好的玩家是有很大优势的。经常会有“我在挂掉前打中了目标，但是他没死”的情况。你甚至在挂掉前能听到你的枪响和命中的声音，却没对目标造成伤害。</p>
<p>若是在Overwatch中，玩家反应时间的差异对结果影响较小。比如说，如果服务器tick rate是64，若Player A比Player B早15ms射击，那么双方的射击都是在同一个15.6ms tick之内，所以最终结果是双方都命中，都死掉了。</p>
<p>如果延迟补偿过度，就会出现“我朝目标早前的位置开枪，却还是命中他了”。<br>若延迟补偿不足，则会出现“我必须对目标的移动做预判，这样才能命中”。<br>服务器做延迟补偿所记录的历史数据应该是有限的，不然高延迟的玩家会明显拖累其他玩家的游戏体验。</p>
<p>在Overwatch中，服务端延迟补偿也被称为Favoring the shooter(<a href="https://link.zhihu.com/?target=https%3A//www.vg247.com/2016/04/05/overwatch-devs-talk-netcode-and-favouring-the-shooter/">https://www.vg247.com/2016/04/05/overwatch-devs-talk-netcode-and-favouring-the-shooter/</a>, <a href="https://link.zhihu.com/?target=https%3A//www.pcgamesn.com/overwatch/overwatch-netcode">https://www.pcgamesn.com/overwatch/overwatch-netcode</a>)，也就是说，如果你在自己屏幕上瞄准了目标并射击，那么很大概率将命中目标。也有例外情况。比如，若你射击目标的那一刻，目标跳跃躲开了，这时服务器认为目标做了一个完美的闪避，可能会被判断未命中。所以计算命中时并不总是使用射击那一刻的信息。这是为了玩家体验打的补丁。</p>
<p>如果你是要设计一套同步方案，根据设计目的不同可能有不同的方案。公平性、即时反馈、网络流量等都可能是重要的设计目标。可以参考以下因素：</p>
<p>1）网络链接。延迟越低越好。选择一个延迟最低的服务器开始游戏是很重要的。网络上的拥塞程度也会导致网络延迟。延迟补偿可以帮助解决“射击和命中”的问题，但是如果你的网络不好，更多的情况下，你可能会体验到“已经跑到墙后面还是被打中”或者“我先射击但还是死掉了”的情况。</p>
<p>2）如果你的客户端frame rate很低（只要低于显示设备刷新频率或跟他差不多），会导致感受延迟变大，通常比tick rate带来的问题更严重。</p>
<p>3）尽量使用内插值。大多数游戏使用的内插值间隔是tick间隔的两倍，主要考虑到如果一个数据包丢掉了，玩家的移动中断也不会在屏幕上表现出来。如果网络状况很好，没有丢包，把插值间隔设置为tick间隔是没有问题的。但是如果有丢包，就会导致抖动。比如在CS:GO中，这对体验的影响比把服务端tick rate从20调高到64带来的体验影响更明显。如果这个值设的太低，会导致极大的抖动。</p>
<p>4）如果有可能，你应该增加游戏的client update rate来优化体验。其代价是CPU和带宽消耗。对于客户端来说，除非你家的网络带宽非常低，增加CPU和带宽消耗是可以接受的。</p>
<p>5）如果你的显示设备刷新率是60hz，那么很有可能你根本感受不到tick rate在64和128会有什么差异，因为由于tick rate差异导致的改变根本无法通过你的显示设备体现出来。</p>
<p>6）通常来说，服务端tick rate越高，用户交互就越流畅，也更准确。当然网络同步量也越大。如果我们对比tick rate64（CS:GO比赛）和20（Overwatch Beta服务器宣传的帧率），两者因为帧率差异导致的最大可感受延迟是35ms.平均情况下是17.5ms.大多数人是察觉不到其中的差异的，但是有经验的玩家通常是能感受到的。高的tick rate并不会影响到延迟补偿的工作。所以有时候，你还是会有明明自己已经跑到墙后面了可是还是死了的体验。把tick rate提高到64并不能解决这个问题。</p>
<p>7）Responsiveness: 当你按下按键的时候，需要能立刻看到反馈。这对动作游戏和FPS游戏都是非常重要的。有多个因素会影响即时反馈。首先，客户端发送玩家的输入应该是即时的。其次，客户端不等服务端回应就根据玩家的输入做状态预测和插值。在Overwatch中，客户端会维护一个历史纪录用于验证客户端预测的准确性。最后，服务端tick rate也会影响反馈。投射物的模拟也应和玩家做类似处理，并加上飞行时间，让玩家对反馈产生的时间有预期。</p>
<p>8）处理丢包。在Overwatch中，丢包是通过在客户端加速“命令帧”和在服务端设置命令缓存来解决的(<a href="https://link.zhihu.com/?target=http%3A//www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and">http://www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and</a>, <a href="https://link.zhihu.com/?target=http%3A//www.gad.qq.com/article/detail/28682">http://www.gad.qq.com/article/detail/28682</a>). 首先，系统采用确定性模拟技术，将时间量化为“命令帧”。每个命令帧都固定为16毫秒（比赛时是7毫秒）。服务端和客户端模拟都运行在保持同步的时钟和这个量化值之上，保持固定的更新频率。当客户端意识到丢包时，会比约定频率更快的模拟，而服务端则将命令缓冲区增大。客户端发送指令的频率加快，而服务端缓冲变大以容忍更多的丢包。客户端的指令数据包包含了未经服务端确认过的所有指令，这样服务端就有机会在实际模拟并发送确认包前更新缓冲区。</p>
<p><strong>延迟改进</strong></p>
<p>暴雪表示会采用一些技术来改进延迟的情况：</p>
<ul>
<li>把网络状况相近的玩家匹配到一起，这样相对公平</li>
<li>提供60帧tick的服务器，目前是20帧的服务器</li>
<li>网络稳定时候，直接使用客户端指令，而不是缓存48ms的</li>
<li>网络波动时候，回溯加一个上限，比如250ms，不再是无限回溯了</li>
</ul>
<ul>
<li><a href="https://www.gdcvault.com/play/1024001/-Overwatch-Gameplay-Architecture-and" target="_blank" rel="noopener">Overwatch - Gameplay Architecture and Netcode - GDCVault</a></li>
<li><a href="http://gad.qq.com/article/detail/28682" target="_blank" rel="noopener">《守望先锋》架构设计与网络同步 - GAD</a></li>
<li><a href="http://gad.qq.com/article/detail/28219" target="_blank" rel="noopener">《守望先锋》中的网络脚本化的武器和技能系统 - GAD</a></li>
<li><a href="https://www.gdcvault.com/play/1024653/Networking-Scripted-Weapons-and-Abilities" target="_blank" rel="noopener">Networking Scripted Weapons and Abilities in Overwatch - GDC Vault</a></li>
<li><a href="https://blog.codingnow.com/2017/06/overwatch_ecs.html" target="_blank" rel="noopener">浅谈《守望先锋》中的 ECS 架构 - 云风的 BLOG</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25703934" target="_blank" rel="noopener">GDC 2017 技术选荐合辑 - 知乎专栏</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28825322" target="_blank" rel="noopener">守望先锋等 FPS 游戏的网络同步 - 知乎专栏</a></li>
<li><a href="https://www.gamereplays.org/overwatch/portals.php?show=page&name=overwatch-a-guide-to-understanding-netcode" target="_blank" rel="noopener">A guide to understanding netcode - GAMEREPLAYS.ORG</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>同步</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>orleans的部署模式</title>
    <url>/dotnet-2020-02-03-orleans-Deployment/</url>
    <content><![CDATA[<h1 id="蓝绿部署（Blue-Green-Deployment）"><a href="#蓝绿部署（Blue-Green-Deployment）" class="headerlink" title="蓝绿部署（Blue/Green Deployment）"></a>蓝绿部署（Blue/Green Deployment）</h1><p>过去的 10 年里，很多公司都在使用蓝绿部署（发布）来实现热部署，这种部署方式具有安全、可靠的特点。蓝绿部署虽然算不上“ Sliver Bullet”，但确实很实用。<br>蓝绿部署是最常见的一种0 downtime部署的方式，是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。蓝绿部署原理上很简单，就是通过冗余来解决问题。通常生产环境需要两组配置（蓝绿配置），一组是active的生产环境的配置（绿配置），一组是inactive的配置（蓝绿配置）。用户访问的时候，只会让用户访问active的服务器集群。在绿色环境（active）运行当前生产环境中的应用，也就是旧版本应用version1。当你想要升级到version2 ，在蓝色环境（inactive）中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。随后需要监测新版本应用，也就是version2 是否有故障和异常。如果运行良好，就可以删除version1 使用的资源。如果运行出现了问题，可以通过负载均衡器指向快速回滚到绿色环境。<br>蓝绿部署的优点：<br>这种方式的好处在你可以始终很放心的去部署inactive环境，如果出错并不影响生产环境的服务，如果切换后出现问题，也可以在非常短的时间内把再做一次切换，就完成了回滚。而且同时在线的只有一个版本。蓝绿部署无需停机，并且风险较小。<br>(1) 部署版本1的应用（一开始的状态），所有外部请求的流量都打到这个版本上。<br>(2) 部署版本2的应用，版本2的代码与版本1不同(新功能、Bug修复等)。<br>(3) 将流量从版本1切换到版本2。<br>(4) 如版本2测试正常，就删除版本1正在使用的资源（例如实例），从此正式用版本2。<br>从过程不难发现，在部署的过程中，应用始终在线。并且，新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响。这样风险很小，并且，只要老版本的资源不被删除，理论上，可以在任何时间回滚到老版本。<br>蓝绿部署的弱点：<br>使用蓝绿部署需要注意的一些细节包括：<br>1、当切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果数据库后端无法处理，会是一个比较麻烦的问题。<br>2、有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止；<br>3、需要提前考虑数据库与应用部署同步迁移/回滚的问题。<br>4、蓝绿部署需要有基础设施支持。<br>5、在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。<br>6、另外，这种方式不好的地方还在于冗余产生的额外维护、配置的成本，以及服务器本身运行的开销。<br>蓝绿部署适用的场景：<br>1、不停止老版本，额外搞一套新版本，等测试发现新版本OK后，删除老版本。<br>2、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。<br>3、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。</p>
<h1 id="滚动发布（rolling-update）"><a href="#滚动发布（rolling-update）" class="headerlink" title="滚动发布（rolling update）"></a>滚动发布（rolling update）</h1><p>滚动发布，一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。<br>这种方式也有很多缺点，例如：<br>(1) 没有一个确定OK的环境。使用蓝绿部署，我们能够清晰地知道老版本是OK的，而使用滚动发布，我们无法确定。<br>(2) 修改了现有的环境。<br>(3) 如果需要回滚，很困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚。此时，脾气不好的程序猿很可能想掀桌子，因为回滚是一个痛苦，并且漫长的过程。<br>(4) 有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容/缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。<br>并不是说滚动发布不好，滚动发布也有它非常合适的场景。</p>
<p><img src="../../assets/images/2020-02-03-orleans-Deployment/20190516171224267.png" alt="img"></p>
<h1 id="orleans支持-蓝绿部署模型以及滚动部署模型"><a href="#orleans支持-蓝绿部署模型以及滚动部署模型" class="headerlink" title="orleans支持 蓝绿部署模型以及滚动部署模型"></a>orleans支持 <em>蓝绿部署模型<em>以及</em>滚动部署模型</em></h1><ul>
<li><p>ClusterId：这是Orleans集群的唯一ID。使用此ID的所有客户端和Silo将能够直接相互通信。但是，您可以选择ClusterId对不同的部署使用不同的名称。</p>
</li>
<li><p>ServiceId：这是您的应用程序的唯一ID，将由某些提供程序（例如持久性提供程序）使用。此ID应该保持稳定，并且在整个部署中都不应更改。</p>
</li>
</ul>
<p>Orleans has both <code>ClusterId</code> &amp; <code>ServiceId</code> to support the <em>blue/green deployment model</em>.</p>
<p>In this model, each deployment slot will have a distinct <code>ClusterId</code> (eg, the values could be “blue-slot” &amp; “green-slot”) but they will always have the same <code>ServiceId</code> (eg, “my-service”). The “blue-slot” silos will only talk to other “blue-slot” silos.</p>
<p><em>However</em> <strong>Grain A</strong> in the blue cluster and <strong>Grain A</strong> in the green cluster will still share the same storage - if they are both active then one will see a conflict when writing to the state if the other activation has already written it.</p>
<p>This allows for the state in the database to remain consistent when multiple clusters are active (which is usually a short period of time - during the upgrade).</p>
<p>If you do not use blue/green deployments then you can set <code>ClusterId</code> &amp; <code>ServiceId</code> to the same value.</p>
<p>To say this in a different way:</p>
<ul>
<li><code>ClusterId</code> + <code>ServiceId</code> are used for cluster membership</li>
<li><code>ServiceId</code> is used for storage</li>
</ul>
<p><a href="https://github.com/dotnet/orleans/issues/5696#issuecomment-503595998" target="_blank" rel="noopener">https://github.com/dotnet/orleans/issues/5696#issuecomment-503595998</a></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>同步</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性hash算法</title>
    <url>/dotnet-2020-02-06-Consistent-Hash/</url>
    <content><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><code>负载均衡</code>和<code>分布式场景</code></p>
<p>随着业务的扩展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常使用的数据，我们可以使用Redis作为缓存机制，减少数据层的压力。因此，重构后的系统架构如下图所示：<br><img src="../../assets/images/2020-02-06-Consistent_Hash/3560038521-5c37267165ddf_articlex.png" alt="简单架构"></p>
<p>优化最简单的策略就是，把常用的数据保存到Redis中，为了实现高可用使用了3台Redis（没有设置集群，集群至少要6台）。每次Redis请求会随机发送到其中一台，但是这种策略会引发如下两个问题：</p>
<ul>
<li>同一份数据可能在多个Redis数据库，造成数据冗余</li>
<li>某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中</li>
</ul>
<p>要解决上述的问题，我们需要稍稍改变一些key存入Redis的规则：<strong>使用hash算法</strong><br>例如，有三台Redis，对于每次的访问都可以通过计算hash来求得hash值。<br>如公式 h=hash(key)%3，我们把Redis编号设置成0,1,2来保存对应hash计算出来的值，h的值等于Redis对应的编号。<br>但是hash算法也会面临容错性和扩展性的问题。容错性是指当系统中的某个服务出现问题时，不能影响其他系统。扩展性是指当加入新的服务器后，整个系统能正确高效运行。</p>
<p>现假设有一台Redis服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个key就要按h = Hash(key) % 2重新计算。</p>
<p>同样，如果新增一台服务器，规则也同样需要重新计算，h = Hash(key) % 4。因此，系统中如果有服务器更变，会直接影响到Hash值，大量的key会重定向到其他服务器中，造成缓存命中率降低，而这种情况在分布式系统中是十分糟糕的。</p>
<p>一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的变更不会造成大量的哈希重定位。一致性哈希算法由此而生~</p>
<h2 id="2-一致性哈希算法"><a href="#2-一致性哈希算法" class="headerlink" title="2 一致性哈希算法"></a>2 一致性哈希算法</h2><blockquote>
<p>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>
</blockquote>
<p>简单的说，一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环如下：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/1926833502-5c372671647ce_articlex.png" alt="哈希环"><br>整个空间按顺时针方向组织，0和2^32-1在零点中方向重合。</p>
<p>接下来，把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。<br><img src="../../assets/images/2020-02-06-Consistent_Hash/1992706399-5c37267165131_articlex.png" alt="哈希环2"><br>然后，我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。</p>
<p>例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/2362548025-5c3726711599a_articlex.png" alt="哈希环3"><br>根据一致性哈希算法，数据A会被定为到Server 1上，数据B被定为到Server 2上，而C、D被定为到Server 3上。</p>
<h2 id="3-容错性和扩展性"><a href="#3-容错性和扩展性" class="headerlink" title="3 容错性和扩展性"></a>3 容错性和扩展性</h2><p>那么使用一致性哈希算法的容错性和扩展性如何呢？</p>
<h3 id="3-1-容错性"><a href="#3-1-容错性" class="headerlink" title="3.1 容错性"></a>3.1 容错性</h3><p>假如RedisService2宕机了，那么会怎样呢？</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/2142503411-5c37267117f14_articlex.png" alt="Redis2宕机"></p>
<p>那么，数据B对应的节点保存到RedisService3中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。</p>
<h3 id="3-2-扩展性"><a href="#3-2-扩展性" class="headerlink" title="3.2 扩展性"></a>3.2 扩展性</h3><p>下面考虑另一种情况，假如增加一台服务器Redis4，具体位置如下图所示：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/1713186145-5c37267126a94_articlex.png" alt="RedisServicee4"><br>原本数据C是保存到Redis3中，但由于增加了Redis4，数据C被保存到Redis4中。干扰的也只有Redis3而已，其他数据不会受到影响。</p>
<p>因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性</p>
<h2 id="4-虚拟节点"><a href="#4-虚拟节点" class="headerlink" title="4 虚拟节点"></a>4 虚拟节点</h2><p>前面部分都是讲述到Redis节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。</p>
<p>例如，我们的的系统有两台Redis，分布的环位置如下图所示：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/2099070812-5c37267114872_articlex.png" alt="哈希环"><br>这会产生一种情况，Redis4的hash范围比Redis3的hash范围大，导致数据大部分都存储在Redis4中，数据存储不平衡。</p>
<p>为了解决这种数据存储不平衡的问题，一致性哈希算法引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。</p>
<p>具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、 RedisService1#2、 RedisService1#3、 RedisService2#1、 RedisService2#2、 RedisService2#3，具体位置如下图所示：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/4164216256-5c3726711ca88_articlex.png" alt="虚拟节点"></p>
<p>对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为<strong>32甚至更大</strong>，因此即使<strong>很少的服务节点</strong>也能做到相对<strong>均匀的数据分布</strong>。</p>
<ul>
<li><a href="https://github.com/tg123/ConsistentSharp" target="_blank" rel="noopener">https://github.com/tg123/ConsistentSharp</a></li>
<li><a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Consistent_hashing</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>地图的aoi</title>
    <url>/dotnet-2020-02-07-aoi/</url>
    <content><![CDATA[<h2 id="为什么要进行视野管理？"><a href="#为什么要进行视野管理？" class="headerlink" title="为什么要进行视野管理？"></a>为什么要进行视野管理？</h2><p>1.如果不进行视野管理，流量上来看，假设平均每秒5个移动包（80字节），1个技能包（160字节），单人每秒多少？500kb。</p>
<p>2.客户端表现来看，客户端受屏幕大小影响，离得远的玩家看不见，没有必要发给客户端。客户端性能所限，玩家多，放各种 技能，当然会看。</p>
<p>3.从性能上考虑，服务端不用遍历全场景对象…也会大大减少性能消耗。</p>
<h1 id="格子"><a href="#格子" class="headerlink" title="格子"></a>格子</h1><h2 id="Land"><a href="#Land" class="headerlink" title="Land"></a>Land</h2><p>IncServer将每个场景看做是由n个land（块）组成，每个land就是一个大小固定的正方形，默认512 * 512。比如一个scene的尺寸为1200 * 700：</p>
<p><img src="../../assets/images/2020-02-07-aoi/IncServer-Scene-RealScene.png" alt="img"></p>
<p>则需要6个land来表示:</p>
<p><img src="../../assets/images/2020-02-07-aoi/IncServer-Scene.png" alt="img"></p>
<h2 id="Patch"><a href="#Patch" class="headerlink" title="Patch"></a>Patch</h2><p>Land进一步被划分为若干个Patch（格子）。以patch为单位，land的边长是2的整数次幂。</p>
<p><img src="../../assets/images/2020-02-07-aoi/IncServer-Scene-Patch.png" alt="img"></p>
<h2 id="分块管理"><a href="#分块管理" class="headerlink" title="分块管理"></a>分块管理</h2><p>World对游戏对象的管理以patch为单位，<strong>每个patch都对应有一个对象链表</strong>。</p>
<p>整个world中所有的对象链表的链表头可依次存储于一个一维数组中，这样根据对象的世界坐标，即可方便的计算出其所属的patch以及对应的对象链表。</p>
<p><img src="../../assets/images/2020-02-07-aoi/IncServer-Scene-ObjectLink.png" alt="img"></p>
<p>假设对象的坐标为(x, z)，patch的边长为patch_size，land的边长为land_size，整个场景在x方向上有land_x个land，则对象所属的对象链表的索引计算方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index &#x3D; (z &#x2F; patch_size) * (land_x * (land_size &#x2F; patch_size)) + (x &#x2F; patch_size);</span><br></pre></td></tr></table></figure>

<h3 id="IncServer的AOI"><a href="#IncServer的AOI" class="headerlink" title="IncServer的AOI"></a>IncServer的AOI</h3><p>与常见的九宫格不同，IncServer支持NEAR、MIDDLE、FAR、FULL四种视野范围：</p>
<p><img src="../../assets/images/2020-02-07-aoi/IncServer-Scene-ViewRange.png" alt="img"></p>
<ul>
<li>NEAR：当前对象所位于的patch</li>
<li>MIDDLE：与NEAR相邻的patch</li>
<li>FAR：与MID相邻的patch（NEAR除外）</li>
<li>FULL：NEAR + MIDDILE + FAR</li>
</ul>
<p>不过在实际开发中，所有对象的视野都是FULL，即每个对象都能看到以自己所在patch为中心前后左右各两个patch（总计25个patch）内的其他对象。之后的讨论均假设<strong>所有游戏对象的视野范围均为FULL</strong>。</p>
<p>如果对象B进入对象A的视野范围，则根据A对象类型，可能会触发不同的逻辑，比如：</p>
<ul>
<li>对象A是玩家：将B对象<strong>序列化</strong>到对象A的客户端。</li>
<li>对象B是怪物：执行对象进入怪物视野的逻辑，比如激活AI等。</li>
</ul>
<p>后文将以上情况称之为在对象A的视野中加载对象B，简称为<strong>视野加载</strong>。</p>
<h3 id="九宫格"><a href="#九宫格" class="headerlink" title="九宫格"></a>九宫格</h3><p>让我们首先绘制一个2D的地图</p>
<p><img src="../../assets/images/2020-02-07-aoi/3276b001c9ca66df2fd93650fc75bc3d.jpeg" alt=" 3.1 网络法实现AOI算法  - 图1">我们给这个地图定义一些数值：</p>
<p><strong>场景相关数值计算</strong></p>
<ul>
<li>场景大小： 250*250 ， w(x轴宽度) = 250，l(y轴长度) = 250</li>
<li>x轴格子数量：nx = 5</li>
<li>y轴格子数量：ny = 5</li>
<li>格子宽度: dx = w / nx = 250 / 5 = 50</li>
<li>格子长度: dy = l / ny = 250 / 5 = 50</li>
<li>格子的x轴坐标：idx</li>
<li>格子的y轴坐标：idy</li>
<li>格子编号：id = idy *nx + idx (利用格子坐标得到格子编号)</li>
<li>格子坐标：idx = id % nx , idy = id / nx (利用格子id得到格子坐标)</li>
<li>格子的x轴坐标: idx = id % nx (利用格子id得到x轴坐标编号)</li>
<li>格子的y轴坐标: idy = id / nx (利用格子id得到y轴坐标编号)</li>
</ul>
<p>以上几个数值，请参考图，简单过一下，就可以理解的，初中的几何计算而已。</p>
<p>九宫格也是打格子的方式之一，把地图划分为很多小格子，每个格子记录格子内的玩家，每个玩家的aoi范围是以自己为中心范围内的九个格子，九个格子的大小略大于屏幕大小，同样的有三个主要的操作：enter,move,leave</p>
<p>enter:根据玩家坐标，加入到所属的格子中，通过计算以这个格子的为中心的九个格子，这九个格子内的玩家就要被通知有新玩家初始化，同时这个新玩家初始化九个格子内的所有玩家。</p>
<p>move:根据移动前位置的格子，计算出移动前的oldaoi集合，根据当前位置的格子，计算出当前的curaoi集合，如果oldaoi, curaoi为同一个格子，则通知格子内的所有玩家该玩家在移动。如果oldaoi,curaoi不是同一个格子，即发生了跨格子的操作，那么要将该玩家从旧格子移除，同时加入新格子。同时分别遍历oldaoi,curaoi,计算出需要通知玩家消失的格子集合，通知玩家出生的格子集合，以及通知玩家移动的格子集合。</p>
<p>leave:玩家离开地图，将玩家从对应的格子里面删除，同时通知aoi集合有玩家离开。</p>
<p> 服务器大格子的大小，以3*3的格子要总比客户端显示范围要大一点为原则。比客户端大一点，是为了预留资源加载的时间。<br>　　如下图所示，绿色表示手机客户端的显示区域，当角色A在格子6中时，他可以看到1,2,3,5,6,7,9,10,11这9个格子里的内容，那么当他的状态发生变化时，就需要同步给在这9个格子里的所有玩家；同样，当这9个格子里的有玩家或者怪物的状态改变时，也需要都同步给角色A。</p>
<p><img src="../../assets/images/2020-02-07-aoi/1430365886_455802.jpg" alt="img"></p>
<p>　　当角色A移动到角色B所在的格子(7)，则他将不再看到1,5,9这三个格子里的内容，同时他将新看到4,8,12这三个格子里的地图内容（玩家和怪物）。所以这个过程中，服务器要下发消息，删除角色A所在的客户端里的1,5,9这三个格子里的地图内容，同时下发消息新增4,8,12这三个格子里的地图内容（类型一）。<br>　　推荐大格子具体的大小，按客户端iPhone4S的960<em>640分辨来制定，取屏幕长宽的1/2大一些，可以定为640</em>360。 </p>
<ul>
<li><a href="https://github.com/artasccope/GameFW.AOI" target="_blank" rel="noopener">https://github.com/artasccope/GameFW.AOI</a> </li>
<li><a href="https://www.bookstack.cn/read/zinx/78aa012966213643.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/zinx/78aa012966213643.md</a></li>
</ul>
<h3 id="灯塔法"><a href="#灯塔法" class="headerlink" title="灯塔法"></a>灯塔法</h3><p>所谓灯塔法，即将大地图划分成有限的小格子，在每个小格子中间放一个灯塔，这个灯塔管理两个队列：一个是本格子内所有的对象集合，另一个是对本灯塔感兴趣的对象集合（简称观察者）。</p>
<p>而地图上的每个对象，维护一个视野队列：该队列为其视野范围内的所有对象，即自身感兴趣的所有对象。</p>
<p>一个对象在地图上面运动：分为三个操作：enter，move，leave.</p>
<p>enter:当对象进入地图的时候，根据对象的当前位置和对象的感知距离，可以获取到该对象能观察到的所有灯塔，遍历这些灯塔，将该对象添加为其观察者。同时将这些对象添加到自己的视野队列中。</p>
<p>move:当对象开始移动的时候，对象从一个点到另一个店，那么视野范围必然发生变化。此刻需要将对象从老的灯塔的观察者列表移除，同时将对象添加进新的灯塔的观察者列表。此外，还需要跟新玩家的视野队列，因为视野范围变化，视野内的对象也相应变化。</p>
<p>leave:当对象离开的时候，将自身从附近灯塔的观察者队列中移除。</p>
<p>通过灯塔法，每当物体发生变化，我们能马上根据其当前位置，定位到他的所在的灯塔，同时找到它视野范围内相关联的物体。这样避免了遍历地图上所有玩家进行处理的方式。</p>
<p>当然灯塔的格子大小划分要因地制宜，格子越小，消耗内存越大，同时计算量变大。</p>
<ul>
<li><p><a href="https://github.com/Bestpoker/AOI" target="_blank" rel="noopener">https://github.com/Bestpoker/AOI</a> </p>
</li>
<li><p><a href="https://github.com/NetEase/pomelo-aoi" target="_blank" rel="noopener">https://github.com/NetEase/pomelo-aoi</a></p>
</li>
<li><p><a href="https://github.com/ahuangege/tower-aoi" target="_blank" rel="noopener">https://github.com/ahuangege/tower-aoi</a></p>
</li>
</ul>
<p>前几天把pomelo中的tower aoi的js实现看了一遍，总结如下：</p>
<ol>
<li><p>js代码写得不是很好，发现了几个小问题；</p>
</li>
<li><p>“对象(包括观察者)出现”“对象(包括观察者)消失”“对象(包括观察者)位置变化”“观察者位置变化”的回调通知(前三者通知对应灯塔区域的观察者，第四个通知观察者本身)没有可测试的样例，采用的话需要自己实现和测试；</p>
</li>
<li><p>只考虑了起点和终点，移动路径上的玩家被忽视了，路径短的话也可能不是问题(长路径切分成多个短路径做位置更新)；</p>
</li>
<li><p>观察者可能收到超出自己视野范围的消息；</p>
</li>
<li><p>优点是可处理视野不同的观察者，相对于普通扫格子的实现在代码层面耦合度降低、效率提升不明显(把扫格子实现的地格看做一个灯塔区域，在地格上记录观察者就可以模拟这种灯塔模型，削去了遍历周边地格所有对象的逻辑)</p>
</li>
<li><p>这里做的是四边形灯塔区域，云风提的那种六边形灯塔区域减少查询灯塔个数是特指视野半径&lt;=六边形边长的一半这种情况</p>
<ol start="7">
<li>tower aoi其实就是处理地图视野的一个设计，类似于订阅-发布，我订阅某一块区域表示对这一块区域感兴趣，那么有对象在这一块区域出现消失移动你就通知我</li>
</ol>
</li>
</ol>
<h1 id="十字链表法"><a href="#十字链表法" class="headerlink" title="十字链表法"></a>十字链表法</h1><p>这里以2d游戏为例，3d游戏顺势扩展即可。</p>
<p>所谓十字链表法，即维护两天链表，一条根据地图上所有物体的x坐标从小到大依次插入链表，一条根据地图上所有物体的y坐标从小到大依次插入链表，可以想象成一个十字架。这样便把地图上的所有对象按序分配到了x,y链表上。</p>
<p>这里的链表为双向链表，双向链表的好处是，获取到链表中的一个节点，便可以向前和向后遍历。这样，当我们拿到一个对象时，要获取该对象的视野范围就变得非常简单。避免了从头到尾遍历所有对象。</p>
<p>首先根据x坐标，在x链表上找到该节点，然后从该节点向前和向后遍历，根据x方向的视野范围找出需要识别的对象。</p>
<p>然后根据y坐标，在y链表上找到该节点，然后从该节点向前和向后遍历，根据y方向的视野范围找出需要识别的对象。</p>
<p>拿到x,y链表上需要关注的对象，然后取他们的交集，这便是玩家视野范围内的对象。</p>
<p>对于对象在地图上的enter,move,leave 。根据前面的思路就变得非常简单</p>
<ul>
<li><a href="https://github.com/zhepama/AOI" target="_blank" rel="noopener">https://github.com/zhepama/AOI</a> </li>
</ul>
<h4 id="十字链表基本原理"><a href="#十字链表基本原理" class="headerlink" title="十字链表基本原理"></a><strong>十字链表基本原理</strong></h4><p>根据二维地图，将其分成x轴和y轴两个链表。如果是三维地图，则还需要维护多一个z轴的链表。将对象的坐标值按照从小到大相应的排列在相应的坐标轴上面。</p>
<ul>
<li>添加到AOI（ADD）: 根据新增对象的X,Y坐标,依次遍历X,Y轴坐标链表,这里有两个目的,一个是获得这个新增对象的坐标在X,Y轴坐标的位置,另一方面获得该通知哪些结点.通知的范围,每个对象可以自己定制自己的通知范围。必须X,Y坐标同时都在通知范围内才可以进入通知集合，我们要按照从小到大进行插入。例如X轴坐标为:</li>
</ul>
<p><code>a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f-&gt;g-&gt;h</code></p>
<p>假设新增一个对象z,它最终所在的位置是c和d之间,需要重新在链表的头部开始遍历寻找z的位置，比如z的X轴位置是5：</p>
<p><code>a(0)-&gt;b(1)-&gt;c(2)-&gt;d(3)-&gt;e(4)-z(5)-&gt;f(6)-&gt;g(7)-&gt;h(8)</code></p>
<p>但是这样会发现一个问题，如果需要管理的坐标少还可以。但如果有很多个坐标比如1W个坐标，那这个链表会很长，如果每次都需要从头部开始查找效率就很低。针对这样的插入方法目前大家常用的有快速排序、分治、按区域划分格子等方式。</p>
<h4 id="目前常用的排序算法"><a href="#目前常用的排序算法" class="headerlink" title="目前常用的排序算法"></a><strong>目前常用的排序算法</strong></h4><ul>
<li>快速排序（Quicksort）是对<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306">冒泡排序</a>的一种改进。</li>
</ul>
<p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E9%80%92%E5%BD%92/1740695">递归</a>进行，以此达到整个数据变成有序<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%BA%8F%E5%88%97/1302588">序列</a>。</p>
<ul>
<li>分治算法</li>
</ul>
<p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。</p>
<ul>
<li>按区域划分格子</li>
</ul>
<p>该方法是把区域划分成多个格子，比如X坐标1到X坐标4为一个格子我们（暂时称之为A格子），坐标5到X坐标9为一个格子（暂时称之为B格子）。这样做的好处是，当你插入的坐标是2的时候，我们只需要遍历A格子里面的数据找到自己位置就可以了。</p>
<p>综合以上三种方法，大家一眼就看出来了。是的，按区域划分格子的方式是目前最佳的方式。从时间复杂度等等所有方便都是这个最佳，但是这个方法也有一个很大的问题，用这样的方式插入是很快了，但查找范围内的坐标就变的很困难了。大家可以仔细考虑一下或者自己写一个DEMO。你马上会发现，当我知道我的位置的情况下，我该如何查找周围玩家呢，是的。这样的话十字链就没有什么用了。</p>
<p>当然会有人说我在每个格子之间用链表进行连接就可以了，那么问题又来了。该如何连接，肯定有很复杂的代码才可以完成这样逻辑。就算是你能完成这个链表的连接，但这些逻辑会提升了时间复杂度。</p>
<h4 id="快慢针"><a href="#快慢针" class="headerlink" title="快慢针"></a>快慢针</h4><p>所谓快慢针就是，总有一个指针快于一个指针。</p>
<p>实现方式是，插入的时候把链表分成多份、比如链表长度为10，快的指针每次移动4个，然后对比当前节点如果位置小于的话，把慢指针指向快指针的位置，快指针继续向后面4个格子移动，直到找到大于的节点为止，这时候慢指针开始向前移动一个一个的对比位置就可以了。如果一直没有找到大于的节点，那就表示要插入的位置是当前链表最后的位置。</p>
<p>相信大家已经看明白了，是的。这样的情况下效率就很高了，唯一的问题就是这个时间复杂度不稳定。使用这个方式，查找周围玩家直接前后查找移动就可以了。效率也非常高。</p>
<p>快慢针实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (First &#x3D;&#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">      node.Link.YNode &#x3D; AddFirst(AoiPool.Instance.Fetch&lt;LinkedListNode&lt;AoiNode&gt;&gt;(node).Value);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">       var slowCursor &#x3D; First;</span><br><span class="line"></span><br><span class="line">       var skip &#x3D; Convert.ToInt32(Math.Ceiling(Convert.ToDouble(Count) &#x2F;</span><br><span class="line">                     Convert.ToDouble(_skipCount)));</span><br><span class="line"></span><br><span class="line">       if (Last.Value.Position.Y &gt; node.Position.Y)</span><br><span class="line">       &#123;</span><br><span class="line">            for (var i &#x3D; 0; i &lt; _skipCount; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                 &#x2F;&#x2F; 移动快指针</span><br><span class="line"></span><br><span class="line">                 var fastCursor &#x3D; FastCursor(i * skip, skip);</span><br><span class="line"></span><br><span class="line">                 &#x2F;&#x2F; 如果快指针的值小于插入的值，把快指针赋给慢指针，当做当前指针。</span><br><span class="line"></span><br><span class="line">                 if (fastCursor.Value.Position.Y &lt;&#x3D; node.Position.Y)</span><br><span class="line">                 &#123;</span><br><span class="line">                       slowCursor &#x3D; fastCursor;</span><br><span class="line"></span><br><span class="line">                            continue;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 &#x2F;&#x2F; 慢指针移动到快指针位置</span><br><span class="line"></span><br><span class="line">                 while (slowCursor !&#x3D; fastCursor)</span><br><span class="line">                 &#123;</span><br><span class="line">                      if (slowCursor &#x3D;&#x3D; null) break;</span><br><span class="line"></span><br><span class="line">                      if (slowCursor.Value.Position.Y &gt;&#x3D; node.Position.Y)</span><br><span class="line">                      &#123;</span><br><span class="line">                           node.Link.YNode &#x3D; AddBefore(slowCursor,</span><br><span class="line">                                    AoiPool.Instance.Fetch&lt;LinkedListNode&lt;AoiNode&gt;&gt;(node).Value);</span><br><span class="line"></span><br><span class="line">                           return;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                       slowCursor &#x3D; slowCursor.Next;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">if (node.Link.YNode &#x3D;&#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">       node.Link.YNode &#x3D; AddLast(AoiPool.Instance.Fetch&lt;LinkedListNode&lt;AoiNode&gt;&gt;(node).Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><ul>
<li>Move（当角色移动后通知AOI）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#region 移动X轴</span><br><span class="line"></span><br><span class="line">            if (Math.Abs(node.Position.X - x) &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (x &gt; node.Position.X)</span><br><span class="line">                &#123;</span><br><span class="line">                    var cur &#x3D; node.Link.XNode.Next;</span><br><span class="line"></span><br><span class="line">                    while (cur !&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (x &lt; cur.Value.Position.X)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _xLinks.Remove(node.Link.XNode);</span><br><span class="line"></span><br><span class="line">                            node.Position.X &#x3D; x;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.XNode &#x3D; _xLinks.AddBefore(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (cur.Next &#x3D;&#x3D; null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _xLinks.Remove(node.Link.XNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.X &#x3D; x;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.XNode &#x3D; _xLinks.AddAfter(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        cur &#x3D; cur.Next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    var cur &#x3D; node.Link.XNode.Previous;</span><br><span class="line"></span><br><span class="line">                    while (cur !&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (x &gt; cur.Value.Position.X)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _xLinks.Remove(node.Link.XNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.X &#x3D; x;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.XNode &#x3D; _xLinks.AddBefore(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (cur.Previous &#x3D;&#x3D; null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _xLinks.Remove(node.Link.XNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.X &#x3D; x;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.XNode &#x3D; _xLinks.AddAfter(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        cur &#x3D; cur.Previous;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            #endregion</span><br><span class="line"></span><br><span class="line">            #region 移动Y轴</span><br><span class="line"></span><br><span class="line">            if (Math.Abs(node.Position.Y - y) &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (y &gt; node.Position.Y)</span><br><span class="line">                &#123;</span><br><span class="line">                    var cur &#x3D; node.Link.YNode.Next;</span><br><span class="line"></span><br><span class="line">                    while (cur !&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (y &lt; cur.Value.Position.Y)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _yLinks.Remove(node.Link.YNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.Y &#x3D; y;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.YNode &#x3D; _yLinks.AddBefore(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (cur.Next &#x3D;&#x3D; null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _yLinks.Remove(node.Link.YNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.Y &#x3D; y;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.YNode &#x3D; _yLinks.AddAfter(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        cur &#x3D; cur.Next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    var cur &#x3D; node.Link.YNode.Previous;</span><br><span class="line"></span><br><span class="line">                    while (cur !&#x3D; null)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (y &gt; cur.Value.Position.Y)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _yLinks.Remove(node.Link.YNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.Y &#x3D; y;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.YNode &#x3D; _yLinks.AddBefore(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (cur.Previous &#x3D;&#x3D; null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _yLinks.Remove(node.Link.YNode);</span><br><span class="line">                            </span><br><span class="line">                            node.Position.Y &#x3D; y;</span><br><span class="line">                            </span><br><span class="line">                            node.Link.YNode &#x3D; _yLinks.AddAfter(cur, node);</span><br><span class="line"></span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        cur &#x3D; cur.Previous;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            #end-region</span><br></pre></td></tr></table></figure>

<ul>
<li>查找周围（按照指定的范围查找自己周围玩家）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var cur &#x3D; i &#x3D;&#x3D; 0 ? node.Link.XNode.Next : node.Link.XNode.Previous;</span><br><span class="line"></span><br><span class="line">                while (cur !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) &gt; area.X)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) &lt;&#x3D; area.Y)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (Distance(node.Position, cur.Value.Position) &lt;&#x3D; area.X)</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    cur &#x3D; i &#x3D;&#x3D; 0 ? cur.Next : cur.Previous;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (var i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">               var cur &#x3D; i &#x3D;&#x3D; 0 ? node.Link.YNode.Next : node.Link.YNode.Previous;</span><br><span class="line"></span><br><span class="line">                while (cur !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (Math.Abs(Math.Abs(cur.Value.Position.Y) - Math.Abs(node.Position.Y)) &gt; area.Y)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (Math.Abs(Math.Abs(cur.Value.Position.X) - Math.Abs(node.Position.X)) &lt;&#x3D; area.X)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (Distance(node.Position, cur.Value.Position) &lt;&#x3D; area.Y)</span><br><span class="line">                        &#123;</span><br><span class="line">                            if (!node.AoiInfo.MovesSet.Contains(cur.Value.Id)) node.AoiInfo.MovesSet.Add(cur.Value.Id);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    cur &#x3D; i &#x3D;&#x3D; 0 ? cur.Next :cur.Previous;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>



<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>九宫格<ul>
<li>优点: cpu消耗小</li>
<li>缺点: 内存开销大,内存消耗不仅和实体数有关,还和场景大小成正比</li>
</ul>
</li>
<li>十字链表<ul>
<li>优点: 内存开销小,内存消耗仅和实体数有关,和场景大小无关</li>
<li>缺点: cpu消耗高,每次移动都需要计算视野差,当实体在小区域堆积严重时效率更差</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>同步</tag>
        <tag>地图</tag>
        <tag>aoi</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏的匹配机制ELO</title>
    <url>/dotnet-2020-02-09-room-elo/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/edc5d341956a" target="_blank" rel="noopener">https://www.jianshu.com/p/edc5d341956a</a></p>
<p><a href="https://blog.csdn.net/weixin_30876945/article/details/98079738?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30876945/article/details/98079738?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
<p><a href="https://blog.csdn.net/yekoufeng/article/details/80573857?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/yekoufeng/article/details/80573857?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>C# 深浅复制</title>
    <url>/dotnet-2020-02-10-Icloneable/</url>
    <content><![CDATA[<p>关于深浅复制大家可参考MSDN：<a href="https://msdn.microsoft.com/zh-cn/library/system.object.memberwiseclone.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/zh-cn/library/system.object.memberwiseclone.aspx</a> </p>
<p>所谓深浅复制可解读为：</p>
<p>浅复制：C#语言种的MemberwiseClone方法仅仅是再内存种创建一个新对象，然后将原有对象的所有字段直接复制过去，无论是值类型还是引用类型，是值类型的就复制值类型，是应用类型的就复制引用本身（而不会复制所引用的对象），因此，是浅拷贝。</p>
<p>需要注意的是:  在利用MemberwiseClone()创建新对象的时候，不会像利用new的时候一样，也就是不会先执行字段的创建和构造方法条用的过程。</p>
<p>深复制：如果字段是值类型的，则对字段执行逐位复制，如果字段是引用类型的，则把引用类型的对象指向<strong>一个全新的对象！</strong></p>
<h2 id="ICloneable接口"><a href="#ICloneable接口" class="headerlink" title="ICloneable接口"></a>ICloneable接口</h2><p>ICloneable接口包含一个Clone方法，可以用来创建当前对象的拷贝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ICloneable </span><br><span class="line">&#123; </span><br><span class="line">    object Clone(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>ICloneable的问题是Clone方法并不会显式地指定是执行浅拷贝或深拷贝，因此调用者将无法确定实际情况。因此，有一些关于把ICloneable从.NET框架中淘汰的讨论。MSDN文档似乎暗示Clone方法是进行的深拷贝，但是文档没有明确的说明：</p>
<p>ICloneable接口包含一个成员方法，Clone，意在支持超过MemberWiseClone所提供的功能… MemberWiseClone进行的是浅拷贝…</p>
<p>类型安全的克隆</p>
<p>ICloneable的另一个缺点是Clone方法返回的是一个对象，因此每次调用Clone都要进行一次强制类型转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person joe &#x3D; new Person(); </span><br><span class="line">joe.Name &#x3D; &quot;Joe Smith&quot;; </span><br><span class="line">Person joeClone &#x3D; (Person)joe.Clone();</span><br></pre></td></tr></table></figure>


<p>一种可以避免进行强制类型转换的方式是提供你自己的类型安全的Clone方法。注意，你依然要提供ICloneable.Clone方法的以满足iCloneable接口的要求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person : ICloneable </span><br><span class="line">&#123; </span><br><span class="line">    public string Name; </span><br><span class="line">    object ICloneable.Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        return this.Clone(); </span><br><span class="line">    &#125; </span><br><span class="line">    public Person Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        return (Person)this.MemberwiseClone(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>手工克隆</li>
</ol>
<p>一个能够保证对象完全按照你所想的那样进行克隆的方式是手工克隆对象的每一个域（field）。这种方式的缺点是麻烦而且容易出错：如果你在类中增 加了一个域，你很可能会忘记更新Clone方法。还要在克隆引用对象指向原始对象的时候，注意避免无限循环引用。下面是一个进行深拷贝的简单例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person : ICloneable </span><br><span class="line">&#123; </span><br><span class="line">    public string Name; </span><br><span class="line">    public Person Spouse; </span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        Person p &#x3D; new Person(); </span><br><span class="line">        p.Name &#x3D; this.Name; </span><br><span class="line">        if (this.Spouse !&#x3D; null) </span><br><span class="line">            p.Spouse &#x3D; (Person)this.Spouse.Clone(); </span><br><span class="line">        return p; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用MemberWiseClone方法</li>
</ol>
<p>MemberWiseClone是Object类的受保护方法，能够通过创建一个新对象，并把所有当前对象中的非静态域复制到新对象中，从而创建一 个浅拷贝。对于值类型的域，进行的是按位拷贝。对于引用类型的域，引用会被赋值而引用的对象则不会。因此，原始对象及其克隆都会引用同一个对象。注意，这 种方法对派生类都是有效的，也就是说，你只需在基类中定义一次Clone方法。下面是一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person : ICloneable </span><br><span class="line">&#123; </span><br><span class="line">    public string Name; </span><br><span class="line">    public Person Spouse; </span><br><span class="line">    public object Clone() </span><br><span class="line">    &#123; </span><br><span class="line">        return this.MemberwiseClone(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用反射进行克隆</li>
</ol>
<p>用反射进行克隆是使用Activator.CreateInstance方法来创建一个相同类型的新对象，然后用反射对所有域进行浅拷贝。这种方法 的优点是它是全自动的，不需要在对象中添加或删除成员的时候修改克隆方法。另外它也能被写成提供深拷贝的方法。缺点是使用了反射，因此会比较慢，而且在部 分受信任的环境中是不可用的。示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static TOut TransReflection&lt;TIn, TOut&gt;(TIn tIn)</span><br><span class="line">        &#123;</span><br><span class="line">            TOut tOut &#x3D; Activator.CreateInstance&lt;TOut&gt;();</span><br><span class="line">            var tInType &#x3D; tIn.GetType();</span><br><span class="line">            foreach (var itemOut in tOut.GetType().GetProperties())</span><br><span class="line">            &#123;</span><br><span class="line">                var itemIn &#x3D; tInType.GetProperty(itemOut.Name); ;</span><br><span class="line">                if (itemIn !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    itemOut.SetValue(tOut, itemIn.GetValue(tIn));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return tOut;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p><strong>调用一百万次耗时：2464毫秒</strong></p>
<ol start="4">
<li>使用序列化进行克隆</li>
</ol>
<p>克隆一个对象的最简单的方法是将它序列化并立刻反序列化为一个新对象。和反射方法一样，序列化方法是自动的，无需在对对象成员进行增删的时候做出修 改。缺点是序列化比其他方法慢，甚至比用反射还慢，所有引用的对象都必须是可序列化的（Serializable）。另外，取决于你所使用的序列化的类型 （XML，SOAP，二进制）的不同，私有成员可能不能像期望的那样被克隆。示例代码在这里，这里和这里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StudentSecond ss&#x3D; JsonConvert.DeserializeObject&lt;StudentSecond&gt;(JsonConvert.SerializeObject(s));</span><br></pre></td></tr></table></figure>

<p><strong>调用一百万次耗时：</strong>2984毫秒</p>
<p><a href="http://wiki.unity3d.com/index.php/ObjectCopier" target="_blank" rel="noopener">http://wiki.unity3d.com/index.php/ObjectCopier</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Runtime.Serialization;</span><br><span class="line">using System.Runtime.Serialization.Formatters.Binary;</span><br><span class="line">using System.IO;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Reference Article http:&#x2F;&#x2F;www.codeproject.com&#x2F;KB&#x2F;tips&#x2F;SerializedObjectCloner.aspx</span><br><span class="line">&#x2F;&#x2F;&#x2F; </span><br><span class="line">&#x2F;&#x2F;&#x2F; Provides a method for performing a deep copy of an object.</span><br><span class="line">&#x2F;&#x2F;&#x2F; Binary Serialization is used to perform the copy.</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public static class ObjectCopier</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Perform a deep Copy of the object.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;The type of object being copied.&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;source&quot;&gt;The object instance to copy.&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;The copied object.&lt;&#x2F;returns&gt;</span><br><span class="line">    public static T Clone&lt;T&gt;(this T source)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!typeof(T).IsSerializable)</span><br><span class="line">        &#123;</span><br><span class="line">            throw new ArgumentException(&quot;The type must be serializable.&quot;, &quot;source&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; Don&#39;t serialize a null object, simply return the default for that object</span><br><span class="line">        if (Object.ReferenceEquals(source, null))</span><br><span class="line">        &#123;</span><br><span class="line">            return default(T);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        IFormatter formatter &#x3D; new BinaryFormatter();</span><br><span class="line">        Stream stream &#x3D; new MemoryStream();</span><br><span class="line">        using (stream)</span><br><span class="line">        &#123;</span><br><span class="line">            formatter.Serialize(stream, source);</span><br><span class="line">            stream.Seek(0, SeekOrigin.Begin);</span><br><span class="line">            return (T)formatter.Deserialize(stream);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>使用IL进行克隆</li>
</ol>
<p>一种罕见的解决方案是使用IL（中间语言）来进行对象克隆。这种方式创建一个动态方法（DynamicMethod），获取中间语言生成器 （ILGenerator），向方法中注入代码，把它编译成一个委托，然后执行这个委托。委托会被缓存，因此中间语言只在初次克隆的时候才会生成，后续的 克隆都不会重新生成一遍。尽管这种方法比使用反射快，但是这种方法难以理解和维护。示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　 public static class TransExpV2&lt;TIn, TOut&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private static readonly Func&lt;TIn, TOut&gt; cache &#x3D; GetFunc();</span><br><span class="line">    private static Func&lt;TIn, TOut&gt; GetFunc()</span><br><span class="line">    &#123;</span><br><span class="line">        ParameterExpression parameterExpression &#x3D; Expression.Parameter(typeof(TIn), &quot;p&quot;);</span><br><span class="line">        List&lt;MemberBinding&gt; memberBindingList &#x3D; new List&lt;MemberBinding&gt;();</span><br><span class="line"></span><br><span class="line">        foreach (var item in typeof(TOut).GetProperties())</span><br><span class="line">        &#123;</span><br><span class="line">　　　　　　　　　if (!item.CanWrite)</span><br><span class="line">　　　　　　　　　　    continue;</span><br><span class="line"></span><br><span class="line">            MemberExpression property &#x3D; Expression.Property(parameterExpression, typeof(TIn).GetProperty(item.Name));</span><br><span class="line">            MemberBinding memberBinding &#x3D; Expression.Bind(item, property);</span><br><span class="line">            memberBindingList.Add(memberBinding);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MemberInitExpression memberInitExpression &#x3D; Expression.MemberInit(Expression.New(typeof(TOut)), memberBindingList.ToArray());</span><br><span class="line">        Expression&lt;Func&lt;TIn, TOut&gt;&gt; lambda &#x3D; Expression.Lambda&lt;Func&lt;TIn, TOut&gt;&gt;(memberInitExpression, new ParameterExpression[] &#123; parameterExpression &#125;);</span><br><span class="line"></span><br><span class="line">        return lambda.Compile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static TOut Trans(TIn tIn)</span><br><span class="line">    &#123;</span><br><span class="line">        return cache(tIn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用：<strong>StudentSecond ss= TransExpV2.Trans(s);</strong></p>
<p><strong>调用一百万次耗时：107毫秒\</strong></p>
<ol start="6">
<li>使用扩展方法进行克隆</li>
</ol>
<p>Havard Stranden用扩展方法（extention method）创建了一个自定义的克隆框架。这个框架能够创建对象及其引用的对象的深拷贝，不管对象结构有多复杂。缺点是，这是一个不提供源代码的自定义 框架（更新：现在已经包括源代码了，参见本文评论），并且它不能在不使用无参数构造器的时候，拷贝由私有方法创建的对象。另一个问题，也是所有自动化的深 克隆方法共有的问题是，深拷贝通常需要灵活地处理不能进行简单自动化特殊情况（例如未受管理的资源）。</p>
<h3 id="一个测试类"><a href="#一个测试类" class="headerlink" title="一个测试类"></a>一个测试类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using Microsoft.VisualStudio.TestTools.UnitTesting;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System;</span><br><span class="line">namespace dotnet_samples_test</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public class Person : ICloneable </span><br><span class="line">    &#123;</span><br><span class="line">        public IdInfo IdInfo;</span><br><span class="line">        public int Age &#123; get; set; &#125;</span><br><span class="line">        public string Name &#123; get; set; &#125;</span><br><span class="line">        public string Address &#123; get; set; &#125;</span><br><span class="line">        public List&lt;string&gt; Phones &#123; get; set; &#125; &#x3D; new List&lt;string&gt;();</span><br><span class="line">        public object Clone()</span><br><span class="line">        &#123;</span><br><span class="line">            return this.MemberwiseClone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Person ShallowCopy()</span><br><span class="line">        &#123;</span><br><span class="line">            return (Person)this.Clone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Person DeepCopy()</span><br><span class="line">        &#123;</span><br><span class="line">            var result &#x3D;  (Person)this.Clone();</span><br><span class="line">            result.IdInfo &#x3D; result.IdInfo.DeepCopy();</span><br><span class="line">            result.Phones &#x3D; result.Phones.ToList();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public class IdInfo</span><br><span class="line">    &#123;</span><br><span class="line">        public int IdNumber;</span><br><span class="line">        public IdInfo(int IdNumber)</span><br><span class="line">        &#123;</span><br><span class="line">            this.IdNumber &#x3D; IdNumber;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public object Clone()</span><br><span class="line">        &#123;</span><br><span class="line">            return this.MemberwiseClone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IdInfo ShallowCopy()</span><br><span class="line">        &#123;</span><br><span class="line">            return (IdInfo)this.Clone();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IdInfo DeepCopy()</span><br><span class="line">        &#123;</span><br><span class="line">            var result &#x3D;  (IdInfo)this.Clone();</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [TestClass]</span><br><span class="line">    public class CloneTest1</span><br><span class="line">    &#123;</span><br><span class="line">        [TestMethod]</span><br><span class="line">        public void TestMethod1()</span><br><span class="line">        &#123;</span><br><span class="line">            var person1 &#x3D; new Person</span><br><span class="line">            &#123;</span><br><span class="line">                Name &#x3D; &quot;長澤雅美&quot;,</span><br><span class="line">                Age &#x3D; 30,</span><br><span class="line">                Address &#x3D; &quot;日本静岡縣磐田市&quot;,</span><br><span class="line">                Phones &#x3D; new List&lt;string&gt; &#123; &quot;9&quot;, &quot;1&quot;, &quot;1&quot; &#125;,</span><br><span class="line">                IdInfo &#x3D; new IdInfo(1)</span><br><span class="line">            &#125;;</span><br><span class="line">            var person2 &#x3D; person1.ShallowCopy();</span><br><span class="line">            person2.IdInfo.IdNumber &#x3D; 2;</span><br><span class="line">            person2.Phones.RemoveAt(0);</span><br><span class="line">            person2.Name&#x3D;&quot;冈本伊朗&quot;;</span><br><span class="line">            Console.WriteLine(&quot;person1的名字:&quot;+person1.Name);</span><br><span class="line">            Console.WriteLine(&quot;person1第一个数字是:&quot;+person1.Phones[0]);</span><br><span class="line">            Console.WriteLine(&quot;person1id是:&quot;+person1.IdInfo.IdNumber);</span><br><span class="line"></span><br><span class="line">                      Console.WriteLine(&quot;person2的名字:&quot;+person2.Name);</span><br><span class="line">            Console.WriteLine(&quot;person2第一个数字是:&quot;+person2.Phones[0]);</span><br><span class="line">            Console.WriteLine(&quot;person2id是:&quot;+person2.IdInfo.IdNumber);</span><br><span class="line">            Assert.AreEqual(person1.IdInfo.IdNumber,person2.IdInfo.IdNumber);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [TestMethod]</span><br><span class="line">        public void TestMethod2()</span><br><span class="line">        &#123;</span><br><span class="line">            var person1 &#x3D; new Person</span><br><span class="line">            &#123;</span><br><span class="line">                Name &#x3D; &quot;長澤雅美&quot;,</span><br><span class="line">                Age &#x3D; 30,</span><br><span class="line">                Address &#x3D; &quot;日本静岡縣磐田市&quot;,</span><br><span class="line">                Phones &#x3D; new List&lt;string&gt; &#123; &quot;9&quot;, &quot;1&quot;, &quot;1&quot; &#125;,</span><br><span class="line">                IdInfo &#x3D; new IdInfo(1)</span><br><span class="line">            &#125;;</span><br><span class="line">            var person2 &#x3D; person1.DeepCopy();</span><br><span class="line">            person2.IdInfo.IdNumber &#x3D; 2;</span><br><span class="line">            person2.Phones.RemoveAt(0);</span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(&quot;person1的名字:&quot;+person1.Name);</span><br><span class="line">            Console.WriteLine(&quot;person1第一个数字是:&quot;+person1.Phones[0]);</span><br><span class="line">            Console.WriteLine(&quot;person1id是:&quot;+person1.IdInfo.IdNumber);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;person2的名字:&quot;+person2.Name);</span><br><span class="line">            Console.WriteLine(&quot;person2第一个数字是:&quot;+person2.Phones[0]);</span><br><span class="line">            Console.WriteLine(&quot;person2id是:&quot;+person2.IdInfo.IdNumber);</span><br><span class="line"></span><br><span class="line">            Assert.AreEqual(person1.IdInfo.IdNumber,person2.IdInfo.IdNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>PHP</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>C#引用类型对象在循环引用时会不会内存泄漏</title>
    <url>/dotnet-2020-02-11-gc/</url>
    <content><![CDATA[<p>对于垃圾收集（GC）, 我们需要考虑三件事情：哪些内存需要回收？如何判断是垃圾对象？垃圾回收算法有哪些？</p>
<h2 id="一、GC的工作区域"><a href="#一、GC的工作区域" class="headerlink" title="一、GC的工作区域"></a>一、GC的工作区域</h2><p><strong>1、不是GC的工作区域</strong></p>
<p>  (1)程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭；</p>
<p>  (2)栈中的栈帧随着方法的进入和退出而进行入栈和出栈操作，每个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具有确定性。</p>
<p>在这几个区域不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。</p>
<p><strong>2、GC的工作区域（哪些内存需要GC回收？）</strong></p>
<p>(1)垃圾回收重点关注的是堆和方法区部分的内存。</p>
<p>​    因为一个接口中的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分</p>
<p>配和回收都是动态的，所以垃圾回收器所关注的主要是这部分的内存。</p>
<h2 id="二、垃圾对象的判定"><a href="#二、垃圾对象的判定" class="headerlink" title="二、垃圾对象的判定"></a>二、垃圾对象的判定</h2><p>Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，哪些还活着。对象死去的时候才需要回收。</p>
<h4 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h4><p>   引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。</p>
<p>如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。</p>
<p>优点</p>
<p>  1)可即刻回收垃圾，每个对象都知道自己的被引用数，当counter为0时，对象就会把自己作为空闲空间连接到空闲链表，也就是在对象变成垃圾的同时就会被回收.</p>
<p>  2）最大暂停时间短，每次通过指向mutator生成垃圾时，这部分垃圾都会被回收，大幅削减了mutator的最大暂停时间。</p>
<p>缺点</p>
<p>  1)引用和去引用伴随加法和减法，影响性能</p>
<p>  2)很难处理循环引用</p>
<h4 id="2、可达性分析算法"><a href="#2、可达性分析算法" class="headerlink" title="2、可达性分析算法"></a>2、可达性分析算法</h4><p>   这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。</p>
<p>Java语言是通过可达性分析算法来判断对象是否存活的。</p>
<p><img src="../../assets/images/2020-02-11-gc/1090617-20180621212836385-64372595.png" alt="img"></p>
<p> C#与Java中，<strong>GC采用的是GC Root 的链路可达性分析算法解决的GC标记问题</strong>。原理就是一个对象只要有GC Root引用，就不会释放</p>
<p><strong>.NET中可以当作GC Root的对象有如下几种：</strong></p>
<p>1、全局变量</p>
<p>2、静态变量</p>
<p>3、栈上的所有局部变量(JIT)</p>
<p>4、栈上传入的参数变量</p>
<p>5、寄存器中的变量</p>
<p><strong>在Java中，可以当做GC Root的对象有以下几种：</strong></p>
<p>1、虚拟机（JVM）栈中的引用的对象</p>
<p>2、方法区中的类静态属性引用的对象</p>
<p>3、方法区中的常量引用的对象（主要指声明为final的常量值）</p>
<p>4、本地方法栈中JNI的引用的对象</p>
<h2 id="三、垃圾回收算法"><a href="#三、垃圾回收算法" class="headerlink" title="三、垃圾回收算法"></a>三、垃圾回收算法</h2><h4 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h4><p>简单来说有两个步骤：标记、清除。</p>
<p> (1). 标记阶段：找到所有可访问的对象，做个标记</p>
<p> (2). 清除阶段：遍历堆，把未被标记的对象回收<br><img src="../../assets/images/2020-02-11-gc/1090617-20180621213112064-1445464345.png" alt="img"></p>
<p> 缺 点</p>
<p>  (1)因为涉及大量的内存遍历工作，所以执行性能较低，这也会导致“stop the world”时间较长，java程序吞吐量降低；</p>
<p>  (2)对象被清除之后，被清除的对象留下内存的空缺位置会造成内存不连续，空间浪费。</p>
<h4 id="2、标记整理-压缩-算法"><a href="#2、标记整理-压缩-算法" class="headerlink" title="2、标记整理(压缩)算法"></a><strong>2、标记整理(压缩)算法</strong></h4><p>标记-整理算法适合用于存活对象较多的场合，如老年代。它在标记-清除算法的基础上做了一些优化。</p>
<p>   (1)、标记阶段：它的第一个阶段与标记/清除算法是一模一样的。</p>
<p>   (2)、整理阶段：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。<br><img src="../../assets/images/2020-02-11-gc/1090617-20180621213518377-283931527.png" alt="img"></p>
<p>​    上图中可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲</p>
<p>列表显然少了许多开销。</p>
<p>优点</p>
<p>   标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。</p>
<p>缺点</p>
<p>   标记/整理算法唯一的缺点就是效率也不高。不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 </p>
<h4 id="3、复制算法"><a href="#3、复制算法" class="headerlink" title="3、复制算法"></a>3、复制算法</h4><p>   复制算法简单来说就是把内存一分为二，但只使用其中一份，在垃圾回收时，将正在使用的那份内存中存活的对象复制到另一份空白的内存中，最后将正在使用的内存空间的对象清除，完成垃圾回收。<br><img src="../../assets/images/2020-02-11-gc/1090617-20180621213541943-2048983954.png" alt="img"></p>
<p>优点<br>    复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。<br>缺点<br>    复制算法的代价是将内存缩小为原来的一半，这个太要命了。</p>
<p>注意（重要）</p>
<p>​    现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一块为Eden（伊面区）和两块较小的</p>
<p>Survivor（幸存区）空间(默认比例-&gt;8:1:1)。每次使用Eden和其中的一块Survivor，垃圾回收时候将上述两块中存活的对象复制到另外一块Survivor上，同时清理上述Eden和Survivor。所以每次新生代就可以使用90%</p>
<p>的内存。只有10%的内存是浪费的。(不能保证每次新生代都少于10%的对象存活，当在垃圾回收复制时候如果一块Survivor不够时候，需要老年代来分担，大对象直接进入老年代) </p>
<p>总的来讲：复制算法不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）</p>
<h4 id="4、三种算法总结"><a href="#4、三种算法总结" class="headerlink" title="4、三种算法总结"></a>4、三种算法总结</h4><p>相同点</p>
<p>   (1)三个算法都基于根搜索算法去判断一个对象是否应该被回收，而支撑根搜索算法可以正常工作的理论依据，就是语法中变量作用域的相关内容。</p>
<p>   (2)在GC线程开启时，或者说GC过程开始时，它们都要暂停应用程序（stop the world）。</p>
<p>区别</p>
<p>三种算法比较：</p>
<p>​    效率：复制算法&gt;标记-整理算法&gt;标记-清除算法；</p>
<p>​    内存整齐度：复制算法=标记-整理算法&gt;标记-清除算法</p>
<p>​    内存利用率：标记-整理算法=标记-清除算法&gt;复制算法</p>
<h4 id="5、分代收集算法"><a href="#5、分代收集算法" class="headerlink" title="5、分代收集算法"></a>5、分代收集算法</h4><p>   首先这不是一种新算法，它是一种思想。现在使用的Java虚拟机并不是只是使用一种内存回收机制，而是分代收集的算法。就是将内存根据对象存活的周期划分为几块。一般是把堆分为新生代、和老年代。短命对</p>
<p>象存放在新生代中，长命对象放在老年代中。<br><img src="../../assets/images/2020-02-11-gc/1090617-20180621214050767-1145517463.png" alt="img"></p>
<p>  这个图是我拷贝来的，但要记住java8以后，已经没有永久区了，之前永久区存放的东西基本上放到了元空间中。</p>
<p>对于不同的代，采用不同的收集算法：</p>
<p>​    新生代：由于存活的对象相对比较少，因此可以采用复制算法该算法效率比较快。</p>
<p>​    老年代：由于存活的对象比较多哈，可以采用标记-清除算法或是标记-整理算法。</p>
<h2 id="各平台GC算法"><a href="#各平台GC算法" class="headerlink" title="各平台GC算法"></a>各平台GC算法</h2><p>关于Mono和unity ，集成的是开源项目BOEHM ，BOEHM算法采用标记清除法,il2cpp也是实现了boehm算法</p>
<h1 id="关于c-和java中的循环引用"><a href="#关于c-和java中的循环引用" class="headerlink" title="关于c#和java中的循环引用"></a>关于c#和java中的循环引用</h1><p>循环引用指的是A引用了B，而B又引用了A。在写代码的时候，都难免会这样写：地图引用了战斗单位，战斗单位又引用了地图。。</p>
<p> 如图：（来源于国外大神的解释）</p>
<p><img src="../../assets/images/2020-02-11-mem/5b1933eb47c2a.png" alt="小议C#引用类型对象在循环引用时会不会内存泄漏"></p>
<p>当A没有再被其他类引用，则A，B，C都应该被垃圾回收。如果判断该对象是否需要被回收的依据是基于引用计数的，那上面代码就会是这样：B被C和A引了，引用计数为2，C被B引了，引用计数为1，这样内存就泄露了。</p>
<p>所以C#的GC并没有用引用计数。GC有一些“根”，对象都挂在上面。从“根”往其子结点进行遍历，就可以标注出哪些对象是被使用的。A对象没有被其他引用，A作为B，C的入口，所以A,B,C都变成了被回收的对象。</p>
<p>只要是涉及到的对象不能从GC Roots<a href="https://droidyue.com/blog/2014/10/12/understanding-weakreference-in-java/" target="_blank" rel="noopener">强引用</a>可到达，垃圾回收器都会进行清理来释放内存。</p>
<p>综上，C#在做循环引用的时候是不会出现垃圾回收问题的。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>地图</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>扒一扒.net、.net framework、mono和Unity</title>
    <url>/dotnet-2020-02-12-netcore-mono-netframework/</url>
    <content><![CDATA[<p>1.什么是CLR？</p>
<p>CLR（Common Language Runtime）即公共语言运行时，是一个由多种编程语言使用的“运行时”，我的理解是就是运行环境，类似于jvm虚拟机的东西，只不过CLR并不关心你用的语言是什么，无论你用的是C#，或者C++等，当通过编译器编译后，都会转换为CLR可以识别的中间语言IL</p>
<p>2.CLR的工作方式</p>
<p>CLR是不和模块工作的，它和程序集工作，如下</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/v2-5efca0f8c5f31440e6d17c766a6cc6b6_1440w.jpg" alt="img"></p>
<p>当加载了公共语言运行时时，电脑必须安装了.NET Framework,同时CLR会检测目标平台，如32位Windows，或64位windows，然后决定创建对应的进程；</p>
<p>如图1-2，托管程序集同时包含元数据和IL，当编译器把源代码转换为中间语言IL后，为了执行方法，CLR会把方法的IL转换为本机（native）CPU指令，即JIT（just in time“即时”）编译</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/v2-e12d13ed3e967c0b7463fb2764034d87_1440w.jpg" alt="img"></p>
<p>在方法执行前，CLR会检测代码引用的所有类型，然后分配一个内部数据结构来管理引用访问，在这个数据结构中每个方法会有一个对应的记录项，每个记录项都包含地址，根据地址找到函数的实现，CLR将每个记录项都设置成（指向）一个内部的未编档函数，即JITCompiler当方法首次调用WriteLine时，JITCompiler会被调用，将方法的IL代码编译为本机的CPU指令。当方法第一次被调用时，JIT编译器会验证IL代码，当第二次时，由于第一次已经完成了验证和编译，所以第二次会直接执行。</p>
<p>1.Mono</p>
<p>mono即基于.NET Framework 的开源实现，基于C#的ECMA标准，包含C#编译器和CLR。mono使C#拥有了跨平台的能力。</p>
<p>2.为什么Mono能跨平台？</p>
<p>因为它使用了CIL（Common Intermediate Language）的通用中间语言，也叫MSIL的指令集，CIL可以在任何支持CLI（Common Language Infrastructure）“通用语言基础结构”的环境下运行，由于CIL能运行在所有支持CLI的环境中，比如.net运行时或者mono运行时，也就是说和具体的平台或者CPU无关。</p>
<p>.net从一个抽象上来说其实是一个理念，即使得多种语言编写的程序能够通过一个通用的runtime运行在不同的操作系统以及硬件平台上。但光有理念不行，还需要实现，我们这里把对于.net里面的某个实现叫做.net platform（比如.net framework就是一个在windows上实现的.net platform，mono则是一个跨平台的.net platform）。一个.net platform想要达成.net的目标，就需要一些组件，比如上图中CLR通用语言运行时，比如FCL基础类库，比如各种语言的编译器，编译器编译出来的东西想要能在CLR中运行，那也需要遵循一定的标准，这就是CLI和CIL，CIL规定了编译输出的规则，而CLI规定了编译器输入语言的规则，只有符合这种标准的语言才能编译成CIL语言运行在CLR中。</p>
<p>好了现在有了CIL和CLR，程序员可以用符合CLI的语言比如C#编写程序了，然后将其编译成CIL，最后在CLR中运行。但是问题来了，程序员开发程序的时候需要用到一些功能以及数据结构，不可能所有的功能细节都自己实现，不然开发成本也太高了，所以就需要提供一些基础类库，方便程序员进行开发，那么需要提供哪些基础类库呢？这也需要一个标准，而.Net Standard就是用于这个目的，它规定了某个.net platform需要提供哪些API给开发者。这样的话加入一个开发者在.net platform A（比如.net framework）上开发了一个项目，然后想迁移到.net platform B（比如Mono）上，那么只要两个platform实现了同一个.net standard那么源代码就无需修改可以直接编译运行。</p>
<p>不过还有一个问题，假如我有一台机器，装了.net platform A（比如.net framework）和.net platform B（比如Mono），那么我在A上编译出来的一个.net程序放到B上可以运行么？理论上应该没问题，毕竟CIL是统一的，虽然一个是A的CLR一个是B的CLR，但是它们都是用来处理CIL程序，就像java代码编译出来既可以运行在JVM上也可以运行在delvik上一样。然而实际上不一定，因为CIL本身也不是一成不变的，它也有自己的版本，看下面这个文档：</p>
<p><a href="https://msdn.microsoft.com/en-us/library/bb822049.aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/bb822049.aspx</a></p>
<p>里面的表格详细说明了.net framework和CLR版本之间的关系，从.net framework 2.0到3.5使用的是CLR 2.0，.net framework 4.0以后使用的是CLR 4.0，中间没有CLR 3.0版本。这也就意味着CIL语言本身也在发生变化，面向CLR 4.0编译出来的程序自然是不能运行在CLR 2.0上的。</p>
<p>说那到底什么是.net framework呢？个人理解从抽象角度说.net framework是对.net标准（这个标准具体包括CLI，CIL，.net standard等）在windows平台上的一套实现，具体上说.net framework包含一整套解决方案，包含许多字组件，比如编译器、CLR、FCL等等，其中每个组件都有自己的版本，比如编译器有自己的版本用于适应不同版本的语言，比如.net framework 3.5的编译器只支持到C# 3.0，最新已经到C# 7.0了；每个版本的.net framework提供的FCL也在不断丰富，比如System.LINQ到.net framework 3.5才有；CLR的版本也会不同，之前已经说过了。因此.net framework的版本其实就是其组件版本的一个集合，高版本的.net framework中的每个子组件都进行了一定的版本更新。</p>
<p>其实正常来说.net framework只是对.net标准的一套实现而已，其他的对于.net标准的实现完全可以将各种不同版本的组件组合起来用，比如我一套.net platform提供了.net framework 4.0的FCL和面向C# 6.0的编译器，但用的是CLR 2.0的运行时，这并没有什么问题，只要编译器和运行时匹配就行了（mono就是这么干的）。但是由于.net是微软提出来的而且.net framework是微软开发的，那别的.net platform实现自然就已.net framework为标杆，每个版本的.net framework都提供了一些新的features，支持.net framework x.x就是说这个.net platform实现了x.x版本.net framework的特性，比如下面是mono主页上的文档：</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144055880.png" alt="img"> <img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144129490.png" alt="img"></p>
<p>可以看到上面说的是.net 4.6 4.5，这里表示的其实是.net framework，这个图片的意思就是最新版本的mono已经实现了.net framework 4.6中支持C# 6的特性，以及此外还可以发现只有.net 3.5和2.0是mono完全实现了其所有特性。准确的说其实是mono实现了.net framework的大部分feature，并且还提供了一些mono自己的class library。Mono和.net framework大致有一个对应关系，如这篇文章所说：<a href="http://www.cnblogs.com/zhaoqingqing/archive/2016/08/12/5762867.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhaoqingqing/archive/2016/08/12/5762867.html</a></p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144146834.png" alt="img"></p>
<p>这个表似乎不完全正确，mono 2.0实现了System.LinQ组件，这个组件在.net 3.5中提供，所以mono 2.0对应的应该是.net 2.0/3.5，即两者之和。不过还是可以当做一个参考。所以说加入一个程序集是用.net framework 3.5构建的，引用了一些dll如system.core以及system.linq，那么要想把其导入mono项目中，就必须保证mono的版本高于2.0，不然会找不到相应的引用。</p>
<p>还有一点需要注意，网上很多讲.net版本的时候讲.net framework version和CLR version混为一谈，有些时候说的.net 2.0指的其实是CLR 2.0。另外有些人把System.Environment.Version误以为是.ne framework版本，其实不是，msdn上说的很明确，这个值指的是CLR的版本：</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144202709.png" alt="img"></p>
<p>另外还有一点值得注意，在vs中构建一个.net framework 3.5的项目时是，引用的System.dll是在系统的.net v2.0目录下的，也就是说.net framework不是独立的，而是依赖于.net framework 2.0.不过.net 4.0以后的版本好像就不是这样了，每次新版本都是独立的。</p>
<p>最后谈一下Unity，Unity为了跨平台使用了Mono，其使用的Mono版本可以通过代码或者命令行方式获得，unity forum上已经有牛人说明了：</p>
<p><a href="http://answers.unity3d.com/questions/259448/how-to-determine-mono-version-of-unity-.html" target="_blank" rel="noopener">http://answers.unity3d.com/questions/259448/how-to-determine-mono-version-of-unity-.html</a></p>
<p>我自己的测试结果是mono 2.0</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144215834.png" alt="img"></p>
<p>查了一下mono官网，mono 2.0是08年的老古董（Unity居然还在用，貌似是版权问题，没有深究），而用vs打开一下Unity中的脚本，查看一下项目构建文件.csproj：</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144232772.png" alt="img"></p>
<p>可以看到Unity用的是.net 3.5，所以难道Unity的脚本是用.net framework 3.5构建的？显然不是。</p>
<p>我们知道vs有一个东西叫VSTU，它最大的作用就是可以用vs的断点调试功能调试Unity Editor。Unity中的脚本在vs中打开的时候会构建一个VSTU项目。VSTU项目虽然跟普通VS项目看上去很像，但其实VSTU项目本质上并不是真正的vs项目，如果你右键项目-&gt;属性是没有反应的（VSTU 2.1以前有反应，之后就禁用了），而且右键项目中的引用也不会有添加引用选项，其实VSTU是把vs当做了一个功能强大的编辑器。</p>
<p>但VSTU不只是利用了VS进行语法检查这么简单，它的另一个作用就是断点调试。在没有断点调试的情况下，Unity使用自己的编译器进行编译，生成Assembly-CSharp.dll（在/Library/目录中），点击Play按钮的时候用的是这个dll，而用VS进行断点调试的时候则会用VS的编译器编译出Assembly-CSharp.dll以及pdb文件，在\Temp\UnityVS_obj\Debug\目录中，此时点击Play用的就是这个dll。当然build出exe的时候用的还是自己的编译器。</p>
<p>VSTU对项目进行了限制，不能直接在VS中添加新的dll，但可以拷贝到Unity项目的Asset目录下，这样Unity会重新构建VSTU项目，把拷进去的dll显示在引用列表里面。</p>
<p>VSTU构建的项目是基于.net framework 3.5的。因为Unity用的是mono 2.0啊，mono 2.0实现的feature包括.net framework 2.0和3.5，而UnityEngine.dll引用了System.Core.dll，而这个dll在.net framework 3.5才有，如果是是基于.net framework 2.0构建，那么第一有些mono 2.0支持的feature在vs里面就会找不到，另外也无法断点调试，因为编译通不过。</p>
<p>其实也可以在Unity的安装目录中寻找一些端倪，在windows下为：</p>
<p>C:\Program Files\Unity\Editor\Data\Mono\lib\mono\2.0</p>
<p>这个目录2.0目测就是mono的版本，目录中有很多dll，比如System.*.dll，这说明unity自带了mono项目，提供了mono 2.0中实现的基础类库。虽然Unity的脚本可以在像VS以及MonoDeveloper中打开，但是在build的时候用的还是Unity自带的Mono中的编译器，而Mono 2.0仅支持到C# 3.0，所以有些最新的语法在Unity里面是无法编译通过的（Unity 5.3.5 p8提供了一个新的编译器mono 4.4用于测试，但是似乎没有下文了）。</p>
<p>总结一下就是，Unity使用的是mono 2.0，支持C# 3.0，提供与.net framework 3.5/2.0 API兼容的类库（mono 2.0实现了.net framework 2.0 + 3.5的feature，但是没有实现.net framework 3.0的WPF的feature，所以官网的说法是<strong>.Net 2.0/3.5 framework profile</strong>），使用了与CLR 2.0兼容的mono runtime，因此用vs构建Unity的dll需要.net framework 3.5以下，不然runtime不兼容；如果要用到UnityEngine等Unity的功能必须用.net framework 3.5这个版本，不然vs项目找不到System.Core.dll，无法通过编译，如果只是一些工具类，不需要引用UnityEngine.dll，那么用.net framework 2.0构建是可以的。vs只是一个第三方构建工具，想要构建出Unity能用的dll就不能使用Unity（Mono 2.0）不支持的feature。</p>
<p>最后有一点之前一直在困扰我，但今天稍微有点想通了，就是Unity的Player Setting里面有个API compability Level：</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144252210.png" alt="img"></p>
<p>这个只有两个选项：.Net 2.0和.Net 2.0 Subnet，这个说实话让人很不解，从字面上讲是指API兼容，那兼容到.net 2.0难道是指兼容.net framework 2.0的FCL API？但Unity可以用到.net framework 3.5的一些库啊。网上找了一通以后发现了如下网址：</p>
<p><a href="https://docs.unity3d.com/412/Documentation/ScriptReference/MonoCompatibility.html" target="_blank" rel="noopener">https://docs.unity3d.com/412/Documentation/ScriptReference/MonoCompatibility.html</a></p>
<p>以及这个Question：</p>
<p><a href="https://forum.unity3d.com/threads/unity-supports-c-3-5-or-2-0.111440/" target="_blank" rel="noopener">https://forum.unity3d.com/threads/unity-supports-c-3-5-or-2-0.111440/</a></p>
<p>其中有一句话很关键：</p>
<p><strong>The 2.0 there is likely a good reflection of what you have at least</strong></p>
<p>所以梳理一下就是.Net 2.0和.Net 2.0 Subnet是指编写的C#代码能够引用的函数集合的不同，如果选择了subset那么dll就不会被导入到项目中来。比如同一个项目用.Net 2.0和.Net 2.0 Subnet构建出来的目录如下，可以很明显看到两者的差别。</p>
<p><img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144306179.png" alt="img">  <img src="../../assets/images/2020-02-12-netcore-mono-netframework/20170423144321069.png" alt="img"></p>
<p>当新建一个Unity项目时，只会有一些核心的dll会被导入到项目中，其他的dll需要从外部拷贝到项目的Asset文件夹下，VSTU项目中是不能直接添加引用的，个人感觉VSTU对项目的限制有点多，像是把开发者当成傻子，因为你在用Unity那么这些功能就给你禁用掉，不过目测可以通过修改.sln或者.csproj文件来实现一些特殊需要。那.net framework 3.5呢？其实Unity支持的是.net framework 2.0 + 3.5，跳过了3.0，因为3.0是WPF的，Unity不需要，.net 2.0指的是你至少可以用哪些feature。</p>
<p>Unity最近因为加入了.Net基金会，出了几个用最新mono的测试版：</p>
<p><a href="https://forum.unity3d.com/threads/upgraded-mono-net-in-editor-on-5-5-0b4.433541/" target="_blank" rel="noopener">https://forum.unity3d.com/threads/upgraded-mono-net-in-editor-on-5-5-0b4.433541/</a></p>
<p>Unity 5.5.0 b4里面API compability Level增加了一个4.6选项，其实是把原来的mono 2.0换成mono 4.6进行测试，mono 4.6支持C# 6.0，并且开发者可以使用.net 4.6的API写程序，然而也不知道什么时候能有稳定版。而且mono都快要被淘汰了，以后目测都是IL2CPP了。</p>
<ul>
<li><a href="https://www.cnblogs.com/w-wfy/p/7450167.html" target="_blank" rel="noopener">https://www.cnblogs.com/w-wfy/p/7450167.html</a></li>
<li><a href="https://blog.csdn.net/wzjssssssssss/article/details/80196314" target="_blank" rel="noopener">https://blog.csdn.net/wzjssssssssss/article/details/80196314</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>Java</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>c#编译和运行启动原理</title>
    <url>/dotnet-2020-02-13-csharp-run/</url>
    <content><![CDATA[<p>用C#编写的源代码被编译为一种符合CLI规范的中间语言（IL）。IL代码与资源（例如位图和字符串）一起作为一种称为程序集的可执行文件存储在磁盘上，通常具有的扩展名为.exe（应用程序）或.dll（库）。程序集包含清单，它提供有关程序集的类型、版本、区域性和安全要求等信息。</p>
<p>执行C#程序时，程序集将加载到CLR中，它可能会根据清单中的信息执行不同的操作。然后，如果符合安全要求，CLR就会执行实时（JIT）编译以将IL代码转换为本机机器指令。CLR还提供与自动垃圾回收、异常处理和资源管理有关的其他服务。由CLR执行的代码有时会称为“托管代码”。</p>
<p>[<img src="../../assets/images/2020-02-13-csharp-run/094920_15170513.gif" alt="什么是C#语言？作用有哪些？">]</p>
<p><img src="../../assets/images/2020-02-13-csharp-run/v2-757e0e6e8813e7441cd758121e564729_1440w.jpg" alt="img"></p>
<h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/" target="_blank" rel="noopener">CSC.exe</a>是C＃编译器，可以编译您的C＃代码并生成可执行（.exe）文件，动态链接库（.dll）或代码模块（.netmodule）。</p>
<p><a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild" target="_blank" rel="noopener">MSBuild</a>是Microsoft Build Engine，可用于从Visual Studio生成<a href="https://docs.microsoft.com/zh-cn/visualstudio/ide/solutions-and-projects-in-visual-studio" target="_blank" rel="noopener">项目和解决方案</a> 。 此外，即使我编写了一些.cs文件和一个自定义项目文件（.xxproj）来构建它们，我们也可以使用msbuild.exe并使用<code>msbuild xxx.xxproj</code>类的命令来构建它们。 请参阅<a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/walkthrough-creating-an-msbuild-project-file-from-scratch" target="_blank" rel="noopener">本文档</a> 。</p>
<p><strong>它们之间的关系：</strong></p>
<ol>
<li>如果我只有几个.cs文件，并且想要编译它们以输出.exe及其它内容，那么csc.exe就足够了。 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe" target="_blank" rel="noopener">在命令行中</a> （ <code>by cmd.exe or other things</code> ） 使用它来编译代码。</li>
<li>如果创建项目文件（.xxproj）以更好地控制资源，.cs文件和其他文件，则可以<a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/msbuild-command-line-reference" target="_blank" rel="noopener">在命令行中使用msbuild</a>来构建它们以输出.exe或其他内容。 我们应该知道的一点是，msbuild.exe不仅可以构建C＃代码，而且还可以构建<code>VB.net, C++, F#</code> …当我使用msbuild使用<code>msbuild xx.csproj</code>类的命令来构建C＃代码时，它将<code>call csc.exe to compile C# code and pass parameters read from the .csproj file to it</code> 。</li>
<li>尽管msbuild是Visual Studio中的构建系统，但它并不依赖于Visual Studio。</li>
</ol>
<p>您可能想知道msbuild传递给特定构建的csc的信息。 在这种情况下，只需使用msbuild的详细程度开关即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msbuild MyProject.csproj &#x2F;target:rebuild &#x2F;verbosity:diag</span><br></pre></td></tr></table></figure>

<p>请参阅<a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/obtaining-build-logs-with-msbuild?view=vs-2015&redirectedfrom=MSDN" target="_blank" rel="noopener">使用MSBuild获取构建日志</a> 。</p>
<h3 id="mono系列"><a href="#mono系列" class="headerlink" title="mono系列"></a>mono系列</h3><p>Mono C＃编译器被认为是C＃1.0，C＃2.0，C＃3.0，C＃4.0，C＃5.0和C＃6.0（ECMA）的完整功能，并且部分支持C＃7。<a href="https://www.mono-project.com/docs/about-mono/languages/csharp/" target="_blank" rel="noopener">https://www.mono-project.com/docs/about-mono/languages/csharp/</a></p>
<p>从历史上看，存在相同编译器的各种版本。</p>
<ul>
<li><p>gmcs：编译器以2.0 mscorlib为目标。引用2.0概要文件库（在.NET 2.0和.NET 3.5中定义的API）并公开完整的C＃3.0语言。</p>
</li>
<li><p>smcs：以2.1 mscorlib为目标的编译器，以构建Moonlight应用程序。 引用2.1概要文件库（为Silverlight定义的API）并公开完整的C＃3.0语言。这是用于创建Silverlight / Moonlight应用程序的编译器。</p>
</li>
<li><p>dmcs：编译器针对4.0 mscorlib。引用4.0概要文件库（.NET 4.0中定义的API）并支持C＃4.0。</p>
</li>
</ul>
<h2 id="编译为-MSIL"><a href="#编译为-MSIL" class="headerlink" title="编译为 MSIL"></a>编译为 MSIL</h2><p>编译为托管代码时，编译器将源代码转换为 Microsoft 中间语言 (MSIL)，这是一组独立于 CPU 且可以有效地转换为本机代码的说明。 MSIL 包括有关加载、存储、初始化和调用对象方法的说明，以及有关算术和逻辑运算、控制流、直接内存访问、异常处理和其他操作的说明。 代码可以运行之前，必须将 MSIL 转换为特定于 CPU 的代码，通常通过 <a href="https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_msil_to_native_code" target="_blank" rel="noopener">实时 (JIT) 编译器</a>实现。 由于公共语言运行时为其支持的每个计算机基础结构提供一个或多个 JIT 编译器，同一组的 MSIL 可以在任何受支持的基础结构上进行 JIT 编译和运行。</p>
<p>当编译器生成 MSIL 时，它还生成元数据。 元数据描述代码中的类型，包括每种类型的定义、每种类型的成员的签名、代码引用的成员以及运行时在执行时间使用的其他数据。 MSIL 和元数据包含在一个可移植的可执行 (PE) 文件中，该文件基于且扩展已发布的 Microsoft PE 和历来用于可执行内容的通用对象文件格式 (COFF)。 容纳 MSIL 或本机代码以及元数据的这种文件格式使操作系统能够识别公共语言运行时映像。 文件中元数据的存在以及 MSIL 使代码能够描述自身，这意味着将不需要类型库或接口定义语言 (IDL)。 运行时在执行期间会根据需要从文件中查找并提取元数据。</p>
<blockquote>
<p><strong>什么是非托管代码(unmanaged code)？</strong>　　</p>
<p>　　<strong>非托管代码，直接编译成目标计算机码，在</strong><a href="http://baike.baidu.com/view/159628.htm" target="_blank" rel="noopener"><strong>公共语言运行库</strong></a><strong>环境的外部，由操作系统直接执行的代码，代码必须自己提供垃圾回收，类型检查，安全支持等服务。如需要内存管理等服务，必须显示调用操作系统的接口，通常调用Windows SDK所提供的API来实现内存管理。</strong></p>
<p> 当项目选择名字以MFC，ATL，Win32开头的项目类型，那么这个项目所产生的就是非托管程序。</p>
<p> 非托管代码就是在Visual Studio .NET 2002发布之前所创建的代码。例如Visual Basic 6, Visual C++ 6, 最糟糕的是，连那些依然残存在你的硬盘中、拥有超过15年历史的陈旧C编译器所产生的代码都是非托管代码。托管代码直接编译成目标计算机的机械码，这些代码只能运行在编译出它们的计算机上，或者是其它相同处理器或者几乎一样处理器的计算机上。非托管代码不能享受一些运行库所提供的服务，例如安全和内存管理等。如果非托管代码需要进行内存管理等服务，就必须显式地调用操作系统的接口，通常来说，它们会调用Windows SDK所提供的API来实现。就最近的情况来看，非托管程序会通过COM接口来获取操作系统服务。</p>
<p> 跟Visual Studio平台的其他编程语言不一样，Visual C++可以创建非托管程序。当你创建一个项目，并且选择名字以M FC，ATL或者Win32开头的项目类型，那么这个项目所产生的就是非托管程序。</p>
</blockquote>
<h2 id="将-MSIL-编译为本机代码"><a href="#将-MSIL-编译为本机代码" class="headerlink" title="将 MSIL 编译为本机代码"></a>将 MSIL 编译为本机代码</h2><p>运行 Microsoft 中间语言 (MSIL) 前，必须根据CLR公共语言运行时将其编译为目标计算机基础结构的本机代码。 .NET Framework 提供两种方法来执行此转换：</p>
<ul>
<li>.NET Framework 实时 (JIT) 编译器。</li>
<li>.NET Framework <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank" rel="noopener">Ngen.exe（本机映像生成器）</a>。</li>
</ul>
<h3 id="由-JIT-编译器编译"><a href="#由-JIT-编译器编译" class="headerlink" title="由 JIT 编译器编译"></a>由 JIT 编译器编译</h3><p>在加载和执行程序集的内容时，JIT 编译在应用程序运行时按需将 MSIL 转换为本机代码。 由于公共语言运行时为每个受支持的 CPU 基础结构提供 JIT 编译器，开发人员可以构建一组 MSIL 程序集，这些程序集可以进行 JIT 编译并可在具有不同计算机基础结构的不同计算机上运行。 但是，如果你的托管代码调用特定于平台的本机 API 或特定于平台的类库，它将仅在该操作系统上运行。</p>
<p>JIT 编译将执行期间可能永远不会调用的某些代码的可能性考虑在内。 它根据需要在执行期间转换 MSIL，而不是使用时间和内存来将 PE 文件中所有 MSIL 转换为本机代码，并在内存中存储生成的本机代码，以便该进程上下文中的后续调用可以对其进行访问。 加载类型并将其初始化时，加载程序创建并将存根附加到类型中的每个方法。 第一次调用某个方法时，存根将控件传递给 JIT 编译器，后者将该方法的 MSIL 转换为本机代码，并将存根修改为直接指向生成的本机代码。 因此，对 JIT 编译的方法的后续调用会直接转到本机代码。</p>
<h3 id="使用-NGen-exe-的安装时代码生成"><a href="#使用-NGen-exe-的安装时代码生成" class="headerlink" title="使用 NGen.exe 的安装时代码生成"></a>使用 NGen.exe 的安装时代码生成</h3><p>由于在调用该程序集中定义的各个方法时，JIT 编译器将程序集的 MSIL 转换为本机代码，因此它在运行时中对性能产生负面影响。 在大多数情况下，这种性能降低的程度是可以接受的。 更为重要的是，由 JIT 编译器生成的代码会绑定到触发编译的进程上。 它无法在多个进程之间进行共享。 若要允许生成的代码跨应用程序的多个调用或跨共享一组程序集的多个进程进行共享，则公共语言运行时支持预编译模式。 这种预编译模式使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/framework/tools/ngen-exe-native-image-generator" target="_blank" rel="noopener">Ngen.exe（本机映像生成器）</a>将 MSIL 程序集转换为本机代码，非常类似 JIT 编译器执行的操作。 但是，Ngen.exe 的操作在三个方面不同于 JIT 编译器的操作：</p>
<ul>
<li>它在运行应用程序之前而非运行该应用程序时，将 MSIL 转换为本机代码。</li>
<li>它一次编译整个程序集，而不是一次编译一种方法。</li>
<li>它将本机映像缓存中生成的代码作为磁盘上的文件保存。</li>
</ul>
<blockquote>
<p>基本上每个人都知道的是，所有.Net语言都将被编译成为一个叫做IL汇编的中间语言。但是计算机是如何执行这个中间代码的，却是很多人不知道，甚至理解错误了的。JIT是.NET程序运行的重要部件之一，全称是即时编译器。很多人都以为JIT其实就是跟Java VM差不多的东西，是一个Interpreter，在运行时读取IL汇编代码，然后模拟成x86代码（也就是俗称的虚拟机）。但是事实上，.NET使用的是更为高级的技术。 .Net程序被加载入内存以后，当某段IL代码被第一次运行的时候，JIT编译器就会将这段IL代码，全部编译成本地代码，然后再执行。这也就是为什么.NET程序第一次运行都启动很慢的原因！ 随.NET库，微软还附带了一个工具，可以事先将.NET程序所有的IL代码都编译成本地代码并保存在缓存区中，这样一来，这个程序就跟c++编译的一模一样了，没有任何区别，运行时也可以脱离JIT了（这里不要混淆了，这里不是说可以脱离.NET库，而是说不需要在进行即时编译这个过程了）。所以，请不要将.NET和Java混为一谈，两个的运行效率根本不是一个等级的！</p>
<p> JIT的优化指的是可以针对本地CPU，在编译时进行优化。传统程序在编译时，为了保证兼容性，通常使用最通用的指令集（比如古老的386指令集）来编译。而JIT知道CPU的具体类型，可以充分利用这些附加指令集进行编译，这样的性能提升是很可观的。</p>
</blockquote>
<h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>PE（Portable Execute）文件是Windows下可执行文件的总称，常见的有DLL，EXE，OCX，SYS等，事实上，一个文件是否是PE文件与其扩展名无关，PE文件可以是任何扩展名。那Windows是怎么区分可执行文件和非可执行文件的呢？我们调用LoadLibrary传递了一个文件名，系统是如何判断这个文件是一个合法的动态库呢？这就涉及到PE文件结构了</p>
<p>C#生成的exe既然是window下可执行文件，那也就是标准的PE文件，和普通win32的exe文件格式一样。我们来看下exe文件的格式：</p>
<blockquote>
<p>dll文件本质上和exe一样，只是少了入口函数。</p>
</blockquote>
<p><img src="../../assets/images/2020-02-13-csharp-run/884430-20160313213206835-2135598609.png" alt="img"></p>
<p>MS-DOC MZ Header和MS-DOS Stub是为了兼容DOS系统存在的，目的是使这个exe在DOS下执行时弹出一个提示”This program cannot be run in DOS mode”。</p>
<p>PE Header包含了这个文件的一些信息，如：文件创建日期，文件类型，Section的数量，Optional Header的大小等等。详细可以参考Winnt.h里的结构_IMAGE_FILE_HEADER。</p>
<p>PE Optional Header则包含了文件的版本号以及重要的基地址和AddressOfEntryPoint（RVA-Relative Virtual Address)，这是程序执行的入口地址，双击exe后就从这里开始执行。对C#程序来说，这里指向的是.net的核心库MsCorEE.dll的_CorExeMain()函数。当然这是针对XP系统的，XP以后的系统，OS Loader已经可以判断出这个PE是否包含CLR头来决定是否运行MsCorEE.dll的_CorExeMain()函数。</p>
<p>Section有很多，包括代码节，数据节等，C#程序会把CLR头，元数据，IL放在这里面。</p>
<blockquote>
<p>CLR是什么呢，全称Common Language Runtime，公共语言运行时，CLR主要是管理程序集，托管堆内存，异常处理和线程同步等等。</p>
</blockquote>
<p>CLR头具体可以参考CorHdr.h中的IMAGE_COR20_HEADER结构，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct IMAGE_COR20_HEADER</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; CLR版本信息</span><br><span class="line">        ULONG cb;</span><br><span class="line">        USHORT MajorRuntimeVersion;</span><br><span class="line">        USHORT MinorRuntimeVersion;</span><br><span class="line"></span><br><span class="line">        IMAGE_DATA_DIRECTORY MetaData; &#x2F;&#x2F;元数据</span><br><span class="line">        ULONG Flags;</span><br><span class="line">        ULONG EntryPointToken;  &#x2F;&#x2F;入口函数Main的标识</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        IMAGE_DATA_DIRECTORY Resources;  &#x2F;&#x2F;资源</span><br><span class="line">        IMAGE_DATA_DIRECTORY StrongNameSignature;  &#x2F;&#x2F;强名称标识</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Regular fixup and binding information</span><br><span class="line">        IMAGE_DATA_DIRECTORY CodeManagerTable;</span><br><span class="line">        IMAGE_DATA_DIRECTORY VTableFixups;</span><br><span class="line">        IMAGE_DATA_DIRECTORY ExportAddressTableJumps;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Precompiled image info (internal use only - set to zero)</span><br><span class="line">        IMAGE_DATA_DIRECTORY ManagedNativeHeader;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    IMAGE_COR20_HEADER;</span><br></pre></td></tr></table></figure>

<p>元数据很重要，验证代码类型安全，GC的对象引用跟踪还有我们常用的反射都需要用到元数据。</p>
<p>元数据主要由定义表，引用表，清单表组成。</p>
<p>定义表包括应用所有的类型，方法，字段，属性，参数，事件的定义,代码里任何的定义项都可以在这个表里找到，反射就是靠这个表只要一个名字就能得到属性或函数。运行时的类型安全检查也离不开它。</p>
<p>引用表包括程序集，类型和成员的引用，我们知道GC在回收内存时先默认认为所有对象都是垃圾，然后通过线程栈上的根（cpu寄存器，局部变量，参数，静态变量）找引用的对象，能找到的说明还在使用就去掉垃圾标记，这个表可以让GC在回收内存时方便从根找到所有引用。</p>
<p>清单表主要是程序集，文件，资源的定义。</p>
<p>现在来看看双击后是怎样运行的：</p>
<p><img src="../../assets/images/2020-02-13-csharp-run/884430-20160313222148397-1732805152.png" alt="img"></p>
<p>双击文件后OS Loader加载PE文件并解析，在PE Optional Header里找到基地址和RVA，通过这两个确定了程序的入口地址，这个地址指向MsCorEE.dll的_CorExeMain()，执行它。_CorExeMain()开始执行，选择加载合适版本的CLR，CLR开始运行，CLR运行时会分配一个连续的地址空间用作托管堆，并用一个指针NextObjPtr指到开始位置，下次分配内存时就从指针指的位置开始。</p>
<p>CLR运行后从CLR头里找到应用程序入口标识，也就是Main()方法的MethodDefToken，通过这个标识在元数据表MethodDef里找到Main方法的偏移位置，这样就可以找到Main()的IL代码。</p>
<p>CLR检查Main方法里面是否有没加载的类型，没有的话就加载进来并在托管堆上建一个类型对象，类型对象包含静态字段，方法，基类的引用。然后给类型的方法表里每个方法一个存根，存根是用于标识是否被JIT编译过。</p>
<blockquote>
<p>JIT: just-in-time Compiler，即时编译器。</p>
</blockquote>
<p>JIT编译之前CLR会对Main方法的代码进行验证，确保类型安全且元数据正确，一切没问题后先检查类型方法表里这个方法的存根，不为空的话表示已经编译过就不需要再次编译，没有的话JIT把这段IL代码编译成本地代码保存到内存中并方法表的存根做上标记，然后JIT返回编译前的位置并把原来CLR指向JIT的地址修改为指向本地代码的地址，这样函数的本地代码开始执行。程序执行到哪里就编译到哪里，没有执行到的就不会加载和编译，同样的代码再次执行的话就直接在内存里拿了，这也是为什么第一次运行C#时比较慢而后面就快的原因。这样就开始陆续执行所有的代码，程序也就跑起来了。</p>
<p>在内存上，运行线程会把函数的参数和局部变量压入线程栈上，栈上的空间默认是1M，方法的参数和局部变量都会压到函数的栈帧上，方法里的对象在托管堆NextObjPtr指向的位置分配内存并把内存地址存到栈上的局部变量里。CLR会给托管堆上的每个对象包括对象类型都添加两个字段，一个对象类型指针，一个同步块索引。</p>
<blockquote>
<p>说起栈帧，大家在调试代码时应该都喜欢用CallStack吧，这可以通过看调用栈很方便来定位出问题的具体原因，这个CallStack也就是方法的栈帧的具体显示，一级一级的。</p>
</blockquote>
<p>对象类型指针从字面上就很容易知道跟类型有关。CLR刚开始运行时就分配了一个Type的对象类型，他的对象类型指针指向自己，后面创建的对象类型的对象类型指针指针就指向这个Type，而new出来的对象的对象类型指针就指向它的类型，这样所有对象都能找到自己的类型使CLR在运行时能确保类型安全。</p>
<p>同步块索引的格式是前6个标志位加后面26位内容（32位系统），作用则有好几个。</p>
<p>\1. 调用对象的gethashcode()后标志位改变一位，后26位会存储对象的hashcode，保证对象生命周期内hashcode的唯一；</p>
<p>\2. lock时用到，CLR会维护一个同步块数组，每项由一个指向同步块的指针和对象指针组成，lock时同样改变标识位，然后去同步块数组找一个闲置项，后26则变成这项在数组中的索引，有人要问了，刚才hashcode不是用了这26位吗，现在变了，hashcode岂不是丢了。确实，hashcode在lock之后不能直接存到索引了，不过同步块中专门准备了一个字段用来存hashcode，所以可以转移到同步块中，这样设计是为了节省内存，因为大部分情况下是不用lock的，也就不需要增加多余的同步块。</p>
<p>另外为什么是索引而不是地址呢，因为同步块数组的大小不是固定的，随着对象的增多而变大，在内存上的位置可能会发生变化，所以用索引就不用管数组在哪个位置了。</p>
<p>当线程进入lock后检查同步块的m_motion，发现没有标识则进入lock区域并把标识改变，如果已经有同一个线程进去则把计数器加1，如果已经有其他线程则等待。</p>
<p>\3. 垃圾回收时的标识，GC触发时首先认为所有的对象都是垃圾，由局部变量，寄存器，静态变量这些根向上找，凡是包含的对象都认为还有引用，在同步块索引上修改一位标识，当所有对象都遍历过后没有标识的对象就会被清掉，然后再是整理内存、修改引用地址等。</p>
<p>看个简单的例子，只用于演示，不考虑合理性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace Test</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int height &#x3D; 170;</span><br><span class="line">            int weight &#x3D; 60;</span><br><span class="line">            People.Find();</span><br><span class="line">            People developer &#x3D; new Developer()(height, weight);</span><br><span class="line">            bool isHealthyWeight &#x3D; developer.IsHealthyWeight();</span><br><span class="line">            bool isRich &#x3D; developer.IsRich();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class People</span><br><span class="line">    &#123;</span><br><span class="line">        int _height;</span><br><span class="line">        int _weight;</span><br><span class="line"></span><br><span class="line">        public People(int height, int weight)</span><br><span class="line">        &#123;</span><br><span class="line">            _height &#x3D; height;</span><br><span class="line">            _weight &#x3D; weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public virtual bool IsRich();</span><br><span class="line"></span><br><span class="line">        public bool IsHealthyWeight()</span><br><span class="line">        &#123;</span><br><span class="line">            var healthyWeight &#x3D; (Height - 80) * 0.7;</span><br><span class="line">            return Weight &lt;&#x3D; healthyWeight * 1.1 &amp;&amp; Weight &gt;&#x3D; healthyWeight * 0.9;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static string Find(string id) &#123; return &quot;&quot;; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Developer : People</span><br><span class="line">    &#123;</span><br><span class="line">        public Developer(int height, int weight) : base(height, weight)</span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">        public override bool IsRich()</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="../../assets/images/2020-02-13-csharp-run/884430-20160313222410850-1585024295.png" alt="img"></p>
<p><em>*图片不清楚可以放大看</em></p>
<p>首先判断类型是否都加载，用到了int，bool，string，这些是在mscorlib.dll程序集的system命名空间下，所以先加载mscorlib.dll程序集，再把int，bool，string加到类型对象里。另外还有我们自己定义的Developer和People，也把类型对象创建好，另外也别忘了基类object，也要加载进来。（实际上还有double啊，这里就没画了）另外继承类的类型对象里面都有个字段指向基类，所以才能往上执行到基类方法表里的方法。</p>
<p>局部变量都在线程栈上，Find()方法是静态方法，直接去People类型对象的方法表里去找，找到后看是否有存根标识，没有的话做JIT编译，有的话直接运行。</p>
<p>developer的实例化虽然是用People定义的，但实例还是Developer，所以developer的类型对象指针指向Developer，对象里除了类型对象指针还有实例字段，包括基类的。内存分配在托管堆上，并把地址给到线程栈上的变量中。</p>
<p>虚函数也一样，在运行时已经确定是Developer，所以会调用Developer方法表里的IsRich方法，一样先JIT，再运行。</p>
<p>以上就是一个简单的C#程序的运行过程和在内存上的表现，本篇主要内容来自CLR via C#这本书</p>
<ul>
<li><a href="https://www.cnblogs.com/brookshi/p/5273281.html" target="_blank" rel="noopener">https://www.cnblogs.com/brookshi/p/5273281.html</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_to_msil" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/managed-execution-process?redirectedfrom=MSDN#compiling_to_msil</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/clr" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/standard/clr</a></li>
<li><a href="https://www.cnblogs.com/qtiger/p/11176575.html" target="_blank" rel="noopener">https://www.cnblogs.com/qtiger/p/11176575.html</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>同步</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>abp新建项目指南</title>
    <url>/dotnet-2020-05-29-abp-start/</url>
    <content><![CDATA[<h1 id="替换数据库为mysql"><a href="#替换数据库为mysql" class="headerlink" title="替换数据库为mysql"></a>替换数据库为mysql</h1><ol>
<li>替换mysql,Dothass.Blog.EntityFrameworkCore项目中   </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;PackageReference Include&#x3D;&quot;Volo.Abp.EntityFrameworkCore.MySQL&quot; Version&#x3D;&quot;2.8.0&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>删除之前的迁移目录</p>
</li>
<li><p>修改连接字符串 项目<code>Dothass.Blog.DbMigrator</code>和<code>Dothass.Blog.Web</code>..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;详情请见https:&#x2F;&#x2F;www.connectionstrings.com&#x2F;mysql&#x2F;</span><br><span class="line">&quot;ConnectionStrings&quot;: &#123;</span><br><span class="line">   &quot;Default&quot;: server&#x3D;localhost;port&#x3D;3306;database&#x3D;dothass.blog;uid&#x3D;root;password&#x3D;123456&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成新的迁移,nuget包管理器.默认项目设置为<code>Dothass.Blog.EntityFrameworkCore.DbMigrations</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add-Migration Init</span><br></pre></td></tr></table></figure>

<p>相关链接: <a href="https://docs.abp.io/zh-Hans/abp/latest/Entity-Framework-Core-MySQL" target="_blank" rel="noopener">https://docs.abp.io/zh-Hans/abp/latest/Entity-Framework-Core-MySQL</a></p>
<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><ol>
<li>将三个项目copy到程序中.然后在web项目中添加依赖<code>typeof(AbpExtensionWebModule)</code>即可</li>
<li>修改migrationservice,<code>DotHass.Blog.Domain</code>项目下<code>BlogDbMigrationService</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private async Task SeedDataAsync(Tenant tenant &#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    	Logger.LogInformation($&quot;Executing &#123;(tenant &#x3D;&#x3D; null ? &quot;host&quot; : tenant.Name + &quot; tenant&quot;)&#125; database seed...&quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;IdentityDataSeedContributor : IDataSeedContributor ---&gt; IIdentityDataSeeder</span><br><span class="line">      &#x2F;&#x2F;手动实例化上下文,来设置admin的email和密码..或者替换IIdentityDataSeeder的service</span><br><span class="line">      var seedContext &#x3D; new DataSeedContext(tenant?.Id);</span><br><span class="line">      var configurationSection &#x3D; _configuration.GetSection(&quot;Identity&quot;);</span><br><span class="line">      seedContext.WithProperty(&quot;AdminEmail&quot;, configurationSection[&quot;AdminEmail&quot;]);</span><br><span class="line">      seedContext.WithProperty(&quot;AdminPassword&quot;, configurationSection[&quot;AdminPassword&quot;]);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;PermissionDataSeedContributor : IDataSeedContributor  ---&gt;IPermissionDataSeeder</span><br><span class="line">      &#x2F;&#x2F;为amidn添加权限 -- 一般来说不用改什么,但是需要在BlogDbMigratorModule中引用你设置权限的模块依赖..否则找不到你添加的权限</span><br><span class="line"></span><br><span class="line">      await _dataSeeder.SeedAsync(seedContext);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>执行项目Dothass.Blog.DbMigrator初始化数据</li>
</ol>
<h1 id="关于客户端js"><a href="#关于客户端js" class="headerlink" title="关于客户端js"></a>关于客户端js</h1><p>执行 yarn &amp; gulp 将所有包都会将自己的资源复制到wwwroot/libs文件夹中. 否则一些模块例如博客的js时不会起作用的</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>sync</tag>
        <tag>JS</tag>
        <tag>abp</tag>
      </tags>
  </entry>
  <entry>
    <title>dotnet-2020-06-11-IdentityServer-use</title>
    <url>/dotnet-2020-06-11-IdentityServer-use/</url>
    <content><![CDATA[<p>DotHass.Lobby.Domain\IdentityServer\IdentityServerDataSeedContributor.cs 中 CreateClientsAsync()</p>
<p>会在dataseed的时候生成默认数据</p>
<p>When I try to send a HTTPS POST request from a desktop (Servers are in production environment) the following message is displayed inside the console :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error: unable to verify the first certificate</span><br></pre></td></tr></table></figure>

<p>After: <code>Postman -&gt; Preferences -&gt; General -&gt; SSL certificate validation -&gt; OFF</code> <strong>it works</strong></p>
<p><a href="https://localhost:5000/.well-known/openid-configuration" target="_blank" rel="noopener">https://localhost:5000/.well-known/openid-configuration</a></p>
<ol>
<li><p><a href="http://localhost:5000/connect/token" target="_blank" rel="noopener">http://localhost:5000/connect/token</a></p>
<p><img src="../../assets/images/2020-06-11-IdentityServer-use/image-20200613165200371.png" alt="image-20200613165200371"></p>
</li>
<li><p><a href="http://localhost:5000/connect/userinfo" target="_blank" rel="noopener">http://localhost:5000/connect/userinfo</a> 将type设置成bearer token,token填入上面获得的access_token</p>
</li>
</ol>
<p><img src="../../assets/images/2020-06-11-IdentityServer-use/image-20200613165246959.png" alt="image-20200613165246959"></p>
<p>3.注意发布release后.配置表中的  ..如果配置错误将会认证失败</p>
<p>appsettings.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;App&quot;: &#123;</span><br><span class="line">    &quot;SelfUrl&quot;: &quot;http:&#x2F;&#x2F;localhost:5000&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;ConnectionStrings&quot;: &#123;</span><br><span class="line">    &quot;Default&quot;: &quot;Server&#x3D;localhost;User Id&#x3D;root;Password&#x3D;123456;Database&#x3D;dothass.blog&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;AuthServer&quot;: &#123;</span><br><span class="line">    &quot;Authority&quot;: &quot;http:&#x2F;&#x2F;localhost:5000&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;IdentityServer&quot;: &#123;</span><br><span class="line">    &quot;Clients&quot;: &#123;</span><br><span class="line">      &quot;Blog_App&quot;: &#123;</span><br><span class="line">        &quot;ClientId&quot;: &quot;Blog_App&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>appsettings.Development.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;App&quot;: &#123;</span><br><span class="line">    &quot;SelfUrl&quot;: &quot;https:&#x2F;&#x2F;localhost:44377&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;AuthServer&quot;: &#123;</span><br><span class="line">    &quot;Authority&quot;: &quot;https:&#x2F;&#x2F;localhost:44377&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还要注意请求的域名是否一样,127.0.0.1或者localhost…可能返回结果即使一样.但是不能授权.</p>
<p>使用<a href="http://jwt.calebb.net/解析看下access_token" target="_blank" rel="noopener">http://jwt.calebb.net/解析看下access_token</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> alg: &quot;RS256&quot;,</span><br><span class="line"> kid: &quot;1oauLjO2TtmvAH-4A7CCLg&quot;,</span><br><span class="line"> typ: &quot;at+jwt&quot;</span><br><span class="line">&#125;.</span><br><span class="line">&#123;</span><br><span class="line"> nbf: 1592054993,</span><br><span class="line"> exp: 1623590993,</span><br><span class="line"> iss: &quot;http:&#x2F;&#x2F;127.0.0.1:5000&quot;,</span><br><span class="line"> aud: &quot;Blog&quot;,</span><br><span class="line"> client_id: &quot;Blog_App&quot;,</span><br><span class="line"> sub: &quot;fa9626f7-0f6f-6158-2afd-39f5a7f6d03f&quot;,</span><br><span class="line"> auth_time: 1592054993,</span><br><span class="line"> idp: &quot;local&quot;,</span><br><span class="line"> role: &quot;admin&quot;,</span><br><span class="line"> name: &quot;admin&quot;,</span><br><span class="line"> email: &quot;admin@abp.io&quot;,</span><br><span class="line"> email_verified: false,</span><br><span class="line"> scope: [</span><br><span class="line">  &quot;address&quot;,</span><br><span class="line">  &quot;email&quot;,</span><br><span class="line">  &quot;openid&quot;,</span><br><span class="line">  &quot;phone&quot;,</span><br><span class="line">  &quot;profile&quot;,</span><br><span class="line">  &quot;role&quot;,</span><br><span class="line">  &quot;Blog&quot;,</span><br><span class="line">  &quot;offline_access&quot;</span><br><span class="line"> ],</span><br><span class="line"> amr: [</span><br><span class="line">  &quot;pwd&quot;</span><br><span class="line"> ]</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#123;</span><br><span class="line"> alg: &quot;RS256&quot;,</span><br><span class="line"> kid: &quot;1oauLjO2TtmvAH-4A7CCLg&quot;,</span><br><span class="line"> typ: &quot;at+jwt&quot;</span><br><span class="line">&#125;.</span><br><span class="line">&#123;</span><br><span class="line"> nbf: 1592055396,</span><br><span class="line"> exp: 1623591396,</span><br><span class="line"> iss: &quot;http:&#x2F;&#x2F;localhost:5000&quot;,</span><br><span class="line"> aud: &quot;Blog&quot;,</span><br><span class="line"> client_id: &quot;Blog_App&quot;,</span><br><span class="line"> sub: &quot;fa9626f7-0f6f-6158-2afd-39f5a7f6d03f&quot;,</span><br><span class="line"> auth_time: 1592055396,</span><br><span class="line"> idp: &quot;local&quot;,</span><br><span class="line"> role: &quot;admin&quot;,</span><br><span class="line"> name: &quot;admin&quot;,</span><br><span class="line"> email: &quot;admin@abp.io&quot;,</span><br><span class="line"> email_verified: false,</span><br><span class="line"> scope: [</span><br><span class="line">  &quot;address&quot;,</span><br><span class="line">  &quot;email&quot;,</span><br><span class="line">  &quot;openid&quot;,</span><br><span class="line">  &quot;phone&quot;,</span><br><span class="line">  &quot;profile&quot;,</span><br><span class="line">  &quot;role&quot;,</span><br><span class="line">  &quot;Blog&quot;,</span><br><span class="line">  &quot;offline_access&quot;</span><br><span class="line"> ],</span><br><span class="line"> amr: [</span><br><span class="line">  &quot;pwd&quot;</span><br><span class="line"> ]</span><br><span class="line">&#125;.</span><br></pre></td></tr></table></figure>



<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.InvalidOperationException: IDX20803: Unable to obtain configuration from: &#39;[PII is hidden. For more details, see https:&#x2F;&#x2F;aka.ms&#x2F;IdentityModel&#x2F;PII.]&#39;.</span><br><span class="line"> ---&gt; System.IO.IOException: IDX20804: Unable to retrieve document from: &#39;[PII is hidden. For more details, see https:&#x2F;&#x2F;aka.ms&#x2F;IdentityModel&#x2F;PII.]&#39;.</span><br><span class="line"> ---&gt; System.Net.Http.HttpRequestException: The SSL connection could not be established, see inner exception.</span><br><span class="line"> ---&gt; System.Security.Authentication.AuthenticationException: The remote certificate is invalid according to the validation procedure.</span><br><span class="line">   at System.Net.Security.SslStream.StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception)</span><br><span class="line">   at System.Net.Security.SslStream.CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.StartSendBlob(Byte[] incoming, Int32 count, AsyncProtocolRequest asyncRequest)</span><br><span class="line">   at System.Net.Security.SslStream.ProcessReceivedBlob(Byte[] buffer, Int32 count, AsyncProtocolRequest asyncRequest)</span><br></pre></td></tr></table></figure>

<p>可以看出来这些问题是和SSL证书有关，经过排查，发现IdentityServer4配置中：使用了<strong>IP:PORT</strong>的形式配置的授权地址，但是SSL证书是以域名形式申请的，这就造成了SSL证书不能验证通过。</p>
<p>解决方法：<strong>将授权地址配置为域名:端口的形式</strong>，完美解决上述问题。注意域名为SSL证书申请时用到的域名。</p>
<p>localhost使用的是开发证书,也是类似域名,127.0.0.1也是有问题的</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>sync</tag>
        <tag>JS</tag>
        <tag>abp</tag>
      </tags>
  </entry>
  <entry>
    <title>关于abp的用户的一些问题</title>
    <url>/dotnet-2020-07-05-abp-database-user/</url>
    <content><![CDATA[<h1 id="数据迁移上下文"><a href="#数据迁移上下文" class="headerlink" title="数据迁移上下文"></a>数据迁移上下文</h1><p>abp的dbcontext是分成两种的,一个是程序运行的dbcontext,一个是数据迁移的dbcontext</p>
<p><code>PlayGroundMigrationsDbContext.cs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override void OnModelCreating(ModelBuilder builder)</span><br><span class="line">&#123;</span><br><span class="line">    base.OnModelCreating(builder);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Include modules to your migration db context *&#x2F;</span><br><span class="line"></span><br><span class="line">    builder.ConfigurePermissionManagement();</span><br><span class="line">    builder.ConfigureSettingManagement();</span><br><span class="line">    builder.ConfigureBackgroundJobs();</span><br><span class="line">    builder.ConfigureAuditLogging();</span><br><span class="line">    builder.ConfigureIdentity();</span><br><span class="line">    builder.ConfigureIdentityServer();</span><br><span class="line">    builder.ConfigureFeatureManagement();</span><br><span class="line">    builder.ConfigureTenantManagement();</span><br><span class="line"></span><br><span class="line">    &#x2F;* Configure your own tables&#x2F;entities inside the ConfigurePlayGround method *&#x2F;</span><br><span class="line"></span><br><span class="line">    builder.ConfigurePlayGround();</span><br><span class="line">    builder.ConfigureBlogging();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PlayGroundDbContext.cs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override void OnModelCreating(ModelBuilder builder)</span><br><span class="line">&#123;</span><br><span class="line">    base.OnModelCreating(builder);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Configure the shared tables (with included modules) here *&#x2F;</span><br><span class="line"></span><br><span class="line">    builder.Entity&lt;AppUser&gt;(b &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        b.ToTable(AbpIdentityDbProperties.DbTablePrefix + &quot;Users&quot;); &#x2F;&#x2F;Sharing the same table &quot;AbpUsers&quot; with the IdentityUser</span><br><span class="line"></span><br><span class="line">        b.ConfigureByConvention();</span><br><span class="line">        b.ConfigureAbpUser();</span><br><span class="line"></span><br><span class="line">        &#x2F;* Configure mappings for your additional properties</span><br><span class="line">         * Also see the PlayGroundEfCoreEntityExtensionMappings class</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    &#x2F;* Configure your own tables&#x2F;entities inside the ConfigurePlayGround method *&#x2F;</span><br><span class="line"></span><br><span class="line">    builder.ConfigurePlayGround();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到他们共同执行了 builder.ConfigurePlayGround();</p>
<h2 id="为什么这样设计"><a href="#为什么这样设计" class="headerlink" title="为什么这样设计?"></a>为什么这样设计?</h2><ul>
<li>为了模块间不产生依赖,例如用户表,迁移dbcontext中使用了IdentityUser,而运行的dbcontext使用了appuser进行了对其的映射,<a href="https://github.com/abpframework/abp/issues/1998" target="_blank" rel="noopener">https://github.com/abpframework/abp/issues/1998</a></li>
<li>如何为user添加属性.<a href="https://github.com/abpframework/abp/issues/2453" target="_blank" rel="noopener">https://github.com/abpframework/abp/issues/2453</a></li>
</ul>
<h1 id="如何共用user"><a href="#如何共用user" class="headerlink" title="如何共用user"></a>如何共用user</h1><p>我们来看下定义的Iuser接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IUser : IAggregateRoot&lt;Guid&gt;, IMultiTenant</span><br><span class="line">&#123;</span><br><span class="line">    string UserName &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    [CanBeNull]</span><br><span class="line">    string Email &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    [CanBeNull]</span><br><span class="line">    string Name  &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    [CanBeNull]</span><br><span class="line">    string Surname &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    bool EmailConfirmed &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    [CanBeNull]</span><br><span class="line">    string PhoneNumber &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    bool PhoneNumberConfirmed &#123; get; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dbcontext中的配置字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void ConfigureAbpUser&lt;TUser&gt;(this EntityTypeBuilder&lt;TUser&gt; b)</span><br><span class="line">    where TUser : class, IUser</span><br><span class="line">&#123;</span><br><span class="line">    b.Property(u &#x3D;&gt; u.TenantId).HasColumnName(nameof(IUser.TenantId));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.UserName).IsRequired().HasMaxLength(AbpUserConsts.MaxUserNameLength).HasColumnName(nameof(IUser.UserName));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.Email).IsRequired().HasMaxLength(AbpUserConsts.MaxEmailLength).HasColumnName(nameof(IUser.Email));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.Name).HasMaxLength(AbpUserConsts.MaxNameLength).HasColumnName(nameof(IUser.Name));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.Surname).HasMaxLength(AbpUserConsts.MaxSurnameLength).HasColumnName(nameof(IUser.Surname));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.EmailConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.EmailConfirmed));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.PhoneNumber).HasMaxLength(AbpUserConsts.MaxPhoneNumberLength).HasColumnName(nameof(IUser.PhoneNumber));</span><br><span class="line">    b.Property(u &#x3D;&gt; u.PhoneNumberConfirmed).HasDefaultValue(false).HasColumnName(nameof(IUser.PhoneNumberConfirmed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dbcontext中的user表是如何创建,更新和使用的..<code>UserLookupService.cs</code></p>
<p>先看下查找,其中<code>IdentityUserRepositoryExternalUserLookupServiceProvider : IExternalUserLookupServiceProvider,</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public async Task&lt;TUser&gt; FindByIdAsync(Guid id, CancellationToken cancellationToken &#x3D; default)</span><br><span class="line">       &#123;</span><br><span class="line">           var localUser &#x3D; await _userRepository.FindAsync(id, cancellationToken: cancellationToken);</span><br><span class="line"></span><br><span class="line">           if (ExternalUserLookupServiceProvider &#x3D;&#x3D; null)</span><br><span class="line">           &#123;</span><br><span class="line">               return localUser;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (SkipExternalLookupIfLocalUserExists &amp;&amp; localUser !&#x3D; null)</span><br><span class="line">           &#123;</span><br><span class="line">               return localUser;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           IUserData externalUser;</span><br><span class="line"></span><br><span class="line">           try</span><br><span class="line">           &#123;</span><br><span class="line">               externalUser &#x3D; await ExternalUserLookupServiceProvider.FindByIdAsync(id, cancellationToken);</span><br><span class="line">               if (externalUser &#x3D;&#x3D; null)</span><br><span class="line">               &#123;</span><br><span class="line">                   if (localUser !&#x3D; null)</span><br><span class="line">                   &#123;</span><br><span class="line">                       &#x2F;&#x2F;TODO: Instead of deleting, should be make it inactive or something like that?</span><br><span class="line">                       await WithNewUowAsync(() &#x3D;&gt; _userRepository.DeleteAsync(localUser, cancellationToken: cancellationToken));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           catch (Exception ex)</span><br><span class="line">           &#123;</span><br><span class="line">               Logger.LogException(ex);</span><br><span class="line">               return localUser;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (localUser &#x3D;&#x3D; null)</span><br><span class="line">           &#123;</span><br><span class="line">               await WithNewUowAsync(() &#x3D;&gt; _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));</span><br><span class="line">               return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (localUser is IUpdateUserData &amp;&amp; ((IUpdateUserData)localUser).Update(externalUser))</span><br><span class="line">           &#123;</span><br><span class="line">               await WithNewUowAsync(() &#x3D;&gt; _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">               return localUser;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码可见,如果找不到该用户..会自动创建一个,如何继承了IUpdateUserData则会更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (localUser &#x3D;&#x3D; null)</span><br><span class="line">&#123;</span><br><span class="line">    await WithNewUowAsync(() &#x3D;&gt; _userRepository.InsertAsync(CreateUser(externalUser), cancellationToken: cancellationToken));</span><br><span class="line">    return await _userRepository.FindAsync(id, cancellationToken: cancellationToken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (localUser is IUpdateUserData &amp;&amp; ((IUpdateUserData)localUser).Update(externalUser))</span><br><span class="line">&#123;</span><br><span class="line">    await WithNewUowAsync(() &#x3D;&gt; _userRepository.UpdateAsync(localUser, cancellationToken: cancellationToken));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    return localUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新还可以通过eventbus</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BlogUserSynchronizer :</span><br><span class="line">    IDistributedEventHandler&lt;EntityUpdatedEto&lt;UserEto&gt;&gt;,</span><br><span class="line">    ITransientDependency</span><br><span class="line">&#123;</span><br><span class="line">    protected IBlogUserRepository UserRepository &#123; get; &#125;</span><br><span class="line">    protected IBlogUserLookupService UserLookupService &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">    public BlogUserSynchronizer(</span><br><span class="line">        IBlogUserRepository userRepository, </span><br><span class="line">        IBlogUserLookupService userLookupService)</span><br><span class="line">    &#123;</span><br><span class="line">        UserRepository &#x3D; userRepository;</span><br><span class="line">        UserLookupService &#x3D; userLookupService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async Task HandleEventAsync(EntityUpdatedEto&lt;UserEto&gt; eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        var user &#x3D; await UserRepository.FindAsync(eventData.Entity.Id);</span><br><span class="line">        if (user &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            user &#x3D; await UserLookupService.FindByIdAsync(eventData.Entity.Id);</span><br><span class="line">            if (user &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (user.Update(eventData.Entity))</span><br><span class="line">        &#123;</span><br><span class="line">            await UserRepository.UpdateAsync(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="如何给IdentityUser添加额外的属性"><a href="#如何给IdentityUser添加额外的属性" class="headerlink" title="如何给IdentityUser添加额外的属性"></a>如何给IdentityUser添加额外的属性</h1><h2 id="Extra-Properties"><a href="#Extra-Properties" class="headerlink" title="Extra Properties"></a>Extra Properties</h2><p>首先IdentityUser已经被定义,虽然我们可以通过dbcontext配置修改数据表的字段,,但是不能被映射,所以有了Extra Properties</p>
<p><a href="https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities" target="_blank" rel="noopener">https://docs.abp.io/zh-Hans/abp/latest/Customizing-Application-Modules-Extending-Entities</a></p>
<h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p>会在数据库中创建字段</p>
<p><code>AppUser.cs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public virtual string Sex &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">private AppUser()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PlayGroundDbContext.cs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">builder.Entity&lt;AppUser&gt;(b &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    b.ToTable(AbpIdentityDbProperties.DbTablePrefix + &quot;Users&quot;); &#x2F;&#x2F;Sharing the same table &quot;AbpUsers&quot; with the IdentityUser</span><br><span class="line"></span><br><span class="line">    b.ConfigureByConvention();</span><br><span class="line">    b.ConfigureAbpUser();</span><br><span class="line"></span><br><span class="line">    &#x2F;* Configure mappings for your additional properties</span><br><span class="line">     * Also see the PlayGroundEfCoreEntityExtensionMappings class</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    b.Property(x &#x3D;&gt; x.Sex).HasMaxLength(128);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>PlayGroundEfCoreEntityExtensionMappings.cs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Configure()</span><br><span class="line"> &#123;</span><br><span class="line">     PlayGroundModulePropertyConfigurator.Configure();</span><br><span class="line"></span><br><span class="line">     OneTimeRunner.Run(() &#x3D;&gt;</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;* You can configure entity extension properties for the</span><br><span class="line">          * entities defined in the used modules.</span><br><span class="line">          *</span><br><span class="line">          * The properties defined here becomes table fields.</span><br><span class="line">          * If you want to use the ExtraProperties dictionary of the entity</span><br><span class="line">          * instead of creating a new field, then define the property in the</span><br><span class="line">          * PlayGroundDomainObjectExtensions class.</span><br><span class="line">          *</span><br><span class="line">          * Example:</span><br><span class="line">          *</span><br><span class="line">          * ObjectExtensionManager.Instance</span><br><span class="line">          *    .MapEfCoreProperty&lt;IdentityUser, string&gt;(</span><br><span class="line">          *        &quot;MyProperty&quot;,</span><br><span class="line">          *        b &#x3D;&gt; b.HasMaxLength(128)</span><br><span class="line">          *    );</span><br><span class="line">          *</span><br><span class="line">          * See the documentation for more:</span><br><span class="line">          * https:&#x2F;&#x2F;docs.abp.io&#x2F;en&#x2F;abp&#x2F;latest&#x2F;Customizing-Application-Modules-Extending-Entities</span><br><span class="line">          *&#x2F;</span><br><span class="line"></span><br><span class="line">         ObjectExtensionManager.Instance</span><br><span class="line">               .MapEfCoreProperty&lt;IdentityUser, string&gt;(</span><br><span class="line">           nameof(AppUser.Sex),</span><br><span class="line">           b &#x3D;&gt; b.HasMaxLength(128)</span><br><span class="line">               );</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看生成的迁移表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public partial class Added_Sex_T_User : Migration</span><br><span class="line">&#123;</span><br><span class="line">    protected override void Up(MigrationBuilder migrationBuilder)</span><br><span class="line">    &#123;</span><br><span class="line">        migrationBuilder.AddColumn&lt;string&gt;(</span><br><span class="line">            name: &quot;Sex&quot;,</span><br><span class="line">            table: &quot;AbpUsers&quot;,</span><br><span class="line">            maxLength: 128,</span><br><span class="line">            nullable: true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void Down(MigrationBuilder migrationBuilder)</span><br><span class="line">    &#123;</span><br><span class="line">        migrationBuilder.DropColumn(</span><br><span class="line">            name: &quot;Sex&quot;,</span><br><span class="line">            table: &quot;AbpUsers&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-07-05-abp-database-migration/image-20200714123314743.png" alt="image-20200714123314743"></p>
<p>它时如何被添加到迁移dbcontext中的</p>
<p><code>AbpEntityTypeBuilderExtensions.cs</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void ConfigureByConvention(this EntityTypeBuilder b)</span><br><span class="line">&#123;</span><br><span class="line">    b.TryConfigureConcurrencyStamp();</span><br><span class="line">    b.TryConfigureExtraProperties();  &#x2F;&#x2F;配置扩展属性,就是ExtraProperties字段</span><br><span class="line">    b.TryConfigureObjectExtensions();&#x2F;&#x2F;就是这里对象扩展,ObjectExtensionManager.Instance添加属性,然后从这里再根据类型读取出来</span><br><span class="line">    b.TryConfigureMayHaveCreator();</span><br><span class="line">    b.TryConfigureMustHaveCreator();</span><br><span class="line">    b.TryConfigureSoftDelete();</span><br><span class="line">    b.TryConfigureDeletionTime();</span><br><span class="line">    b.TryConfigureDeletionAudited();</span><br><span class="line">    b.TryConfigureCreationTime();</span><br><span class="line">    b.TryConfigureLastModificationTime();</span><br><span class="line">    b.TryConfigureModificationAudited();</span><br><span class="line">    b.TryConfigureMultiTenant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>你可以创建<strong>自己的表</strong>来存储属性,而不是创建新实体并映射到同一表. 你通常复制原始实体的一些值. 例如可以将 <code>Name</code> 字段添加到你自己的表中,它是原表中 <code>Name</code> 字段的副本.</p>
<p>在这种情况下你不需要处理迁移问题,但是需要处理数据复制问题. 当重复的值发生变化时,你应该在表中同步相同的变化. 你可以使用本地或分布式<a href="https://docs.abp.io/zh-Hans/abp/latest/Event-Bus" target="_blank" rel="noopener">事件总线</a>订阅原始实体的更改事件. 这是根据来自另一个微服务的数据推荐的方法,特别是如果它们有单独的物理数据库(你可以在网络中搜索关于微服务设计的数据共享,这是一个广泛的主题).</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>sync</tag>
        <tag>同步</tag>
        <tag>abp</tag>
      </tags>
  </entry>
  <entry>
    <title>abp的dOC模块使用</title>
    <url>/dotnet-2020-07-10-abp-doc/</url>
    <content><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="../../assets/images/2020-07-10-abp-doc/image-20200716181126415.png" alt="image-20200716181126415"></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>abp 使用拉的方式从github直接请求,然后存储到数据库作为缓存</p>
<p>注意开发环境下,他会从github直接拉取而不会经过数据库缓存,所以会很慢</p>
<h1 id="关于版本"><a href="#关于版本" class="headerlink" title="关于版本"></a>关于版本</h1><p>当你写完书的时候.打个tag,然后把tag的版本号填入上方的..最新版本的分支名称即可</p>
<h1 id="关于多语言"><a href="#关于多语言" class="headerlink" title="关于多语言"></a>关于多语言</h1><p>注意多语言abp使用了缓存..所以如果你更改了docs-langs.json,需要重启服务器,或者清空缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Languages&quot;:[</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;DisplayName&quot; : &quot;English&quot;,</span><br><span class="line">        &quot;Code&quot; : &quot;en&quot;,</span><br><span class="line">        &quot;IsDefault&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;DisplayName&quot; : &quot;简体中文&quot;,</span><br><span class="line">        &quot;Code&quot; : &quot;zh&quot;,</span><br><span class="line">        &quot;IsDefault&quot;: true</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h1 id="关于参数-doc-params"><a href="#关于参数-doc-params" class="headerlink" title="关于参数[doc-params]"></a>关于参数[doc-params]</h1><p>abp使用了scriban文本模板语言引擎.</p>
<p><a href="https://github.com/lunet-io/scriban" target="_blank" rel="noopener">https://github.com/lunet-io/scriban</a></p>
<p>具体的示例参见:</p>
<ul>
<li><a href="https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&amp;DB=EF&amp;Tiered=No" target="_blank" rel="noopener">https://docs.abp.io/zh-Hans/abp/latest/Getting-Started?UI=MVC&amp;DB=EF&amp;Tiered=No</a></li>
<li><a href="https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.md" target="_blank" rel="noopener">https://github.com/abpframework/abp/blob/master/docs/zh-Hans/Getting-Started.md</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;parameters&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;UI&quot;,</span><br><span class="line">      &quot;displayName&quot;: &quot;UI&quot;,</span><br><span class="line">      &quot;values&quot;: &#123;</span><br><span class="line">        &quot;MVC&quot;: &quot;MVC &#x2F; Razor Pages&quot;,</span><br><span class="line">        &quot;NG&quot;: &quot;Angular&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;DB&quot;,</span><br><span class="line">      &quot;displayName&quot;: &quot;Database&quot;,</span><br><span class="line">      &quot;values&quot;: &#123;</span><br><span class="line">        &quot;EF&quot;: &quot;Entity Framework Core&quot;,</span><br><span class="line">        &quot;Mongo&quot;: &quot;MongoDB&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Tiered&quot;,</span><br><span class="line">      &quot;displayName&quot;: &quot;Tiered&quot;,</span><br><span class="line">      &quot;values&quot;: &#123;</span><br><span class="line">        &quot;No&quot;: &quot;Not Tiered&quot;,</span><br><span class="line">        &quot;Yes&quot;: &quot;Tiered&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>markdow中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;[doc-params]</span><br><span class="line">&#123;</span><br><span class="line">    &quot;UI&quot;: [&quot;MVC&quot;,&quot;NG&quot;],</span><br><span class="line">    &quot;DB&quot;: [&quot;EF&quot;, &quot;Mongo&quot;],</span><br><span class="line">    &quot;Tiered&quot;: [&quot;Yes&quot;, &quot;No&quot;]</span><br><span class="line">&#125;</span><br><span class="line">本教程介绍了如何创建一个新的&#123;&#123;if UI &#x3D;&#x3D; &quot;MVC&quot;&#125;&#125; ASP.NET Core MVC web &#123;&#123;else if UI &#x3D;&#x3D; &quot;NG&quot;&#125;&#125; Angular &#123;&#123;end&#125;&#125;. 配置并运行它.</span><br></pre></td></tr></table></figure>

<p>生成的html</p>
<p><img src="../../assets/images/2020-07-10-abp-doc/image-20200718164036943.png" alt="image-20200718164036943"></p>
<p>当切换ui的值后的显示,我们看到字符发生了改变</p>
<p><img src="../../assets/images/2020-07-10-abp-doc/image-20200718164137023.png" alt="image-20200718164137023"></p>
<h1 id="关于-doc-template"><a href="#关于-doc-template" class="headerlink" title="关于[doc-template]"></a>关于[doc-template]</h1><p>还没看到如何用</p>
<h1 id="404"><a href="#404" class="headerlink" title="404"></a>404</h1><p>因为访问github如果超时就会出现404.</p>
<p>所以建议控制台设置代理然后运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$env:http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">$env:https_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">dotnet run .\IG.Www.Web.csproj</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>代理</tag>
        <tag>JS</tag>
        <tag>abp</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>abp默认语言规则</title>
    <url>/dotnet-2020-07-15-abp-default-language/</url>
    <content><![CDATA[<h1 id="abp默认语言规则"><a href="#abp默认语言规则" class="headerlink" title="abp默认语言规则"></a>abp默认语言规则</h1><p>abp是依托与aspnetcore的.我们先来看看aspnetcore是怎么实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">services.Configure&lt;RequestLocalizationOptions&gt;(options &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        var supportedCultures &#x3D; new List&lt;CultureInfo&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            new CultureInfo(&quot;en-US&quot;),</span><br><span class="line">            new CultureInfo(&quot;en&quot;),</span><br><span class="line">            new CultureInfo(&quot;fr-FR&quot;),</span><br><span class="line">            new CultureInfo(&quot;fr&quot;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        options.DefaultRequestCulture &#x3D; new RequestCulture(&quot;en-US&quot;);</span><br><span class="line">        options.SupportedCultures &#x3D; supportedCultures;</span><br><span class="line">        options.SupportedUICultures &#x3D; supportedCultures;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;中间件</span><br><span class="line">    app.UseRequestLocalization();</span><br></pre></td></tr></table></figure>

<h2 id="中间件request的语言判断"><a href="#中间件request的语言判断" class="headerlink" title="中间件request的语言判断"></a>中间件request的语言判断</h2><p>在每次请求里 <a href="https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNet/Localization/RequestLocalizationOptions/index.html" target="_blank" rel="noopener">RequestLocalizationOptions</a> 的 <a href="https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/RequestCultureProvider/index.html" target="_blank" rel="noopener">RequestCultureProvider</a> 列表会被遍历，第一个provider 会被使用来判断请求使用的文化。默认的 provider 来自<code>RequestLocalizationOptions</code> 类,如果没有非空的 provider，<code>DefaultRequestCulture</code> 被使用。所以如果发现语言不是按照逻辑顺序显示,先检查请求网址,再检查<code>cookie</code>(很难注意到),最后检查acceptlanguage</p>
<h3 id="QueryStringRequestCultureProvider"><a href="#QueryStringRequestCultureProvider" class="headerlink" title="QueryStringRequestCultureProvider"></a><a href="https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/QueryStringRequestCultureProvider/index.html" target="_blank" rel="noopener">QueryStringRequestCultureProvider</a></h3><p>下面的例子指定了具体的区域性（语言和区域）设置为西班牙语/墨西哥：</p>
<p><a href="http://localhost:5000/?culture=es-MX&amp;ui-culture=es-MX" target="_blank" rel="noopener">http://localhost:5000/?culture=es-MX&amp;ui-culture=es-MX</a></p>
<p>如果你仅仅使用（culture 或者 ui-culture）中的一个参数进行传递，查询字符串 provider 将使用你传递一个值来设置这两个参数。例如，仅设置culture，将会同样设置 Culture 和 UICulture：</p>
<p><a href="http://localhost:5000/?culture=es-MX" target="_blank" rel="noopener">http://localhost:5000/?culture=es-MX</a></p>
<h3 id="CookieRequestCultureProvider"><a href="#CookieRequestCultureProvider" class="headerlink" title="CookieRequestCultureProvider"></a><a href="https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/CookieRequestCultureProvider/index.html" target="_blank" rel="noopener">CookieRequestCultureProvider</a></h3><p>CookieRequestCultureProvider 的 DefaultCookieName 返回用于跟踪用户的首选区域性信息默认的 Cookie 名称。默认的 Cookie 名称是 “.AspNetCore.Culture”。</p>
<p>cookie 的格式是 c=%LANGCODE%|uic=%LANGCODE%, c 为区域信息 和 uic 为 UI 区域信息，例如：</p>
<p>c=’en-UK’|uic=’en-US’</p>
<p>如果仅指定 culture 或 UI culture中的一个，指定的区域性信息将同时用于 culture和 UI culture。</p>
<h3 id="AcceptLanguageHeaderRequestCultureProvider"><a href="#AcceptLanguageHeaderRequestCultureProvider" class="headerlink" title="AcceptLanguageHeaderRequestCultureProvider"></a><a href="https://docs.asp.net/projects/api/en/latest/autoapi/Microsoft/AspNetCore/Localization/AcceptLanguageHeaderRequestCultureProvider/index.html" target="_blank" rel="noopener">AcceptLanguageHeaderRequestCultureProvider</a></h3><p>这个一般是根据浏览器的设置进行访问的<br><img src="../../assets/images/2020-07-15-abp-default-language/image-20200719113919074.png" alt="image-20200719113919074"><br>不同的浏览器默认语言不同,chrome浏览器可以再语言里设置</p>
<p><img src="../../assets/images/2020-07-15-abp-default-language/c83d70cf3bc79f3d3ec73c6db4a1cd11728b294d.png" alt="img"></p>
<h2 id="Cultures"><a href="#Cultures" class="headerlink" title="Cultures"></a>Cultures</h2><ul>
<li><p><code>SupportedCultures</code> 的 <a href="https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo(v=vs.110).aspx" target="_blank" rel="noopener">CultureInfo</a> 对象决定了和文化相关的函数，如日期，时间，数字和货币格式的结果。同时决定了文字如何排序，大小写转换以及字符串比较。参考<a href="https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.currentculture(v=vs.110).aspx" target="_blank" rel="noopener">CultureInfo.CurrentCulture</a> 获取更多关于服务器如何获取文化的信息。</p>
</li>
<li><p><code>SupportedUICultures</code> 决定如何通过 <a href="https://msdn.microsoft.com/en-us/library/system.resources.resourcemanager(v=vs.110).aspx" target="_blank" rel="noopener">ResourceManager</a> 查找翻译字符串（从 <em>.resx</em> 文件）。 <em>ResourceManager</em> 只是通过 CurrentUICulture 简单的查找指定文化的字符串。</p>
</li>
</ul>
<p>.NET 的每个线程都会拥有 <code>CurrentCulture</code> 和<code>CurrentUICulture</code> 对象。当 ASP.NET Core 在渲染与文化相关的函数的时候会检视这些对象值。例如，如果当前线程的区域性设置为 “en-US” （英语、美国）， <code>DateTime.Now.ToLongDateString() &quot;Thursday, February 18, 2016&quot;</code> ，但如果 CurrentCulture 设置为 “es-ES”（西班牙语、西班牙），输出将会是 “jueves, 18 de febrero de 2016”。</p>
<h2 id="abp的实现"><a href="#abp的实现" class="headerlink" title="abp的实现"></a>abp的实现</h2><p>Volo.Abp.AspNetCore项目中DefaultAbpRequestLocalizationOptionsProvider.cs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#GetLocalizationOptionsAsync()</span><br><span class="line">#根据设置获取默认语言,如果默认语言为en</span><br><span class="line">var languages &#x3D; await languageProvider.GetLanguagesAsync();</span><br><span class="line">var defaultLanguage &#x3D; await settingProvider.GetOrNullAsync(LocalizationSettingNames.DefaultLanguage);</span><br><span class="line"></span><br><span class="line">var options &#x3D; !languages.Any()</span><br><span class="line">? new RequestLocalizationOptions()</span><br><span class="line">: new RequestLocalizationOptions</span><br><span class="line">&#123;</span><br><span class="line">DefaultRequestCulture &#x3D; DefaultGetRequestCulture(defaultLanguage, languages),</span><br><span class="line"></span><br><span class="line">SupportedCultures &#x3D; languages</span><br><span class="line">.Select(l &#x3D;&gt; l.CultureName)</span><br><span class="line">.Distinct()</span><br><span class="line">.Select(c &#x3D;&gt; new CultureInfo(c))</span><br><span class="line">.ToArray(),</span><br><span class="line"></span><br><span class="line">SupportedUICultures &#x3D; languages</span><br><span class="line">.Select(l &#x3D;&gt; l.UiCultureName)</span><br><span class="line">.Distinct()</span><br><span class="line">.Select(c &#x3D;&gt; new CultureInfo(c))</span><br><span class="line">.ToArray()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#如果设置中的默认语言不存在,则选取第一个语言作为默认语言</span><br><span class="line">private static RequestCulture DefaultGetRequestCulture(string defaultLanguage, IReadOnlyList&lt;LanguageInfo&gt; languages)</span><br><span class="line">&#123;</span><br><span class="line">    if (defaultLanguage &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">    var firstLanguage &#x3D; languages.First();</span><br><span class="line">    return new RequestCulture(firstLanguage.CultureName, firstLanguage.UiCultureName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var (cultureName, uiCultureName) &#x3D; LocalizationSettingHelper.ParseLanguageSetting(defaultLanguage);</span><br><span class="line">    return new RequestCulture(cultureName, uiCultureName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后中间件是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.UseAbpRequestLocalization();</span><br></pre></td></tr></table></figure>

<p>中间件使用的是AbpRequestLocalizationMiddleware,其实它只是对aspnetcore的RequestLocalizationMiddleware进行了一层包装</p>
<h3 id="如何修改默认语言"><a href="#如何修改默认语言" class="headerlink" title="如何修改默认语言"></a>如何修改默认语言</h3><p>首先注意浏览器发送的中文的<code>accept-language</code>的值与ABP值是不一样的:</p>
<ul>
<li>浏览器(如Chrome)的值为<code>zh-CN</code></li>
<li>而ABP的简体中文的值为<code>zh-Hans</code></li>
</ul>
<p>首先修改配置文件appsettings.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Settings&quot;: &#123;</span><br><span class="line">	&quot;Abp.Localization.DefaultLanguage&quot;: &quot;zh-Hans&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在中间件中删除AcceptLanguageHeaderRequestCultureProvider</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.UseAbpRequestLocalization(options &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.RequestCultureProviders.RemoveAll(provider &#x3D;&gt; provider is AcceptLanguageHeaderRequestCultureProvider);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>C</tag>
        <tag>sync</tag>
        <tag>JS</tag>
        <tag>abp</tag>
      </tags>
  </entry>
  <entry>
    <title>Orleans 最佳实践</title>
    <url>/dotnet-2020-08-09-Orleans-Best-Practices/</url>
    <content><![CDATA[<h1 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h1><p>grain激活体是单线程的，默认情况下，激活体会自始至终地处理完成每个请求后，才会处理下一个请求。<br>可重入的激活体，可以在上一个请求尚未完成处理的情况下，开始执行另一个请求。执行仍然限于单个线程，因此激活体仍然一次执行一个回合，并且每个回合仅代表激活体的一个请求执行。<br>可重入的grain代码永远不会并行运行多段grain代码（grain代码的执行将始终是单线程的），但是，可重入的grain可能会看到不同请求交错执行的代码。也就是说，来自不同请求的延续回合，是交错执行的。</p>
<p>因为访问grain一般是需要跨服务器的，所以可重入是很有必要的。。</p>
<h1 id="无状态Grain"><a href="#无状态Grain" class="headerlink" title="无状态Grain"></a>无状态Grain</h1><p>grain永远是运行在服务端的,包括无状态的.</p>
<h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p>time是单线程的..</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   public override async Task OnActivateAsync()</span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">       if (this.TimerDisposable &#x3D;&#x3D; null)</span><br><span class="line">       &#123;</span><br><span class="line">           this.TimerDisposable &#x3D; RegisterTimer(</span><br><span class="line">                       this.SaveChanges,</span><br><span class="line">                       &quot;timer&quot;,</span><br><span class="line">                       TimeSpan.FromMilliseconds(0),</span><br><span class="line">                       TimeSpan.FromMilliseconds(1)</span><br><span class="line">                       );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       await base.OnActivateAsync();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   private Task SaveChanges(object arg)</span><br><span class="line">   &#123;</span><br><span class="line">       this.persisitent.State.num++;</span><br><span class="line"></span><br><span class="line">       return this.persisitent.WriteStateAsync();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public async Task StartUp()</span><br><span class="line">   &#123;</span><br><span class="line">       this.persisitent.State.num &#x3D; 0;</span><br><span class="line">       await this.WriteStateAsync();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">      var grain &#x3D; this.GrainFactory.GetGrain&lt;ITimeTestGrain&gt;(1000);</span><br><span class="line"></span><br><span class="line">       await grain.StartUp();</span><br></pre></td></tr></table></figure>

<p>以上代码当duetime设置为0的时候,会有类型的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Orleans.Storage.InconsistentStateException: ETag mismatch - tried with ETag: a62ea0e1-a40d-43c3-a508-1e8615351443</span><br></pre></td></tr></table></figure>

<p>原因猜测,grain未激活完成的时候,如果为0的时候,这个时候time的callback(SaveChanges)还没有加入到任务队列,就调用了state,而之后也立即同时调用了state这个时候就会报错.</p>
<p>解决方案:</p>
<ul>
<li>不要设置duetime为0</li>
<li>或者不要在OnActivateAsync中RegisterTimer,在Activate后再RegisterTimer</li>
</ul>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html" target="_blank" rel="noopener">https://dotnet.github.io/orleans/Documentation/resources/Best_Practices.html</a></li>
</ul>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>sync</tag>
      </tags>
  </entry>
  <entry>
    <title>c#特性参数</title>
    <url>/dotnet-2020-08-10-param-attribute/</url>
    <content><![CDATA[<p>可以通过反射获取这些特性然后做处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var message &#x3D; new MessageData &#123;</span><br><span class="line"></span><br><span class="line">            Header&#x3D;&quot;header...&quot;,</span><br><span class="line">            Body&#x3D;&quot;body....&quot;,</span><br><span class="line">            Footer&#x3D;&quot;footer...&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Type objT &#x3D; typeof(Program);</span><br><span class="line">        Type fromBodyT &#x3D; typeof(FromBodyAttribute);</span><br><span class="line">        MethodInfo method &#x3D; objT.GetMethod(&quot;Test&quot;);</span><br><span class="line"></span><br><span class="line">        ParameterInfo[] paramsInfo &#x3D; method.GetParameters();</span><br><span class="line">        var parameters&#x3D; new List&lt;object&gt;(paramsInfo.Length);</span><br><span class="line">        foreach (ParameterInfo parameterInfo in paramsInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            var parameter &#x3D; new object();</span><br><span class="line">            if (parameterInfo.CustomAttributes.Any(i &#x3D;&gt; i.AttributeType &#x3D;&#x3D; fromBodyT))</span><br><span class="line">                parameter &#x3D; message.Body;</span><br><span class="line">            parameters.Add(parameter);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        object result &#x3D; method.Invoke(null, parameters.ToArray());</span><br><span class="line">        Console.WriteLine(result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public class FromBodyAttribute : Attribute</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static string Test([FromBody] string body)</span><br><span class="line">    &#123;</span><br><span class="line">        return body;</span><br><span class="line">    &#125;</span><br><span class="line">    class MessageData</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        public string Body &#123; get; set; &#125;</span><br><span class="line">        public string Header &#123; get; set; &#125;</span><br><span class="line">        public string Footer &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core 获取 HttpContext.Current 以及 AsyncLocal 与 ThreadLocal</title>
    <url>/dotnet-2020-08-11-httpcontextaccessor-asynclocal/</url>
    <content><![CDATA[<p>在 DotNetCore 当中不再像 MVC5 那样可以通过 <code>HttpContext.Current</code> 来获取到当前请求的上下文。</p>
<p>不过微软提供了一个 IHttpContextAccessor 来让我们访问当前请求的 Http 上下文，其定义<br>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace Microsoft.AspNetCore.Http</span><br><span class="line">&#123;</span><br><span class="line">	public interface IHttpContextAccessor</span><br><span class="line">	&#123;</span><br><span class="line">	    HttpContext HttpContext &#123; get; set; &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要使用的话需要将其添加到 Ioc 容器当中，在 Startup 类的 ConfigureService 我们可以将其默认实现注册到 Ioc 之中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void ConfigureService(IServiceCollection services) &#123;</span><br><span class="line">    services.TryAddSingleton&lt;IHttpContextAccessor, HttpContextAccessor&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们可以来看看 <code>HttpContextAccessor</code> 的具体实现:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace Microsoft.AspNetCore.Http</span><br><span class="line">&#123;</span><br><span class="line">    public class HttpContextAccessor : IHttpContextAccessor</span><br><span class="line">    &#123;</span><br><span class="line">        private static AsyncLocal&lt;HttpContext&gt; _httpContextCurrent &#x3D; new AsyncLocal&lt;HttpContext&gt;();</span><br><span class="line"></span><br><span class="line">        public HttpContext HttpContext</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return _httpContextCurrent.Value;</span><br><span class="line">            &#125;</span><br><span class="line">            set</span><br><span class="line">            &#123;</span><br><span class="line">                _httpContextCurrent.Value &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在其内部主要是用了一个 <code>AsyncLocal&lt;HttpContext&gt;</code> 来保存一个 HttpContext 实例，那么 Accessor 是什么时候被赋值的呢？答案就是在每次 HTTP 请求的时候会将其赋值。</p>
<p><code>AsyncLocal&lt;T&gt;</code> 是什么东西？<br><code>AsyncLocal&lt;T&gt;</code> 是在 .Net 4.6 之后推出的一个对象，该对象接受一个泛型参数，其主要作用是保存异步等待上下文中共享某个变量的值。<br>而异步方法是基于 Task 的自动线程调度，在异步上下文切换的时候可能导致数据丢失。例如在 await 调用之前对某个变量进行了赋值，而这个变量是多个线程间共享的，当 await 调用返回之前的调用点的时候，可能调用点之后的代码还处在之前的线程上，也有可能被调度到其他线程上。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static async Task TestMethod() &#123;</span><br><span class="line">    Console.WriteLine($&quot;当前线程ID&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">    await Task.Delay(100);</span><br><span class="line">    Console.WriteLine($&quot;当前线程ID&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 await 等待任务执行完成之后，后面的代码输出的 ID 与调用之前的 ID 不一样，说明发生了线程切换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    Action @delegate &#x3D; async () &#x3D;&gt; await TestMethod();</span><br><span class="line"></span><br><span class="line">    @delegate();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c93755a0.png" alt="Img"><br>从代码上看他们似乎在同一个线程，但是在执行的时候就已经发生了线程切换的操作了。<br>而我们在这里如果使用一个 <code>ThreadLocal&lt;T&gt;</code>变量来存储的话，会发生什么事情呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ThreadLocal&lt;int&gt; _threadLocal &#x3D; new ThreadLocal&lt;int&gt;();</span><br><span class="line">static AsyncLocal&lt;int&gt; _asyncLocal &#x3D; new AsyncLocal&lt;int&gt;();</span><br><span class="line"></span><br><span class="line">static void Main(string[] args) &#123;</span><br><span class="line">    Action @delegate &#x3D; async () &#x3D;&gt; await TestMethod();</span><br><span class="line"></span><br><span class="line">    @delegate();</span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static async Task TestMethod() &#123;</span><br><span class="line">    _threadLocal.Value &#x3D; 1000;</span><br><span class="line">    _asyncLocal.Value &#x3D; 2000;</span><br><span class="line">    Console.WriteLine($&quot;当前线程ID&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;&#123;nameof(_threadLocal)&#125;，值:&#123;_threadLocal.Value&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;&#123;nameof(_asyncLocal)&#125;，值:&#123;_asyncLocal.Value&#125;&quot;);</span><br><span class="line">    await Task.Delay(100);</span><br><span class="line">    Console.WriteLine($&quot;当前线程ID&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;&#123;nameof(_threadLocal)&#125;，值:&#123;_threadLocal.Value&#125;&quot;);</span><br><span class="line">    Console.WriteLine($&quot;&#123;nameof(_asyncLocal)&#125;，值:&#123;_asyncLocal.Value&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-08-11-httpcontextaccessor-asynclocal/5b2f1c938eec4.png" alt="Img"><br>SO，在这里解释一下， <code>ThreadLocal</code> 是用于为不同的线程保存不同的变量值的，即同一个变量在不同线程当中存储的值可以不一样。在这里使用是为了保证在 TestMethod 方法中变量的唯一性，这个在同步方法用是没问题的，但这里使用了 await 关键字导致等待异步调用结束后代码已经被调度到其他的线程了，所以这里没用。而 <code>AsyncLocal&lt;T&gt;</code> 正是为了这种情况而准备的。</p>
<p>这就解释了为什么是单例却在每个线程是不同的值.</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>C</tag>
        <tag>sync</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Kestrel源码分析</title>
    <url>/dotnet-2020-08-15-Kestrel-source-code/</url>
    <content><![CDATA[<p>Kestrel是<a href="https://link.zhihu.com/?target=http%3A//ASP.NET">http://ASP.NET</a> Core框架内置的默认Web Server 什么是Web Server? 根据<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Web_server">维基百科</a>的定义: Web Server是可以处理来自客户端的HTTP协议请求并返回网页的软件或硬件。 因此Kestrel的主要功能就是接收来自网络客户端的HTTP请求，并根据请求返回对应的网页（数据也是一种网页）。</p>
<h2 id="定义-IServer、IHttpApplication-lt-TContext-gt"><a href="#定义-IServer、IHttpApplication-lt-TContext-gt" class="headerlink" title="定义 - IServer、IHttpApplication&lt;TContext&gt;"></a>定义 - <code>IServer</code>、<code>IHttpApplication&lt;TContext&gt;</code></h2><hr>
<p><a href="https://link.zhihu.com/?target=http%3A//ASP.NET">http://ASP.NET</a> Core定义了两个基本的接口<code>IServer</code>，及<code>IHttpApplication&lt;TContext&gt;</code>，<code>IServer</code>接口定义了Web Server的基本功能，<code>IHttpApplication&lt;TContext&gt;</code>则定义了处理HTTP协议的应用程序的基本功能，我们首先来看下这两个定义:</p>
<h2 id="Web-服务器-IServer"><a href="#Web-服务器-IServer" class="headerlink" title="Web 服务器 - IServer"></a>Web 服务器 - <code>IServer</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace Microsoft.AspNetCore.Hosting.Server</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Represents a server.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public interface IServer : IDisposable</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; A collection of HTTP features of the server.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        IFeatureCollection Features &#123; get; &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Start the server with an application.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;application&quot;&gt;An instance of &lt;see cref&#x3D;&quot;IHttpApplication&#123;TContext&#125;&quot;&#x2F;&gt;.&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TContext&quot;&gt;The context associated with the application.&lt;&#x2F;typeparam&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;cancellationToken&quot;&gt;Indicates if the server startup should be aborted.&lt;&#x2F;param&gt;</span><br><span class="line">        Task StartAsync&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; application, CancellationToken cancellationToken);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Stop processing requests and shut down the server, gracefully if possible.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;cancellationToken&quot;&gt;Indicates if the graceful shutdown should be aborted.&lt;&#x2F;param&gt;</span><br><span class="line">        Task StopAsync(CancellationToken cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Features</code> 是一个功能集合，其中可以包含所有应用程序需要的，用以处理HTTP协议各个阶段和组成部分的功能集，以接口的形式注入到<code>Features</code>中。</p>
<p><code>StartAsync</code>方法可以启动IServer对象，用来接受用户请求。包含两个参数：<code>IHttpApplication&lt;TContext&gt;</code>和<code>CancellationToken</code>。 <code>IHttpApplicatoin&lt;TContext&gt;</code>是最终处理HTTP请求的应用程序入口点，在ASP.NET Core应用程序中，默认的<code>IHttpApplication&lt;TContext&gt;</code>实现是：<code>HostingApplication</code>，我们会在稍后的部分进行详细的介绍。 而<code>CancellationToken</code>用来响应中断应用程序启动的请求。</p>
<p><code>StopAsync</code>方法用来处理停止服务的请求，接受一个参数<code>CancellationToken</code>，用来响应中断停止应用程序的请求。</p>
<h2 id="Http应用程序-IHttpApplication-lt-TContext-gt"><a href="#Http应用程序-IHttpApplication-lt-TContext-gt" class="headerlink" title="Http应用程序 - IHttpApplication&lt;TContext&gt;"></a>Http应用程序 - <code>IHttpApplication&lt;TContext&gt;</code></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace Microsoft.AspNetCore.Hosting.Server</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Represents an application.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TContext&quot;&gt;The context associated with the application.&lt;&#x2F;typeparam&gt;</span><br><span class="line">    public interface IHttpApplication&lt;TContext&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Create a TContext given a collection of HTTP features.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;contextFeatures&quot;&gt;A collection of HTTP features to be used for creating the TContext.&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;returns&gt;The created TContext.&lt;&#x2F;returns&gt;</span><br><span class="line">        TContext CreateContext(IFeatureCollection contextFeatures);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Asynchronously processes an TContext.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;context&quot;&gt;The TContext that the operation will process.&lt;&#x2F;param&gt;</span><br><span class="line">        Task ProcessRequestAsync(TContext context);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Dispose a given TContext.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;context&quot;&gt;The TContext to be disposed.&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;exception&quot;&gt;The Exception thrown when processing did not complete successfully, otherwise null.&lt;&#x2F;param&gt;</span><br><span class="line">        void DisposeContext(TContext context, Exception exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IHttpApplication&lt;TContext&gt;</code>接口的定义包含了三个方法： <code>CreateContext</code>方法用来创建处理请求的上下文中所需要的所有相关数据，组成<code>Context</code>对象，由接口的实现自己定义类型， <code>ProcessRequestAsync</code>方法使用<code>CreateContext</code>方法创建的<code>Context</code>对象处理本次请求。 <code>DisposeContext</code>方法在完成请求的处理后，负责释放<code>Context</code>对象。</p>
<h2 id="实现-KestrelServer"><a href="#实现-KestrelServer" class="headerlink" title="实现 - KestrelServer"></a>实现 - <code>KestrelServer</code></h2><p><a href="https://link.zhihu.com/?target=http%3A//ASP.NET">http://ASP.NET</a> Core提供了默认的<code>IServer</code>：<code>KestrelServer</code>，下面我们就来看看<code>KestrelServer</code>具体都做了些什么。</p>
<blockquote>
<p><code>KestrelServer</code> 定义在dotnet/aspnetcore项目中（<a href="https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore">GITHUB REPO</a>）。 项目名称为：Microsoft.AspNetCore.Server.Kestrel.Core 名称空间:Microsoft.AspNetCore.Server.Kestrel.Core <a href="https://link.zhihu.com/?target=https%3A//github.com/dotnet/aspnetcore/blob/master/src/Servers/Kestrel/Core/src/KestrelServer.cs">源代码</a></p>
</blockquote>
<h2 id="服务器启动：端口监听，协议解析及请求处理。"><a href="#服务器启动：端口监听，协议解析及请求处理。" class="headerlink" title="服务器启动：端口监听，协议解析及请求处理。"></a>服务器启动：端口监听，协议解析及请求处理。</h2><p>我们先看一下<code>KestrelServer</code>.<code>StartAsync()</code>方法的代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public async Task StartAsync&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; application, CancellationToken cancellationToken)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                if (!BitConverter.IsLittleEndian)</span><br><span class="line">                &#123;</span><br><span class="line">                    throw new PlatformNotSupportedException(CoreStrings.BigEndianNotSupported);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ValidateOptions();</span><br><span class="line"></span><br><span class="line">                if (_hasStarted)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; The server has already started and&#x2F;or has not been cleaned up yet</span><br><span class="line">                    throw new InvalidOperationException(CoreStrings.ServerAlreadyStarted);</span><br><span class="line">                &#125;</span><br><span class="line">                _hasStarted &#x3D; true;</span><br><span class="line"></span><br><span class="line">                ServiceContext.Heartbeat?.Start();</span><br><span class="line"></span><br><span class="line">                async Task OnBind(ListenOptions options)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; Add the HTTP middleware as the terminal connection middleware</span><br><span class="line">                    options.UseHttpServer(ServiceContext, application, options.Protocols);</span><br><span class="line"></span><br><span class="line">                    var connectionDelegate &#x3D; options.Build();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Add the connection limit middleware</span><br><span class="line">                    if (Options.Limits.MaxConcurrentConnections.HasValue)</span><br><span class="line">                    &#123;</span><br><span class="line">                        connectionDelegate &#x3D; new ConnectionLimitMiddleware(connectionDelegate, Options.Limits.MaxConcurrentConnections.Value, Trace).OnConnectionAsync;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    var connectionDispatcher &#x3D; new ConnectionDispatcher(ServiceContext, connectionDelegate);</span><br><span class="line">                    var transport &#x3D; await _transportFactory.BindAsync(options.EndPoint).ConfigureAwait(false);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Update the endpoint</span><br><span class="line">                    options.EndPoint &#x3D; transport.EndPoint;</span><br><span class="line">                    var acceptLoopTask &#x3D; connectionDispatcher.StartAcceptingConnections(transport);</span><br><span class="line"></span><br><span class="line">                    _transports.Add((transport, acceptLoopTask));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                await AddressBinder.BindAsync(_serverAddresses, Options, Trace, OnBind).ConfigureAwait(false);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Trace.LogCritical(0, ex, &quot;Unable to start Kestrel.&quot;);</span><br><span class="line">                Dispose();</span><br><span class="line">                throw;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><code>Kestrel</code>首先会检查服务器的<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/zh-hans/%E5%AD%97%E8%8A%82%E5%BA%8F">字节序</a>，目前是不支持大端序的。 然后检查最大请求长度限制的设置项，以及服务器是否已经启动。</p>
<p>最后，通过<code>AddressBinder</code>对预先配置的IP地址或终结点(EndPoint)名称进行监听，开始接受客户端的请求。</p>
<p>当每有一个新的HTTP请求通过TCP协议或其他协议和服务器成功简历连接后，AddressBinder使用<code>ThreadPool.UnsafeQueueUserWorkItem()</code>方法将<code>OnBind()</code>方法添加到线程池中，等待线程池的调度。</p>
<p>如果此时进程有可用的线程，就会调用<code>OnBind()</code>方法，处理用户的HTTP请求。</p>
<p><code>OnBind()</code>方法默认使用<code>HttpConnectionMiddleware&lt;ServiceContext&gt;</code>中间件，处理新接入的用户请求，当设置了<code>MaxConcurrentConnections</code>值为<code>True</code>时，则会默认使用<code>ConnectionLimitMiddleware</code>中间件，限制最大可用连接数，如果当前请求数已经达到最大可接受连接数，则拒绝用户的请求并断开连接，否则调用<code>HttpConnectionMiddleware&lt;ServiceContext&gt;</code>中间件，继续处理用户的请求。</p>
<h2 id="处理HTTP请求-HttpConnectionMiddleware-lt-ServiceContext-gt-、HttpConnection"><a href="#处理HTTP请求-HttpConnectionMiddleware-lt-ServiceContext-gt-、HttpConnection" class="headerlink" title="处理HTTP请求 - HttpConnectionMiddleware&lt;ServiceContext&gt;、HttpConnection"></a>处理HTTP请求 - <code>HttpConnectionMiddleware&lt;ServiceContext&gt;</code>、<code>HttpConnection</code></h2><p><code>HttpConnectionMiddleware&lt;ServiceContext&gt;</code>中间件负责组装连接相关的上下文数据<code>HttpConnectionContext</code>，并使用<code>HttpConnection</code>类处理用户请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal class HttpConnectionMiddleware&lt;TContext&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly ServiceContext _serviceContext;</span><br><span class="line">        private readonly IHttpApplication&lt;TContext&gt; _application;</span><br><span class="line">        private readonly HttpProtocols _protocols;</span><br><span class="line"></span><br><span class="line">        public HttpConnectionMiddleware(ServiceContext serviceContext, IHttpApplication&lt;TContext&gt; application, HttpProtocols protocols)</span><br><span class="line">        &#123;</span><br><span class="line">            _serviceContext &#x3D; serviceContext;</span><br><span class="line">            _application &#x3D; application;</span><br><span class="line">            _protocols &#x3D; protocols;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Task OnConnectionAsync(ConnectionContext connectionContext)</span><br><span class="line">        &#123;</span><br><span class="line">            var memoryPoolFeature &#x3D; connectionContext.Features.Get&lt;IMemoryPoolFeature&gt;();</span><br><span class="line"></span><br><span class="line">            var httpConnectionContext &#x3D; new HttpConnectionContext</span><br><span class="line">            &#123;</span><br><span class="line">                ConnectionId &#x3D; connectionContext.ConnectionId,</span><br><span class="line">                ConnectionContext &#x3D; connectionContext,</span><br><span class="line">                Protocols &#x3D; _protocols,</span><br><span class="line">                ServiceContext &#x3D; _serviceContext,</span><br><span class="line">                ConnectionFeatures &#x3D; connectionContext.Features,</span><br><span class="line">                MemoryPool &#x3D; memoryPoolFeature.MemoryPool,</span><br><span class="line">                Transport &#x3D; connectionContext.Transport,</span><br><span class="line">                LocalEndPoint &#x3D; connectionContext.LocalEndPoint as IPEndPoint,</span><br><span class="line">                RemoteEndPoint &#x3D; connectionContext.RemoteEndPoint as IPEndPoint</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            var connection &#x3D; new HttpConnection(httpConnectionContext);</span><br><span class="line"></span><br><span class="line">            return connection.ProcessRequestsAsync(_application);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTTP版本控制-HttpConnection"><a href="#HTTP版本控制-HttpConnection" class="headerlink" title="HTTP版本控制 - HttpConnection"></a>HTTP版本控制 - <code>HttpConnection</code></h3><p>当用户创建<code>HttpConnection</code>类时，在初始化过程中，会根据用户请求声明的HTTP协议版本，分别创建对应版本的Connection类，并使用该类处理用户请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public async Task ProcessRequestsAsync&lt;TContext&gt;(IHttpApplication&lt;TContext&gt; httpApplication)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Ensure TimeoutControl._lastTimestamp is initialized before anything that could set timeouts runs.</span><br><span class="line">                _timeoutControl.Initialize(_systemClock.UtcNowTicks);</span><br><span class="line"></span><br><span class="line">                IRequestProcessor requestProcessor &#x3D; null;</span><br><span class="line"></span><br><span class="line">                switch (SelectProtocol())</span><br><span class="line">                &#123;</span><br><span class="line">                    case HttpProtocols.Http1:</span><br><span class="line">                        &#x2F;&#x2F; _http1Connection must be initialized before adding the connection to the connection manager</span><br><span class="line">                        requestProcessor &#x3D; _http1Connection &#x3D; new Http1Connection&lt;TContext&gt;(_context);</span><br><span class="line">                        _protocolSelectionState &#x3D; ProtocolSelectionState.Selected;</span><br><span class="line">                        break;</span><br><span class="line">                    case HttpProtocols.Http2:</span><br><span class="line">                        &#x2F;&#x2F; _http2Connection must be initialized before yielding control to the transport thread,</span><br><span class="line">                        &#x2F;&#x2F; to prevent a race condition where _http2Connection.Abort() is called just as</span><br><span class="line">                        &#x2F;&#x2F; _http2Connection is about to be initialized.</span><br><span class="line">                        requestProcessor &#x3D; new Http2Connection(_context);</span><br><span class="line">                        _protocolSelectionState &#x3D; ProtocolSelectionState.Selected;</span><br><span class="line">                        break;</span><br><span class="line">                    case HttpProtocols.None:</span><br><span class="line">                        &#x2F;&#x2F; An error was already logged in SelectProtocol(), but we should close the connection.</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        &#x2F;&#x2F; SelectProtocol() only returns Http1, Http2 or None.</span><br><span class="line">                        throw new NotSupportedException($&quot;&#123;nameof(SelectProtocol)&#125; returned something other than Http1, Http2 or None.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                _requestProcessor &#x3D; requestProcessor;</span><br><span class="line"></span><br><span class="line">                if (requestProcessor !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    var connectionHeartbeatFeature &#x3D; _context.ConnectionFeatures.Get&lt;IConnectionHeartbeatFeature&gt;();</span><br><span class="line">                    var connectionLifetimeNotificationFeature &#x3D; _context.ConnectionFeatures.Get&lt;IConnectionLifetimeNotificationFeature&gt;();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; These features should never be null in Kestrel itself, if this middleware is ever refactored to run outside of kestrel,</span><br><span class="line">                    &#x2F;&#x2F; we&#39;ll need to handle these missing.</span><br><span class="line">                    Debug.Assert(connectionHeartbeatFeature !&#x3D; null, nameof(IConnectionHeartbeatFeature) + &quot; is missing!&quot;);</span><br><span class="line">                    Debug.Assert(connectionLifetimeNotificationFeature !&#x3D; null, nameof(IConnectionLifetimeNotificationFeature) + &quot; is missing!&quot;);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Register the various callbacks once we&#39;re going to start processing requests</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; The heart beat for various timeouts</span><br><span class="line">                    connectionHeartbeatFeature?.OnHeartbeat(state &#x3D;&gt; ((HttpConnection)state).Tick(), this);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Register for graceful shutdown of the server</span><br><span class="line">                    using var shutdownRegistration &#x3D; connectionLifetimeNotificationFeature?.ConnectionClosedRequested.Register(state &#x3D;&gt; ((HttpConnection)state).StopProcessingNextRequest(), this);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; Register for connection close</span><br><span class="line">                    using var closedRegistration &#x3D; _context.ConnectionContext.ConnectionClosed.Register(state &#x3D;&gt; ((HttpConnection)state).OnConnectionClosed(), this);</span><br><span class="line"></span><br><span class="line">                    await requestProcessor.ProcessRequestsAsync(httpApplication);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Log.LogCritical(0, ex, $&quot;Unexpected exception in &#123;nameof(HttpConnection)&#125;.&#123;nameof(ProcessRequestsAsync)&#125;.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            finally</span><br><span class="line">            &#123;</span><br><span class="line">                if (_http1Connection?.IsUpgraded &#x3D;&#x3D; true)</span><br><span class="line">                &#123;</span><br><span class="line">                    _context.ServiceContext.ConnectionManager.UpgradedConnectionCount.ReleaseOne();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>HTTP1和HTTP2处理HTTP协议的方式有所不同，HTTP1协议解析完成后，会立即调用<code>IHttpApplication&lt;TContext&gt;</code>处理请求，HTTP2协议解析完成后，会再次调用<code>ThreadPool.UnsafeQueueUserWorkItem()</code>方法等待线程池可用线程。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p><code>Kestrel</code>服务的代码量并不下，其中主要是辅助接受用户请求和解析HTTP协议的代码，在这里不做详细的介绍，各位读者有兴趣的，可以详细阅读源代码。</p>
<p>我们看到，<code>Kestrel</code>服务在接受和处理请求时，都用到了线程池，可以极大的提高服务器的吞吐量。</p>
<p>后面，我们还会详细介绍系统默认的<code>IHttpApplication&lt;TContext&gt;</code>实现，看看ASP.NET Core是如何将HTTP转发到Controller和Action，其中又有哪些精妙的代码呢。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>sync</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentDictionary并发字典</title>
    <url>/dotnet-2020-08-16-ConcurrentDictionary/</url>
    <content><![CDATA[<p>ConcurrentDictionary主要用于要从多个线程（或异步任务）修改字典的情景中。如果来自单个线程，则可以根据需要使用尽可能多的代码使用标准Dictionary；）</p>
<p>如果您查看ConcurrentDictionary上的方法，则会发现一些有趣的方法，例如TryAdd，TryGetValue，TryUpdate和TryRemove。</p>
<p>例如，若使用普通的Dictionary类时可能会看到下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; There are better ways to do this... but we need an example ;)</span><br><span class="line">if (!dictionary.ContainsKey(id))</span><br><span class="line">    dictionary.Add(id, value);</span><br></pre></td></tr></table></figure>
<p>多线程中同时调用该段代码,并且使用相同的id来调用Add,它将引发异常。</p>
<p>ConcurrentDictionary方法TryAdd为您处理该问题，并将返回true/false，告诉您是否已添加它（或该键是否已在字典中）。</p>
<p>因此，除非您在代码的多线程部分中进行工作，否则您可能仅可以使用标准的Dictionary类。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>IOptions、IOptionsMonitor以及IOptionsSnapshot</title>
    <url>/dotnet-2020-08-17-netcore-options/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>ASP.NET Core引入了Options模式，使用类来表示相关的设置组。简单的来说，就是用强类型的类来表达配置项，这带来了很多好处。<br>初学者会发现这个框架有3个主要的面向消费者的接口：IOptions<TOptions>、IOptionsMonitor<TOptions>以及IOptionsSnapshot<TOptions>。<br>这三个接口初看起来很类似，所以很容易引起困惑，什么场景下该用哪个接口呢？</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>我们先从一小段代码着手（TestOptions类只有一个字符串属性Name，代码略）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var builder &#x3D; new ConfigurationBuilder();</span><br><span class="line">        builder.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true); &#x2F;&#x2F;注意最后一个参数值，true表示配置文件更改时会重新加载。</span><br><span class="line">        var configuration &#x3D; builder.Build();</span><br><span class="line">        var services &#x3D; new ServiceCollection();</span><br><span class="line">        services.AddOptions();</span><br><span class="line">        services.Configure&lt;TestOptions&gt;(configuration); &#x2F;&#x2F;这里通过配置文件绑定TestOptions</span><br><span class="line">        var provider &#x3D; services.BuildServiceProvider();</span><br><span class="line">        Console.WriteLine(&quot;修改前：&quot;);</span><br><span class="line">        Print(provider);</span><br><span class="line"></span><br><span class="line">        Change(provider); &#x2F;&#x2F;使用代码修改Options值。</span><br><span class="line">        Console.WriteLine(&quot;使用代码修改后：&quot;);</span><br><span class="line">        Print(provider);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;请修改配置文件。&quot;);</span><br><span class="line">        Console.ReadLine(); &#x2F;&#x2F;等待手动修改appsettings.json配置文件。</span><br><span class="line">        Console.WriteLine(&quot;修改appsettings.json文件后：&quot;);</span><br><span class="line">        Print(provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Print(IServiceProvider provider)</span><br><span class="line">    &#123;</span><br><span class="line">        using(var scope &#x3D; provider.CreateScope())</span><br><span class="line">        &#123;</span><br><span class="line">            var sp &#x3D; scope.ServiceProvider;</span><br><span class="line">            var options1 &#x3D; sp.GetRequiredService&lt;IOptions&lt;TestOptions&gt;&gt;();</span><br><span class="line">            var options2 &#x3D; sp.GetRequiredService&lt;IOptionsMonitor&lt;TestOptions&gt;&gt;();</span><br><span class="line">            var options3 &#x3D; sp.GetRequiredService&lt;IOptionsSnapshot&lt;TestOptions&gt;&gt;();</span><br><span class="line">            Console.WriteLine(&quot;IOptions值: &#123;0&#125;&quot;, options1.Value.Name);</span><br><span class="line">            Console.WriteLine(&quot;IOptionsMonitor值: &#123;0&#125;&quot;, options2.CurrentValue.Name);</span><br><span class="line">            Console.WriteLine(&quot;IOptionsSnapshot值: &#123;0&#125;&quot;, options3.Value.Name);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void Change(IServiceProvider provider)</span><br><span class="line">    &#123;</span><br><span class="line">        using(var scope &#x3D; provider.CreateScope())</span><br><span class="line">        &#123;</span><br><span class="line">            var sp &#x3D; scope.ServiceProvider;</span><br><span class="line">            sp.GetRequiredService&lt;IOptions&lt;TestOptions&gt;&gt;().Value.Name &#x3D; &quot;IOptions Test 1&quot;;</span><br><span class="line">            sp.GetRequiredService&lt;IOptionsMonitor&lt;TestOptions&gt;&gt;().CurrentValue.Name &#x3D; &quot;IOptionsMonitor Test 1&quot;;</span><br><span class="line">            sp.GetRequiredService&lt;IOptionsSnapshot&lt;TestOptions&gt;&gt;().Value.Name &#x3D; &quot;IOptionsSnapshot Test 1&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>appsettings.json文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Name&quot;: &quot;Test 0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，首先从appsettings.json文件读取配置，然后向容器注册依赖配置文件的TestOptions，接着分别打印IOptions&lt;&gt;,IOptionsMonitor&lt;&gt;和IOptionsSnapshot&lt;&gt;的值。</p>
<p>接着通过代码来修改TestOptions的值，打印。<br>然后通过修改appsettings.json文件来修改TestOptions的值，打印。</p>
<p>注意，<strong>我们仅注册了一次TestOptions，却可以分别通过IOptions&lt;&gt;,IOptionsMonitor&lt;&gt;和IOptionsSnapshot&lt;&gt;接口来获取TestOptions的值。</strong></p>
<p>如果我们把appsettings.json文件中Name的值修改为Test 2，那么上面这段代码的输出是这样的：</p>
<p><img src="../../assets/images/2020-08-17-netcore-options/94928-20200323160553644-291512622.png" alt="img"></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们可以看到第一次通过代码修改IOptions&lt;&gt;和IOptionsMonitor&lt;&gt;的值后，再次打印都被更新了，但是IOptionsSnapshot&lt;&gt;没有，为什么呢？<br>让我们从Options框架的源代码着手，理解为什么会这样。<br>当我们需要使用Options模式时，我们都会调用定义在OptionsServiceCollectionExtensions类上的扩展方法AddOptions(this IServiceCollection services)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var services &#x3D; new ServiceCollection();</span><br><span class="line">services.AddOptions();</span><br></pre></td></tr></table></figure>

<p>我们观察AddOptions方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IServiceCollection AddOptions(this IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    if (services &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentNullException(nameof(services));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptions&lt;&gt;), typeof(OptionsManager&lt;&gt;)));</span><br><span class="line">    services.TryAdd(ServiceDescriptor.Scoped(typeof(IOptionsSnapshot&lt;&gt;), typeof(OptionsManager&lt;&gt;)));</span><br><span class="line">    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitor&lt;&gt;), typeof(OptionsMonitor&lt;&gt;)));</span><br><span class="line">    services.TryAdd(ServiceDescriptor.Transient(typeof(IOptionsFactory&lt;&gt;), typeof(OptionsFactory&lt;&gt;)));</span><br><span class="line">    services.TryAdd(ServiceDescriptor.Singleton(typeof(IOptionsMonitorCache&lt;&gt;), typeof(OptionsCache&lt;&gt;)));</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码我们可以得知，IOptions&lt;&gt;和IOptionsMonitor&lt;&gt;被注册为单例服务，而IOptionsSnapshot&lt;&gt;被注册为范围服务。<br>由于IOptions&lt;&gt;和IOptionsMonitor&lt;&gt;都被注册为单例服务，因此每次获取的都是同一个实例，所以更改了以后的值是保留的。<br>而IOptionsSnapshot&lt;&gt;被注册为范围服务，所以每次创建新范围时获取的都是一个新的值，外部的更改只对当次有效，不会保留到下次（不能跨范围，对于ASP.NET Core来说不能跨请求）。</p>
<p>我们继续看第二次修改，第二次修改配置文件后IOptionsMonitor&lt;&gt;和IOptionsSnapshot&lt;&gt;的值更新了，而IOptions&lt;&gt;的值没有更新。<br>IOptions&lt;&gt;好理解，它被注册为单例服务，第一次访问的时候生成实例并加载配置文件中的值，此后再也不会读取配置文件，所以它的值不会更新。<br>IOptionsSnapshot&lt;&gt;被注册为范围服务，每次重新生成一个新的范围时，它都会从配置文件中获取值，因此它的值会更新。<br>但是，IOptionsMonitor&lt;&gt;呢，它被注册为单例，为什么也会更新呢？<br>让我们回到AddOptions的源代码，我们留意到IOptionsMonitor&lt;&gt;的实现是OptionsManager&lt;&gt;。<br>当我们打开OptionsManager的源代码时，一切都很清楚了。<br>它的构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public OptionsMonitor(IOptionsFactory&lt;TOptions&gt; factory, IEnumerable&lt;IOptionsChangeTokenSource&lt;TOptions&gt;&gt; sources, IOptionsMonitorCache&lt;TOptions&gt; cache)</span><br><span class="line">&#123;</span><br><span class="line">    _factory &#x3D; factory;</span><br><span class="line">    _sources &#x3D; sources;</span><br><span class="line">    _cache &#x3D; cache;</span><br><span class="line"></span><br><span class="line">    foreach (var source in _sources)</span><br><span class="line">    &#123;</span><br><span class="line">        var registration &#x3D; ChangeToken.OnChange(</span><br><span class="line">                () &#x3D;&gt; source.GetChangeToken(),</span><br><span class="line">                (name) &#x3D;&gt; InvokeChanged(name),</span><br><span class="line">                source.Name);</span><br><span class="line"></span><br><span class="line">        _registrations.Add(registration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来OptionsMonitor的更新能力是从IOptionsChangeTokenSource<TOptions>而来，但是这个接口的实例又是谁呢？<br>我们回到最开始的代码的第10行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.Configure&lt;TestOptions&gt;(configuration);</span><br></pre></td></tr></table></figure>

<p>这是一个定义在Microsoft.Extensions.Options.ConfigurationExtensions.dll的扩展方法，最后实际调用的是它的一个重载方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IServiceCollection Configure&lt;TOptions&gt;(this IServiceCollection services, string name, IConfiguration config, Action&lt;BinderOptions&gt; configureBinder)</span><br><span class="line">    where TOptions : class</span><br><span class="line">&#123;</span><br><span class="line">    if (services &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentNullException(nameof(services));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (config &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new ArgumentNullException(nameof(config));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    services.AddOptions();</span><br><span class="line">    services.AddSingleton&lt;IOptionsChangeTokenSource&lt;TOptions&gt;&gt;(new ConfigurationChangeTokenSource&lt;TOptions&gt;(name, config));</span><br><span class="line">    return services.AddSingleton&lt;IConfigureOptions&lt;TOptions&gt;&gt;(new NamedConfigureFromConfigurationOptions&lt;TOptions&gt;(name, config, configureBinder));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>秘密就在上面的第15行，ConfigurationChangeTokenSource，它引用了代表配置文件的对象config，所以配置文件更新，IOptionsMonitor就会跟着更新。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>IOptions&lt;&gt;是单例，因此一旦生成了，除非通过代码的方式更改，它的值是不会更新的。<br>IOptionsMonitor&lt;&gt;也是单例，但是它通过IOptionsChangeTokenSource&lt;&gt; 能够和配置文件一起更新，也能通过代码的方式更改值。<br>IOptionsSnapshot&lt;&gt;是范围，所以在配置文件更新的下一次访问，它的值会更新，但是它不能跨范围通过代码的方式更改值，只能在当前范围（请求）内有效。</p>
<p>官方文档是这样介绍的：<br>IOptionsMonitor<TOptions>用于检索选项和管理TOptions实例的选项通知，它支持下面的场景：</p>
<ul>
<li>实例更新通知。</li>
<li>命名实例。</li>
<li>重新加载配置。</li>
<li>选择性的让实例失效。</li>
</ul>
<p>IOptionsSnapshot<TOptions>在需要对每个请求重新计算选项的场景中非常有用。<br>IOptions<TOptions>可以用来支持Options模式，但是它不支持前面两者所支持的场景，如果你不需要支持上面的场景，你可以继续使用IOptions<TOptions>。</p>
<p>所以你应该根据你的实际使用场景来选择到底是用这三者中的哪一个。<br><strong>一般来说，如果你依赖配置文件，那么首先考虑IOptionsMonitor&lt;&gt;，如果不合适接着考虑IOptionsSnapshot&lt;&gt;，最后考虑IOptions&lt;&gt;。\</strong><br>****有一点需要注意，在ASP.NET Core应用中IOptionsMonitor可能会导致同一个请求中选项的值不一致——当你正在修改配置文件的时候——这可能会引发一些奇怪的bug。<br>如果这个对你很重要，请使用IOptionsSnapshot，它可以保证同一个请求中的一致性，但是它可能会带来轻微的性能上的损失。<br>如果你是在app启动的时候自己构造Options（比如在Startup类中）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.Configure&lt;TestOptions&gt;(opt &#x3D;&gt; opt.Name &#x3D; &quot;Test 0&quot;);</span><br></pre></td></tr></table></figure>

<p>IOptions&lt;&gt;最简单，也许是一个不错的选择，Configure扩展方法还有其他重载可以满足你的更多需求。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>C</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core/Framework 创建委托以大幅度提高反射调用的性能</title>
    <url>/dotnet-2020-11-13-Reflection-Method/</url>
    <content><![CDATA[<p>都知道反射伤性能，但不得不反射的时候又怎么办呢？当真的被问题逼迫的时候还是能找到解决办法的。</p>
<p>为反射得到的方法创建一个委托，此后调用此委托将能够提高近乎直接调用方法本身的性能。（当然 Emit 也能够帮助我们显著提升性能，不过直接得到可以调用的委托不是更加方便吗？）</p>
<hr>
<h3 id="性能对比数据"><a href="#性能对比数据" class="headerlink" title="性能对比数据"></a>性能对比数据</h3><p><img src="../../assets/images/2020-11-13-Reflection-Method/20180227195855828" alt="性能对比数据"><br>▲ 没有什么能够比数据更有说服力（注意后面两行是有秒数的）</p>
<p>可能我还需要解释一下那五行数据的含义：</p>
<ol>
<li>直接调用（��<em>应该没有什么比直接调用函数本身更有性能优势的吧</em>）</li>
<li>做一个跟直接调用的方法功能一模一样的委托（��<em>目的是看看调用委托相比调用方法本身是否有性能损失，从数据上看，损失非常小</em>）</li>
<li><strong>本文重点</strong> 将反射出来的方法创建一个委托，然后调用这个委托（��<em>看看吧，性能跟直接调差别也不大嘛</em>）</li>
<li>先反射得到方法，然后一直调用这个方法（��<em>终于可以看出来反射本身还是挺伤性能的了，50 多倍的性能损失啊</em>）</li>
<li>缓存都不用，从头开始反射然后调用得到的方法（��<em>100 多倍的性能损失了</em>）</li>
</ol>
<p>以下是测试代码，可以更好地理解上图数据的含义：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Walterlv.Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 调用的目标实例。</span></span><br><span class="line">            <span class="keyword">var</span> instance = <span class="keyword">new</span> StubClass();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射找到的方法。</span></span><br><span class="line">            <span class="keyword">var</span> method = <span class="keyword">typeof</span>(StubClass).GetMethod(<span class="keyword">nameof</span>(StubClass.Test), <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>) &#125;);</span><br><span class="line">            Assert.IsNotNull(method);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将反射找到的方法创建一个委托。</span></span><br><span class="line">            <span class="keyword">var</span> func = InstanceMethodBuilder&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;.CreateInstanceMethod(instance, method);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跟被测方法功能一样的纯委托。</span></span><br><span class="line">            Func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pureFunc = <span class="keyword">value</span> =&gt; <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 测试次数。</span></span><br><span class="line">            <span class="keyword">var</span> count = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接调用。</span></span><br><span class="line">            <span class="keyword">var</span> watch = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">            watch.Start();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = instance.Test(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 直接调用"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用同样功能的 Func 调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = pureFunc(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 使用同样功能的 Func 调用"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射创建出来的委托调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = func(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 使用反射创建出来的委托调用"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反射得到的方法缓存调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = method.Invoke(instance, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">5</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 使用反射得到的方法缓存调用"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 直接使用反射调用。</span></span><br><span class="line">            watch.Restart();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> result = <span class="keyword">typeof</span>(StubClass).GetMethod(<span class="keyword">nameof</span>(StubClass.Test), <span class="keyword">new</span>[] &#123; <span class="keyword">typeof</span>(<span class="keyword">int</span>) &#125;)</span><br><span class="line">                    ?.Invoke(instance, <span class="keyword">new</span> <span class="keyword">object</span>[] &#123; <span class="number">5</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            watch.Stop();</span><br><span class="line">            Console.WriteLine(<span class="string">$"<span class="subst">&#123;watch.Elapsed&#125;</span> - <span class="subst">&#123;count&#125;</span> 次 - 直接使用反射调用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">StubClass</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Test</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>实现的关键就在于 <code>MethodInfo.CreateDelegate</code> 方法。这是 .NET Standard 中就有的方法，这意味着 .NET Framework 和 .NET Core 中都可以使用。</p>
<p>此方法有两个重载：</p>
<ul>
<li>要求传入一个类型，而这个类型就是应该转成的委托的类型</li>
<li>要求传入一个类型和一个实例，一样的，类型是应该转成的委托的类型</li>
</ul>
<p>他们的区别在于前者创建出来的委托是直接调用那个实例方法本身，后者则更原始一些，真正调用的时候还需要传入一个实例对象。</p>
<p>拿上面的 <code>StubClass</code> 来说明会更直观一些：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">StubClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Test</span>(<span class="params"><span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前者得到的委托相当于 <code>int Test(int i)</code> 方法，后者得到的委托相当于 <code>int Test(StubClass instance, int i)</code> 方法。（在 IL 里实例的方法其实都是后者，而前者更像 C# 中的代码，容易理解。）</p>
<p>单独使用 <code>CreateDelegate</code> 方法可能每次都需要尝试第一个参数到底应该传入些什么，于是我将其封装成了泛型版本，增加易用性。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Reflection;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics.Contracts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Walterlv.Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    public static class InstanceMethodBuilder&lt;T, TReturnValue&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 调用时就像 var result = func(t)。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Pure</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Func&lt;T, TReturnValue&gt; CreateInstanceMethod&lt;TInstanceType&gt;(TInstanceType instance, MethodInfo method)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(instance));</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(method));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Func&lt;T, TReturnValue&gt;) method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;T, TReturnValue&gt;), instance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 调用时就像 var result = func(this, t)。</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        [<span class="meta">Pure</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Func&lt;TInstanceType, T, TReturnValue&gt; CreateMethod&lt;TInstanceType&gt;(MethodInfo method)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(method));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (Func&lt;TInstanceType, T, TReturnValue&gt;) method.CreateDelegate(<span class="keyword">typeof</span>(Func&lt;TInstanceType, T, TReturnValue&gt;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型的多参数版本可以使用泛型类型生成器生成，我在 <a href="http://blog.csdn.net/WPwalter/article/details/79216183" target="_blank" rel="noopener">生成代码，从 <code>到</code> —— 自动生成多个类型的泛型 - 吕毅</a> 一文中写了一个泛型生成器，可以稍加修改以便适应这种泛型类。</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>C＃枚举中使用Flags特性</title>
    <url>/dotnet-2020-11-24-flags/</url>
    <content><![CDATA[<p>假如有类型 Show 的定义如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">十進位表示法</span><br><span class="line">[Flags]</span><br><span class="line">enum Days</span><br><span class="line">&#123;</span><br><span class="line">    None      &#x3D; 0,  &#x2F;&#x2F; 0000 0000</span><br><span class="line">    Sunday    &#x3D; 1,  &#x2F;&#x2F; 0000 0001</span><br><span class="line">    Monday    &#x3D; 2,  &#x2F;&#x2F; 0000 0010</span><br><span class="line">    Tuesday   &#x3D; 4,  &#x2F;&#x2F; 0000 0100</span><br><span class="line">    Wednesday &#x3D; 8,  &#x2F;&#x2F; 0000 1000</span><br><span class="line">    Thursday  &#x3D; 16, &#x2F;&#x2F; 0001 0000</span><br><span class="line">    Friday    &#x3D; 32, &#x2F;&#x2F; 0010 0000</span><br><span class="line">    Saturday  &#x3D; 64  &#x2F;&#x2F; 0100 0000</span><br><span class="line">&#125;</span><br><span class="line">位元移位表示法</span><br><span class="line">[Flags]</span><br><span class="line">enum Days</span><br><span class="line">&#123;</span><br><span class="line">    None      &#x3D; 0,      &#x2F;&#x2F; 0000 0000</span><br><span class="line">    Sunday    &#x3D; 1 &lt;&lt; 0, &#x2F;&#x2F; 0000 0001</span><br><span class="line">    Monday    &#x3D; 1 &lt;&lt; 1, &#x2F;&#x2F; 0000 0010</span><br><span class="line">    Tuesday   &#x3D; 1 &lt;&lt; 2, &#x2F;&#x2F; 0000 0100</span><br><span class="line">    Wednesday &#x3D; 1 &lt;&lt; 3, &#x2F;&#x2F; 0000 1000</span><br><span class="line">    Thursday  &#x3D; 1 &lt;&lt; 4, &#x2F;&#x2F; 0001 0000</span><br><span class="line">    Friday    &#x3D; 1 &lt;&lt; 5, &#x2F;&#x2F; 0010 0000</span><br><span class="line">    Saturday  &#x3D; 1 &lt;&lt; 6  &#x2F;&#x2F; 0100 0000</span><br><span class="line">&#125;</span><br><span class="line">二進位表示法 (C# 7.2新增)</span><br><span class="line">[Flags]</span><br><span class="line">enum Days</span><br><span class="line">&#123;</span><br><span class="line">    None      &#x3D; 0b_0000_0000, &#x2F;&#x2F; 0000 0000</span><br><span class="line">    Sunday    &#x3D; 0b_0000_0001, &#x2F;&#x2F; 0000 0001</span><br><span class="line">    Monday    &#x3D; 0b_0000_0010, &#x2F;&#x2F; 0000 0010</span><br><span class="line">    Tuesday   &#x3D; 0b_0000_0100, &#x2F;&#x2F; 0000 0100</span><br><span class="line">    Wednesday &#x3D; 0b_0000_1000, &#x2F;&#x2F; 0000 1000</span><br><span class="line">    Thursday  &#x3D; 0b_0001_0000, &#x2F;&#x2F; 0001 0000</span><br><span class="line">    Friday    &#x3D; 0b_0010_0000, &#x2F;&#x2F; 0010 0000</span><br><span class="line">    Saturday  &#x3D; 0b_0100_0000  &#x2F;&#x2F; 0100 0000</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">十六進位表示法</span><br><span class="line">[Flags]</span><br><span class="line">enum RenderType</span><br><span class="line">&#123;</span><br><span class="line">   None &#x3D; 0x0,</span><br><span class="line">   DataUri &#x3D; 0x1,</span><br><span class="line">   GZip &#x3D; 0x2,</span><br><span class="line">   ContentPage &#x3D; 0x4,</span><br><span class="line">   ViewPage &#x3D; 0x8,</span><br><span class="line">   HomePage &#x3D; 0x10 &#x2F;&#x2F; Next two values could be 0x20, 0x40</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>&amp; 按位与</li>
<li>| 按位或</li>
<li>^ 按位异或</li>
<li>~取反</li>
</ul>
<h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><p>a|b: 并集(所有的和,相同部分只算一次);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; A &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;物理&#39;,&#39;化学&#39;,&#39;生物&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; B &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;政治&#39;,&#39;地理&#39;,&#39;历史&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; A | B</span><br><span class="line">&#123;&#39;英语&#39;, &#39;物理&#39;, &#39;语文&#39;, &#39;政治&#39;, &#39;化学&#39;, &#39;数学&#39;, &#39;生物&#39;, &#39;地理&#39;, &#39;历史&#39;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-11-24-flags/image-20210404182659146.png" alt="image-20210404182659146"></p>
<h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; A &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;物理&#39;,&#39;化学&#39;,&#39;生物&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; B &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;政治&#39;,&#39;地理&#39;,&#39;历史&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; A &amp; (~B)</span><br><span class="line">&#123;&#39;物理&#39;, &#39;生物&#39;, &#39;化学&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; B &amp; (~A)</span><br><span class="line">&#123;&#39;政治&#39;, &#39;历史&#39;, &#39;地理&#39;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-11-24-flags/image-20210404182718872.png" alt="image-20210404182718872"></p>
<h2 id="补集-对称差集"><a href="#补集-对称差集" class="headerlink" title="补集(对称差集)"></a>补集(对称差集)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; A &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;物理&#39;,&#39;化学&#39;,&#39;生物&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; B &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;政治&#39;,&#39;地理&#39;,&#39;历史&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; A ^ B</span><br><span class="line">&#123;&#39;物理&#39;, &#39;生物&#39;, &#39;化学&#39;, &#39;政治&#39;, &#39;历史&#39;, &#39;地理&#39;&#125;</span><br></pre></td></tr></table></figure>



<p><img src="../../assets/images/2020-11-24-flags/image-20210404182742701.png" alt="image-20210404182742701"></p>
<p><img src="../../assets/images/2020-11-24-flags/image-20210404182802570.png" alt="image-20210404182802570"></p>
<h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; A &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;物理&#39;,&#39;化学&#39;,&#39;生物&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; B &#x3D; &#123;&#39;数学&#39;,&#39;语文&#39;,&#39;英语&#39;,&#39;政治&#39;,&#39;地理&#39;,&#39;历史&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; A &amp; B</span><br><span class="line">&#123;&#39;英语&#39;, &#39;语文&#39;, &#39;数学&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Show show &#x3D; Show.A | Show.B;</span><br><span class="line">show.HasFlag(Show.A);</span><br></pre></td></tr></table></figure>
<p>从性能上看通过 <code>&amp;</code> 的性能会比 HasFlag 高，但是从可读性上 HasFlag 更友好，如果你的代码没有性能问题推荐使用 HasFlag 方法</p>
<p><img src="../../assets/images/2020-11-24-flags/image-20210404182612251.png" alt="image-20210404182612251"></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌浏览器下netcore登录失败问题</title>
    <url>/dotnet-2020-12-11-chrome-login-fail/</url>
    <content><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>When you use HTTP on your Identity Server 4 enabled website, users may not login because of the changes made by Chrome in the version 8x. This occurs when you use HTTP schema in your website. The issue is explained here <a href="https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication" target="_blank" rel="noopener">https://docs.microsoft.com/en-gb/dotnet/core/compatibility/3.0-3.1#http-browser-samesite-changes-impact-authentication</a></p>
<h2 id="How-to-solve-it"><a href="#How-to-solve-it" class="headerlink" title="How to solve it?"></a>How to solve it?</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step-1"></a>Step-1</h3><p>Create the below extension in your <strong>*.Web</strong> project.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Builder;</span><br><span class="line"><span class="keyword">using</span> Microsoft.AspNetCore.Http;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.Extensions.DependencyInjection</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SameSiteCookiesServiceCollectionExtensions</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> -1 defines the unspecified value, which tells ASPNET Core to NOT</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> send the SameSite attribute. With ASPNET Core 3.1 the</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;seealso cref="SameSiteMode" /&gt;</span> enum will have a definition for</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Unspecified.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> SameSiteMode Unspecified = (SameSiteMode)(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Configures a cookie policy to properly set the SameSite attribute</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> for Browsers that handle unknown values as Strict. Ensure that you</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> add the <span class="doctag">&lt;seealso cref="Microsoft.AspNetCore.CookiePolicy.CookiePolicyMiddleware" /&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> into the pipeline before sending any cookies!</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Minimum ASPNET Core Version required for this code:</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>   - 2.1.14</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>   - 2.2.8</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>   - 3.0.1</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>   - 3.1.0-preview1</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Starting with version 80 of Chrome (to be released in February 2020)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> cookies with NO SameSite attribute are treated as SameSite=Lax.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> In order to always get the cookies send they need to be set to</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> SameSite=None. But since the current standard only defines Lax and</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Strict as valid values there are some browsers that treat invalid</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> values as SameSite=Strict. We therefore need to check the browser</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> and either send SameSite=None or prevent the sending of SameSite=None.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Relevant links:</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> - https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> - https://tools.ietf.org/html/draft-west-cookie-incrementalism-00</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> - https://www.chromium.org/updates/same-site</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> - https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> - https://bugs.webkit.org/show_bug.cgi?id=198181</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="services"&gt;</span>The service collection to register <span class="doctag">&lt;see cref="CookiePolicyOptions" /&gt;</span> into.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>The modified <span class="doctag">&lt;see cref="IServiceCollection" /&gt;</span>.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IServiceCollection <span class="title">ConfigureNonBreakingSameSiteCookies</span>(<span class="params"><span class="keyword">this</span> IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.MinimumSameSitePolicy = Unspecified;</span><br><span class="line">                options.OnAppendCookie = cookieContext =&gt;</span><br><span class="line">                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);</span><br><span class="line">                options.OnDeleteCookie = cookieContext =&gt;</span><br><span class="line">                CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> services;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CheckSameSite</span>(<span class="params">HttpContext httpContext, CookieOptions options</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">if</span> (options.SameSite == SameSiteMode.None)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">var</span> userAgent = httpContext.Request.Headers[<span class="string">"User-Agent"</span>].ToString();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DisallowsSameSiteNone(userAgent))</span><br><span class="line">                &#123;</span><br><span class="line">                    options.SameSite = Unspecified;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Checks if the UserAgent is known to interpret an unknown value as Strict.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> For those the <span class="doctag">&lt;see cref="CookieOptions.SameSite" /&gt;</span> property should be</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> set to <span class="doctag">&lt;see cref="Unspecified" /&gt;</span>.</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> This code is taken from Microsoft:</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> https://devblogs.microsoft.com/aspnet/upcoming-samesite-cookie-changes-in-asp-net-and-asp-net-core/</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/remarks&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="userAgent"&gt;</span>The user agent string to check.<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>Whether the specified user agent (browser) accepts SameSite=None or not.<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">DisallowsSameSiteNone</span>(<span class="params"><span class="keyword">string</span> userAgent</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// Cover all iOS based browsers here. This includes:</span></span><br><span class="line">            <span class="comment">//   - Safari on iOS 12 for iPhone, iPod Touch, iPad</span></span><br><span class="line">            <span class="comment">//   - WkWebview on iOS 12 for iPhone, iPod Touch, iPad</span></span><br><span class="line">            <span class="comment">//   - Chrome on iOS 12 for iPhone, iPod Touch, iPad</span></span><br><span class="line">            <span class="comment">// All of which are broken by SameSite=None, because they use the</span></span><br><span class="line">            <span class="comment">// iOS networking stack.</span></span><br><span class="line">            <span class="comment">// Notes from Thinktecture:</span></span><br><span class="line">            <span class="comment">// Regarding https://caniuse.com/#search=samesite iOS versions lower</span></span><br><span class="line">            <span class="comment">// than 12 are not supporting SameSite at all. Starting with version 13</span></span><br><span class="line">            <span class="comment">// unknown values are NOT treated as strict anymore. Therefore we only</span></span><br><span class="line">            <span class="comment">// need to check version 12.</span></span><br><span class="line">            <span class="keyword">if</span> (userAgent.Contains(<span class="string">"CPU iPhone OS 12"</span>)</span><br><span class="line">               || userAgent.Contains(<span class="string">"iPad; CPU OS 12"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cover Mac OS X based browsers that use the Mac OS networking stack.</span></span><br><span class="line">            <span class="comment">// This includes:</span></span><br><span class="line">            <span class="comment">//   - Safari on Mac OS X.</span></span><br><span class="line">            <span class="comment">// This does not include:</span></span><br><span class="line">            <span class="comment">//   - Chrome on Mac OS X</span></span><br><span class="line">            <span class="comment">// because they do not use the Mac OS networking stack.</span></span><br><span class="line">            <span class="comment">// Notes from Thinktecture:</span></span><br><span class="line">            <span class="comment">// Regarding https://caniuse.com/#search=samesite MacOS X versions lower</span></span><br><span class="line">            <span class="comment">// than 10.14 are not supporting SameSite at all. Starting with version</span></span><br><span class="line">            <span class="comment">// 10.15 unknown values are NOT treated as strict anymore. Therefore we</span></span><br><span class="line">            <span class="comment">// only need to check version 10.14.</span></span><br><span class="line">            <span class="keyword">if</span> (userAgent.Contains(<span class="string">"Safari"</span>)</span><br><span class="line">               &amp;&amp; userAgent.Contains(<span class="string">"Macintosh; Intel Mac OS X 10_14"</span>)</span><br><span class="line">               &amp;&amp; userAgent.Contains(<span class="string">"Version/"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cover Chrome 50-69, because some versions are broken by SameSite=None</span></span><br><span class="line">            <span class="comment">// and none in this range require it.</span></span><br><span class="line">            <span class="comment">// Note: this covers some pre-Chromium Edge versions,</span></span><br><span class="line">            <span class="comment">// but pre-Chromium Edge does not require SameSite=None.</span></span><br><span class="line">            <span class="comment">// Notes from Thinktecture:</span></span><br><span class="line">            <span class="comment">// We can not validate this assumption, but we trust Microsofts</span></span><br><span class="line">            <span class="comment">// evaluation. And overall not sending a SameSite value equals to the same</span></span><br><span class="line">            <span class="comment">// behavior as SameSite=None for these old versions anyways.</span></span><br><span class="line">            <span class="keyword">if</span> (userAgent.Contains(<span class="string">"Chrome/5"</span>) || userAgent.Contains(<span class="string">"Chrome/6"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (GetChromeVersion(userAgent) &gt;= <span class="number">80</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetChromeVersion</span>(<span class="params"><span class="keyword">string</span> userAgent</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> Convert.ToInt32(userAgent.Split(<span class="string">"Chrome/"</span>)[<span class="number">1</span>].Split(<span class="string">'.'</span>)[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step-2"></a>Step-2</h3><p>Assume that your project name is <em>Acme.BookStore</em>. Then open <code>AcmeBookStoreWebModule.cs</code> class.</p>
<p>Add the following line to <code>ConfigureServices()</code> method.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">context.Services.ConfigureNonBreakingSameSiteCookies();</span><br></pre></td></tr></table></figure>



<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step-3"></a>Step-3</h3><p>Go to<code>OnApplicationInitialization()</code> method in <code>AcmeBookStoreWebModule.cs</code> add <code>app.UseCookiePolicy();</code></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnApplicationInitialization</span>(<span class="params">ApplicationInitializationContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> app = context.GetApplicationBuilder();</span><br><span class="line">        <span class="keyword">var</span> env = context.GetEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">        &#123;</span><br><span class="line">                app.UseDeveloperExceptionPage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                app.UseErrorPage();</span><br><span class="line">                app.UseHsts();</span><br><span class="line">        &#125;</span><br><span class="line">		 <span class="comment">// Before UseAuthentication or anything else that writes cookies.</span></span><br><span class="line">        app.UseCookiePolicy(); <span class="comment">//&lt;--- added this ---&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>It’s all! You are ready to go!</p>
<hr>
<p>Referenced from <a href="https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/" target="_blank" rel="noopener">https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/</a></p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>NETCORE</tag>
        <tag>Win</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Converting between Structs and Byte Arrays</title>
    <url>/dotnet-2021-05-01-Converting-between-Structs-and-Byte-Arrays/</url>
    <content><![CDATA[<p>In object-oriented code bases, we tend to express most of not all of our data in highly semantic and contextual ways – that is, we use classes that contain both data and behaviour, and often even more information through inheritance, attributes, and more.</p>
<p>However, sometimes we need to extract the data contained in these types – for example for sending network messages, or saving to disk. In this post we will look into converting between structs and byte arrays, to make exactly this possible.</p>
<p>We will compare different ways of doing so, and analyse them for performance and easy of use.</p>
<h2 id="Why-byte-arrays"><a href="#Why-byte-arrays" class="headerlink" title="Why byte arrays?"></a>Why byte arrays?</h2><p>The reason we will be looking into serialising our data into byte arrays is because these are essentially the most fundamental data storage format. We can easily write them to a network buffer or stream, or to a file.</p>
<p>There are many alternatives and none of them will be right for every single use case. For example, I like to use JSON files to store settings, scripts, and text-based assets, as well as asset meta data.</p>
<p>In those cases performance is not the most important consideration. Instead it is more valuable to be able to edit and review files easily inside a text editor.</p>
<p>In situations where performance is important however – such as the mentioned networking or compact file storage – serialising only the relevant data itself and skipping the encoding and formatting inherent to clear text files can be key.</p>
<h2 id="Why-structures"><a href="#Why-structures" class="headerlink" title="Why structures?"></a>Why structures?</h2><p>There are several reasons for why we are talking about structures specifically.</p>
<p>First, I want to make a clear distinction between data and behaviour, by using a type that contains exactly the data we are interested in serialising.</p>
<p>Secondly, structures are much more reliable and controllable when it comes to binary data layout. We will see how this is important for our last method of serialisation.</p>
<p>Overall, we can use structures to directly represent the data that will be written into our byte array. For our example of networking this means that we have a clear one to one correspondence between our structures and our network messages.</p>
<h2 id="BinaryFormatter"><a href="#BinaryFormatter" class="headerlink" title="BinaryFormatter"></a><code>BinaryFormatter</code></h2><p>In our first method of converting between structs and byte arrays, we will make use of .NET’s <a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx" target="_blank" rel="noopener">BinaryFormatter</a> class.</p>
<p>The entire purpose of that class is to serialise an object into binary format (i.e. a byte array) – as well as deserialising the same back into objects.</p>
<p>The class offers a lot of functionality – most of which we are not interested in here. Of interest to us are only two methods: <code>Serialize()</code> and <code>Deserialize()</code>.</p>
<p>These methods allow us to read/write our data to any stream. In many cases we could use this to write to a network – or file – buffer or stream directly. For our purpose – and for ease of testing, we will use the <code>MemoryStream</code> class which is little more than a stream wrapper around a byte array in the first place.</p>
<p>Here are two generic methods that do exactly this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static byte[] Serialize&lt;T&gt;(T data)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var formatter &#x3D; new BinaryFormatter();</span><br><span class="line">    var stream &#x3D; new MemoryStream();</span><br><span class="line">    formatter.Serialize(stream, data);</span><br><span class="line">    return stream.ToArray();</span><br><span class="line">&#125;</span><br><span class="line">public static T Deserialize&lt;T&gt;(byte[] array)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var stream &#x3D; new MemoryStream(array);</span><br><span class="line">    var formatter &#x3D; new BinaryFormatter();</span><br><span class="line">    return (T)formatter.Deserialize(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>These methods can now be easily used like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Serializable] &#x2F;&#x2F; BinaryFormatter needs this attribute</span><br><span class="line">struct MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; some fields here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var data &#x3D; new MyStruct();</span><br><span class="line">var bytes &#x3D; Serialize(data);</span><br><span class="line">var data2 &#x3D; Deserialize&lt;MyStruct&gt;(bytes);</span><br><span class="line">&#x2F;&#x2F; data and data2 now contain the same values</span><br></pre></td></tr></table></figure>

<p>This looks great!</p>
<p>It seems that we have found a solution that is both easy to use, and requires almost no work if we want to expand it. Allowing for the conversion of new structs simple requires the addition of the <code>Serializable</code> attribute, while we have to do nothing at all if we modify our structures to include more, less, or different data.</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>How about performance?</p>
<p>I wrote a little test that both serialises and deserialises hundreds of thousands of times, and repeats that process several times to make sure we get accurate results. You can find the full code of it <a href="https://github.com/amulware/genericgamedev-tests/tree/master/src/StructByteArrayConversion" target="_blank" rel="noopener">on my GitHub</a></p>
<p>Here are the results:</p>
<p>Using <code>BinaryFormatter</code>,<br>– converting a 16 byte structs to an array one million times takes 4.86 seconds;<br>– converting an array to a 16 byte struct one million times takes 3.85 seconds.</p>
<p>This means that a single call to either of our methods takes less than 5 microseconds.</p>
<p>That is pretty good!</p>
<p>With this performance we can easily write and read thousands of networking messages per second before we will notice the performance impact. That is easily enough for most games and other real-time applications.</p>
<p>There is another kind of performance measurement that is important however – and especially so when it comes to networking: Bandwidth.</p>
<p>The struct I ran the tests with consisted of exactly 16 bytes. That means that in principle we should be able to write it into a byte array with length 16. The BinaryFormatter however – and this is related to the other features it has – writes a total of 218 bytes to the array.</p>
<p>Suffice it to say: That is a whole lot more.</p>
<p>The advantage of this is, that the object that is deserialised will actually be of the correct type. I merely made the method generic so that we could perform the cast and return the structure boxed in the result of <code>BinaryFormatter.Deserialize()</code>.</p>
<p>There are cases were we care less about the amount of data, and prefer to handle our data in this way. For this post however, I want to find a method that results in an array as small as possible.</p>
<h2 id="BinaryWriter-BinaryReader"><a href="#BinaryWriter-BinaryReader" class="headerlink" title="BinaryWriter/BinaryReader"></a><code>BinaryWriter</code>/<code>BinaryReader</code></h2><p>Our second case study will be two other .NET classes: <a href="https://msdn.microsoft.com/en-us/library/system.io.binaryreader(v=vs.110).aspx" target="_blank" rel="noopener">BinaryWriter</a> and <a href="https://msdn.microsoft.com/en-us/library/system.io.binarywriter(v=vs.110).aspx" target="_blank" rel="noopener">BinaryReader</a></p>
<p>These classes are much simpler. They do little more than allowing us to write and read primitive types like integers and booleans to and from an arbitrary stream.</p>
<p>This means that we cannot write the entire structure to our stream with just a single line of code any more. Instead we need to write and read all fields manually:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MyStruct</span><br><span class="line">&#123;</span><br><span class="line">    int anInteger;</span><br><span class="line">    float aFloat;</span><br><span class="line">    long aLong;</span><br><span class="line"></span><br><span class="line">    public byte[] ToArray()</span><br><span class="line">    &#123;</span><br><span class="line">        var stream &#x3D; new MemoryStream();</span><br><span class="line">        var writer &#x3D; new BinaryWriter(stream);</span><br><span class="line"></span><br><span class="line">        writer.Write(this.anInteger);</span><br><span class="line">        writer.Write(this.aFloat);</span><br><span class="line">        writer.Write(this.aLong);</span><br><span class="line"></span><br><span class="line">        return stream.ToArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static MyStruct FromArray(byte[] bytes)</span><br><span class="line">    &#123;</span><br><span class="line">        var reader &#x3D; new BinaryReader(new MemoryStream(bytes));</span><br><span class="line"></span><br><span class="line">        var s &#x3D; default(MyStruct);</span><br><span class="line"></span><br><span class="line">        s.anInteger &#x3D; reader.ReadInt32();</span><br><span class="line">        s.aFloat &#x3D; reader.ReadSingle();</span><br><span class="line">        s.aLong &#x3D; reader.ReadInt64();</span><br><span class="line"></span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using these methods is similarly easy to the ones above:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data &#x3D; new MyStruct();</span><br><span class="line">var array &#x3D; data.ToArray();</span><br><span class="line">var data2 &#x3D; MyStruct.FromArray(array);</span><br></pre></td></tr></table></figure>

<p>In this case, the returned array is indeed exactly 16 bytes long.</p>
<h3 id="Performance-1"><a href="#Performance-1" class="headerlink" title="Performance"></a>Performance</h3><p>But how does this manual approach measure up in performance?</p>
<p>Very well!</p>
<p>In my test, the times for serialising and deserialising went from 4.86 and 3.85 down to 0.50 and 0.20 seconds respectively (again for one million conversions each).</p>
<p>It turns out this approach is not only space efficient, but it is also around ten times faster than the previous one – seemingly no reason to look back!</p>
<p>In fact, there is an optimisation we can make to increase performance even further: We do not have to create new <code>MemoryStream</code>s and <code>BinaryReader</code>/<code>BinaryWriter</code>s for each method call. Instead we can reuse them – either by having static ones (watch out for thread-safety!) or by keeping them in whatever object manages for example our network traffic.</p>
<p>Doing so drops my measured time down to 0.14 and 0.11 seconds respectively.</p>
<p>Note that the same optimisation can be applied to the first method. However – while positive – the performance increase is much less than in this case, relative to the overall much worse time.</p>
<h3 id="Some-concerns"><a href="#Some-concerns" class="headerlink" title="Some concerns"></a>Some concerns</h3><p>If we do look back to the code however, note how if we add another structure that we would like to serialise, we have to add the two methods to it, and adapt them to its fields.</p>
<p>Further, if we change one of our structures, we have to make sure to reflect that change in both of these methods. We are bound to forget – especially when adding a new field – which could easily result in a small debugging nightmare.</p>
<p>Ideally we can find a solution that is fast, uses little space, and does not require us to continuously maintain our serialisation code.</p>
<h2 id="Marshalling"><a href="#Marshalling" class="headerlink" title="Marshalling"></a>Marshalling</h2><p>The last approach we will take a look at is that of marshalling.</p>
<p>Marshalling refers to using both managed and unmanaged data and the transfer between them. By default, any object created in C# lives in managed memory, which has a lot of advantages – such as automatic garbage collection. Using unmanaged memory on the other hand is more difficult in C#, and requires us to allocate and free space manually. If we forget to do so, we may cause memory leaks that will eventually cause our application to crash.</p>
<p>All of the functionality we are interested in can be found in the static <a href="https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.marshal(v=vs.100).aspx" target="_blank" rel="noopener">Marshal</a> class.</p>
<p>Specifically, we will use:</p>
<ul>
<li><code>Marshal.SizeOf()</code><br>to determine the byte size of our structs;</li>
<li><code>Marshal.AllocHGlobal()</code><br>to allocate unmanaged memory;</li>
<li><code>Marshal.StructureToPtr()</code><br>to marshal (copy) our structure to the allocated unmanaged memory;</li>
<li><code>Marshal.PtrToStructure()</code><br>to marshal (copy) from unmanaged memory back to our structure;</li>
<li><code>Marshal.Copy()</code><br>to copy between the unmanaged memory and our byte array;</li>
<li><code>Marshal.FreeHGlobal()</code><br>to free the allocated memory;</li>
</ul>
<p>Using these methods we can construct the following methods:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static byte[] Serialize&lt;T&gt;(T s)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var size &#x3D; Marshal.SizeOf(typeof(T));</span><br><span class="line">    var array &#x3D; new byte[size];</span><br><span class="line">    var ptr &#x3D; Marshal.AllocHGlobal(size);</span><br><span class="line">    Marshal.StructureToPtr(s, ptr, true);</span><br><span class="line">    Marshal.Copy(ptr, array, 0, size);</span><br><span class="line">    Marshal.FreeHGlobal(ptr);</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static T Deserialize&lt;T&gt;(byte[] array)</span><br><span class="line">    where T : struct</span><br><span class="line">&#123;</span><br><span class="line">    var size &#x3D; Marshal.SizeOf(typeof(T));</span><br><span class="line">    var ptr &#x3D; Marshal.AllocHGlobal(size);</span><br><span class="line">    Marshal.Copy(array, 0, ptr, size);</span><br><span class="line">    var s &#x3D; (T)Marshal.PtrToStructure(ptr, typeof(T));</span><br><span class="line">    Marshal.FreeHGlobal(ptr);</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that due to the unsafety of using unmanaged memory, we may want to use a <a href="https://msdn.microsoft.com/en-us/library/zwc8s4fz.aspx" target="_blank" rel="noopener">try – finally</a> block to make sure the memory will always be freed, even if something goes wrong. For brevity, this is left out here.</p>
<p>When testing our code, which again is as easy to use as before – in fact the method signatures are exactly the same as our first pair – we see that it indeed works as we hope.</p>
<p>Without any code inside our structures and completely generic methods there is no need to write or maintain any code when adding or modifying structures.</p>
<p>Further the resulting array is the expected 16 bytes long.</p>
<h3 id="Performance-2"><a href="#Performance-2" class="headerlink" title="Performance"></a>Performance</h3><p>When running these methods through the tests, converting structs to byte arrays and vice versa takes a mere 0.47 and 0.60 seconds respectively (again for one million calls).</p>
<h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p>Here is a table with the results from the performance tests:</p>
<table>
<thead>
<tr>
<th align="left">16 byte struct</th>
<th align="left">struct to array</th>
<th align="left">array to struct</th>
</tr>
</thead>
<tbody><tr>
<td align="left">binary formatter (218 byte array!)</td>
<td align="left">4.86s</td>
<td align="left">3.85s</td>
</tr>
<tr>
<td align="left">binary writer/reader</td>
<td align="left">0.50s</td>
<td align="left">0.20s</td>
</tr>
<tr>
<td align="left"><strong>binary w/r (singleton)</strong></td>
<td align="left"><strong>0.14s</strong></td>
<td align="left"><strong>0.11s</strong></td>
</tr>
<tr>
<td align="left">marshalling</td>
<td align="left">0.47s</td>
<td align="left">0.60s</td>
</tr>
</tbody></table>
<p>Clearly, if what we care about most is performance, writing and reading our data manually, using shared <code>BinaryWriter</code> and <code>BinaryReader</code> objects is the fastest method.</p>
<p>On the other hand, the <code>BinaryFormatter</code> and <code>Marshal</code> methods allow for much easier reuse and make our code significantly more robust to change since there is no code to update and maintain.</p>
<p>To provide some more data, here are the results from the same test, but this time with a 128 byte structure:</p>
<table>
<thead>
<tr>
<th align="left">128 byte struct</th>
<th align="left">struct to array</th>
<th align="left">array to struct</th>
</tr>
</thead>
<tbody><tr>
<td align="left">binary formatter (218 byte array!)</td>
<td align="left">17.32s</td>
<td align="left">14.47s</td>
</tr>
<tr>
<td align="left">binary writer/reader</td>
<td align="left">1.48s</td>
<td align="left">0.66s</td>
</tr>
<tr>
<td align="left"><strong>binary w/r (singleton)</strong></td>
<td align="left"><strong>0.78s</strong></td>
<td align="left"><strong>0.56s</strong></td>
</tr>
<tr>
<td align="left">marshalling</td>
<td align="left">0.84s</td>
<td align="left">0.75s</td>
</tr>
</tbody></table>
<p>We can see that the relative ordering of the different measurements is still the same. However, note how the <code>BinaryWriter</code> and <code>BinaryReader</code> measurements are getting significantly closer to the <code>Marshal</code> ones.</p>
<p>While I would not necessarily encourage structures of this size, I would argue that marshalling is the best approach for large structures in almost every case. The slightly slower performance is easily justified by the much more maintainable code.</p>
<p>In fact, I would go as far and say that even for small structures the ease of using marshalling is still top advantageous despite the lower performance.</p>
<p>In the end, binary serialization is unlikely to ever be a bottleneck, and unless it is, we should choose the option that fulfils our requirements of small array size and ease of use.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>We took a look at three – and a half – different ways of converting between structs and byte arrays.</p>
<p>Judging by memory usage, performance, and ease of use, there is no clear winner – only a clear loser unless we specifically need the additional functionality of <code>BinaryFormatter</code>.</p>
<p>However, in marshalling we found a method that is reasonably fast, while acing our other requirements.</p>
<p>While in extremely performance critical code we may want to write our data manually, marshalling is likely the best alternative in the vast majority of cases.</p>
<p>Feel free to let me know if you agree with this analysis, or if you have other methods of achieving the same result that may be worth looking into.</p>
<p>Enjoy the pixels!</p>
]]></content>
      <categories>
        <category>dotnet</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>GitHub</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何有效的养成一个习惯</title>
    <url>/essay-2020-05-03-yang-cheng-yi-ge-xi-guan/</url>
    <content><![CDATA[<h1 id="养成习惯的要点"><a href="#养成习惯的要点" class="headerlink" title="养成习惯的要点"></a>养成习惯的要点</h1><ol>
<li>习惯从简到难，一开始一定不要太难，完不成打击自信心。少即是多，慢即是快。微习惯。</li>
<li>为习惯找到好的反馈和效果，提升做下去的动力，比如跑了步，称一下瘦了五斤，这么明显，就会坚持下去</li>
<li>给予自己奖励</li>
<li>把要做的事情想象成一件快乐的事情，而不是一个麻烦，你会对做快乐的事情厌烦吗？比如早起，想到早起可以看到清晨的朝阳，上学的小朋友，出门卖早餐的小摊贩，还可以看到锻炼的美女。</li>
</ol>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
  </entry>
  <entry>
    <title>读&lt;&lt;早起魔法&gt;&gt;</title>
    <url>/essay-2020-07-02-zao-qi-mo-fa/</url>
    <content><![CDATA[<p>第一章作者用了三节分别解释三个问题:</p>
<ul>
<li>什么是早起？</li>
<li>早起的好处？</li>
<li>怎么样才能早起？</li>
</ul>
<p>第二章作者主要围绕着他的金字塔,进行阐述</p>
<ol>
<li>要制定宏伟目标（要有人生规划/长期目标） </li>
<li>建立季度体系（用90天而不是365天作为规划的周期，定期回顾，选择重点目标，建立笔记和日程） </li>
<li>固有习惯（通过培养固有习惯协助自己实现目标，比如早起，比如运动） </li>
<li>理想惯例（建立仪式感，建立理想一周安排） </li>
<li>高效能策略（合并日程记录工具，文档管理工具和笔记工具，确保专注时间，实现零平衡，即收件箱清零，项目清单清零，桌面和工作区域整洁） </li>
<li>追踪进度（日，周，月，季度，年度反思，设定一个问责联系人） </li>
<li>成为达人（站立工作，听音乐工作等）</li>
</ol>
<p>第三章 作者说明了怎么实践金字塔，把一个大的目标拆成一个一个小目标放在每天。</p>
<p>总体来说,可实施性还是很高的.人总是有惰性的,同时喜欢先做简单的事情.</p>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
  </entry>
  <entry>
    <title>关于我唱歌跑调的那些事</title>
    <url>/essay-2020-09-10-changge/</url>
    <content><![CDATA[<p>之前读了阿德勒的书，其中一直不理解他说的一点，人的性格和过去没有关系。</p>
<p>这也是和佛罗伊德流派的区别，我们常看的犯罪小说，电视剧，或者周围发生的人和事处处透漏着童年阴影对成人性格的影响，比如孩童时期遇到的挫折导致长大后的性格缺陷，抑郁，心理扭曲或者变态杀人。</p>
<p>我一直对此深以为然，甚至迷惑阿德勒为什么会反对这种观点，以至于写下很长的书评进行反驳。</p>
<p>前几天和朋友广场跑步，朋友看到有做直播唱歌的，歌性大起要去ktv，而对于五音不全的我则煎熬的度过了四五个小时，在凌晨两点半才散场。</p>
<p>我真的五音不全吗？<br>是的。唱的很难听！</p>
<p>我什么时候开始不敢大声唱歌的？<br>依稀记得小时候父亲在工作，可能我对着电视机唱的太大声打扰了他，以至于他对我吼着唱的太难听。<br>自此可能就羞于唱歌了吧。</p>
<p>完美，佛罗伊德的理论，童年阴影对现在的影射，看似一切都合情合理。</p>
<p>直到我开始问自己一些问题。</p>
<p>我为什么不敢在ktv唱歌？<br>因为我不会唱，唱的难听，怕别人嘲笑。</p>
<p>我现在只要学习，就能唱好歌吗？<br>能。我坚信只要学习就一定不会走调。</p>
<p>那我为什么不去学习？<br>因为学会唱一首歌并不会给我带来多大的成就感和愉悦感，却会花费大量的时间</p>
<p>到这一刻，我突然明白，过去的经历是会对你产生影响，但这影响并不是一生。对于后面的生活你完全有重新选择的机会。剩下的是你有没有去挑战它的必要和如何掌握挑战它的方法和技巧。</p>
<p>那人们放着那些性格缺陷，而为什么总是不去改变呢？<br>因为如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦、更加不幸的生活在等着自己。所以大部分的人很难踏出那一步。</p>
<p>那怎么去改变自己呢？<br>多看书，多了解自己，虽然书中有时未必有答案，但是有一天终会豁然开朗，比如今天的我又解决了一个昨天的惑。还可以和一起成长的朋友说出心结，从别人那里获得鼓励，或者鼓励自己。还有些事情，但真的解决不了。</p>
<p>顺道延伸下孩子教育问题。<br>1 不要去随意的批评你的孩子。很多人可能会因噎废食直接理解为不要去批评你的孩子。<br>2 在孩子做一件事情失败的时候或者没有成功可能的时候，不要因为心疼他让他放弃，去帮他找到成功的路。<br>3 不要对孩子做任何评价，包括表扬正面的词语，因为任何的词语都会对他做出思想上的限制，额类似三体中的思想钢印。那怎么表达你对他的爱呢？只要表达你此时此刻自己真实的感受就可以。</p>
<p>以上全是瞎扯，如若信之，造成后果，概不负责！</p>
]]></content>
      <categories>
        <category>essay</category>
      </categories>
  </entry>
  <entry>
    <title>windows发送到手机Ftp</title>
    <url>/tool-2019-06-20-windows-send-to-ftp/</url>
    <content><![CDATA[<h2 id="右键发送到菜单位置"><a href="#右键发送到菜单位置" class="headerlink" title="右键发送到菜单位置"></a>右键发送到菜单位置</h2><ul>
<li><p>右键点击系统桌面左下角的【开始】，在开始菜单中点击【运行】，</p>
</li>
<li><p>在运行对话框中输入：<code>shell:sendto</code>命令,点击确定或者回车，打开SendTo（发送到）窗口；</p>
</li>
<li><p>或者直接打开 目录</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">invoke-item</span> <span class="string">"C:\Users\zhepama\AppData\Roaming\Microsoft\Windows\SendTo"</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><img src="../../assets/images/2019-06-20-windows-send-to-ftp/2019-06-21-18-29-28.png" alt=""></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>shell</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title>windows特殊目录修复</title>
    <url>/tool-2019-06-24-shell-folders-are-displayed-with-the-standard-folder-icon-in-windows/</url>
    <content><![CDATA[<h2 id="Desktop-ini-Contents-for-Various-Shell-Folders"><a href="#Desktop-ini-Contents-for-Various-Shell-Folders" class="headerlink" title="Desktop.ini Contents for Various Shell Folders"></a>Desktop.ini Contents for Various Shell Folders</h2><h3 id="For-Windows-7"><a href="#For-Windows-7" class="headerlink" title="For Windows 7"></a>For Windows 7</h3><p><strong>Contacts</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%CommonProgramFiles%\system\wab32res.dll,-10100</span><br><span class="line">InfoTip&#x3D;@%CommonProgramFiles%\system\wab32res.dll,-10200</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-181</span><br></pre></td></tr></table></figure>

<p><strong>Documents</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21770</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-112</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-235</span><br></pre></td></tr></table></figure>

<p><strong>Desktop</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21769</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-183</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">GameExplorer.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10082</span><br><span class="line">Windows Media Player.lnk&#x3D;@%SystemRoot%\system32\unregmp2.exe,-4</span><br><span class="line">Chess.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10054</span><br><span class="line">FreeCell.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10055</span><br><span class="line">Hearts.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10056</span><br><span class="line">Internet Checkers.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10101</span><br><span class="line">Minesweeper.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10057</span><br><span class="line">Spider Solitaire.lnk&#x3D;@%SystemRoot%\system32\gameux.dll,-10061</span><br></pre></td></tr></table></figure>

<p><strong>Downloads</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21798</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-184</span><br></pre></td></tr></table></figure>

<p><strong>Favorites</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21796</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-115</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-173</span><br></pre></td></tr></table></figure>

<p><strong>Links</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21810</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-185</span><br><span class="line">DefaultDropEffect&#x3D;4</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">RecentPlaces.lnk&#x3D;@shell32.dll,-37217</span><br><span class="line">Desktop.lnk&#x3D;@shell32.dll,-21769</span><br><span class="line">Downloads.lnk&#x3D;@shell32.dll,-21798</span><br></pre></td></tr></table></figure>

<p><strong>Music</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21790</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12689</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-108</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-237</span><br></pre></td></tr></table></figure>

<p><strong>Pictures</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21779</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12688</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-113</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-236</span><br></pre></td></tr></table></figure>

<p><strong>Recent</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21797</span><br><span class="line">InfoTip&#x3D;@shell32,dll,-12692</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-117</span><br><span class="line">CLSID&#x3D;&#123;0C39A5CF-1A7A-40C8-BA74-8900E6DF5FCD&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Saved Games</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21814</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-186</span><br></pre></td></tr></table></figure>

<p><strong>Searches</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-9031</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-18</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">Indexed Locations.search-ms&#x3D;@searchfolder.dll,-32820</span><br><span class="line">Everywhere.search-ms&#x3D;@searchfolder.dll,-32822</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="For-Windows-Vista"><a href="#For-Windows-Vista" class="headerlink" title="For Windows Vista"></a>For Windows Vista</h3><p><strong>Documents</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21770</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-112</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-235</span><br></pre></td></tr></table></figure>

<p><strong>Pictures</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21779</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12688</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-113</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-236</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">Sample Pictures.lnk&#x3D;@%SystemRoot%\system32\shell32.dll,-21805</span><br></pre></td></tr></table></figure>

<p><strong>Music</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21790</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12689</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-108</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-237</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">Sample Music.lnk&#x3D;@%SystemRoot%\system32\shell32.dll,-21806</span><br></pre></td></tr></table></figure>

<p><strong>Videos</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21791</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12690</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-189</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-238</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">Sample Videos.lnk&#x3D;@%SystemRoot%\system32\shell32.dll,-21807</span><br></pre></td></tr></table></figure>

<p><strong>Searches</strong>report this ad</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-9031</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-18</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">Indexed Locations.search-ms&#x3D;@shell32.dll,-32811</span><br><span class="line">Everywhere.search-ms&#x3D;@shell32.dll,-32814</span><br><span class="line">Shared By Me.search-ms&#x3D;@shell32.dll,-32802</span><br><span class="line">Recent Music.search-ms&#x3D;@shell32.dll,-32803</span><br><span class="line">Recent Documents.search-ms&#x3D;@shell32.dll,-32804</span><br><span class="line">Recent Pictures and Videos.search-ms&#x3D;@shell32.dll,-32806</span><br><span class="line">Recent E-mail.search-ms&#x3D;@shell32.dll,-32807</span><br><span class="line">Recently Changed.search-ms&#x3D;@shell32.dll,-32813</span><br></pre></td></tr></table></figure>

<p><strong>Downloads</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21798</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-184</span><br></pre></td></tr></table></figure>

<p><strong>Favorites</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21796</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-115</span><br><span class="line">IconFile&#x3D;%SystemRoot%\system32\shell32.dll</span><br><span class="line">IconIndex&#x3D;-173</span><br></pre></td></tr></table></figure>

<p><strong>Contacts</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%CommonProgramFiles%\system\wab32res.dll,-10100</span><br><span class="line">InfoTip&#x3D;@%CommonProgramFiles%\system\wab32res.dll,-10200</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-181</span><br></pre></td></tr></table></figure>

<p><strong>Desktop</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21769</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-183</span><br></pre></td></tr></table></figure>

<p><strong>Links</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21810</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-185</span><br><span class="line">DefaultDropEffect&#x3D;4</span><br><span class="line">[LocalizedFileNames]</span><br><span class="line">Public.lnk&#x3D;@shell32.dll,-21816</span><br><span class="line">Searches.lnk&#x3D;@shell32.dll,-9031</span><br><span class="line">Recently Changed.lnk&#x3D;@shell32.dll,-32813</span><br><span class="line">Music.lnk&#x3D;@shell32.dll,-21790</span><br><span class="line">Pictures.lnk&#x3D;@shell32.dll,-21779</span><br><span class="line">Documents.lnk&#x3D;@shell32.dll,-21770</span><br></pre></td></tr></table></figure>

<p><strong>Saved Games</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21814</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\imageres.dll,-186</span><br></pre></td></tr></table></figure>

<p><strong>Public Desktop</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21799</span><br></pre></td></tr></table></figure>

<p><strong>Public Documents</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21801</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\shell32.dll,-235</span><br></pre></td></tr></table></figure>

<p><strong>Public Music</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21803</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12689</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\shell32.dll,-237</span><br></pre></td></tr></table></figure>

<p><strong>Public Pictures</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21802</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12688</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\shell32.dll,-236</span><br></pre></td></tr></table></figure>

<p><strong>Public Videos</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[.ShellClassInfo]</span><br><span class="line">LocalizedResourceName&#x3D;@%SystemRoot%\system32\shell32.dll,-21804</span><br><span class="line">InfoTip&#x3D;@%SystemRoot%\system32\shell32.dll,-12690</span><br><span class="line">IconResource&#x3D;%SystemRoot%\system32\shell32.dll,-238</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>shell</tag>
        <tag>windows</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>scourcetree  总是需要输入密码</title>
    <url>/tool-2019-08-07-sourcetree-git-password/</url>
    <content><![CDATA[<h2 id="Git密钥存储相关"><a href="#Git密钥存储相关" class="headerlink" title="Git密钥存储相关"></a>Git密钥存储相关</h2><p>幸运的是，Git 拥有一个凭证系统来处理这个事情。 下面有一些 Git 的选项：</p>
<ul>
<li>默认所有都不缓存。 每一次连接都会询问你的用户名和密码。</li>
<li>“cache” 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。</li>
<li>“store” 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。 这意味着除非你修改了你在 Git 服务器上的密码，否则你永远不需要再次输入你的凭证信息。 这种方式的缺点是你的密码是用明文的方式存放在你的 home 目录下。</li>
<li>如果你使用的是 Mac，Git 还有一种 “osxkeychain” 模式，它会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的。</li>
<li>如果你使用的是 Windows，你可以安装一个叫做 “winstore” 的辅助工具。 这和上面说的 “osxkeychain” 十分类似，但是是使用 Windows Credential Store 来控制敏感信息。 可以在 <a href="https://gitcredentialstore.codeplex.com/" target="_blank" rel="noopener">https://gitcredentialstore.codeplex.com</a> 下载。</li>
</ul>
<h2 id="推荐使用凭证存储模式-“manager”"><a href="#推荐使用凭证存储模式-“manager”" class="headerlink" title="推荐使用凭证存储模式 “manager”"></a>推荐使用凭证存储模式 “manager”</h2><ul>
<li><p>在这里对比 “wincred” 和 “manager”的区别</p>
</li>
<li><ul>
<li><p><strong>相同点：</strong></p>
</li>
<li><ul>
<li>都会将用户信息存储到Windows凭据管理器中</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>不同点：</strong></p>
</li>
<li><ul>
<li>Windows凭据管理器中<strong>用户信息是否加密</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><ul>
<li><ul>
<li>“wincred” 模式下的用户信息展示如下</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Internet 地址或网络地址：git:https:&#x2F;&#x2F;用户名@github.com； </span><br><span class="line">用户名：真实用户名</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><ul>
<li>“manager” 模式下的用户信息展示如下</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Internet 地址或网络地址：git:https:&#x2F;&#x2F;github.com； </span><br><span class="line">用户名：PersonalAccessToken</span><br></pre></td></tr></table></figure>

<ul>
<li>很明显，在<strong>用户信息暴露</strong>的情况下，其他人很容易通过 https://用户名@<a href="https://link.zhihu.com/?target=http%3A//github.com">http://github.com</a> 访问到路径对应的项目，为了避免这种<strong>风险</strong>的存在，我们可以安装 “Git Credential Manager for Windows” 的辅助工具。</li>
</ul>
<h3 id="store的使用"><a href="#store的使用" class="headerlink" title="store的使用"></a>store的使用</h3><p><code>git config --global credential.helper store</code></p>
<p>“store” 模式可以接受一个 <code>--file &lt;path&gt;</code> 参数，可以自定义存放密码的文件路径（默认是 <code>~/.git-credentials</code> ）</p>
<h3 id="微软特有的Git-Credential-Manager"><a href="#微软特有的Git-Credential-Manager" class="headerlink" title="微软特有的Git Credential Manager"></a>微软特有的Git Credential Manager</h3><p>WINDOS部分版本的GIT会提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git: &#39;credential-cache&#39; is not a git command. See &#39;get --help&#39;.</span><br></pre></td></tr></table></figure>

<p>实际上是缺少微软的 Git Credential Manager</p>
<h4 id="安裝-Git-Credential-Manager-for-Windows解决"><a href="#安裝-Git-Credential-Manager-for-Windows解决" class="headerlink" title="安裝 Git Credential Manager for Windows解决"></a>安裝 Git Credential Manager for Windows解决</h4><p>最新的下载地址为：</p>
<p><a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest" target="_blank" rel="noopener">https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/latest</a></p>
<p>下载安装完后可以通过命令进行查看是否生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper manager</span><br></pre></td></tr></table></figure>

<h4 id="安裝-Git-Credential-Manager-Core解决"><a href="#安裝-Git-Credential-Manager-Core解决" class="headerlink" title="安裝 Git-Credential-Manager-Core解决"></a>安裝 Git-Credential-Manager-Core解决</h4><p>最新的下载地址为：</p>
<p><a href="https://github.com/microsoft/Git-Credential-Manager-Core" target="_blank" rel="noopener">https://github.com/microsoft/Git-Credential-Manager-Core</a></p>
<p>下载安装完后可以通过命令进行查看是否生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper manager-core</span><br></pre></td></tr></table></figure>



<h4 id="检查验证工具是否在path中"><a href="#检查验证工具是否在path中" class="headerlink" title="检查验证工具是否在path中"></a>检查验证工具是否在path中</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line">core.symlinks&#x3D;false</span><br><span class="line">core.autocrlf&#x3D;true</span><br><span class="line">core.fscache&#x3D;true</span><br><span class="line">color.diff&#x3D;auto</span><br><span class="line">color.status&#x3D;auto</span><br><span class="line">color.branch&#x3D;auto</span><br><span class="line">color.interactive&#x3D;true</span><br><span class="line">help.format&#x3D;html</span><br><span class="line">diff.astextplain.textconv&#x3D;astextplain</span><br><span class="line">rebase.autosquash&#x3D;true</span><br><span class="line">filter.lfs.clean&#x3D;git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge&#x3D;git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process&#x3D;git-lfs filter-process</span><br><span class="line">filter.lfs.required&#x3D;true</span><br><span class="line">credential.helper&#x3D;!&quot;D:&#x2F;Application&#x2F;Scoop&#x2F;apps&#x2F;git&#x2F;2.32.0.windows.1&#x2F;mingw64&#x2F;libexec&#x2F;git-core&#x2F;git-credential-manager-core.exe&quot;</span><br></pre></td></tr></table></figure>

<p>如果提交的时候仍有问题,提示xxxxcommad不可用.查看下你现在使用的credential.helper是否在path中.如果不在则进行手动添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:\Application\Scoop\apps\git\2.32.0.windows.1\mingw64\libexec\git-core</span><br></pre></td></tr></table></figure>

<p>如果使用的是sourcetree 还得查看,他默认使用的git是不是全局的</p>
<h1 id="SourceTree删除GIT密码"><a href="#SourceTree删除GIT密码" class="headerlink" title="SourceTree删除GIT密码"></a>SourceTree删除GIT密码</h1><h2 id="store"><a href="#store" class="headerlink" title="store"></a>store</h2><p>删除~/.git-credentials</p>
<h2 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h2><p>windows存储的初始密码账号不对，导致每次请求远程url都会报错，我们要到控制面板\用户帐户\凭据管理器中手动更改我们的credential凭证;如下，是我的凭证配置；只需要编辑下即可，当然你也可以删除你要请求的远程的凭证,我没试过，当你git pull，GIT会让你输入一次用户明和密码，以后每次请求，GIT会从windows凭证中查找；<img src="../../assets/images/2019-08-07-sourcetree-git-password/20190404111514753.png" alt="在这里插入图片描述"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>当GIT服务器修改密码后，sourcetree本地记住的密码，会导致提交代码失败。<br>本地删除当前用户目录下保存密码的文件，文件路径：<br>C:\Users\wuxiaoyuan\AppData\Local\Atlassian\SourceTree\passwd<br>清空文件内容即可</p>
<h1 id="同网站多账号的问题"><a href="#同网站多账号的问题" class="headerlink" title="同网站多账号的问题"></a>同网站多账号的问题</h1><p>如果同一个网站有多个账号..查看-&gt;选项-&gt;验证</p>
<ul>
<li>编辑那个网站的账号,就会新建一个用户名@xxx.com的账号</li>
<li>然后把那个公用的删除</li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8</a></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>powershell 常用命令</title>
    <url>/tool-2019-08-10-powershell-command/</url>
    <content><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>Get-PSDrive  Windows PowerShell 驱动器是一个数据存储位置，你可以像访问 Windows PowerShell 中的文件系统驱动器那样访问它。</p>
</li>
<li><p>Get-Alias 和   ls Alias:(驱动器)     列出所有alias</p>
</li>
<li><p>ls Env:(驱动器)    列出所有的环境变量</p>
</li>
<li><p>ls Variable:(驱动器) 和 Get-Variable 列出所有的变量</p>
</li>
<li><p>ls Function:(驱动器)  列出所有的函数</p>
</li>
<li><p>get-command   查看命令信息 可以查看某个命令的path  get-command mysqldump</p>
</li>
<li><p>invoke-item  向windows桌面双击操作一样打开某个文件或者目录</p>
</li>
<li><p>$env:path -split “;”  以列表形式列出所有path</p>
</li>
<li><p>ls env:    列出env驱动器中的内容</p>
</li>
<li><pre><code class="powershell"> <span class="variable">$path</span> = [<span class="type">environment</span>]::GetEnvironmentvariable(<span class="string">"path"</span>,<span class="string">"user"</span>)
 [<span class="type">environment</span>]::SetEnvironmentvariable(<span class="string">"Path"</span>, <span class="variable">$path</span>+<span class="string">";c:\powershellscript"</span>, <span class="string">"User"</span>)
&lt;!--￼<span class="number">0</span>--&gt;
</code></pre>
</li>
</ul>
<p>执行一个ps文件:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NoError</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ps1File = <span class="string">@"C:\my script folder\script.ps1"</span>;</span><br><span class="line">    <span class="keyword">var</span> startInfo = <span class="keyword">new</span> ProcessStartInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        FileName = <span class="string">"powershell.exe"</span>,</span><br><span class="line">        Arguments = <span class="string">$"-NoProfile -ExecutionPolicy unrestricted -file \"<span class="subst">&#123;ps1File&#125;</span>\""</span>,</span><br><span class="line">        UseShellExecute = <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Process.Start(startInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先编码执行一个复杂的命令:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Base64EncodedCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> psCommmand = <span class="string">@"echo ""quoted value"" </span></span><br><span class="line"><span class="string">    echo ""Second Line""</span></span><br><span class="line"><span class="string">    pause"</span>;</span><br><span class="line">    <span class="keyword">var</span> psCommandBytes = System.Text.Encoding.Unicode.GetBytes(psCommmand);</span><br><span class="line">    <span class="keyword">var</span> psCommandBase64 = Convert.ToBase64String(psCommandBytes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> startInfo = <span class="keyword">new</span> ProcessStartInfo()</span><br><span class="line">    &#123;</span><br><span class="line">        FileName = <span class="string">"powershell.exe"</span>,</span><br><span class="line">        Arguments = <span class="string">$"-NoProfile -ExecutionPolicy unrestricted -EncodedCommand <span class="subst">&#123;psCommandBase64&#125;</span>"</span>,</span><br><span class="line">        UseShellExecute = <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Process.Start(startInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用c-类调用powershell-命令"><a href="#使用c-类调用powershell-命令" class="headerlink" title="使用c#类调用powershell 命令"></a>使用c#类调用powershell 命令</h3><p><img src="../../assets/images/2019-08-10-powershell-command/image.png" alt="img"></p>
<p>接著我們在 Program.cs 檔案引用兩個命名空間如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Management.Automation;</span><br><span class="line">using System.Management.Automation.Runspaces;</span><br></pre></td></tr></table></figure>

<p>大功告成，現在你可以將 PowerShell 指令整合到你的 C# 應用程式中了！ </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (PowerShell powershell &#x3D; PowerShell.Create())</span><br><span class="line">&#123;</span><br><span class="line">    powershell.AddScript(&quot;Get-Service | Where-Object &#123; $_.Status -eq &#39;Stopped&#39; &#125;&quot;);</span><br><span class="line"></span><br><span class="line">    foreach (PSObject result in powershell.Invoke())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(result.Members[&quot;Name&quot;].Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回字符窜:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (PowerShell powershell &#x3D; PowerShell.Create())</span><br><span class="line">&#123;</span><br><span class="line">    powershell.AddScript(&quot;Get-Service | Out-String&quot;);</span><br><span class="line"></span><br><span class="line">    foreach (string str in powershell.Invoke&lt;string&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>捕捉错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (PowerShell powershell &#x3D; PowerShell.Create())</span><br><span class="line">&#123;</span><br><span class="line">    powershell.AddScript(&quot;Get-Service99&quot;);</span><br><span class="line"></span><br><span class="line">    foreach (PSObject result in powershell.Invoke())</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(result.Members[&quot;Name&quot;].Value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(&quot;執行過程中發生錯誤\n&quot;);</span><br><span class="line">    PSDataCollection&lt;ErrorRecord&gt; errors &#x3D; powershell.Streams.Error;</span><br><span class="line">    if (errors !&#x3D; null &amp;&amp; errors.Count &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (ErrorRecord err in errors)</span><br><span class="line">        &#123;</span><br><span class="line">            System.Console.WriteLine(&quot;錯誤: &#123;0&#125;&quot;, err.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>shell</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title>scoop的使用</title>
    <url>/tool-2019-08-20-scoop-use/</url>
    <content><![CDATA[<h1 id="安装scoop前提"><a href="#安装scoop前提" class="headerlink" title="安装scoop前提"></a>安装scoop前提</h1><p>版本大于等于3的powershell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; $psversiontable.psversion.major</span><br></pre></td></tr></table></figure>
<p>确保您已允许PowerShell执行本地脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; set-executionpolicy remotesigned -scope currentuser</span><br></pre></td></tr></table></figure>





<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开powershell,win+r,然后输入powershell</span><br><span class="line">#更改策略</span><br><span class="line">Set-ExecutionPolicy RemoteSigned -scope CurrentUser</span><br><span class="line"></span><br><span class="line">#安装</span><br><span class="line">iex (new-object net.webclient).downloadstring(&#39;https:&#x2F;&#x2F;get.scoop.sh&#39;)</span><br><span class="line"></span><br><span class="line">#安装git</span><br><span class="line">scoop install git</span><br><span class="line"></span><br><span class="line">#开启extras库</span><br><span class="line">scoop bucket add extras</span><br><span class="line"></span><br><span class="line">#开启java库</span><br><span class="line">scoop bucket add java</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">scoop update</span><br><span class="line"></span><br><span class="line">#查看安装软件列表</span><br><span class="line">scoop list</span><br><span class="line"></span><br><span class="line">#搜索某软件</span><br><span class="line">scoop search xxx</span><br><span class="line"></span><br><span class="line">#打开某软件官网</span><br><span class="line">scoop home xxx</span><br><span class="line"></span><br><span class="line">#查看某软件安装信息</span><br><span class="line">scoop info xxx</span><br><span class="line"></span><br><span class="line">#查看某软件执行命令位置</span><br><span class="line">scoop which xxx</span><br><span class="line"></span><br><span class="line">#查看某软件当前状态，是否有更新等信息</span><br><span class="line">scoop status xxx</span><br><span class="line"></span><br><span class="line">#更新某软件</span><br><span class="line">scoop update xxx</span><br><span class="line"></span><br><span class="line">#卸载某软件,以xxx为例</span><br><span class="line">scoop uninstall xxx</span><br></pre></td></tr></table></figure>

<p>这里是一个按照 Github score（由 Star 数量、Fork 数量和 App 数量综合决定的 Github score）排列的 bucket 列表：<a href="https://github.com/rasa/scoop-directory/blob/master/by-score.md" target="_blank" rel="noopener">Scoop buckets by Github score</a>。</p>
<h1 id="安装scoop到自定义目录"><a href="#安装scoop到自定义目录" class="headerlink" title="安装scoop到自定义目录"></a>安装scoop到自定义目录</h1><p>如果重新安装系统.只需要将shime路径添加到环境变量path中<code>D:\Application\Scoop\shims</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-executionpolicy</span> remotesigned <span class="literal">-scope</span> currentuser</span><br><span class="line"></span><br><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'SCOOP'</span>,<span class="string">'D:\Application\Scoop'</span>,<span class="string">'User'</span>)</span><br><span class="line"></span><br><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'Path'</span>,[<span class="type">System.Environment</span>]::GetEnvironmentVariable(<span class="string">'Path'</span>,[<span class="type">System.EnvironmentVariableTarget</span>]::User)+<span class="string">";D:\Application\Scoop\shims"</span>,<span class="string">'User'</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$env:SCOOP</span>=<span class="string">'D:\Application\Scoop'</span></span><br><span class="line"></span><br><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'SCOOP_GLOBAL'</span>,<span class="string">'D:\Application\ScoopGlobal'</span>,<span class="string">'Machine'</span>)</span><br><span class="line"></span><br><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'Path'</span>,[<span class="type">System.Environment</span>]::GetEnvironmentVariable(<span class="string">'Path'</span>,[<span class="type">System.EnvironmentVariableTarget</span>]::Machine)+<span class="string">";D:\Application\ScoopGlobal\shims"</span>,<span class="string">'Machine'</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable">$env:SCOOP_GLOBAL</span>=<span class="string">'D:\Application\ScoopGlobal'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#重置应用以解决冲突,会重置环境变量,快捷方式等..</span></span><br><span class="line">scoop reset *</span><br><span class="line"><span class="comment">#检查潜在的问题..执行下看看使用scoop会有什么问题</span></span><br><span class="line">scoop checkup</span><br><span class="line"><span class="comment">#如果使用了aria2感觉慢的话可以修改下参数或者关闭</span></span><br><span class="line">scoop config aria2<span class="literal">-max</span><span class="literal">-connection</span><span class="literal">-per</span><span class="literal">-server</span> <span class="number">16</span></span><br><span class="line">scoop config aria2<span class="operator">-split</span> <span class="number">16</span></span><br><span class="line">scoop config aria2<span class="literal">-min</span><span class="operator">-split</span><span class="literal">-size</span> <span class="number">1</span>M</span><br><span class="line">scoop config aria2<span class="literal">-enabled</span> false  </span><br><span class="line"><span class="comment">#下面是日常更新软件命令</span></span><br><span class="line">sudo scoop update * <span class="literal">-g</span> ; scoop update * ; sudo scoop cleanup * <span class="literal">-g</span> ; scoop cleanup *</span><br><span class="line"><span class="comment"># 查看 Scoop 还能直接识别哪些 bucket</span></span><br><span class="line">scoop bucket known</span><br></pre></td></tr></table></figure>
<h3 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Invoke-Item</span> <span class="string">"~\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Scoop Apps"</span></span><br></pre></td></tr></table></figure>

<p><strong>将Scoop安装到自定义目录</strong><br>假设目标目录是<code>D:\Application\Scoop</code>,在PowerShell命令控制台中运行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'SCOOP'</span>,<span class="string">'D:\Application\Scoop'</span>,<span class="string">'User'</span>)</span><br><span class="line"><span class="variable">$env:SCOOP</span>=<span class="string">'D:\Application\Scoop'</span></span><br><span class="line">iex (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">'https://get.scoop.sh'</span>)</span><br></pre></td></tr></table></figure>
<p>将全局应用安装到自定义目录,假设目标目录是<code>D:\Application\ScoopGlobal</code>,在PowerShell命令控制台中运行：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'SCOOP_GLOBAL'</span>,<span class="string">'D:\Application\ScoopGlobal'</span>,<span class="string">'Machine'</span>)</span><br><span class="line"><span class="variable">$env:SCOOP_GLOBAL</span>=<span class="string">'D:\Application\ScoopGlobal'</span></span><br></pre></td></tr></table></figure>

<h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><p>以我常用应用为例(可作为脚本文件,后缀ps1)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">###安装scoop并自定义安装路径</span></span><br><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'SCOOP'</span>,<span class="string">'D:\Application\Scoop'</span>,<span class="string">'User'</span>)</span><br><span class="line"><span class="variable">$env:SCOOP</span>=<span class="string">'D:\Application\Scoop'</span></span><br><span class="line">iex (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">'https://get.scoop.sh'</span>)</span><br><span class="line">[<span class="type">environment</span>]::setEnvironmentVariable(<span class="string">'SCOOP_GLOBAL'</span>,<span class="string">'D:\Application\ScoopGlobal'</span>,<span class="string">'Machine'</span>)</span><br><span class="line"><span class="variable">$env:SCOOP_GLOBAL</span>=<span class="string">'D:\Application\ScoopGlobal'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#git,程序员必备,只有安装了git才能添加其他桶</span></span><br><span class="line">scoop install git;</span><br><span class="line"><span class="comment">#arias2 scoop 下载会用到</span></span><br><span class="line">scoop install aria2;</span><br><span class="line"><span class="comment">#7zip 一些app会用到</span></span><br><span class="line">scoop install <span class="number">7</span>zip</span><br><span class="line"><span class="comment">#scoop checkup提示装的软件</span></span><br><span class="line">scoop install wixtoolset</span><br><span class="line"></span><br><span class="line"><span class="comment">###添加桶</span></span><br><span class="line"><span class="comment">#scoop内置的桶</span></span><br><span class="line"><span class="comment">#scoop bucket known;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### D:\Application\Scoop\buckets,如果发现bucket中有错误可以检查并删除</span></span><br><span class="line">scoop bucket add extras;</span><br><span class="line">scoop bucket add Java;</span><br><span class="line">scoop bucket add versions;</span><br><span class="line"><span class="comment">#一个还不错的</span></span><br><span class="line">scoop bucket add Ash258 <span class="string">'https://github.com/Ash258/scoop-Ash258.git'</span></span><br><span class="line"><span class="comment">#一个还不错的桶</span></span><br><span class="line">scoop bucket add dodorz https://github.com/dodorz/scoop<span class="literal">-bucket</span></span><br><span class="line"><span class="comment">#一个还不错的桶</span></span><br><span class="line">scoop bucket add dorado https://github.com/h404bi/dorado</span><br><span class="line"><span class="comment">#一个还不错的桶</span></span><br><span class="line">scoop bucket add Hass https://github.com/zhepama/Scoop<span class="literal">-Hass</span></span><br><span class="line"><span class="comment">### 添加代理</span></span><br><span class="line">scoop config proxy <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">1080</span></span><br><span class="line"><span class="comment"># 删除代理</span></span><br><span class="line">scoop config rm proxy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###安装全局应用</span></span><br><span class="line">scoop install apache <span class="literal">-g</span>;</span><br><span class="line">scoop install redis <span class="literal">-g</span>;</span><br><span class="line">scoop install mysql <span class="literal">-g</span>;</span><br><span class="line"><span class="comment"># jdk最好使用8,否则android-sdk会有问题</span></span><br><span class="line">scoop install ojdkbuild8 <span class="literal">-g</span>; </span><br><span class="line">scoop install php <span class="literal">-g</span>;</span><br><span class="line"><span class="comment">#整合apache php</span></span><br><span class="line">iex (<span class="built_in">new-object</span> net.webclient).downloadstring(<span class="string">'https://gist.githubusercontent.com/nilkesede/c98a275b80b6d373131df82eaba96c63/raw/apache-php-init.ps1'</span>)</span><br><span class="line"><span class="comment"># 或者手动修改apache配置</span></span><br><span class="line"><span class="comment">#LoadModule php7_module 'C:/Users/xxxxx/scoop/apps/php71/current/php7apache2_4.dll'</span></span><br><span class="line"><span class="comment">#AddHandler application/x-httpd-php .php</span></span><br><span class="line"><span class="comment">#PHPIniDir "C:\Users\xxxxx\scoop\apps\php71\current"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###安装APP</span></span><br><span class="line"><span class="comment">#使用nvm安装nodejs  https://www.sitepoint.com/quick-tip-multiple-versions-node-nvm/</span></span><br><span class="line">scoop install nvm</span><br><span class="line">nvm list available</span><br><span class="line">nvm install <span class="number">12.18</span>.<span class="number">2</span></span><br><span class="line"><span class="comment">#效率启动神器</span></span><br><span class="line">scoop install wox;</span><br><span class="line"><span class="comment">#文件检索</span></span><br><span class="line">scoop install everything;</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">scoop install bandizip;</span><br><span class="line"><span class="comment">#远程终端</span></span><br><span class="line">scoop install MobaXterm;</span><br><span class="line"><span class="comment">#桌面控制</span></span><br><span class="line">scoop install teamviewer;</span><br><span class="line"><span class="comment">#markdown编写</span></span><br><span class="line">scoop install typora;</span><br><span class="line"><span class="comment">#编辑器 注意使用vscode-portable,这样data文件夹就会持久化在scoop,而不是c盘用户目录</span></span><br><span class="line"><span class="comment">#From "$env:USERPROFILE\.vscode\extensions" to "$env:USERPROFILE\scoop\persist\vscode-portable\data\extensions"</span></span><br><span class="line"><span class="comment">#From "$env:APPDATA\Code" to "$env:USERPROFILE\scoop\persist\vscode-portable\data\user-data"</span></span><br><span class="line"><span class="comment">#如果想添加右键菜单.执行下current文件夹下的vscode-install-context.reg</span></span><br><span class="line">scoop install vscode<span class="literal">-portable</span>;</span><br><span class="line"><span class="comment">#ditto 剪贴板</span></span><br><span class="line">scoop install ditto</span><br><span class="line"><span class="comment">#postman</span></span><br><span class="line">scoop install postman</span><br><span class="line"><span class="comment">#heidisql</span></span><br><span class="line">scoop install heidisql</span><br><span class="line"><span class="comment">#imageglass 图片浏览器</span></span><br><span class="line">scoop install imageglass</span><br><span class="line"><span class="comment">#quick look</span></span><br><span class="line">scoop install quicklook</span><br><span class="line"><span class="comment">#obs  录制视频或者直播</span></span><br><span class="line">scoop install obs<span class="literal">-studio</span></span><br><span class="line"><span class="comment"># 录像软件</span></span><br><span class="line">scoop install captura</span><br><span class="line"><span class="comment">#switchhosts</span></span><br><span class="line">scoop install switchhosts</span><br><span class="line"><span class="comment"># gradle</span></span><br><span class="line">scoop install gradle</span><br><span class="line"><span class="comment"># android-sdk</span></span><br><span class="line">scoop install android<span class="literal">-sdk</span></span><br><span class="line"><span class="comment"># 安装ndk 老版本下载https://developer.android.com/ndk/downloads/older_releases.html</span></span><br><span class="line"><span class="comment"># sdkmanager ndk-bundle</span></span><br><span class="line"><span class="comment"># shadowsocksr-csharp</span></span><br><span class="line">scoop install shadowsocksr<span class="literal">-csharp</span></span><br><span class="line"><span class="comment"># 截图软件</span></span><br><span class="line">scoop install picpick</span><br><span class="line">scoop install snipaste</span><br><span class="line">scoop install sharex </span><br><span class="line">scoop install lightshot</span><br><span class="line"><span class="comment">#xmind8</span></span><br><span class="line">scoop install XMind2020</span><br><span class="line"><span class="comment"># android-studio</span></span><br><span class="line">scoop install android<span class="literal">-studio</span></span><br><span class="line"><span class="comment">#记住sourcetree的git最好使用内嵌版本</span></span><br><span class="line">scoop install sourcetree</span><br><span class="line"><span class="comment"># php的包工具</span></span><br><span class="line">scoop intstall composer</span><br><span class="line"><span class="comment"># 反向代理</span></span><br><span class="line">scoop install frp</span><br><span class="line"><span class="comment">#网易云音乐</span></span><br><span class="line">scoop install neteasemusic</span><br><span class="line"><span class="comment"># ftp工具</span></span><br><span class="line">scoop install filezilla </span><br><span class="line"><span class="comment"># pdf阅读工具</span></span><br><span class="line"> scoop install foxit<span class="literal">-reader</span></span><br><span class="line"><span class="comment"># 播放器</span></span><br><span class="line">scoop install potplayer </span><br><span class="line"><span class="comment"># draw工程图,uml工具</span></span><br><span class="line">scoop install draw.io</span><br><span class="line"><span class="comment"># 定时提醒休息工具</span></span><br><span class="line">scoop install wnr</span><br><span class="line"><span class="comment"># 投屏工具</span></span><br><span class="line">scoop install scrcpy </span><br><span class="line"><span class="comment"># 卸载工具</span></span><br><span class="line">scoop install geekuninstaller</span><br><span class="line"><span class="comment">#浏览器</span></span><br><span class="line">scoop install  firefox<span class="literal">-developer</span><span class="literal">-zh</span><span class="literal">-cn</span></span><br><span class="line">scoop install  googlechrome</span><br><span class="line"><span class="comment">#wechat</span></span><br><span class="line">scoop install wechat</span><br><span class="line"><span class="comment">#steam</span></span><br><span class="line">scoop install steam</span><br><span class="line"><span class="comment"># pwsh</span></span><br><span class="line">scoop install pwsh</span><br><span class="line"><span class="comment">#windows teraminal</span></span><br><span class="line">scoop install windows<span class="literal">-terminal</span></span><br><span class="line"><span class="comment"># 反编译 ilspy  https://github.com/sailro/Reflexil下载Reflexil将Reflexil.ILSpy.Plugin.dll直接扔到ilspy目录下即行</span></span><br><span class="line">scoop install ilspy</span><br><span class="line">scoop install dnspy</span><br><span class="line"><span class="comment">#win+x菜单编辑</span></span><br><span class="line">scoop install WinXMenuEditor   </span><br><span class="line"><span class="comment">#发送到菜单编辑</span></span><br><span class="line">scoop install SendToMenuEditor</span><br><span class="line"><span class="comment"># 上下文菜单</span></span><br><span class="line">scoop install EasyContextMenu</span><br><span class="line"><span class="comment"># 备份开始屏幕</span></span><br><span class="line">scoop install BackupStartMenuLayout</span><br><span class="line"><span class="comment">#定时关机</span></span><br><span class="line">scoop install kshutdown</span><br><span class="line"><span class="comment"># 创建可启动U盘的工具  https://www.ventoy.net/cn/index.html</span></span><br><span class="line">scoop install ventoy</span><br><span class="line"><span class="comment"># 修改dns工具</span></span><br><span class="line">scoop install dnsjumper</span><br></pre></td></tr></table></figure>



<h1 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo httpd -k install -n apache  </span><br><span class="line">start-service apache</span><br><span class="line">remove-service apache</span><br></pre></td></tr></table></figure>
<h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>文件路径<code>D:\Application\ScoopGlobal\apps\apache\current\conf\httpd.conf</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Define SRVROOT &quot;D:\Application\ScoopGlobal\apps\apache\current&quot;</span><br><span class="line">ServerName localhost</span><br></pre></td></tr></table></figure>

<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server --service-install D:\Application\ScoopGlobal\apps\redis\current\redis.windows-service.conf --loglevel verbose</span><br></pre></td></tr></table></figure>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>注册MySQL服务,(因为scoop是低污染的,所以要自己做):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --install MySQL --defaults-file&#x3D;&quot;D:\Application\ScoopGlobal\apps\mysql\current\my.ini&quot;</span><br></pre></td></tr></table></figure>

<p>注意mysql8密码可能认证有错误my.ini中需要设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default_authentication_plugin&#x3D;mysql_native_password</span><br></pre></td></tr></table></figure>





<h1 id="pwsh"><a href="#pwsh" class="headerlink" title="pwsh"></a>pwsh</h1><p>将pwsh添加到terminal中,配置默认路径:<code>C:\Users\zhepama\AppData\Local\Microsoft\Windows Terminal\settings.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This file was initially generated by Windows 终端(未打包) 1.0.200517002-release1.0</span></span><br><span class="line"><span class="comment">// It should still be usable in newer versions, but newer versions might have additional</span></span><br><span class="line"><span class="comment">// settings, help text, or changes that you will not see unless you clear this file</span></span><br><span class="line"><span class="comment">// and let us generate a new one for you.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To view the default settings, hold "alt" while clicking on the "Settings" button.</span></span><br><span class="line"><span class="comment">// For documentation on these settings, see: https://aka.ms/terminal-documentation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"$schema"</span>: <span class="string">"https://aka.ms/terminal-profiles-schema"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"defaultProfile"</span>: <span class="string">"&#123;90cbdc15-f4fe-49d2-a245-ec066b70845f&#125;"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// You can add more global application settings here.</span></span><br><span class="line">  <span class="comment">// To learn more about global settings, visit https://aka.ms/terminal-global-settings</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, selections are automatically copied to your clipboard.</span></span><br><span class="line">  <span class="attr">"copyOnSelect"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If enabled, formatted data is also copied to your clipboard</span></span><br><span class="line">  <span class="attr">"copyFormatting"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A profile specifies a command to execute paired with information about how it should look and feel.</span></span><br><span class="line">  <span class="comment">// Each one of them will appear in the 'New Tab' dropdown,</span></span><br><span class="line">  <span class="comment">//   and can be invoked from the commandline with `wt.exe -p xxx`</span></span><br><span class="line">  <span class="comment">// To learn more about profiles, visit https://aka.ms/terminal-profile-settings</span></span><br><span class="line">  <span class="attr">"profiles"</span>: &#123;</span><br><span class="line">    <span class="attr">"defaults"</span>: &#123;</span><br><span class="line">      <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"list"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the powershell.exe profile.</span></span><br><span class="line">        <span class="attr">"guid"</span>: <span class="string">"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Windows PowerShell"</span>,</span><br><span class="line">        <span class="attr">"commandline"</span>: <span class="string">"powershell.exe"</span>,</span><br><span class="line">        <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">        <span class="attr">"guid"</span>: <span class="string">"&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"命令提示符"</span>,</span><br><span class="line">        <span class="attr">"commandline"</span>: <span class="string">"cmd.exe"</span>,</span><br><span class="line">        <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"guid"</span>: <span class="string">"&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;"</span>,</span><br><span class="line">        <span class="attr">"hidden"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Azure Cloud Shell"</span>,</span><br><span class="line">        <span class="attr">"source"</span>: <span class="string">"Windows.Terminal.Azure"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"guid"</span>: <span class="string">"&#123;90cbdc15-f4fe-49d2-a245-ec066b70845f&#125;"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"pwsh"</span>,</span><br><span class="line">        <span class="attr">"commandline"</span>: <span class="string">"D:\\Application\\Scoop\\apps\\pwsh\\current\\pwsh.exe"</span>,</span><br><span class="line">        <span class="attr">"hidden"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"startingDirectory"</span>: <span class="string">"%USERPROFILE%"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom color schemes to this array.</span></span><br><span class="line">  <span class="comment">// To learn more about color schemes, visit https://aka.ms/terminal-color-schemes</span></span><br><span class="line">  <span class="attr">"schemes"</span>: [],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add custom keybindings to this array.</span></span><br><span class="line">  <span class="comment">// To unbind a key combination from your defaults.json, set the command to "unbound".</span></span><br><span class="line">  <span class="comment">// To learn more about keybindings, visit https://aka.ms/terminal-keybindings</span></span><br><span class="line">  <span class="attr">"keybindings"</span>: [</span><br><span class="line">    <span class="comment">// Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.</span></span><br><span class="line">    <span class="comment">// These two lines additionally bind them to Ctrl+C and Ctrl+V.</span></span><br><span class="line">    <span class="comment">// To learn more about selection, visit https://aka.ms/terminal-selection</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"command"</span>: &#123;</span><br><span class="line">        <span class="attr">"action"</span>: <span class="string">"copy"</span>,</span><br><span class="line">        <span class="attr">"singleLine"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"keys"</span>: <span class="string">"ctrl+c"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"paste"</span>,</span><br><span class="line">      <span class="attr">"keys"</span>: <span class="string">"ctrl+v"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Ctrl+Shift+F to open the search box</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"find"</span>,</span><br><span class="line">      <span class="attr">"keys"</span>: <span class="string">"ctrl+shift+f"</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Press Alt+Shift+D to open a new pane.</span></span><br><span class="line">    <span class="comment">// - "split": "auto" makes this pane open in the direction that provides the most surface area.</span></span><br><span class="line">    <span class="comment">// - "splitMode": "duplicate" makes the new pane use the focused pane's profile.</span></span><br><span class="line">    <span class="comment">// To learn more about panes, visit https://aka.ms/terminal-panes</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"command"</span>: &#123;</span><br><span class="line">        <span class="attr">"action"</span>: <span class="string">"splitPane"</span>,</span><br><span class="line">        <span class="attr">"split"</span>: <span class="string">"auto"</span>,</span><br><span class="line">        <span class="attr">"splitMode"</span>: <span class="string">"duplicate"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"keys"</span>: <span class="string">"alt+shift+d"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="自制bucket"><a href="#自制bucket" class="headerlink" title="自制bucket"></a>自制bucket</h1><p>最佳方式是使用模板 <a href="https://github.com/Ash258/GenericBucket" target="_blank" rel="noopener">https://github.com/Ash258/GenericBucket</a></p>
<h3 id="如何解压exe的程序"><a href="#如何解压exe的程序" class="headerlink" title="如何解压exe的程序"></a>如何解压exe的程序</h3><p>首先下载的时候后面加上#/dl.7z类似的后缀..然后scoop保存的时候.会把他存在7z格式的文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;architecture&quot;: &#123;</span><br><span class="line">    &quot;64bit&quot;: &#123;</span><br><span class="line">        &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;RoderickQiu&#x2F;wnr&#x2F;releases&#x2F;download&#x2F;v1.17.1&#x2F;wnr-1.17.1-Setup-64.exe#&#x2F;dl.7z&quot;,</span><br><span class="line">        &quot;hash&quot;: &quot;BE14DE68FDBFB3663F57B6B28E8B0CC90AE876DD06CA899839BEB9377FE21436&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;32bit&quot;: &#123;</span><br><span class="line">        &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;RoderickQiu&#x2F;wnr&#x2F;releases&#x2F;download&#x2F;v1.17.1&#x2F;wnr-1.17.1-Setup-32.exe#&#x2F;dl.7z&quot;,</span><br><span class="line">        &quot;hash&quot;: &quot;9C437170019E8AFC82B64A5475E349602E03A9493DD6AC6CACF58FDFD75762DD&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>例如上面旧会被存在scoop/cache/wnr#1.17.1#https_github.com_RoderickQiu_wnr_releases_download_v1.17.1_wnr-1.17.1-Setup-64.exe_dl.7z</p>
<p>然后旧可以解压了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;installer&quot;: &#123;</span><br><span class="line">    &quot;script&quot;: [</span><br><span class="line">        &quot;Expand-7zipArchive -Path (Join-Path $dir &#39;$PLUGINSDIR\\*.7z&#39;) -DestinationPath $dir&quot;,</span><br><span class="line">        &quot;Remove-Item -Path (Join-Path $dir &#39;$PLUGINSDIR&#39;) -Recurse&quot;,</span><br><span class="line">        &quot;Remove-Item \&quot;$dir\\Uninstall wnr.exe\&quot;&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>



<p>安装脚本都是执行在Scoop\apps\wnr\11.XXX\下面</p>
<h3 id="导出-Scoop-软件列表"><a href="#导出-Scoop-软件列表" class="headerlink" title="导出 Scoop 软件列表"></a>导出 Scoop 软件列表</h3><p>备份 Scoop 的方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scoop export &gt; scoop.txt</span><br></pre></td></tr></table></figure>

<p>可以对 Scoop 的导出列表进行额外处理，以方便后续安装。使用 VSCode 打开 <code>scoop.txt</code> 文件，以正则表达式搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(.*?) .*</span><br></pre></td></tr></table></figure>

<p>并全部替换成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$1</span><br></pre></td></tr></table></figure>

<p>注意正则式中包含空格，请完整复制。</p>
<p><img src="../../assets/images/2019-08-20-scoop-use/03.jpg" alt="VSCode 中的正则式替换"></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>shell</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Java</tag>
        <tag>代理</tag>
        <tag>PHP</tag>
        <tag>Redis</tag>
        <tag>JS</tag>
        <tag>proxy</tag>
        <tag>powershell</tag>
        <tag>scoop</tag>
      </tags>
  </entry>
  <entry>
    <title>使用配置文件来管理NuGet包版本F</title>
    <url>/tool-2019-09-02-nuget-manager/</url>
    <content><![CDATA[<p>先创建一个文件<code>Directory.Build.props</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Project&gt;</span><br><span class="line">    &lt;PropertyGroup&gt;</span><br><span class="line">        &lt;NuGet-Kritner-SolarProjection&gt;1.0.2&lt;&#x2F;NuGet-Kritner-SolarProjection&gt;</span><br><span class="line">    &lt;&#x2F;PropertyGroup&gt;</span><br><span class="line">&lt;&#x2F;Project&gt;</span><br></pre></td></tr></table></figure>

<p>然后修改你的项目文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">  &lt;PackageReference Include&#x3D;&quot;Kritner.SolarProjection&quot; Version&#x3D;&quot;$(NuGet-Kritner-SolarProjection)&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;ItemGroup&gt;</span><br></pre></td></tr></table></figure>

<h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><ul>
<li><a href="https://docs.microsoft.com/zh-cn/nuget/consume-packages/package-references-in-project-files" target="_blank" rel="noopener">包的版本号</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/visualstudio/msbuild/customize-your-build?view=vs-2019" target="_blank" rel="noopener">Directory.Build.props的说明</a></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的两种持久化RDB和AOF</title>
    <url>/tool-2019-09-02-redis-aof-rdb/</url>
    <content><![CDATA[<p>Redis 分别提供了 RDB 和 AOF 两种持久化机制：</p>
<ul>
<li>RDB 将数据库的快照（snapshot）以二进制的方式保存到磁盘中。</li>
<li>AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件，以此达到记录数据库状态的目的。</li>
</ul>
<p><img src="../../assets/images/2019-09-02-redis-aof-rdb/graphviz-a7c5f2bb064f2c0307d15dca06d7d31d3adfc032.svg" alt=""></p>
<p>本章首先介绍 AOF 功能的运作机制， 了解命令是如何被保存到 AOF 文件里的， 观察不同的 AOF 保存模式对数据的安全性、以及 Redis 性能的影响。</p>
<p>之后会介绍从 AOF 文件中恢复数据库状态的方法，以及该方法背后的实现机制。</p>
<p>最后还会介绍对 AOF 进行重写以调整文件体积的方法， 并研究这种方法是如何在不改变数据库状态的前提下进行的。</p>
<p>因为本章涉及 AOF 运行的相关机制， 如果还没了解过 AOF 功能的话， 请先阅读 <a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">Redis 持久化手册中关于 AOF 的部分</a> 。</p>
<p><strong>无论是rdb还是aof都是把存储的文件恢复到内存中</strong></p>
<h1 id="RDB优点与缺点"><a href="#RDB优点与缺点" class="headerlink" title="RDB优点与缺点"></a>RDB优点与缺点</h1><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>如果要进行大规模数据的恢复，RDB方式要比AOF方式恢复速度要快。</li>
<li>RDB可以最大化Redis性能，父进程做的就是fork子进程，然后继续接受客户端请求，让子进程负责持久化操作，父进程无需进行IO操作。</li>
<li>RDB是一个非常紧凑(compact)的文件,它保存了某个时间点的数据集，非常适合用作备份，同时也非常适合用作灾难性恢复，它只有一个文件，内容紧凑，通过备份原文件到本机外的其他主机上，一旦本机发生宕机，就能将备份文件复制到redis安装目录下，通过启用服务就能完成数据的恢复。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>RDB这种持久化方式不太适应对数据完整性要求严格的情况，因为，尽管我们可以用过修改快照实现持久化的频率，但是要持久化的数据是一段时间内的整个数据集的状态，如果在还没有触发快照时，本机就宕机了，那么对数据库所做的写操作就随之而消失了并没有持久化本地dump.rdb文件中。</li>
<li>每次进行RDB时，父进程都会fork一个子进程，由子进程来进行实际的持久化操作，如果数据集庞大，那么fork出子进程的这个过程将是非常耗时的，就会出现服务器暂停客户端请求，将内存中的数据复制一份给子进程，让子进程进行持久化操作。<br><img src="../../assets/images/2019-09-02-redis-aof-rdb/20181004174024768.png" alt="img"></li>
</ul>
<h2 id="AOF-命令同步"><a href="#AOF-命令同步" class="headerlink" title="AOF 命令同步"></a>AOF 命令同步</h2><p>Redis 将所有对数据库进行过写入的命令（及其参数）记录到 AOF 文件， 以此达到记录数据库状态的目的， 为了方便起见， 我们称呼这种记录过程为同步。</p>
<p>举个例子， 如果执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; RPUSH list 1 2 3 4</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; KEYS *</span><br><span class="line">1) &quot;list&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; RPOP list</span><br><span class="line">&quot;4&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LPOP list</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LPUSH list 1</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; LRANGE list 0 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>那么其中四条对数据库有修改的写入命令就会被同步到 AOF 文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RPUSH list 1 2 3 4</span><br><span class="line"></span><br><span class="line">RPOP list</span><br><span class="line"></span><br><span class="line">LPOP list</span><br><span class="line"></span><br><span class="line">LPUSH list 1</span><br></pre></td></tr></table></figure>

<p>为了处理的方便， AOF 文件使用网络通讯协议的格式来保存这些命令。</p>
<p>比如说， 上面列举的四个命令在 AOF 文件中就实际保存如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*2</span><br><span class="line">$6</span><br><span class="line">SELECT</span><br><span class="line">$1</span><br><span class="line">0</span><br><span class="line">*6</span><br><span class="line">$5</span><br><span class="line">RPUSH</span><br><span class="line">$4</span><br><span class="line">list</span><br><span class="line">$1</span><br><span class="line">1</span><br><span class="line">$1</span><br><span class="line">2</span><br><span class="line">$1</span><br><span class="line">3</span><br><span class="line">$1</span><br><span class="line">4</span><br><span class="line">*2</span><br><span class="line">$4</span><br><span class="line">RPOP</span><br><span class="line">$4</span><br><span class="line">list</span><br><span class="line">*2</span><br><span class="line">$4</span><br><span class="line">LPOP</span><br><span class="line">$4</span><br><span class="line">list</span><br><span class="line">*3</span><br><span class="line">$5</span><br><span class="line">LPUSH</span><br><span class="line">$4</span><br><span class="line">list</span><br><span class="line">$1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>除了 <a href="http://redis.readthedocs.org/en/latest/connection/select.html#select" target="_blank" rel="noopener">SELECT</a> 命令是 AOF 程序自己加上去的之外， 其他命令都是之前我们在终端里执行的命令。</p>
<p>同步命令到 AOF 文件的整个过程可以分为三个阶段：</p>
<ol>
<li>命令传播：Redis 将执行完的命令、命令的参数、命令的参数个数等信息发送到 AOF 程序中。</li>
<li>缓存追加：AOF 程序根据接收到的命令数据，将命令转换为网络通讯协议的格式，然后将协议内容追加到服务器的 AOF 缓存中。</li>
<li>文件写入和保存：AOF 缓存中的内容被写入到 AOF 文件末尾，如果设定的 AOF 保存条件被满足的话， <code>fsync</code> 函数或者 <code>fdatasync</code> 函数会被调用，将写入的内容真正地保存到磁盘中。</li>
</ol>
<p>以下几个小节将详细地介绍这三个步骤。</p>
<h2 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h2><p>当一个 Redis 客户端需要执行命令时， 它通过网络连接， 将协议文本发送给 Redis 服务器。</p>
<p>比如说， 要执行命令 <code>SET KEY VALUE</code> ， 客户端将向服务器发送文本 <code>&quot;*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n&quot;</code> 。</p>
<p>服务器在接到客户端的请求之后， 它会根据协议文本的内容， 选择适当的命令函数， 并将各个参数从字符串文本转换为 Redis 字符串对象（<code>StringObject</code>）。</p>
<p>比如说， 针对上面的 <a href="http://redis.readthedocs.org/en/latest/string/set.html#set" target="_blank" rel="noopener">SET</a> 命令例子， Redis 将客户端的命令指针指向实现 <a href="http://redis.readthedocs.org/en/latest/string/set.html#set" target="_blank" rel="noopener">SET</a> 命令的 <code>setCommand</code> 函数， 并创建三个 Redis 字符串对象， 分别保存 <code>SET</code> 、 <code>KEY</code> 和 <code>VALUE</code> 三个参数（命令也算作参数）。</p>
<p>每当命令函数成功执行之后， 命令参数都会被传播到 AOF 程序， 以及 REPLICATION 程序（本节不讨论这个，列在这里只是为了完整性的考虑）。</p>
<p>这个执行并传播命令的过程可以用以下伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (execRedisCommand(cmd, argv, argc) &#x3D;&#x3D; EXEC_SUCCESS):</span><br><span class="line"></span><br><span class="line">    if aof_is_turn_on():</span><br><span class="line">        # 传播命令到 AOF 程序</span><br><span class="line">        propagate_aof(cmd, argv, argc)</span><br><span class="line"></span><br><span class="line">    if replication_is_turn_on():</span><br><span class="line">        # 传播命令到 REPLICATION 程序</span><br><span class="line">        propagate_replication(cmd, argv, argc)</span><br></pre></td></tr></table></figure>

<p>以下是该过程的流程图：</p>
<p><img src="../../assets/images/2019-09-02-redis-aof-rdb/graphviz-a5c804211267a10a5c3ffa47c5b600727191a3be.svg" alt=""></p>
<h2 id="缓存追加"><a href="#缓存追加" class="headerlink" title="缓存追加"></a>缓存追加</h2><p>当命令被传播到 AOF 程序之后， 程序会根据命令以及命令的参数， 将命令从字符串对象转换回原来的协议文本。</p>
<p>比如说， 如果 AOF 程序接受到的三个参数分别保存着 <code>SET</code> 、 <code>KEY</code> 和 <code>VALUE</code> 三个字符串， 那么它将生成协议文本 <code>&quot;*3\r\n$3\r\nSET\r\n$3\r\nKEY\r\n$5\r\nVALUE\r\n&quot;</code> 。</p>
<p>协议文本生成之后， 它会被追加到 <code>redis.h/redisServer</code> 结构的 <code>aof_buf</code> 末尾。</p>
<p><code>redisServer</code> 结构维持着 Redis 服务器的状态， <code>aof_buf</code> 域则保存着所有等待写入到 AOF 文件的协议文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct redisServer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其他域...</span><br><span class="line"></span><br><span class="line">    sds aof_buf;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 其他域...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至此， 追加命令到缓存的步骤执行完毕。</p>
<p>综合起来，整个缓存追加过程可以分为以下三步：</p>
<ol>
<li>接受命令、命令的参数、以及参数的个数、所使用的数据库等信息。</li>
<li>将命令还原成 Redis 网络通讯协议。</li>
<li>将协议文本追加到 <code>aof_buf</code> 末尾。</li>
</ol>
<h2 id="文件写入和保存"><a href="#文件写入和保存" class="headerlink" title="文件写入和保存"></a>文件写入和保存</h2><p>每当服务器常规任务函数被执行、 或者事件处理器被执行时， <code>aof.c/flushAppendOnlyFile</code> 函数都会被调用， 这个函数执行以下两个工作：</p>
<p>WRITE：根据条件，将 <code>aof_buf</code> 中的缓存写入到 AOF 文件。</p>
<p>SAVE：根据条件，调用 <code>fsync</code> 或 <code>fdatasync</code> 函数，将 AOF 文件保存到磁盘中。</p>
<p>两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。</p>
<h2 id="AOF-保存模式"><a href="#AOF-保存模式" class="headerlink" title="AOF 保存模式"></a>AOF 保存模式</h2><p>Redis 目前支持三种 AOF 保存模式，它们分别是：</p>
<ol>
<li><code>AOF_FSYNC_NO</code> ：不保存。</li>
<li><code>AOF_FSYNC_EVERYSEC</code> ：每一秒钟保存一次。</li>
<li><code>AOF_FSYNC_ALWAYS</code> ：每执行一个命令保存一次。</li>
</ol>
<p>以下三个小节将分别讨论这三种保存模式。</p>
<h3 id="不保存"><a href="#不保存" class="headerlink" title="不保存"></a>不保存</h3><p>在这种模式下， 每次调用 <code>flushAppendOnlyFile</code> 函数， WRITE 都会被执行， 但 SAVE 会被略过。</p>
<p>在这种模式下， SAVE 只会在以下任意一种情况中被执行：</p>
<ul>
<li>Redis 被关闭</li>
<li>AOF 功能被关闭</li>
<li>系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）</li>
</ul>
<p>这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。</p>
<h3 id="每一秒钟保存一次"><a href="#每一秒钟保存一次" class="headerlink" title="每一秒钟保存一次"></a>每一秒钟保存一次</h3><p>在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。</p>
<p>注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 <code>fsync</code> 或 <code>fdatasync</code> 的调用并不是每秒一次， 它和调用 <code>flushAppendOnlyFile</code> 函数时 Redis 所处的状态有关。</p>
<p>每当 <code>flushAppendOnlyFile</code> 函数被调用时， 可能会出现以下四种情况：</p>
<ul>
<li><p>子线程正在执行 SAVE ，并且：</p>
<blockquote>
<ol>
<li>这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。</li>
<li>这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。</li>
</ol>
</blockquote>
</li>
<li><p>子线程没有在执行 SAVE ，并且：</p>
<blockquote>
<ol>
<li>上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。</li>
<li>上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。</li>
</ol>
</blockquote>
</li>
</ul>
<p>可以用流程图表示这四种情况：</p>
<p><img src="../../assets/images/2019-09-02-redis-aof-rdb/graphviz-1b226a6d0f09ed1b61a30d899372834634b96504.svg" alt=""></p>
<p>根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。</p>
<p>如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。</p>
<p>Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。</p>
<h3 id="每执行一个命令保存一次"><a href="#每执行一个命令保存一次" class="headerlink" title="每执行一个命令保存一次"></a>每执行一个命令保存一次</h3><p>在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。</p>
<p>另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。</p>
<h2 id="AOF-保存模式对性能和安全性的影响"><a href="#AOF-保存模式对性能和安全性的影响" class="headerlink" title="AOF 保存模式对性能和安全性的影响"></a>AOF 保存模式对性能和安全性的影响</h2><p>在上一个小节， 我们简短地描述了三种 AOF 保存模式的工作方式， 现在， 是时候研究一下这三个模式在安全性和性能方面的区别了。</p>
<p>对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下：</p>
<ol>
<li>不保存（<code>AOF_FSYNC_NO</code>）：写入和保存都由主进程执行，两个操作都会阻塞主进程。</li>
<li>每一秒钟保存一次（<code>AOF_FSYNC_EVERYSEC</code>）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。</li>
<li>每执行一个命令保存一次（<code>AOF_FSYNC_ALWAYS</code>）：和模式 1 一样。</li>
</ol>
<p>因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。</p>
<p>模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。</p>
<p>模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。</p>
<p>模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。</p>
<p>综合起来，三种 AOF 模式的操作特性可以总结如下：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">WRITE 是否阻塞？</th>
<th align="left">SAVE 是否阻塞？</th>
<th align="left">停机时丢失的数据量</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AOF_FSYNC_NO</code></td>
<td align="left">阻塞</td>
<td align="left">阻塞</td>
<td align="left">操作系统最后一次对 AOF 文件触发 SAVE 操作之后的数据。</td>
</tr>
<tr>
<td align="left"><code>AOF_FSYNC_EVERYSEC</code></td>
<td align="left">阻塞</td>
<td align="left">不阻塞</td>
<td align="left">一般情况下不超过 2 秒钟的数据。</td>
</tr>
<tr>
<td align="left"><code>AOF_FSYNC_ALWAYS</code></td>
<td align="left">阻塞</td>
<td align="left">阻塞</td>
<td align="left">最多只丢失一个命令的数据。</td>
</tr>
</tbody></table>
<h2 id="AOF-文件的读取和数据还原"><a href="#AOF-文件的读取和数据还原" class="headerlink" title="AOF 文件的读取和数据还原"></a>AOF 文件的读取和数据还原</h2><p>AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本。</p>
<p>这也就是说， 只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。</p>
<p>Redis 读取 AOF 文件并还原数据库的详细步骤如下：</p>
<ol>
<li>创建一个不带网络连接的伪客户端（fake client）。</li>
<li>读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。</li>
<li>根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。</li>
<li>执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。</li>
</ol>
<p>完成第 4 步之后， AOF 文件所保存的数据库就会被完整地还原出来。</p>
<p>注意， 因为 Redis 的命令只能在客户端的上下文中被执行， 而 AOF 还原时所使用的命令来自于 AOF 文件， 而不是网络， 所以程序使用了一个没有网络连接的伪客户端来执行命令。 伪客户端执行命令的效果， 和带网络连接的客户端执行命令的效果， 完全一样。</p>
<p>整个读取和还原过程可以用以下伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def READ_AND_LOAD_AOF():</span><br><span class="line"></span><br><span class="line">    # 打开并读取 AOF 文件</span><br><span class="line">    file &#x3D; open(aof_file_name)</span><br><span class="line">    while file.is_not_reach_eof():</span><br><span class="line"></span><br><span class="line">        # 读入一条协议文本格式的 Redis 命令</span><br><span class="line">        cmd_in_text &#x3D; file.read_next_command_in_protocol_format()</span><br><span class="line"></span><br><span class="line">        # 根据文本命令，查找命令函数，并创建参数和参数个数等对象</span><br><span class="line">        cmd, argv, argc &#x3D; text_to_command(cmd_in_text)</span><br><span class="line"></span><br><span class="line">        # 执行命令</span><br><span class="line">        execRedisCommand(cmd, argv, argc)</span><br><span class="line"></span><br><span class="line">    # 关闭文件</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure>

<p>作为例子， 以下是一个简短的 AOF 文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*2</span><br><span class="line">$6</span><br><span class="line">SELECT</span><br><span class="line">$1</span><br><span class="line">0</span><br><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">SET</span><br><span class="line">$3</span><br><span class="line">key</span><br><span class="line">$5</span><br><span class="line">value</span><br><span class="line">*8</span><br><span class="line">$5</span><br><span class="line">RPUSH</span><br><span class="line">$4</span><br><span class="line">list</span><br><span class="line">$1</span><br><span class="line">1</span><br><span class="line">$1</span><br><span class="line">2</span><br><span class="line">$1</span><br><span class="line">3</span><br><span class="line">$1</span><br><span class="line">4</span><br><span class="line">$1</span><br><span class="line">5</span><br><span class="line">$1</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>当程序读入这个 AOF 文件时， 它首先执行 <code>SELECT 0</code> 命令 —— 这个 <code>SELECT</code> 命令是由 AOF 写入程序自动生成的， 它确保程序可以将数据还原到正确的数据库上。</p>
<p>然后执行后面的 <code>SET key value</code> 和 <code>RPUSH 1 2 3 4</code> 命令， 还原 <code>key</code> 和 <code>list</code> 两个键的数据。</p>
<p>为了避免对数据的完整性产生影响， 在服务器载入数据的过程中， 只有和数据库无关的订阅与发布功能可以正常使用， 其他命令一律返回错误。</p>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>AOF 文件通过同步 Redis 服务器所执行的命令， 从而实现了数据库状态的记录， 但是， 这种同步方式会造成一个问题： 随着运行时间的流逝， AOF 文件会变得越来越大。</p>
<p>举个例子， 如果服务器执行了以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RPUSH list 1 2 3 4      &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">RPOP list               &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">LPOP list               &#x2F;&#x2F; [2, 3]</span><br><span class="line"></span><br><span class="line">LPUSH list 1            &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>那么光是记录 <code>list</code> 键的状态， AOF 文件就需要保存四条命令。</p>
<p>另一方面， 有些被频繁操作的键， 对它们所调用的命令可能有成百上千、甚至上万条， 如果这样被频繁操作的键有很多的话， AOF 文件的体积就会急速膨胀， 对 Redis 、甚至整个系统的造成影响。</p>
<p>为了解决以上的问题， Redis 需要对 AOF 文件进行重写（rewrite）： 创建一个新的 AOF 文件来代替原有的 AOF 文件， 新 AOF 文件和原有 AOF 文件保存的数据库状态完全一样， 但新 AOF 文件的体积小于等于原有 AOF 文件的体积。</p>
<p>以下就来介绍 AOF 重写的实现方式。</p>
<h2 id="AOF-重写的实现"><a href="#AOF-重写的实现" class="headerlink" title="AOF 重写的实现"></a>AOF 重写的实现</h2><p>所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。</p>
<p>考虑这样一个情况， 如果服务器对键 <code>list</code> 执行了以下四条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RPUSH list 1 2 3 4      &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">RPOP list               &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">LPOP list               &#x2F;&#x2F; [2, 3]</span><br><span class="line"></span><br><span class="line">LPUSH list 1            &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>那么当前列表键 <code>list</code> 在数据库中的值就为 <code>[1, 2, 3]</code> 。</p>
<p>如果我们要保存这个列表的当前状态， 并且尽量减少所使用的命令数， 那么最简单的方式不是去 AOF 文件上分析前面执行的四条命令， 而是直接读取 <code>list</code> 键在数据库的当前值， 然后用一条 <code>RPUSH 1 2 3</code> 命令来代替前面的四条命令。</p>
<p>再考虑这样一个例子， 如果服务器对集合键 <code>animal</code> 执行了以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SADD animal cat                 &#x2F;&#x2F; &#123;cat&#125;</span><br><span class="line"></span><br><span class="line">SADD animal dog panda tiger     &#x2F;&#x2F; &#123;cat, dog, panda, tiger&#125;</span><br><span class="line"></span><br><span class="line">SREM animal cat                 &#x2F;&#x2F; &#123;dog, panda, tiger&#125;</span><br><span class="line"></span><br><span class="line">SADD animal cat lion            &#x2F;&#x2F; &#123;cat, lion, dog, panda, tiger&#125;</span><br></pre></td></tr></table></figure>

<p>那么使用一条 <code>SADD animal cat lion dog panda tiger</code> 命令， 就可以还原 <code>animal</code> 集合的状态， 这比之前的四条命令调用要大大减少。</p>
<p>除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。</p>
<p>根据键的类型， 使用适当的写入命令来重现键的当前值， 这就是 AOF 重写的实现原理。 整个重写过程可以用伪代码表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def AOF_REWRITE(tmp_tile_name):</span><br><span class="line"></span><br><span class="line">  f &#x3D; create(tmp_tile_name)</span><br><span class="line"></span><br><span class="line">  # 遍历所有数据库</span><br><span class="line">  for db in redisServer.db:</span><br><span class="line"></span><br><span class="line">    # 如果数据库为空，那么跳过这个数据库</span><br><span class="line">    if db.is_empty(): continue</span><br><span class="line"></span><br><span class="line">    # 写入 SELECT 命令，用于切换数据库</span><br><span class="line">    f.write_command(&quot;SELECT &quot; + db.number)</span><br><span class="line"></span><br><span class="line">    # 遍历所有键</span><br><span class="line">    for key in db:</span><br><span class="line"></span><br><span class="line">      # 如果键带有过期时间，并且已经过期，那么跳过这个键</span><br><span class="line">      if key.have_expire_time() and key.is_expired(): continue</span><br><span class="line"></span><br><span class="line">      if key.type &#x3D;&#x3D; String:</span><br><span class="line"></span><br><span class="line">        # 用 SET key value 命令来保存字符串键</span><br><span class="line"></span><br><span class="line">        value &#x3D; get_value_from_string(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;SET &quot; + key + value)</span><br><span class="line"></span><br><span class="line">      elif key.type &#x3D;&#x3D; List:</span><br><span class="line"></span><br><span class="line">        # 用 RPUSH key item1 item2 ... itemN 命令来保存列表键</span><br><span class="line"></span><br><span class="line">        item1, item2, ..., itemN &#x3D; get_item_from_list(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;RPUSH &quot; + key + item1 + item2 + ... + itemN)</span><br><span class="line"></span><br><span class="line">      elif key.type &#x3D;&#x3D; Set:</span><br><span class="line"></span><br><span class="line">        # 用 SADD key member1 member2 ... memberN 命令来保存集合键</span><br><span class="line"></span><br><span class="line">        member1, member2, ..., memberN &#x3D; get_member_from_set(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;SADD &quot; + key + member1 + member2 + ... + memberN)</span><br><span class="line"></span><br><span class="line">      elif key.type &#x3D;&#x3D; Hash:</span><br><span class="line"></span><br><span class="line">        # 用 HMSET key field1 value1 field2 value2 ... fieldN valueN 命令来保存哈希键</span><br><span class="line"></span><br><span class="line">        field1, value1, field2, value2, ..., fieldN, valueN &#x3D;\</span><br><span class="line">        get_field_and_value_from_hash(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;HMSET &quot; + key + field1 + value1 + field2 + value2 +\</span><br><span class="line">                        ... + fieldN + valueN)</span><br><span class="line"></span><br><span class="line">      elif key.type &#x3D;&#x3D; SortedSet:</span><br><span class="line"></span><br><span class="line">        # 用 ZADD key score1 member1 score2 member2 ... scoreN memberN</span><br><span class="line">        # 命令来保存有序集键</span><br><span class="line"></span><br><span class="line">        score1, member1, score2, member2, ..., scoreN, memberN &#x3D; \</span><br><span class="line">        get_score_and_member_from_sorted_set(key)</span><br><span class="line"></span><br><span class="line">        f.write_command(&quot;ZADD &quot; + key + score1 + member1 + score2 + member2 +\</span><br><span class="line">                        ... + scoreN + memberN)</span><br><span class="line"></span><br><span class="line">      else:</span><br><span class="line"></span><br><span class="line">        raise_type_error()</span><br><span class="line"></span><br><span class="line">      # 如果键带有过期时间，那么用 EXPIREAT key time 命令来保存键的过期时间</span><br><span class="line">      if key.have_expire_time():</span><br><span class="line">        f.write_command(&quot;EXPIREAT &quot; + key + key.expire_time_in_unix_timestamp())</span><br><span class="line"></span><br><span class="line">    # 关闭文件</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h2 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h2><p>上一节展示的 AOF 重写程序可以很好地完成创建一个新 AOF 文件的任务， 但是， 在执行这个程序的时候， 调用者线程会被阻塞。</p>
<p>很明显， 作为一种辅佐性的维护手段， Redis 不希望 AOF 重写造成服务器无法处理请求， 所以 Redis 决定将 AOF 重写程序放到（后台）子进程里执行， 这样处理的最大好处是：</p>
<ol>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求。</li>
<li>子进程带有主进程的数据副本，使用子进程而不是线程，可以在避免锁的情况下，保证数据的安全性。</li>
</ol>
<p>不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。</p>
<p>为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中：</p>
<p><img src="../../assets/images/2019-09-02-redis-aof-rdb/graphviz-982033b83f571a133367a8830ee5cca84f6a08e5.svg" alt=""></p>
<p>换言之， 当子进程在执行 AOF 重写时， 主进程需要执行以下三个工作：</p>
<ol>
<li>处理命令请求。</li>
<li>将写命令追加到现有的 AOF 文件中。</li>
<li>将写命令追加到 AOF 重写缓存中。</li>
</ol>
<p>这样一来可以保证：</p>
<ol>
<li>现有的 AOF 功能会继续执行，即使在 AOF 重写期间发生停机，也不会有任何数据丢失。</li>
<li>所有对数据库进行修改的命令都会被记录到 AOF 重写缓存中。</li>
</ol>
<p>当子进程完成 AOF 重写之后， 它会向父进程发送一个完成信号， 父进程在接到完成信号之后， 会调用一个信号处理函数， 并完成以下工作：</p>
<ol>
<li>将 AOF 重写缓存中的内容全部写入到新 AOF 文件中。</li>
<li>对新的 AOF 文件进行改名，覆盖原有的 AOF 文件。</li>
</ol>
<p>当步骤 1 执行完毕之后， 现有 AOF 文件、新 AOF 文件和数据库三者的状态就完全一致了。</p>
<p>当步骤 2 执行完毕之后， 程序就完成了新旧两个 AOF 文件的交替。</p>
<p>这个信号处理函数执行完毕之后， 主进程就可以继续像往常一样接受命令请求了。 在整个 AOF 后台重写过程中， 只有最后的写入缓存和改名操作会造成主进程阻塞， 在其他时候， AOF 后台重写都不会对主进程造成阻塞， 这将 AOF 重写对性能造成的影响降到了最低。</p>
<p>以上就是 AOF 后台重写， 也即是 <a href="http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener">BGREWRITEAOF</a> 命令的工作原理。</p>
<h2 id="AOF-后台重写的触发条件"><a href="#AOF-后台重写的触发条件" class="headerlink" title="AOF 后台重写的触发条件"></a>AOF 后台重写的触发条件</h2><p>AOF 重写可以由用户通过调用 <a href="http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener">BGREWRITEAOF</a> 手动触发。</p>
<p>另外， 服务器在 AOF 功能开启的情况下， 会维持以下三个变量：</p>
<ul>
<li>记录当前 AOF 文件大小的变量 <code>aof_current_size</code> 。</li>
<li>记录最后一次 AOF 重写之后， AOF 文件大小的变量 <code>aof_rewrite_base_size</code> 。</li>
<li>增长百分比变量 <code>aof_rewrite_perc</code> 。</li>
</ul>
<p>每次当 <code>serverCron</code> 函数执行时， 它都会检查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：</p>
<ol>
<li>没有 <a href="http://redis.readthedocs.org/en/latest/server/bgsave.html#bgsave" target="_blank" rel="noopener">BGSAVE</a> 命令在进行。</li>
<li>没有 <a href="http://redis.readthedocs.org/en/latest/server/bgrewriteaof.html#bgrewriteaof" target="_blank" rel="noopener">BGREWRITEAOF</a> 在进行。</li>
<li>当前 AOF 文件大小大于 <code>server.aof_rewrite_min_size</code> （默认值为 1 MB）。</li>
<li>当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。</li>
</ol>
<p>默认情况下， 增长百分比为 <code>100%</code> ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>AOF 文件通过保存所有修改数据库的命令来记录数据库的状态。</li>
<li>AOF 文件中的所有命令都以 Redis 通讯协议的格式保存。</li>
<li>不同的 AOF 保存模式对数据的安全性、以及 Redis 的性能有很大的影响。</li>
<li>AOF 重写的目的是用更小的体积来保存数据库状态，整个重写过程基本上不影响 Redis 主进程处理命令请求。</li>
<li>AOF 重写是一个有歧义的名字，实际的重写工作是针对数据库的当前值来进行的，程序既不读写、也不使用原有的 AOF 文件。</li>
<li>AOF 可以由用户手动触发，也可以由服务器自动触发。</li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sync</tag>
        <tag>同步</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 SSH 登陆谷歌云 root 或者 普通账户的方法</title>
    <url>/tool-2020-01-02-google-clound-local-login/</url>
    <content><![CDATA[<h1 id="使用普通用户登陆"><a href="#使用普通用户登陆" class="headerlink" title="使用普通用户登陆"></a>使用普通用户登陆</h1><h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><p><img src="../../assets/images/2020-01-02-google-clound-local-login/image-20200112043711450.png" alt="image-20200112043711450"></p>
<p>生成后可以把 Key comment 改为你想要的名称, 这样下面你在连接的时候可以使用比较熟悉的Username 作为登录名, 然后使用 Ctrl + C 把上面显示的那串 ssh-rsa.. 开头的公钥复制下来. 待会要用到这个.</p>
<p><img src="../../assets/images/2020-01-02-google-clound-local-login/image-20200112043833424.png" alt="image-20200112043833424"></p>
<p>然后保存好你的私钥和公钥到本地目录中..私钥是<code>本地</code>用的,公钥是<code>远程服务器</code>用的</p>
<h1 id="添加公钥到谷歌云的实例中"><a href="#添加公钥到谷歌云的实例中" class="headerlink" title="添加公钥到谷歌云的实例中"></a>添加公钥到谷歌云的实例中</h1><p><img src="../../assets/images/2020-01-02-google-clound-local-login/image-20200112044032323.png" alt="image-20200112044032323"></p>
<p>点击实例的名称进入实例的详情后. 进入页面后点击上方的修改, 然后拉到下方找到如下图的地方点击添加一项, 把刚刚复制的公钥粘贴进去, 记得, 正确的公钥是在结尾会有一个空格加上你的 Username , 例如: “…== qian” </p>
<h1 id="使用SSH工具连接到实例"><a href="#使用SSH工具连接到实例" class="headerlink" title="使用SSH工具连接到实例"></a>使用SSH工具连接到实例</h1><p><img src="../../assets/images/2020-01-02-google-clound-local-login/image-20200112044256601.png" alt="image-20200112044256601"></p>
<h1 id="使用-root-账户登陆和修改root密码"><a href="#使用-root-账户登陆和修改root密码" class="headerlink" title="使用 root 账户登陆和修改root密码"></a>使用 root 账户登陆和修改root密码</h1><h3 id="先选择从浏览器打开ssh连接服务器"><a href="#先选择从浏览器打开ssh连接服务器" class="headerlink" title="先选择从浏览器打开ssh连接服务器"></a>先选择从浏览器打开ssh连接服务器</h3><p><a href="https://ycb.hk/usr/uploads/2018/03/2557178057.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-01-02-google-clound-local-login/2557178057.png" alt="img"></a><br>连接登录成功后，输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -i  #切换到root</span><br><span class="line">passwd   #修改密码</span><br></pre></td></tr></table></figure>

<p><a href="https://ycb.hk/usr/uploads/2018/03/2932129962.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-01-02-google-clound-local-login/2932129962.png" alt="img"></a><br>然后会要求输入新密码，然后再重复一次密码，输入密码的时候不会显示出来，所以直接输入密码，然后回车，再然后重复输入密码回车。</p>
<p>修改root密码完成</p>
<h3 id="接着修改SSH配置文件-etc-ssh-sshd-config"><a href="#接着修改SSH配置文件-etc-ssh-sshd-config" class="headerlink" title="接着修改SSH配置文件/etc/ssh/sshd_config"></a>接着修改SSH配置文件/etc/ssh/sshd_config</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config #编辑文件</span><br></pre></td></tr></table></figure>

<p>然后再输</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i   #进入编辑模式</span><br></pre></td></tr></table></figure>

<p>找到以下内容并修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes &#x2F;&#x2F;默认为no，需要开启root用户访问改为yes</span><br><span class="line">PasswordAuthentication yes &#x2F;&#x2F;默认为no，改为yes开启密码登陆</span><br></pre></td></tr></table></figure>

<p><a href="https://ycb.hk/usr/uploads/2018/03/3324977715.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-01-02-google-clound-local-login/3324977715.png" alt="img"></a><br>修改完成后，再下按 esc 键，然后再输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq   #保存并退出</span><br></pre></td></tr></table></figure>

<p><a href="https://ycb.hk/usr/uploads/2018/03/1145294211.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-01-02-google-clound-local-login/1145294211.png" alt="img"></a><br>最后重启下服务器即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot    #重启服务器</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 下安装Shadowsocks 搭建ss</title>
    <url>/tool-2020-01-12-centosn-ss-install/</url>
    <content><![CDATA[<p>CentOS 7 开始默认使用<a href="https://en.wikipedia.org/wiki/Systemd" target="_blank" rel="noopener">Systemd</a>作为开启启动脚本的管理工具，<a href="https://github.com/shadowsocks/" target="_blank" rel="noopener">Shadowsocks</a>则是当前比较受欢迎的科学上网工具，本文将介绍如何在 CentOS 下安装和配置 Shadowsocks 服务。</p>
<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p><a href="https://pip.pypa.io/en/stable/installing/" target="_blank" rel="noopener">pip</a>是 python 的包管理工具。在本文中将使用 python 版本的 shadowsocks，此版本的 shadowsocks 已发布到 pip 上，因此我们需要通过 pip 命令来安装。</p>
<p>在控制台执行以下命令安装 pip：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -o <span class="string">"get-pip.py"</span></span><br><span class="line">python3 get-pip.py</span><br></pre></td></tr></table></figure>

<h2 id="安装配置-shadowsocks"><a href="#安装配置-shadowsocks" class="headerlink" title="安装配置 shadowsocks"></a>安装配置 shadowsocks</h2><p>在控制台执行以下命令安装 shadowsocks：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure>

<p>安装完成后，需要创建配置文件<code>/etc/shadowsocks.json</code>，内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">  <span class="attr">"server_port"</span>: <span class="number">8388</span>,</span><br><span class="line">  <span class="attr">"password"</span>: <span class="string">"uzon57jd0v869t7w"</span>,</span><br><span class="line">  <span class="attr">"method"</span>: <span class="string">"aes-256-cfb"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>method</code>为加密方法，可选<code>aes-128-cfb, aes-192-cfb, aes-256-cfb, bf-cfb, cast5-cfb, des-cfb, rc4-md5, chacha20, salsa20, rc4, table</code></li>
<li><code>server_port</code>为服务监听端口</li>
<li><code>password</code>为密码，可使用<a href="http://ucdok.com/project/generate_password.html" target="_blank" rel="noopener">密码生成工具</a>生成一个随机密码</li>
</ul>
<p>以上三项信息在配置 shadowsocks 客户端时需要配置一致，具体说明可查看 shadowsocks 的帮助文档。</p>
<h2 id="配置自启动"><a href="#配置自启动" class="headerlink" title="配置自启动"></a>配置自启动</h2><p>新建启动脚本文件<code>/etc/systemd/system/shadowsocks.service</code>，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Shadowsocks</span><br><span class="line">After&#x3D;network.target auditd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">TimeoutStartSec&#x3D;0</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks.json --pid-file &#x2F;var&#x2F;run&#x2F;shadowsocks.pid -d start</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks.json  --pid-file &#x2F;var&#x2F;run&#x2F;shadowsocks.pid -d stop</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;shadowsocks.pid</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<p>执行以下命令启动 shadowsocks 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> shadowsocks</span><br><span class="line">systemctl start shadowsocks</span><br></pre></td></tr></table></figure>

<p>为了检查 shadowsocks 服务是否已成功启动，可以执行以下命令查看服务的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status shadowsocks -l</span><br></pre></td></tr></table></figure>

<p>如果服务启动成功，则控制台显示的信息可能类似这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● shadowsocks.service - Shadowsocks</span><br><span class="line">   Loaded: loaded (&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;shadowsocks.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Mon 2015-12-21 23:51:48 CST; 11min ago</span><br><span class="line"> Main PID: 19334 (ssserver)</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;shadowsocks.service</span><br><span class="line">           └─19334 &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">Dec 21 23:51:48 morning.work systemd[1]: Started Shadowsocks.</span><br><span class="line">Dec 21 23:51:48 morning.work systemd[1]: Starting Shadowsocks...</span><br><span class="line">Dec 21 23:51:48 morning.work ssserver[19334]: INFO: loading config from &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line">Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     loading libcrypto from libcrypto.so.10</span><br><span class="line">Dec 21 23:51:48 morning.work ssserver[19334]: 2015-12-21 23:51:48 INFO     starting server at 0.0.0.0:8388</span><br></pre></td></tr></table></figure>



<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AttributeError: &#x2F;lib64&#x2F;libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</span><br></pre></td></tr></table></figure>

<p>以前在openssl，有<code>EVP_CIPHER_CTX_cleanup</code>函数.1.1.0版本中替换成为<code>EVP_CIPHER_CTX_reset</code></p>
<p>解决办法：找到报错的文件(注意:根据你的python版本修改,看报错信息中使用的openssl文件)</p>
<p><code>vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py</code></p>
<p>全文搜索cleanup将所有<code>EVP_CIPHER_CTX_cleanup</code>替换成为<code>EVP_CIPHER_CTX_reset</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s&#x2F;cleanup&#x2F;reset&#x2F;</span><br><span class="line"></span><br><span class="line">:x</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下brew 使用</title>
    <url>/tool-2020-01-13-brew/</url>
    <content><![CDATA[<h3 id="将brew装在非系统盘"><a href="#将brew装在非系统盘" class="headerlink" title="将brew装在非系统盘"></a>将brew装在非系统盘</h3><ul>
<li><p><code>Command-R</code> 重新安装您在 Mac 上安装过的最新 macOS，但不会升级到更高的版本。 </p>
</li>
<li><p><code>Option-Command-R</code> 升级到与您的 Mac 兼容的最新 macOS。 </p>
</li>
<li><p><code>Shift-Option-Command-R</code> 需要安装 <a href="https://link.zhihu.com/?target=https%3A//support.apple.com/zh-cn/HT201260">macOS Sierra 10.12.4</a> 或更高版本重新安装 Mac 随附的 macOS 或仍有提供的最接近版本。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">禁用安全工具,使/usr/<span class="built_in">local</span>可以挂载到非系统盘,需要进入安全模式执行</span></span><br><span class="line">csrutil disable</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 挂载非系统盘到/usr/<span class="built_in">local</span></span></span><br><span class="line">vi /etc/fstab</span><br><span class="line">UUID=BA245166-9FB3-4D88-98E3-147559D0B531 /usr/local apfs rw,auto,nobrowse</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置环境变量HOMEBREW_TEMP需要和brew在同一个硬盘</span></span><br><span class="line">vi ~/.bash_profile</span><br><span class="line">export PATH="/usr/local/bin:$PATH"</span><br><span class="line">export HOMEBREW_TEMP=/usr/local/temp</span><br></pre></td></tr></table></figure>

<h3 id="切换国内的镜像源"><a href="#切换国内的镜像源" class="headerlink" title="切换国内的镜像源"></a>切换国内的镜像源</h3><p>Homebrew 默认使用的是国外的源，在下载时速度可能会比较慢。好在国内的清华大学和中科大提供了 Homebrew 的镜像源，我们可以很轻松的切换源，从而提升我们的下载速度。</p>
<h4 id="使用中科大的镜像"><a href="#使用中科大的镜像" class="headerlink" title="使用中科大的镜像"></a>使用中科大的镜像</h4><p>执行如下命令，即可切换为中科大的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line">git remote <span class="built_in">set</span>-url origin git://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure>

<h4 id="使用清华大学的镜像"><a href="#使用清华大学的镜像" class="headerlink" title="使用清华大学的镜像"></a>使用清华大学的镜像</h4><p>执行如下命令，即可切换为清华大学的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo)</span>"</span> remote <span class="built_in">set</span>-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo homebrew/core)</span>"</span> remote <span class="built_in">set</span>-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br></pre></td></tr></table></figure>

<h3 id="使用-Brewfile-完成环境迁移"><a href="#使用-Brewfile-完成环境迁移" class="headerlink" title="使用 Brewfile 完成环境迁移"></a>使用 Brewfile 完成环境迁移</h3><p>设备永久了，我们的电脑中会有大量的软件，如果你需要迁移环境，重新安装会是一个大麻烦，好在 Homebrew 本身为我们提供了一个非常好用的环境迁移的工具 —— Homebrew Bundle</p>
<p>你首先需要在之前的电脑中执行 <code>brew bundle dump</code> 来完成当前环境的导出,导出完成后，你会得到一个 <em>Brewfile</em>。</p>
<p><img src="../../assets/images/2020-01-13-brew/1.jpeg" alt="img">然后将 <em>Brewfile</em> 复制到新的电脑中，并执行 <code>brew bundle</code> 来开始安装的过程。</p>
<h3 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h3><p><img src="../../assets/images/2020-01-13-brew/%E6%88%AA%E5%B1%8F2020-02-05%E4%B8%8A%E5%8D%884.33.45.png" alt="截屏2020-02-05上午4.33.45"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew cask install launchrocket</span><br></pre></td></tr></table></figure>



<h3 id="常用链接"><a href="#常用链接" class="headerlink" title="常用链接"></a>常用链接</h3><p><a href="https://github.com/Homebrew/homebrew-services" target="_blank" rel="noopener">https://github.com/Homebrew/homebrew-services</a></p>
<p><a href="https://sspai.com/post/56009" target="_blank" rel="noopener">https://sspai.com/post/56009</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title>术语中英文对照</title>
    <url>/tool-2020-02-05-game-en-zh/</url>
    <content><![CDATA[<p>中英对照的网络游戏术语</p>
<p>AC – Armor Class，盔甲等级、级别</p>
<p>Account – 账号，与密码Password相对</p>
<p>Add – 一只玩家加入到组队中，如果请求别人组队，可说Add me pls.</p>
<p>AOE – Area Effect Damage，区域作用魔法，指的是一个可以伤害一个区域中的一群怪物的魔法，即所谓的群攻，现并非魔攻专用</p>
<p>AE – Area Effect，区域作用伤害</p>
<p>AFK – Away from Keyboard，暂时离开(键盘)，意味着玩家暂时不再操控游戏角色，通知其他玩家注意</p>
<p>Aggro – 指一些敌对、主动攻击的怪物，当角色接近它时，它会试图攻击角色，这种行为成为Aggro</p>
<p>Aggro Radius – 怪物周围的区域，进入它意味着怪物会“苏醒”并主动攻击你</p>
<p>Agi – Agility的缩写，意为敏捷，多指代游戏中角色的属性</p>
<p>Avatar – 你的角色，互联网中常用来指头像，如论坛中的会员头像等</p>
<p>Beta – 游戏的测试</p>
<p>Bind(Bound) – 重生复活点</p>
<p>Boss – 游戏中的终极怪物，通常各个级别段都有不同的Boss，中文里可以称为大王，老头儿等</p>
<p>Buff – 主要指辅助类角色为别人施加的有益状态，通俗的说法就是“加状态”，典型的如增加防御、回血速度、躲避率等等</p>
<p>Bug – 游戏中的漏洞</p>
<p>Carebear – 喜欢帮助别人攻击怪物的玩家</p>
<p>Caster – 不能抗怪的角色，如法师</p>
<p>CBT – Closed Beta Test 游戏封闭测试</p>
<p>CD – Cool Down, 多指技能的冷却时间</p>
<p>Character – 游戏中的角色</p>
<p>Cheat – 游戏中的作弊，也只游戏秘笈</p>
<p>Cheese – 利用游戏的不平衡之处牟利</p>
<p>Combat Pets – 被玩家控制的NPC，在战斗中帮助玩家及其队友，直译也有宠物的意思</p>
<p>CR – Corpse Retrevial的缩写，指取回尸体，这要看具体游戏的设置而论，很多游戏没有这个设置</p>
<p>Creep – 怪物</p>
<p>Creep Jacking – 当其他玩家与怪物战斗的时候趁机攻击该玩家</p>
<p>Critters – 面对玩家攻击不会反击的怪物</p>
<p>DD – Direct Damage，直接伤害，非持续性伤害作用</p>
<p>DBUFF – De-Buff的简写，对怪物或敌对玩家施放的具有负面状态，如是对方减速、降低防御、降低准确率等等</p>
<p>Defense – 防御，这是通俗的叫法，具体还有物防、魔防等分类</p>
<p>DKP – Dragon Kill Point的缩写，直译是屠龙点数，一种对玩家贡献的衡量标准</p>
<p>DMG – Damage的缩写，指伤害</p>
<p>DOT – Damage over time，在一段时间内持续对目标造成伤害，持续伤害</p>
<p>DPS – Damage per second的缩写，每秒伤害</p>
<p>Dungeon – 指地宫、地下城等，多指游戏中难度很大的地形，也是Boss的栖居地</p>
<p>FH – Full Health的简写，指生命值全满</p>
<p>FM – Full Mana的简写，指法力全满</p>
<p>Forge – 要塞，可以是游戏中的场景、地图</p>
<p>FS – Full Sport的缩写，指完全负责辅助的角色；汉语里可以做为法师的简称，注意区别</p>
<p>Gank – PvP：当其他玩家与怪物战斗时趁机攻击该玩家，与Creep Jacking 类似</p>
<p>Gate(gateway) – 游戏中的传送，与Portal相似</p>
<p>GM – Game Master的简写，指游戏管理员，服务玩家，维护游戏内正常运行的人</p>
<p>Griefer – 试图骚扰或激怒其他玩家的人</p>
<p>Grinding – 长时间在一地点猎怪，多是为了升级或取得特殊游戏道具</p>
<p>Guild – 公会、团体</p>
<p>Heart – 心脉、血脉，多指游戏角色的属性</p>
<p>HOT – Health Over Time的缩写，指持续性治疗效果</p>
<p>HP – 作为Health point的简写时，指生命值；做为Hit points的简写时指伤害值，其中前者较常用</p>
<p>ID – Identification的简写，网络中表示各种账号，表示账号时，与account意义相同；通常指身份证、证件</p>
<p>INC – Incoming的简写，指引怪的人对其他玩家的警示</p>
<p>Instancing – 游戏中的副本，现在很多网游都引入了这一玩法</p>
<p>INT – Intelligence的简写，指智力，多指代游戏中角色的属性</p>
<p>Item – 泛指游戏内的道具</p>
<p>Kiting – 玩家保持在敌人战斗范围以外的一种战术，从敌人身边跑开，同时对其造成伤害</p>
<p>KO – Knock Out的简写，与人挑战时击败对方</p>
<p>KOS – Killed on Sight的简写，多指游戏中的设置，游戏NPC对敌对阵营玩家的攻击行为</p>
<p>KS – Kill Steal的简写，直译是偷杀，试图杀死另一个人正在对付的怪物，以获取经验(主要目的)、道具(这种情况不多)</p>
<p>Lag – 延时，就是我们平常说的卡，当你卡了，你可以说Laaaaaaaaaag</p>
<p>LFG – Looking for a group的简写，寻找队伍以求加入</p>
<p>LFM – Looking for more的简写，找寻更多的人组队</p>
<p>LOL – Lots of Laugh/Laughing Out Loud的简写，指大笑，很常用的聊天词汇，相当于汉语中的”呵呵”、”哈哈”等，ROFL(笑到打滚)此不常用</p>
<p>LOM – Low on Mana的简写，法力不足</p>
<p>Login – 与Logon, Log-in意义相同，表示登入账号的意思</p>
<p>LOS – Line of Sight的简写，视线</p>
<p>LOOT – 从被杀死的怪物或宝箱里拿取游戏道具、战利品等</p>
<p>Lure – 指引怪，3D游戏中常用，组队杀怪时，有玩家负责将怪引向团队，然后用群攻技能集体杀怪</p>
<p>LVL – Level的简写，游戏角色等级</p>
<p>Maintenance – 维护，一般指游戏停机维护</p>
<p>Mana – 魔法，通俗的称呼是蓝</p>
<p>Map – 地图，游戏内的场景，也可用 Zone 表示地图</p>
<p>Mental – 意念，多指代游戏角色的属性，与下面的Spirit有些类似</p>
<p>Mez – Mesmerize的缩写，指催眠等状态是玩家暂时失去对角色的控制</p>
<p>MMO – Massively Multiplayer Online，大型多人在线</p>
<p>MMOG – Massively Multiplayer Online Game，大型多人在线游戏</p>
<p>MMORPG – Massive Multiplayer Online Role Playing Game，大型多人在线角色扮演游戏</p>
<p>MOB – 指游戏中的怪物，任何怪物都可叫MOB，或游戏中所有由电脑控制的角色，第二种用法不常见</p>
<p>MP – Magic Point魔法值，是对魔法的通俗称呼，正式的叫法应该是Mana</p>
<p>MT – Main Tank的缩写，WOW中的主力抗怪角色，其它游戏中可以没有这样的描述</p>
<p>Muscle – 肌肉，多指游戏角色的属性</p>
<p>Nerf – 消弱</p>
<p>Nerve – 神经，多指游戏角色的属性</p>
<p>Newbie – 菜鸟，形容新玩家，有时也指那些操作不熟练、技术不太好的玩家</p>
<p>Newb – 新人的简称，同上</p>
<p>Ninja – 没有经过相关玩家允许或趁别人没注意而拿走战利品</p>
<p>N00b – 一种用来称呼新人的不礼貌的说法</p>
<p>NPC – Non-Player-Controlled Character，非玩家控制的角色，纯粹的电脑角色，由游戏控制</p>
<p>OBT – Open Beta Test 游戏公开测试</p>
<p>OOM – Out of Mana的简写，法力耗尽，多在组队中提醒队员注意</p>
<p>ORZ – 一个人跪地的无语姿势，象形，表示钦佩的感叹</p>
<p>OT – Over Taunt的缩写，别人的翻译是仇恨失控，怪物对玩家角色的仇恨，多用于WOW中</p>
<p>Party – 组队，与Team相近</p>
<p>Password – 泛指密码</p>
<p>Patch – 补丁</p>
<p>PC – Player controlled character，玩家控制的角色，与上面的NPC是相对的；网络中PC也很常见，指个人电脑</p>
<p>Pet – 被玩家控制的非玩家生物，如宠物、召唤物等</p>
<p>PK – Player Kill或Player Killer，玩家在未经另一个玩家同意的情况下攻击并试图杀死他</p>
<p>Player – 玩家，操作游戏中角色的人</p>
<p>PM – Personal Message的缩写，指一个玩家对另一玩家的私人会话</p>
<p>POP – Repopulation的缩写，指怪物刷新</p>
<p>Portal – 泛指游戏内的传送</p>
<p>Proc – 激活，多指一些武器、装备附加效果、属性</p>
<p>PST – Please Send Tell的简写，指说话的人想通过 /t(ell) 或 /w(hisper) 命令交流</p>
<p>Puller – 负责吸引怪物的玩家，常说引怪，与上面的Lure相近</p>
<p>Pulling – 队伍中的玩家负责吸引一只或几只怪物，并将他们带到队伍所在地，集体杀怪，这多指高级怪物的情况下，与上面的Lure不完全一样</p>
<p>PvE – Player vs. Environment的简写， 玩家与电脑控制的角色战斗</p>
<p>PVP – Player vs. Player的简写，玩家对玩家的战斗</p>
<p>Raid – 可译为突袭，由一群玩家在某一地区进行的大规模作战，有时也指团队副本、大副本</p>
<p>Quest – 游戏中的任务</p>
<p>Re-buff – 重新加有益状态</p>
<p>Res – Resurrect / Rescure的缩写，指复活暂时死亡的角色</p>
<p>Re-Spawn – 一只被杀死的怪物重新刷出</p>
<p>Rest (state) – 角色疲劳状态，一般杀怪经验、物品掉率效率都受影响，是为了玩家健康而强制执行的一项措施</p>
<p>Resistance – 对属性攻击的抵御(如，冰ice, 火fire, 点lighting, 毒poison等)</p>
<p>Respawn – 重生点复活</p>
<p>Roll – 指掷随机数字来决定物品的归属</p>
<p>Root – 给敌人施加的类似定身的状态</p>
<p>Schedule – 泛指游戏内活动的日程表</p>
<p>Sever – 服务器，与游戏客户端相对</p>
<p>Small Pets – 跟随玩家的小动物，可以称为宠物，是否直接影响玩家或怪物，要看具体的游戏设置了</p>
<p>SOLO – 单独杀怪、做任务等，不与别人组队的游戏玩法</p>
<p>Spawns – 在游戏世界中，怪物被刷出时所位于的地点或出现的过程</p>
<p>SPI – Spirit的简写，直译是灵魂，多指代游戏角色的属性</p>
<p>STA – Stamina的缩写，耐力</p>
<p>Stack – 堆放在同一个道具栏中的同类物品的数量，通俗讲就是叠加数量</p>
<p>STR – Strength的缩写，力量，多指代游戏角色的属性</p>
<p>Stun – 击晕(状态)</p>
<p>Tank – 能够承受很多伤害的近战角色，如一名战士，是抗怪的角色</p>
<p>Tap – 对怪物造成伤害，标为你的猎物，一旦你对怪物造成了伤害，只有你才能得到经验值和掠夺战利品</p>
<p>Taunt – 直译是嘲弄的意思，指从其它玩家那里吸引怪物</p>
<p>Team – 游戏内指组队，与Party相近；当用于游戏公司时指(游戏研发、运营)团队</p>
<p>Threat – 直译是威吓的意思，有可能是指将怪物暂时镇住、吓走等</p>
<p>TPP – Third Party Programme，直译为第三方程序，就是平常的外挂</p>
<p>Train – 把一群怪物引向另一名玩家，通俗讲就是陷害</p>
<p>Twink – 高等级带练低等级玩家</p>
<p>&Uuml;ber – super的德语说法，原意指over power, 极其强力</p>
<p>UC – Undercity 地下城</p>
<p>Update – 与Upgrade意义相近，泛指游戏内的更新，如服务器更新、地图更新、道具更新等等</p>
<p>Vendor Trash – 只有商人NPC才愿意购买的物品</p>
<p>VS – Ver Sus的简写，对决、挑战、单挑</p>
<p>WTB – Wanting to buy的缩写，想要购买</p>
<p>WTS – Wanting to sell的缩写，想要出售</p>
<p>XP or Exp – Experience的简写，经验值</p>
<p>3D Accelerator：3D加速器。一种专门提升PC的3D运算功能硬件，但其不能提升计算</p>
<p>机整体的显示效果。</p>
<p>A</p>
<p>ACT（Action Game）：动作类游戏。这类游戏提供玩者一个训练手眼协调及反应力的</p>
<p>环境及功能，通常要求玩者所控制的主角（人或物）根据周遭情况变化做出一定的动</p>
<p>作，如移动、跳跃、攻击、躲避、防守等，来达到游戏所要求的目标。此类游戏讲究逼</p>
<p>真的形体动作、火爆的打斗效果、良好的*作手感及复杂的攻击组合等等。</p>
<p>AI（Artificial Intelligence）：人工智能。就是指计算机模仿真实世界的行为方式</p>
<p>与人类思维与游戏的方式的运算能力。那是一整套极为复杂的运算系统与运算规则。</p>
<p>Alpha：Alpha测试。就是指在游戏制作者控制的环境下进行的游戏测试工作，所以一</p>
<p>般来说a测试是在公司内部进行的。</p>
<p>AVG（Adventure Game）：冒险类游戏。这类游戏在一固定的剧情或故事下，提供玩者</p>
<p>一个可解谜的环境及场景，玩者必须随着故事的安排进行解谜。游戏的目的是借游戏主</p>
<p>角在故事中所冒险积累的经验来解开制作者所设定的谜题或疑点。通常这类游戏常被用</p>
<p>来设计成侦探类型的解谜游戏。</p>
<p>B</p>
<p>Beta：Beta测试。就是指不在制作者控制的环境下进行的游戏测试工作，所以一般来</p>
<p>说Beta测试则是交由选定的测试者单独来进行测试。</p>
<p>Boss：大头目，也称“老板”。在游戏中出现的较为巨大有力与难缠的敌方对手。一</p>
<p>般这类敌人在整个游戏过程中只会出现一次，而常出现在关底，而不像小怪物在游戏中</p>
<p>可以重复登场。</p>
<p>Bug：程序漏洞，俗称“臭虫”。指那些因游戏设计者与测试者的疏漏而剩留在游戏中</p>
<p>的程序错误，严重的话将影响整个作品的质量。</p>
<p>C</p>
<p>Cheat：游戏秘技。游戏设计者暗藏在作品中的特殊技巧，使用后可带给玩者特殊的能</p>
<p>力与效果。最先是程序者为快速测试作品而设计的内部秘技，现在几乎已是每个游戏均</p>
<p>有秘技。</p>
<p>Clock Speed： 游戏执行速度。即游戏在计算机中被运行的速度，常以Megahertz</p>
<p>（MHz）计量。</p>
<p>Code：密码。1）同Cheat条；2）同Source Code条。</p>
<p>D</p>
<p>Doom-like： 三维射击类游戏。即第一人称射击类游戏。游戏画面即为玩者的视野范</p>
<p>围。现在此类游戏多称作Quake-like。</p>
<p>E</p>
<p>E3（Electronic Entertainment Expo）：美国E3大展。 当前世界上最为盛大的电脑</p>
<p>游戏与电视游戏的商贸展示会，基本于每年五月举行。</p>
<p>Easter Egg：复活节彩蛋。 程序中隐藏着的一段意外的内容，常为制作者设计的搞笑</p>
<p>内容，经常是关于制作者自己的介绍与调侃。</p>
<p>ECTS（European Computer Trade Show）：欧洲计算机商贸展示会。被称为欧洲的E3</p>
<p>大展，每年三月和九月于伦敦举行。</p>
<p>Electronic Game：电子游戏。即电脑游戏、电视游戏以及街机和手掌型游戏机的总</p>
<p>称。</p>
<p>Engine：游戏引擎。 即一套游戏的主程序。</p>
<p>Experience Point：经验点数。常出现在角色扮演游戏中，以数值计量人物的成长，</p>
<p>经验点数达到一定数值后常常会升级，这时人物就会变得更强大。</p>
<p>F</p>
<p>FTG（Fighting Game）：格斗类游戏。从动作类游戏脱胎分化出来，就是指两个角色</p>
<p>一对一决斗的游戏形式。现在此类游戏又分化出2D格斗类游戏与3D格斗类游戏。</p>
<p>First Person：第一人称视角。就是指屏幕上不直接出现主角，而是表现为主角的视</p>
<p>野范围。</p>
<p>Flight Sim：飞行模拟类游戏。是模拟类游戏下的一个门类，让玩家感受到*纵飞机以</p>
<p>及飞翔于蓝天上的乐趣。</p>
<p>FMV （Full-motion Video）：全动态影像。即游戏的片头、过场和片尾的动态画面。</p>
<p>Forward Scrolling：向前卷轴。即背景不断向玩者趋近的卷轴模式，常出现在第一人</p>
<p>称射击或模拟类游戏。</p>
<p>Frame：帧，镜头。即显示画面的动态计量单位。</p>
<p>FPS（Frames Per Second）：每秒显示帧数。美国的标准NTSC的电视节目的每秒显示</p>
<p>帧数为30。不少电脑游戏的显示帧数都超过了这个数字。</p>
<p>Free Guy：额外的命。在游戏中，你有可能会获得的额外的命，比如收集一定数量的</p>
<p>某种宝物。</p>
<p>G</p>
<p>Game Over：游戏结束。这是游戏中最常见的话语，通常是表示游戏者失败，而不是通</p>
<p>关爆机。</p>
<p>Gameplay：游戏可玩性。即游戏的玩法，是决定一个游戏有多好玩的重要因素。</p>
<p>Genre：游戏类型。即为不同游戏玩法的游戏作一归类，比如角色扮演类、冒险类、动</p>
<p>作类、模拟类等。</p>
<p>GPU （Graphics Processing Unit）： 图形处理器。辅助CPU处理图形运算。</p>
<p>Graphics Accelerator：图形加速器。专门的提升显示速度和效果的硬件。</p>
<p>Graphic Adventure：图形冒险类游戏。是冒险类游戏下的一个门类， 相对与文字冒</p>
<p>险类游戏。</p>
<p>GUI（Graphical User Interface）：图形用户界面。 即计算机与用户的交互界面。</p>
<p>H</p>
<p>Hidden Level：隐藏关卡。指游戏中隐藏的部分，自行发现。即不玩到这部分也能够</p>
<p>通关，但玩到后可能会使清洁起变化。</p>
<p>High-Res：高解析度。 即精细的画面显示模式，但游戏的运行速度可能会因此有所下</p>
<p>降。</p>
<p>Hint：攻略提示。简单的攻关提示，帮助玩家解决游戏中出现的特别棘手的难题。</p>
<p>HP（Hit Point）：生命力。即人物或作战单位的生命数值。一般HP为0即表示死亡，</p>
<p>甚至Game Over。</p>
<p>HUD（Heads Up Display）：飞行仪表盘。飞行模拟游戏中的常见词，常提供玩家诸如</p>
<p>弹药状况、速度、目标跟踪等作战信息。</p>
<p>I</p>
<p>Interactive Movie：交互式电影。即结合游戏要素与电影要素的一类计算机互动作</p>
<p>品，常常包含大量的FMV（全动态影像）。</p>
<p>Interface：游戏界面。即玩者*作游戏的方式。它决定游戏的上手难度与可玩性。</p>
<p>J</p>
<p>Joypad：游戏手柄。模拟电视游戏的手柄，通常外接在声卡上。</p>
<p>Joystick：游戏<em>纵杆。常用来玩飞行、赛车等模拟类游戏的外接</em>纵杆。</p>
<p>K</p>
<p>L</p>
<p>Level：关卡。即游戏一个连续的完整的舞台、场景。有时也称作Stage。</p>
<p>Low-Res：低解析度。即粗糙的画面显示模式，但运行速度可稍微提高。</p>
<p>M</p>
<p>Motion Capture：动态捕捉。将物体在3D环境中运动的过程数字化的过程。</p>
<p>Motion Tracker：动作跟踪器。动态捕捉时使用到的设备。</p>
<p>Moves：出招。即格斗游戏中人物的出招技巧。</p>
<p>MP（Magic Point）：魔法力。即人物的魔法数值，一旦使用完即不能再使用魔法招</p>
<p>式。</p>
<p>MUD（Multi-user Dungeon）：多用户地牢，俗称“泥巴”。在互联网络上的一种允许</p>
<p>多人参与的实时游戏，一般类似RPG的玩法，但目前多为文字模式。</p>
<p>Multimedia：多媒体。主要指融合多种表现手法的电脑作品。比如FMV（全动态影</p>
<p>像），电脑游戏、交互作品等。</p>
<p>N</p>
<p>Network Games：网络游戏。指容许多人通过某种网络协议连线后便能进行集体游戏的</p>
<p>游戏种类。</p>
<p>NPC（Non Player Character）：非玩者人物。在角色扮演游戏中，玩者会在游戏过程</p>
<p>中遭逢到的所有不受控制的人物。这些人物或会提示重要情报线索，或是无关紧要的人</p>
<p>物。</p>
<p>O</p>
<p>P</p>
<p>Password：过关密码。在游戏一开始处输入后便能直接进入后面的关卡。</p>
<p>Pirate：盗版游戏。即国内到处泛滥令游戏制作公司头痛不已的盗版游戏。</p>
<p>Pixel：像素。屏幕显示的最小基本单位。</p>
<p>Platformer：游戏平台。游戏运行的平台，包括Win95、DOS或者UNIX等。</p>
<p>Player Killing：玩者杀手。指在MUD中，专以攻击玩者人物，而不是非玩者人物的一</p>
<p>类玩家。</p>
<p>Polygon：多角形。运用在2D屏幕中表现3D环境的多角形单位。</p>
<p>Prototype：原型制作。游戏作品的原型制作也就是指以最快的速度制作出游戏的原</p>
<p>型，一个可以执行的程序原型。从这些基础程序与基础图形，制作者可以看到从电脑中</p>
<p>表现出来的与原来设想的有多大差距，经过调整磨合后就进入了正式动工了。</p>
<p>Puzzle：谜题。在冒险类游戏中，考验玩者智力的谜题。</p>
<p>PZL（Puzzle Game）：解谜类游戏。一类专以不断解谜为主要内容的游戏种类。</p>
<p>Q</p>
<p>Quake-like：三维射击类游戏。即第一人称射击类游戏。见Doom-like条。</p>
<p>R</p>
<p>Round：回合。格斗类游戏中的一个较量的回合。</p>
<p>RPG（Role Playing Game）：角色扮演类游戏。这类游戏提供玩者一个可供冒险的世</p>
<p>界（Fantasy World）或者一个反映真实的世界（Real World），这世界包含了各种角</p>
<p>色、建筑、商店、迷宫及各种险峻的地形。玩者所扮演的主角便在这世界中通过旅行、</p>
<p>交谈、交易、打斗、成长、探险及解谜来揭开一系列的故事情节线索，最终走向胜利的</p>
<p>彼岸。玩者依靠自身的胆识、智慧和机敏获得一次又一次的成功，使自己扮演的主角不</p>
<p>断发展壮大，从而得到巨大的精神满足。</p>
<p>RTS（Realtime Strategy Game）： 即时战略类游戏。对应回合制战略游戏，一切都</p>
<p>是实时发生，要求玩者具备较好的敏捷与宏观指挥能力。</p>
<p>S</p>
<p>Scaling：缩放比例。有些游戏提供画面的缩放比例的调整。</p>
<p>Second Person：第二人称视角。即追尾视角，紧随游戏主角的背影。</p>
<p>Shareware Software：共享软件作品。</p>
<p>Side-Scrolling：横向卷轴。即游戏画面的前景与背景从左向右移动的卷轴模式，常</p>
<p>用于2D射击游戏中。</p>
<p>SLG（Simulation Game）：模拟类游戏。这类游戏提供玩者一个可以做逻辑思考及策</p>
<p>略、战略运用的环境，且让玩者有自由支配、管理或统御游戏中的人、事或物的权力，</p>
<p>并通过这种权力及谋略的运用达成游戏所要求的目标。玩者在条件真实、气氛宏大的游</p>
<p>戏环境中充分施展智慧，克敌制胜，达到高层次的成功享受。</p>
<p>Source Code：原代码。用计算机语言直接编成的程序原码，比如C语言、Pascal。</p>
<p>SPT（Sport）：运动类游戏。这类游戏提供一个反映现实（指正常的运动方式及运动</p>
<p>精神）中的运动项目，并让玩者借助控制或管理游戏中的运动员或队伍，来进行运动项</p>
<p>目的比赛。</p>
<p>Stage：关卡。见Level条。</p>
<p>STG（Shooting Game）：射击类游戏。有平面射击类与三维射击类（即第一人称射击</p>
<p>类）。平面射击类还包括横向卷轴与纵向卷轴两种。射击类游戏是早期电脑游戏最常见</p>
<p>的种类。</p>
<p>Storyline：剧情。即游戏的故事大纲，分为直线型、多线型以及开放型等三种。</p>
<p>Strategy Guide：战略指南手册。即游戏包装盒内附有的基本战略指导手册。</p>
<p>Sub-boss：隐藏头目。有些游戏中会隐藏有更厉害的大头目，通常是在通关后。</p>
<p>T</p>
<p>TAB（Table）：桌面类游戏。这类游戏提供一个训练逻辑思考或解谜的环境，并且有</p>
<p>一定的规则及逻辑。玩者必须遵循游戏所设定的规则来解开谜题，达成游戏目标。此类</p>
<p>游戏讲究高超的人工智能、新奇的玩法和舒适的*作环境。玩者在游戏中自得其乐、逍</p>
<p>遥自在，也是一番享受。</p>
<p>TBS（Turn-based Strategy Game）：回合制战略游戏。对应即时战略类游戏。参加战</p>
<p>斗的几方，可以包括计算机在内，依一定顺序分别部署战略。一次部署便称作一个回</p>
<p>合。</p>
<p>Tester：游戏测试者。游戏制作公司专门花钱聘请的测试作品的资深玩家。</p>
<p>Text Adventure：文字冒险类游戏。是冒险类游戏下的一个门类， 相对与图形冒险类</p>
<p>游戏，多是日本制作的小成本卡通游戏。</p>
<p>Third Person：第三人称视角。电脑游戏中最常见的视角，尤其是2D游戏。玩者是以</p>
<p>第三者的角度观察场景与主角的动作。</p>
<p>U</p>
<p>V</p>
<p>Vertically Scrolling：垂直卷轴。即游戏画面的前景与背景从向下向上移动的卷轴</p>
<p>模式，常用于2D射击游戏中。</p>
<p>View：视角。目前许多3D游戏均提供多视角调整功能。</p>
<p>VR （Virtual Reality）：虚拟实境。</p>
<p>W</p>
<p>Walkthrough：游戏攻略。是指完整的游戏攻关指导。</p>
<p>X</p>
<p>Y</p>
<p>Z</p>
<p>Z-line/Z-axis：Z轴。在3D环境中，Z轴一般表示深度，X轴表示高度，Y轴表示宽度，</p>
<p>而具备了Z轴就构成了3D环境。</p>
<p>WOW九大职业：<br>法师mage 战士warriop 德鲁依 drvid 撒满shamam 圣骑士 paladin 术士warlock 盗贼rogue 牧师prisst 猎人 hunter </p>
<p>角色基本术语：</p>
<p>  　　AR——AttackRating攻击准确率</p>
<p>  　　Blocking——ChanceOfBlocking搁挡机率</p>
<p>  　　bloodrun——就是杀怪物，吸取经验值了。一般特指在act5出门之后第一个砍人的地方，叫BloodyFoothills。HC玩家经常在那里升级，比牛关更安全。</p>
<p>  　　CB——CrushingBlow压碎性打击</p>
<p>  　　CE——coldenhanched冰冷强化</p>
<p>  　　Char——Character角色</p>
<p>  　　CR——coldresist冰冷抵抗力</p>
<p>  　　dam——Damage伤害值</p>
<p>  　　Def/DR——Defencerating防御度</p>
<p>  　　DEX——dexterity敏捷度</p>
<p>  　　Dr——damagereduce物理伤害减少(物免)</p>
<p>  　　DS——DeadlyStrike致命攻击</p>
<p>  　　Dualleech——(life，mana)双吸</p>
<p>  　　ED——EnhanchedDamage/EnhanceDefense增强伤害/增强防御(多指前者)</p>
<p>  　　Eng/Erg/Nrg——energy能量/精力</p>
<p>  　　Eth——Ethereal/ethrune无形的(物品)/第五号符文，有将目标Defense防御力降至负值的Bug效果，常镶在武器上。</p>
<p>  　　Exp/XP——Experiencepoint经验值</p>
<p>  　　FBR——fastblockingrate快速格挡机率</p>
<p>  　　FCR——Fastcastrate快速施法率</p>
<p>  　　Fr/w——Fastrun/walk快速奔跑/行走</p>
<p>  　　FHR——Fasthitrecover快速打击恢复</p>
<p>  　　FR——fireresist火焰抵抗力</p>
<p>  　　FE——fireenhanched火焰强化</p>
<p>  　　HP——HitPoints生命值(life)</p>
<p>  　　IAS——IncreasedAttackSpeed提升攻击速度。繁体中文版误译成提升xx%的准确率，繁体中文版的改良补丁有修正。</p>
<p>  　　ITD——IgnoresTarget‘sDefense忽视目标防御</p>
<p>  　　KB——Knockback击退</p>
<p>  　　LE——lightningenhanched闪电强化</p>
<p>  　　Leecher吸血鬼，就是汲取他人的XP来达到足够的clvl，相信大家都做过Leecher吧</p>
<p>  　　life生命值又称：HitPoints(HP)</p>
<p>  　　lightningenhanchedmultishot闪电强化兼多重射击(祈祷你别碰上吧@-@)</p>
<p>  　　LR——lightningresist闪电抵抗力</p>
<p>  　　mana法力值</p>
<p>  　　mod——itemmodifier(prefixesandsuffixes)物品属性(前缀及后缀)</p>
<p>  　　MF——MagicFind魔法物品找寻</p>
<p>  　　Newbie——就是你了(新手)</p>
<p>  　　NPC——Nonplayercharacter非玩家角色</p>
<p>  　　PD——poisondamage毒素伤害(骗点？@_@)</p>
<p>  　　PI——Physicalimmune物理免疫</p>
<p>  　　PR——poisonresist毒素抵抗力</p>
<p>  　　Req——Required/Requirement需求</p>
<p>  　　res——Resistance元素抵抗(四防)</p>
<p>  　　slvl——Skilllevel技能等级</p>
<p>  　　stamina耐力值</p>
<p>  　　STR——strength强壮度/力量</p>
<p>  　　TP——TownPortal/Teleport城镇传送之门/傳送(女巫技能)</p>
<p>  　　UnID——Unidentify未鉴定</p>
<p>  　　VIT——vitality活力/体力值</p>
<p>  　　WP——Waypoint传送小站</p>
<p>  　　XP/Exp——Experiencepoint经验值</p>
<p>  　　增补术语：</p>
<p>  　　BOT——英文Robot的简写，通指各种自动机器人的游戏外挂，譬如KPBOT(自动KP机器人)，SHOPBOT(自动购物机器人)</p>
<p>  　　Dupe——英文duplicate的简写，指复制的装备</p>
<p>  　　Legit——合法物品，指从游戏中真真生成的非Dupe物品(包括BOT打出的物品)，交易用语</p>
<p>  　　Ith——某种利用hack工具制造的Bug物品,多为武器，具有极为变态的伤害值及属性</p>
<p>  　　cg——ChippedGem碎裂的宝石</p>
<p>  　　pg——PerfectGem完美的宝石</p>
<p>  　　PT——PerfectTopaz完美的黄宝石</p>
<p>  　　Jewels——珠宝</p>
<p>  　　Rune——符文</p>
<p>  　　SC——smallcharm小护身符，一般特指7%MF的smallcharm</p>
<p>  　　LC——LargeCharms大型护身符</p>
<p>  　　GC——GrandCharms超大型护身符</p>
<p>  　　cube——TheHoradriccube赫拉迪克方块，常做动词用，指用Cube转化或合成物品的行为</p>
<p>  　　Craft——指物品的手工合成，即其英文原意</p>
<p>  　　MBow——MatriarchalBow女族長之弓，用做DIY合成Curel蓝色Bow的材料，要求其Ilvl物品等级&gt;87。</p>
<p>  　　N‘sc或B‘sc——通指Hell的Baal巴爾(怪物等级Mlvl=95)、Nihlathaks尼塞拉克(怪物等级Mlvl=98)掉出的SC。整个游戏中只有这二位老大出产的SC才可能合出那几种高元素或毒伤害前缀的SC(其Ilvl≥95)。Baal巴爾、Nihlathaks尼塞拉克掉出的GC没什么特别用处。</p>
<p>  　　Diadem權冠——6PerfectSkulls合成RareCirclets稀有头缳用的材料，因为Diadems总能保持Alvl99，能够合出任何可能的词缀。亮黄的RareDiadem或白色的Diadem(可以利用Imbue任务将之造成亮黄的)都可以用做材料。</p>
<p>  　　Clvl—Characterlevel角色等级，很简单的概念，就是指玩家自己角色的级别</p>
<p>  　　Mlvl——MonsterLevel怪物等级，游戏代码中对三个难度的每一个怪物都有固定的等级设定。普通怪物从1-90级，champions，bosses，SuperUniques相对其同类型的普通怪物会加几个等级。譬如Hell的Baal巴爾其怪物等级Mlvl=95、Nihlathaks尼塞拉克其怪物等级Mlvl=98，它们能够出产Cube用的N‘sc。</p>
<p>  　　Ilvl——ItemLevel物品等级，也就是不少玩家俗称的物品内部等级；它是一个变动的数字，其数值就等于各游戏难度掉落该物品的怪物(或者箱子)等级(Mlvl-MonsterLevel)；目前的新版地图都具有了显示怪物等级的功能，省了大家再去翻看资料了。唯一要注意的是不要把怪物等级(Mlvl-MonsterLevel)和怪物所属的的TC-TreasureClass(财宝阶层)混淆</p>
<p>  　　TC——TreasureClass财宝阶层，游戏中划分一组相近物品的游戏代码术语，用于决定物品的生成。玩家们谈论TC时通常会涉及到武器和防具其中之一。武器和防具各自有30个TCs相对应，从3-90，每隔3升一级。</p>
<p>  　　Alvl——AffixLevel词缀等级，游戏中对每一个魔法前缀和后缀有相应的等级设定，这将决定什么样的Ilvl物品等级才能出现它们</p>
<p>  ama:<br>  Bowazon使用Bow或Crossbow类武器为主要攻击手段的Amazon；</p>
<p>  　　Jabazon使用Spears类武器，并以Jab为主要攻击手段的Amazon；</p>
<p>  　　Javazon使用投掷类(主要是Javelins标枪)武器，并以Lightningfury或PlagueJavelin为主要攻击手段的Amazon；</p>
<p>  　　BowandCrossbow——弓箭和弩箭技能树——弓和十字弓技能</p>
<p>  　　MagicArrow——魔法箭——魔法箭；简称:MA</p>
<p>  　　FireArrow——火之箭——火焰箭；简称:FA</p>
<p>  　　ColdArrow——冷之箭——冰箭；</p>
<p>  　　MultipleShot——多重打击——多重箭；简称:MS</p>
<p>  　　ExplodingArrow——爆破箭——爆裂箭；</p>
<p>  　　IceArrow——冰之箭——急凍箭；</p>
<p>  　　GuidedArrow——向导之箭——導引箭；简称:GA</p>
<p>  　　Strafe——惩罚——砲轟；俗称:扫射</p>
<p>  　　ImmolatingArrow——火墙箭——犧牲之箭；简称:Immo</p>
<p>  　　FreezingArrow——冷冻箭——凍結之箭；简称:FA</p>
<p>  　　PassiveandMagic——被动与魔法技能——被動和魔法技能</p>
<p>  　　InnerSight——心灵视觉——内視；</p>
<p>  　　CriticalShot——临界一击——致命攻擊；简称:CS</p>
<p>  　　Dodge——躲避——閃避；</p>
<p>  　　SlowMissiles——缓慢攻击——慢速箭；简称:SM</p>
<p>  　　Avoid——消除——躲避；</p>
<p>  　　Penetrate——渗透——刺入；</p>
<p>  　　Decoy——诱骗——誘餌；</p>
<p>  　　Evade——规避——迴避；</p>
<p>  　　Valkyrie——瓦尔基里——女武神；简称:Valk</p>
<p>  　　Pierce——刺穿——穿刺；</p>
<p>  　　JavelinandSpear——标枪和魔法技能树——標槍和長矛技能</p>
<p>  　　Jab——猛刺——戳刺；</p>
<p>  　　PowerStrike——能量穿透——威力一擊；</p>
<p>  　　PoisonJavelin——毒之枪——毒槍；</p>
<p>  　　Impale——穿刺——刺爆；</p>
<p>  　　LightningBolt——闪电——閃電球；</p>
<p>  　　ChargedStrike——冲刺打击——充能一擊</p>
<p>  　　PlagueJavelin——瘟疫之枪——瘟疫標槍；</p>
<p>  　　Fend——保护——擊退；</p>
<p>  　　LightningStrike——闪电打击——閃電攻擊；</p>
<p>  　　Lightningfury——狂暴闪电——閃電之怒；简称:LF</p>
<p>  　　亚马逊常用武器装备中英文名称对照：</p>
<p>  　　Buriza-DoKyanon布理撒多凱南俗称：玻璃渣/大炮；</p>
<p>  　　CruelMatriarchalBow残忍的女族長之弓。最常见的DIYBow；简称：CMBow</p>
<p>  　　DIYBow就是玩家自己cube或shopping来再镶以40ED/15IASJewel的Bow。以其无可比拟的高速Frame为部分玩家所喜好；</p>
<p>  　　Eaglehorn鷹號角简称:EH；或称EBow</p>
<p>  　　GoldstrikeArch金色的曲线；</p>
<p>  　　Lycander‘sAim雷山得的指標；</p>
<p>  　　Lycander‘sFlank雷山得的側腹；</p>
<p>  　　M‘avina‘sCaster马维娜的施展——马维娜之战斗诗歌；</p>
<p>  　　Titan‘sRevenge泰坦的復仇简称:Titan；</p>
<p>  　　Windforce風之力简称:wf；<br>  asn:<br>  Trapper以Traps陷阱系技能为主要攻击方式的Assassin；</p>
<p>  　　MAAsn以MartialArt武术系技能为主要攻击方式的Assassin；</p>
<p>  　　c/cAsn使用claw+claw双爪作战的Assassin;又称：DualclawAsn；</p>
<p>  　　c/sAsn使用claw+shield爪盾组合方式作战的Assassin；</p>
<p>  　　DualclawAsn即c/cAsn；</p>
<p>  　　MartialArt——武术技能树——武學藝朮简称:MA</p>
<p>  　　TigerStrike——虎击——虎擊；简称:TS</p>
<p>  　　DragonTalon——龙足——龍爪；</p>
<p>  　　DragonClaw——龙爪——雙龍爪；简称:DC</p>
<p>  　　FistsofFire——火拳——焰拳；简称:fof</p>
<p>  　　CobraStrike——眼镜蛇之击——眼鏡蛇攻擊；简称:CS</p>
<p>  　　DragonTail——龙尾——神龍擺尾；简称:DT</p>
<p>  　　ClawsofThunder——雷鸣爪——雷電爪；简称:cot</p>
<p>  　　BladesofIce——冰之刃——寒冰刃；简称:boi</p>
<p>  　　DragonFlight——龙翔——飛龍在天；简称:DF</p>
<p>  　　PhoenixStrike——凤舞——鳳凰攻擊；简称:PS</p>
<p>  　　ShadowDisciplines——幻影技能树——影子訓練</p>
<p>  　　ClawMastery——钢爪精通——支配利爪；简称:CM</p>
<p>  　　PsychicHammer——通灵之锤——心靈戰槌；</p>
<p>  　　BurstofSpeed——爆发速度——加速；简称:BoS</p>
<p>  　　CloakofShadows——幻影披风——魔影斗篷；简称:CoS</p>
<p>  　　WeaponBlock——武器格挡——武器格擋；简称:WB</p>
<p>  　　Fade——消退——能量消解；</p>
<p>  　　ShadowWarrior——幻影战士——影子戰士；</p>
<p>  　　MindBlast——意识攻击波——精神爆震；简称:MB</p>
<p>  　　Venom——毒液——毒牙；</p>
<p>  　　ShadowMaster——幻影精通——支配影子；简称:SM</p>
<p>  　　Traps——陷阱技能树——陷阱</p>
<p>  　　FireBlast——火焰冲击波——火焰爆震；</p>
<p>  　　ShockWeb——电击网——閃電網；</p>
<p>  　　BladeSentinel——刀刃哨兵——刃之守衛；</p>
<p>  　　ChargedBoltSentry——闪电岗哨——電能守衛；</p>
<p>  　　WakeOfFire——火之复苏——火焰復甦；简称:WoF</p>
<p>  　　BladeFury——狂暴之刃——刃之怒；</p>
<p>  　　LightningSentry——闪电陷阱——雷光守衛；简称:LS</p>
<p>  　　WakeOfInferno——地狱火之复苏——復甦獄火；</p>
<p>  　　DeathSentry——死亡陷阱——亡者守衛；简称:DS</p>
<p>  　　BladeShield——刀盾——刀刃之盾；</p>
<p>  　　刺客常用武器装备中英文名称对照：</p>
<p>  　　Bartuc‘sCut-Throat巴特克的猛擊；</p>
<p>  　　Natalya‘sMark娜塔垭的标记——娜塔亚的非难俗称：绿爪，AsnSetClaws</p>
<p>  　　还有部分Cruel前缀的Elite蓝色爪(有些是Ethereal无形的)；比如常见的CruelScissorsSuwayyah残忍的近身剪；简称:CSS</p>
<p>  　　CruelScissorsSuwayyahofQuickness残忍之快速的近身剪；简称:CSSQ</p>
<p>  bar:<br>  Ssbar以Sword+Shield剑盾组合方式作战的Barbarian，目前的主流Bar玩法，多以WW为主要攻击技能；</p>
<p>  　　Throwingbar使用投掷类(Javelins标枪较好)武器，以Doublethrow为主要攻击技能的Barbarian；</p>
<p>  　　Frenzybar使用双手武器，以Frenzy为主要攻击技能的Barbarian；</p>
<p>  　　Spearian以Spears类武器为主要攻击手段的Barbarian；</p>
<p>  　　WarCries——战斗呼声技能树——呐喊</p>
<p>  　　Howl——怒吼——狂嚎；</p>
<p>  　　Findpotion——寻找药剂——找尋藥劑；</p>
<p>  　　Taunt——辱骂——嘲弄；</p>
<p>  　　Shout——咆哮——大叫；</p>
<p>  　　Finditem——寻找物品——找尋物品；</p>
<p>  　　Battlecry——战斗口号——戰嚎；</p>
<p>  　　Battleorders——战斗号令——戰鬥體制；简称:BO</p>
<p>  　　GrimWard——严密防护——殘酷嚇阻；</p>
<p>  　　Warcry——战争呼声——戰鬥狂嚎；</p>
<p>  　　Battlecommand——战斗命令——戰鬥指揮；简称:BC</p>
<p>  　　CombatMasteries——战斗动作掌握技能树——戰鬥專家</p>
<p>  　　Swordmastery——剑术掌握——支配長劍；简称:SM</p>
<p>  　　Axemastery——战斧掌握——支配斧頭；</p>
<p>  　　Macemastery——钉头槌掌握——支配釘頭槌；</p>
<p>  　　Polearmmastery——长杆武器掌握——支配長棍；</p>
<p>  　　Throwingmastery——投掷武器掌握——支配飛擲；</p>
<p>  　　Spearmastery——枪矛掌握——支配長矛；</p>
<p>  　　Increasedstamina——增强持久力——增加耐力；</p>
<p>  　　Ironskin——钢铁皮肤——鉄布杉；简称:IS</p>
<p>  　　Increasedspeed——增强移动力——加速；</p>
<p>  　　Naturalresistance——自然抗力——自然抵抗；简称:NR</p>
<p>  　　Combat——战斗技能树——戰鬥技能</p>
<p>  　　Bash——怒殴——重擊；</p>
<p>  　　Leap——飞跃——跳躍；</p>
<p>  　　Doubleswing——双重挥舞——雙手揮擊；</p>
<p>  　　Stun——晕眩——擊昏；</p>
<p>  　　Doublethrow——双重投掷——雙手投擲；简称:DT</p>
<p>  　　Leapattack——跳跃攻击——跳躍攻擊；简称:LA</p>
<p>  　　Concentrate——集中——專心；</p>
<p>  　　Frenzy——狂怒——狂亂；</p>
<p>  　　Whirlwind——旋风——旋風；简称:WW</p>
<p>  　　Berserk——狂暴——狂戰士；</p>
<p>  　　野蛮人常用武器装备中英文名称对照：</p>
<p>  　　BulKathosSacredCharge布爾凱索的神聖代價——布爾凱索的孩子俗称：Set大剑；</p>
<p>  　　BulKathosTribalGuardian布爾凱索的部族守护——布爾凱索的孩子俗称：Set小剑；</p>
<p>  　　CruelColossusBlade残忍的巨神之刃简称：CCB；</p>
<p>  　　CruelColossussword残忍的巨神之剑简称：CCS；</p>
<p>  　　CruelColossusBladeofQuickness残忍之快速的巨神之刃简称：就是著名的CCBQ了；</p>
<p>  　　CruelColossusBladeofSwiftness残忍之敏捷的巨神之刃简称：CCBS；</p>
<p>  　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ;</p>
<p>  　　CruelHyperionJavelin残忍之亥伯龍之槍(throwingbar推荐选用)</p>
<p>  　　CruelWingedHarpoon残忍之翼魚叉(throwingbar推荐选用)</p>
<p>  　　Doombringer末日毀滅者；简称:Doom</p>
<p>  　　TheGrandfather祖父;简称：GF(女朋友？@_@:$)；</p>
<p>  　　Lightsabre光之軍刀；简称:LS</p>
<p>  　　fury神符之语剑狂暴，常用BalrogBlade制作；<br>   dru:<br>  ElementalistDruid以Elemental元素系技能为主要攻击方式的Druid；</p>
<p>  　　Grizzlygeddon使用Armageddon+SummonGrizzly为主要攻击技能的Druid；</p>
<p>  　　WWdruid即werewolfdruid，就是变狼的Druid；</p>
<p>  　　Elemental——自然力技能树——元素</p>
<p>  　　Firestorm——暴火——火風爆；</p>
<p>  　　MoltenBoulder——熔石——熔漿巨岩；</p>
<p>  　　ArcticBlast——北极冰风——極地風暴；简称:AB</p>
<p>  　　Fissure——裂缝——火山爆；</p>
<p>  　　CycloneArmor——暴风盔甲——颶風裝甲；简称:CA</p>
<p>  　　Twister——缠绕——縑鼬風；</p>
<p>  　　Volcano——火山——火山；</p>
<p>  　　Tornado——龙卷风——龍捲風；</p>
<p>  　　Hurricane——飓风——暴風；</p>
<p>  　　Armageddon——末日战唱—毀天滅地；</p>
<p>  　　ShapeShifting——形态转变技能树——外型變形</p>
<p>  　　Werewolf——人狼——狼人變化；</p>
<p>  　　Lycanthropy——变狼狂——變形朮；</p>
<p>  　　Werebear——人熊——熊人變化；</p>
<p>  　　Maul——大槌——撞槌；</p>
<p>  　　FeralRage——野兽的愤怒——野性狂暴；</p>
<p>  　　FireClaws——火爪——焰爪；</p>
<p>  　　Rabies——狂犬——狂犬病；</p>
<p>  　　ShockWave——冲击波——震波；</p>
<p>  　　Hunger——饥饿——飢餓；</p>
<p>  　　Fury——狂怒——狂怒；</p>
<p>  　　Summoning——召唤技能树——召喚</p>
<p>  　　Raven——乌鸦——烏鴉；</p>
<p>  　　PoisonCreeper——毒藤——猛毒花藤；</p>
<p>  　　OakSage——橡树贤者——橡木智者；简称:OS</p>
<p>  　　SummonSpiritWolf——召唤精灵狼——召喚鬼狼；</p>
<p>  　　CarrionVine——死腐藤——食尸藤；</p>
<p>  　　HeartofWolverine——狼之心——狼獾之心；简称:HoW</p>
<p>  　　SummonDireWolf——召唤恶狼——召喚狂狼；</p>
<p>  　　SolarCreeper——太阳藤蔓)(太陽藤；</p>
<p>  　　SpiritofBarbs——精神倒刺——棘靈；</p>
<p>  　　SummonGrizzly——召唤灰熊——召喚灰熊；简称:Griz</p>
<p>  　　德鲁依常用武器装备中英文名称对照：</p>
<p>  　　Baranar‘sStar巴拉那之星；有时可简称为DS;</p>
<p>  　　Buriza-DoKyanon布理撒多凱南俗称：玻璃渣/大炮；</p>
<p>  　　CruelColossusBladeofQuickness残忍之快速的巨神之刃;简称：就是著名的CCBQ了；</p>
<p>  　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ</p>
<p>  　　Hellslayer地獄毀滅者；</p>
<p>  　　ImmortalKing‘sStoneCrusher不朽之王的石头压碎者；简称:IKMaul；</p>
<p>  　　Messerschmidt‘sReaver希梅斯特的掠奪；</p>
<p>  　　Schaefer‘sHammer史恰佛之鎚；</p>
<p>  　　TheCraniumBasher碎腦槌；</p>
<p>  nec:</p>
<p>  　　Zookeeper以Summoning为主要技能，辅以各种Curses的Necromancer；</p>
<p>  　　Meleemancer以近身格斗为主要攻击手段，而不依赖召唤大批奴仆的肉搏型Necromancer；</p>
<p>  　　Poisonmancer以毒系技能为主要攻击方式，有些以骨系技能辅助的Necromancer；</p>
<p>  　　Venomancer用PoisonDagger攻击的Necromancer</p>
<p>  　　Summoning——召唤系技能树——召喚法術</p>
<p>  　　Skeletonmastery——骷髅掌握——支配骷髏；</p>
<p>  　　Raiseskeleton——复活骷髅——骷髏復甦；</p>
<p>  　　ClayGolem——土之巨人——黏土石魔；简称:CG</p>
<p>  　　GolemMastery——傀儡掌握——支配石魔；简称:GM</p>
<p>  　　Raiseskeletalmage——复活骷髅魔法师——復甦骷髏法師；</p>
<p>  　　BloodGolem——血之巨人——鮮血石魔；简称:BG</p>
<p>  　　Summonedresistance——召唤反抗——召喚抵抗；</p>
<p>  　　IronGolem——钢铁巨人——鋼鐵石魔；简称:IG</p>
<p>  　　FireGolem——火之巨人——火焰石魔；简称:FG</p>
<p>  　　Revive——复兴——重生；</p>
<p>  　　Poisonandbone——毒系骨系技能树——毒素和白骨法術</p>
<p>  　　Teech——牙齿术——牙；</p>
<p>  　　BoneArmor——骨之护甲——白骨裝甲；简称:BA</p>
<p>  　　PoisonDagger——毒之匕首——淬毒匕首；简称:PD(骗点？)</p>
<p>  　　CorpseExplosion+——尸体爆炸术——屍體爆炸；简称:CE</p>
<p>  　　BoneWall——骨墙术——骨墻；</p>
<p>  　　PoisonExplosion——毒气爆炸术——毒爆；</p>
<p>  　　BoneSpear——骨之长矛——骨矛；</p>
<p>  　　BonePrison——骸骨监狱——骨牢；</p>
<p>  　　PoisonNova——毒之雷星——劇毒新星；简称:PN</p>
<p>  　　Bonespirit——骨之灵魂——白骨之魂；简称:BS</p>
<p>  　　Curses——诅咒系技能树——詛咒</p>
<p>  　　AmplifyDamage——加大伤害——傷害加深；简称:Amp/Ad</p>
<p>  　　DimVision——视力模糊——微暗靈視；简称:Dim</p>
<p>  　　Weaken——弱化——削弱；</p>
<p>  　　Ironmaiden——钢铁处女——攻擊反噬；简称:IM</p>
<p>  　　Terror——恐怖——恐懼；</p>
<p>  　　Confuse——混乱——迷亂；</p>
<p>  　　LifeTap——生命源泉——偷取生命；</p>
<p>  　　Attracc——吸引——吸引；</p>
<p>  　　Decrepify——衰老——衰老；简称:Decrep/Dec</p>
<p>  　　LowerResist——降低抵抗力——降低抵抗；简称:LR(烂人@_@)</p>
<p>  　　巫师常用武器装备中英文名称对照：</p>
<p>  　　SuicideBranch自殺支系；</p>
<p>  　　BlackhandKey黑手之鑰；</p>
<p>  　　Wizardspike巫師之刺；</p>
<p>  pal:<br>  Avenger以Vengeance+Conviction为主要攻击技能的Paladin；</p>
<p>  　　Charger/Chargedin以Charge为主要攻击技能的Paladin；</p>
<p>  　　Hammerdin以Concentration+Blessedhammer为主要攻击技能的Paladin；简称:BHdin</p>
<p>  　　Zealot使用Zeal为为主要攻击技能的Paladin；</p>
<p>  　　DefensiveAuras——防御技能树——防禦性靈氣</p>
<p>  　　Prayer——祈祷——祈禱；</p>
<p>  　　ResistFire——火之光环——抗火；</p>
<p>  　　Defiance——藐视光环——反抗；</p>
<p>  　　ResistCold——冰之光环——抗冰冷；</p>
<p>  　　Cleansing——洁净光环——淨化；</p>
<p>  　　ResistLightning——闪电光环——抵抗閃電；</p>
<p>  　　Vigor——活力光环——精力；</p>
<p>  　　Meditation——冥想光环——冥想；</p>
<p>  　　Redemption——补偿光环——救贖；</p>
<p>  　　Salvation——拯救光环——救助；</p>
<p>  　　OffensiveAuras——攻击技能树——攻擊靈氣</p>
<p>  　　Might——力量光环——力量；</p>
<p>  　　Holy-Fire——神圣之火——聖火；</p>
<p>  　　Thorns——荆棘光环——刺針；</p>
<p>  　　BlessedAim——祝福光环——祝福瞄準；</p>
<p>  　　Concentration——集中——專注；简称:Conc</p>
<p>  　　HolyFreeze——圣洁寒冰——神聖冰凍；简称:HF</p>
<p>  　　HolyShock——神圣打击——聖光衝擊；</p>
<p>  　　Sanctuary——避难所——庇護所；</p>
<p>  　　Fanaticism——狂热——狂熱；简称:Fana</p>
<p>  　　Conviction——审判——信念；简称:Conv</p>
<p>  　　Combat——战斗技能树——作戰技能</p>
<p>  　　Sacrifice——牺牲——犧牲；</p>
<p>  　　Smite——重击——重擊；</p>
<p>  　　Holybolt——圣光术——聖光彈；</p>
<p>  　　Zeal——热诚——白熱；</p>
<p>  　　Charge——冲锋——突擊</p>
<p>  　　Vengeance——复仇——復仇；简称:Veng</p>
<p>  　　Blessedhammer——神圣之槌——祝福之錘；简称:BH</p>
<p>  　　Conversion——转化——轉換；</p>
<p>  　　Holyshield——神圣之盾——神聖之盾；简称:HS</p>
<p>  　　Fistoftheheavens——天神之手——天堂之拳；简称:FoH</p>
<p>  　　圣骑士常用武器装备中英文名称对照：</p>
<p>  　　Baranar‘sStar巴拉那之星；有时可简称为DS;</p>
<p>  　　Griswold‘sRedemption格瑞斯华尔德的救赎——格瑞斯华尔德的的传奇；</p>
<p>  　　Lightsabre光之軍刀；简称:LS</p>
<p>  　　Sazabi‘sCobaltRedeemer沙撒壁的忏悔之钴——沙撒壁的雄伟贡品；</p>
<p>  　　Schaefer‘sHammer史恰佛之鎚；简称:Mallet</p>
<p>  　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ</p>
<p>  　　还有部分Cruel前缀或做成fury的Elite武器比如：PhaseBlade，ConquestSword，CrypticSword,MythicalSword，BerserkerAxe,其中PhaseBlade不能通过Cube合成获得Cruel的前缀；</p>
<p>   sor:<br>  Boltress以ChargedBolt为主要攻击技能的Sorceress；</p>
<p>  　　Tweaker指一部分将FCR(FasterCastRate快速施法率)增强到max的Sorceress；</p>
<p>  　　Cold——冰系技能树——冰凍法術</p>
<p>  　　Icebolt——冰箭——冰彈；</p>
<p>  　　FrozenArmor——寒冰护甲——冰封裝甲；</p>
<p>  　　FrostNova——霜之星——霜之新星；简称:FN</p>
<p>  　　IceBlast——寒冰冲击波——冰風暴；</p>
<p>  　　ShiverArmor——战栗护盾——碎冰甲；</p>
<p>  　　GlacialSpike——冰之长钉——冰尖柱；简称:GS</p>
<p>  　　Blizzard——暴风雪——暴風雪；</p>
<p>  　　ChillingArmor——寒冷装甲——寒冰裝甲；</p>
<p>  　　FrozenOrb——冰冻球——冰封球；简称:FO</p>
<p>  　　ColdMatery——寒冰掌握——支配冰冷；简称:CM</p>
<p>  　　Lighting——闪电系技能树——閃電法術</p>
<p>  　　ChargedBolt——闪电弹——充能彈；简称:CB</p>
<p>  　　StaticField——静力唱—靜態力場；简称:SF</p>
<p>  　　Telekinesis——心灵念力术——心靈傳動；简称:TK</p>
<p>  　　Nova——雷星术——新星；</p>
<p>  　　Lightning——闪电——閃電；</p>
<p>  　　ChainLightning——连环闪电——連鎖閃電；简称:CL</p>
<p>  　　Teleport——心灵传送术——傳送；简称:Tele/TP</p>
<p>  　　ThunderStorm——雷暴术——雷云風暴；简称:TS</p>
<p>  　　EnergyShield——能量盾——能量護盾；简称:ES</p>
<p>  　　LightningMastery——闪电掌握——支配閃電；简称:LM</p>
<p>  　　Fire——火系技能树——火焰法術</p>
<p>  　　Firebolt——小火球——火彈；简称:fb</p>
<p>  　　Warmth——热情——暖氣；简称:</p>
<p>  　　Inferno——地狱火——地獄之火；</p>
<p>  　　Blaze——火焰道标——熾烈之焰；</p>
<p>  　　Fireball——大火球——火球；简称:FB</p>
<p>  　　Firewall——火墙术——火墻；简称:FW</p>
<p>  　　Enchant——施魔——強化；</p>
<p>  　　Meteor——流星——隕石；</p>
<p>  　　Hydra——守护神——九頭海蛇；</p>
<p>  　　FireMastery——火系掌握——支配之焰；简称:FM</p>
<p>  　　女巫常用武器装备中英文名称对照：</p>
<p>  　　BladeOfAliBaba阿里巴巴之刃；简称:AliBaba</p>
<p>  　　Gull海鷗;</p>
<p>  　　KelpieSnare水魔陷阱，这个当然不是给女巫MM用的啦，是给我们的”小强”用的；</p>
<p>  　　TheOculus眼球简称:Orb；</p>
<p>  　　Wizardspike巫師之刺；</p>
<p>  　　有时一些属性JP的RareOrb也常常会被部分pvp女巫使用；</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>地图</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Excel中以文本形式存储的数字</title>
    <url>/tool-2020-02-06-excel-text-number/</url>
    <content><![CDATA[<p>在一些特定情况下，单元格中会出现文本形式存储的数字，例如从其他地方复制粘贴过来，或者是较长的数字想要完全显示，设置为文本格式。如果是这样的单元格，在左上角就会有一个绿色小标记。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-7f8eb44c9239a43b4835c12ba326c2d9_720w.jpg" alt="img"></p>
<p>针对不同需求的单元格，进行数据处理的方式也不同。例如有些数字，在后面是需要进行公式计算的，就可以将单元格从文本转化为普通的数字形式。选中需要修改的单元格，如果在一个区域的话可以选中全部的，然后点击右上角浮动的感叹号，在菜单里面选择“转换为数字”。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-b825acebee4b0d575dafcbbb9d85079e_720w.jpg" alt="img"></p>
<p>这样一来，单元格格式就会变回常规，绿色小三角也会自动消失。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-6be2034cecf7128cfdd94adfe2b89d21_720w.jpg" alt="img"></p>
<p>有时候数字较长，例如手机号，也不需要进行公式运算。但是有一个绿色标志，希望去掉，也是可以进行操作的。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-2b7e7de81faec0a733820a239dbff044_720w.jpg" alt="img"></p>
<p>在菜单中选择“忽略错误”即可，这个绿色小三角就会消失了。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-2d84b687d6c420607a09f8dd93146b62_720w.jpg" alt="img"></p>
<p>但要注意的是，双击编辑过这个单元格以后，还是会出现绿色小三角标记的错误提示的。</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf序列化的一些问题</title>
    <url>/tool-2020-03-25-protobuf-Empty-Collections/</url>
    <content><![CDATA[<h1 id="Base-Derived-Classes"><a href="#Base-Derived-Classes" class="headerlink" title="Base / Derived Classes"></a>Base / Derived Classes</h1><p>Each derived class must have its base class marked with [ProtoInclude(<num>, typeof(ProtoBuff-Derived-Class))]. If not, all values will be NULL.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ProtoContract]</span><br><span class="line">[ProtoInclude(100, typeof(HomeFolders))]</span><br><span class="line">[ProtoInclude(200, typeof(PublicFolders))]</span><br><span class="line">public class Folders</span><br><span class="line">&#123;</span><br><span class="line">  [ProtoMember(1)]</span><br><span class="line">  public int ProtoMember1 &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  [ProtoMember(2)]</span><br><span class="line">  public int ProtoMember2 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ProtoContract]</span><br><span class="line">public class HomeFolders : Folders</span><br><span class="line">&#123;</span><br><span class="line">  [ProtoMember(1)]</span><br><span class="line">  public int ProtoMember4 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ProtoContract]</span><br><span class="line">public class PublicFolders : Folders</span><br><span class="line">&#123;</span><br><span class="line">  [ProtoMember(1)]</span><br><span class="line">  public int ProtoMember5 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Avoid-duplicate-property-tags"><a href="#Avoid-duplicate-property-tags" class="headerlink" title="Avoid duplicate property tags"></a>Avoid duplicate property tags</h1><p>Using the same number for ProtoInclude and ProtoMember will generate an error about duplicate property tags. The example below is <strong>NOT</strong> correct.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ProtoContract]</span><br><span class="line">[ProtoInclude(1, typeof(PublicFolders))]</span><br><span class="line">public class Folders</span><br><span class="line">&#123;</span><br><span class="line">  [ProtoMember(1)]</span><br><span class="line">  public int ProtoMember1 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So you need to use a different number for ProtoInclude. Corrected example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ProtoContract]</span><br><span class="line">[ProtoInclude(100, typeof(PublicFolders))]</span><br><span class="line">public class Folders</span><br><span class="line">&#123;</span><br><span class="line">  [ProtoMember(1)]</span><br><span class="line">  public int ProtoMember1 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Null-vs-Empty-Collections"><a href="#Null-vs-Empty-Collections" class="headerlink" title="Null vs. Empty Collections"></a>Null vs. Empty Collections</h1><p>ProtoBuf does not understand the difference between a collection (List, IEnumerable etc) being null versus empty (zero count). For example, if you put these objects into the cache,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;int&gt; list1 &#x3D; new List&lt;int&gt;();</span><br><span class="line">List&lt;int&gt; list2 &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>after deserialization, both the lists will have the same value—that is NULL. There are two ways to solve this:</p>
<ol>
<li><p>Using a private field (we are using this):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ProtoMember(12, OverwriteList &#x3D; true)]</span><br><span class="line">private List _publicFolders;</span><br><span class="line">public List publicFolders</span><br><span class="line">&#123;</span><br><span class="line">  get</span><br><span class="line">  &#123;</span><br><span class="line">    if (_publicFolders &#x3D;&#x3D; null)</span><br><span class="line">    &#123;</span><br><span class="line">      _publicFolders &#x3D; new List();</span><br><span class="line">    &#125;</span><br><span class="line">    return _publicFolders;</span><br><span class="line">  &#125;</span><br><span class="line">  set</span><br><span class="line">  &#123;</span><br><span class="line">    _publicFolders &#x3D; value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using the OnDeserialized attribute:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ProtoMember(2, OverwriteList &#x3D; true)]</span><br><span class="line">private PublicFolder[] publicFolders;</span><br><span class="line">[ProtoMember(3, OverwriteList &#x3D; true)]</span><br><span class="line">private PrivateFolder[] privateFolder;</span><br><span class="line">[ProtoMember(4, OverwriteList &#x3D; true)]</span><br><span class="line">private SecureFolder[] secureFolder;</span><br><span class="line"></span><br><span class="line">[OnDeserialized]</span><br><span class="line">private void HandleSerializationMismatch(StreamingContext context)</span><br><span class="line">&#123;</span><br><span class="line">  publicFolders &#x3D; publicFolders ?? new PublicFolders[0];</span><br><span class="line">  privateFolder &#x3D; privateFolder ?? new PrivateFolder[0];</span><br><span class="line">  secureFolder &#x3D; secureFolder ?? new SecureFolder[0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h1><p>ProtoBuf ignores properties if the class inherits from a collection and the Items property for that collection is null. Example:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Folders : List</span><br><span class="line">&#123;</span><br><span class="line">  public int value1 &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  public int value2 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folders folders &#x3D; new Folders() &#123; value1 &#x3D; 5; value2 &#x3D; 6; &#125;;</span><br></pre></td></tr></table></figure>

<p>After deserialization, the value of the Folders object will be NULL, because the count of items on is 0.</p>
<p>Classes that inherit from special collections are also not supported.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Folders : ReadOnlyCollection</span><br><span class="line">&#123;</span><br><span class="line">  public int value1 &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">  public int value2 &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Folders folders &#x3D; new Folders() &#123; value1 &#x3D; 5; value2 &#x3D; 6; &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="AllowParseableTypes"><a href="#AllowParseableTypes" class="headerlink" title="AllowParseableTypes"></a>AllowParseableTypes</h1><p>AllowParseableTypes is a global switch that determines whether types with “.ToString()” and “Parse(string)” methods should be serialized as strings. We can use this setting for types that can’t be marked in the ProtoContract but can be parseable.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ProtoBufClient()</span><br><span class="line">&#123;</span><br><span class="line">  RuntimeTypeModel.Default.AllowParseableTypes &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For example, to solve the serialization problem with the Version type:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Serializable]</span><br><span class="line">[ProtoContract(SkipConstructor &#x3D; true)]</span><br><span class="line">[ProtoInclude(100, typeof(PrivateFolder))]</span><br><span class="line">[ProtoInclude(200, typeof(PublicFolder))]</span><br><span class="line">[ProtoInclude(300, typeof(SecureFolder))]</span><br><span class="line">public abstract class FolderBase : Folder</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  [ProtoMember(3)]</span><br><span class="line">  private string name;</span><br><span class="line">  [ProtoMember(4)]</span><br><span class="line">  private Owner owner;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Protobuf-net-Generics-on-Unity3D-IL2CPP"><a href="#Protobuf-net-Generics-on-Unity3D-IL2CPP" class="headerlink" title="Protobuf-net Generics on Unity3D IL2CPP."></a>Protobuf-net Generics on Unity3D IL2CPP.</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomCollectionBase&lt;TCollection, TElement, TKey&gt;</span><br><span class="line">&#123;</span><br><span class="line">	protected TCollection _collection;</span><br><span class="line"></span><br><span class="line">	protected SortedDictionary&lt;TKey, bool&gt; _removed;</span><br><span class="line"></span><br><span class="line">	public CustomCollectionBase(TCollection collection)</span><br><span class="line">	&#123;</span><br><span class="line">		_collection &#x3D; collection;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected byte[] _cBytes;</span><br><span class="line"></span><br><span class="line">	protected byte[] _rBytes;</span><br><span class="line"></span><br><span class="line">	protected void __PreSerialize()</span><br><span class="line">	&#123;</span><br><span class="line">		using (MemoryStream stream &#x3D; new MemoryStream())</span><br><span class="line">		&#123;</span><br><span class="line">			Serializer.Serialize(stream, this._collection);</span><br><span class="line">			this._cBytes &#x3D; stream.ToArray();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		using (MemoryStream stream &#x3D; new MemoryStream())</span><br><span class="line">		&#123;</span><br><span class="line">			Serializer.Serialize(stream, this._removed);</span><br><span class="line">			this._rBytes &#x3D; stream.ToArray();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void __PostDeserialize()</span><br><span class="line">	&#123;</span><br><span class="line">		using (MemoryStream stream &#x3D; new MemoryStream(this._cBytes))</span><br><span class="line">		&#123;</span><br><span class="line">			this._collection &#x3D; Serializer.Deserialize&lt;TCollection&gt;(stream);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		using (MemoryStream stream &#x3D; new MemoryStream(this._rBytes))</span><br><span class="line">		&#123;</span><br><span class="line">			this._removed &#x3D; Serializer.Deserialize&lt;SortedDictionary&lt;TKey, bool&gt;&gt;(stream);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ProtoContract]</span><br><span class="line">public class CustomList&lt;TElement&gt; : CustomCollectionBase&lt;List&lt;TElement&gt;, TElement, int&gt;</span><br><span class="line">&#123;</span><br><span class="line">	public CustomList() : base( new List&lt;TElement&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoMember(1)]</span><br><span class="line">	private byte[] _cProto</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return base._cBytes; &#125;</span><br><span class="line">		set &#123; base._cBytes &#x3D; value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoMember(2)]</span><br><span class="line">	private byte[] _rProto</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return base._rBytes; &#125;</span><br><span class="line">		set &#123; base._rBytes &#x3D; value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoBeforeSerialization]</span><br><span class="line">	private void __PreSerialize()</span><br><span class="line">	&#123;</span><br><span class="line">		base.__PreSerialize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoAfterDeserialization]</span><br><span class="line">	private void __PostDeserialize()</span><br><span class="line">	&#123;</span><br><span class="line">		base.__PostDeserialize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ProtoContract]</span><br><span class="line">public class CustomIntDictionary&lt;TElement&gt; : CustomCollectionBase&lt;Dictionary&lt;int, TElement&gt;, TElement, int&gt;</span><br><span class="line">&#123;</span><br><span class="line">	public CustomIntDictionary() : base(new Dictionary&lt;int, TElement&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoMember(1)]</span><br><span class="line">	private byte[] _cProto</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return base._cBytes; &#125;</span><br><span class="line">		set &#123; base._cBytes &#x3D; value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoMember(2)]</span><br><span class="line">	private byte[] _rProto</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return base._rBytes; &#125;</span><br><span class="line">		set &#123; base._rBytes &#x3D; value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoBeforeSerialization]</span><br><span class="line">	private void __PreSerialize()</span><br><span class="line">	&#123;</span><br><span class="line">		base.__PreSerialize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoAfterDeserialization]</span><br><span class="line">	private void __PostDeserialize()</span><br><span class="line">	&#123;</span><br><span class="line">		base.__PostDeserialize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ProtoContract]</span><br><span class="line">public class CustomStringDictionary&lt;TElement&gt; : CustomCollectionBase&lt;Dictionary&lt;string, TElement&gt;, TElement, string&gt;</span><br><span class="line">&#123;</span><br><span class="line">	public CustomStringDictionary() : base(new Dictionary&lt;string, TElement&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoMember(1)]</span><br><span class="line">	private byte[] _cProto</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return base._cBytes; &#125;</span><br><span class="line">		set &#123; base._cBytes &#x3D; value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoMember(2)]</span><br><span class="line">	private byte[] _rProto</span><br><span class="line">	&#123;</span><br><span class="line">		get &#123; return base._rBytes; &#125;</span><br><span class="line">		set &#123; base._rBytes &#x3D; value; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoBeforeSerialization]</span><br><span class="line">	private void __PreSerialize()</span><br><span class="line">	&#123;</span><br><span class="line">		base.__PreSerialize();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[ProtoAfterDeserialization]</span><br><span class="line">	private void __PostDeserialize()</span><br><span class="line">	&#123;</span><br><span class="line">		base.__PostDeserialize();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So basically there are two methods that are defined.</p>
<ol>
<li>__PreSerialize – Converts the collection in to a byte array which becomes the proto member.</li>
<li>__PostDeserialize – Converts the byte array back to the collection.</li>
</ol>
<p>We can completely avoid defining run time types for this generic type. Instead of protobuf-net being responsible of creating the type, we create the type by ourselves using the same protobuf Serializer.</p>
<p>This kind of technique can be used for other generic types as well. Please comment your ideas about this approach.</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客将 RSS 转为邮件订阅</title>
    <url>/tool-2020-06-26-blog-mail-sub/</url>
    <content><![CDATA[<p>RSSMailer | <a href="https://link.zhihu.com/?target=https%3A//rssmailer.app/">https://rssmailer.app/</a></p>
<p>Tinyletter | <a href="https://link.zhihu.com/?target=https%3A//tinyletter.com/">tinyletter</a></p>
<p>Mailchimp| <a href="https://mailchimp.com/" target="_blank" rel="noopener">https://mailchimp.com/</a></p>
<p>相关推荐:</p>
<pre><code>- https://zhuanlan.zhihu.com/p/111978933
- https://zhuanlan.zhihu.com/p/119325491
- https://sspai.com/post/60025</code></pre>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>github下载代码的速度太慢</title>
    <url>/tool-2020-06-27-linux-github-slow/</url>
    <content><![CDATA[<p>作为程序员，最大的同性交友网站估计是大家的标配了，常常会苦恼于git clone某个项目的时候速度太慢，看着控制台那几K十一二K的速度，吐血！！</p>
<p>原因很简单：github的<a href="https://cloud.tencent.com/product/cdn?from=10680" target="_blank" rel="noopener">CDN</a>被高高的墙屏蔽所致了。 所以解决方案也很简单，就是手动把 cdn 和IP地址绑定一下。</p>
<h2 id="1、获取github地址"><a href="#1、获取github地址" class="headerlink" title="1、获取github地址"></a>1、获取github地址</h2><p>访问 <a href="http://github.com.ipaddress.com/" target="_blank" rel="noopener">http://github.com.ipaddress.com/</a> 获取cdn域名以及ip地址..或者打开 <a href="http://tool.chinaz.com/dns" target="_blank" rel="noopener">http://tool.chinaz.com/dns</a> ,这是一个查询域名映射关系的工具 </p>
<h2 id="2、获取-global-ssl-fastly地址"><a href="#2、获取-global-ssl-fastly地址" class="headerlink" title="2、获取 global.ssl.fastly地址"></a>2、获取 global.ssl.fastly地址</h2><p><a href="http://github.global.ssl.fastly.net.ipaddress.com/" target="_blank" rel="noopener">http://github.global.ssl.fastly.net.ipaddress.com/</a> 获取cdn域名以及ip地址</p>
<h2 id="3、打开hosts映射"><a href="#3、打开hosts映射" class="headerlink" title="3、打开hosts映射"></a>3、打开hosts映射</h2><h3 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure>

<p>最末尾添加两句话保存:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">151.101</span><span class="number">.185</span><span class="number">.194</span> http:<span class="comment">//github.global.ssl.fastly.net </span></span><br><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.112</span> http:<span class="comment">//github.com</span></span><br></pre></td></tr></table></figure>

<p>打开CMD刷新一下DNS就好了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>

<h3 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br></pre></td></tr></table></figure>

<p>添加</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">192.30</span><span class="number">.253</span><span class="number">.112</span> https:<span class="comment">//github.com</span></span><br><span class="line"><span class="number">151.101</span><span class="number">.185</span><span class="number">.194</span> https:<span class="comment">//github.global.ssl.fastly.net</span></span><br></pre></td></tr></table></figure>

<p>保存,退出,并重启网络</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<h2 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比:"></a>速度对比:</h2><p>配置前</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Receiving objects:  <span class="number">17</span>% (<span class="number">151</span>/<span class="number">883</span>), <span class="number">348.00</span> KiB | <span class="number">18.00</span> KiB/s</span><br></pre></td></tr></table></figure>

<p>配置后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Receiving objects:  <span class="number">81</span>% (<span class="number">86141</span>/<span class="number">104384</span>), <span class="number">81.31</span>Mib | <span class="number">562.00</span> KiB/s</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>win10开始菜单添加软件以及备份和恢复</title>
    <url>/tool-2020-07-02-win10-start-menu/</url>
    <content><![CDATA[<h1 id="添加应用到开始屏幕"><a href="#添加应用到开始屏幕" class="headerlink" title="添加应用到开始屏幕"></a>添加应用到开始屏幕</h1><p>右键默认就有添加到开始屏幕</p>
<h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><p>默认布局位于 C:\Users\username\AppData\Local\Microsoft\Windows\Shell\ ..注意这是默认布局</p>
<p>真实的布局是存在与注册表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Export-StartLayout –path c:\start\start.xml</span><br><span class="line">Import-StartLayout -layoutpath c:\start\start.xml -mountpath &quot;C:\&quot;</span><br></pre></td></tr></table></figure>









<h2 id="其他路径"><a href="#其他路径" class="headerlink" title="其他路径"></a>其他路径</h2><p>C:\ProgramData\Microsoft\Windows\Start Menu\Programs</p>
<p>C:\Users\zhepama\AppData\Roaming\Microsoft\Windows\Start Menu\Programs</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/configuration/customize-and-export-start-layout#export-the-start-layout" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/configuration/customize-and-export-start-layout#export-the-start-layout</a></li>
<li><a href="https://docs.microsoft.com/en-us/powershell/module/startlayout/import-startlayout?view=win10-ps" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/powershell/module/startlayout/import-startlayout?view=win10-ps</a></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>shell</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title>gitbook的使用</title>
    <url>/tool-2020-07-06-gitbook-use/</url>
    <content><![CDATA[<h3 id="使用npm安装gitbook"><a href="#使用npm安装gitbook" class="headerlink" title="使用npm安装gitbook"></a>使用npm安装gitbook</h3><p>现在安装 Node.js 都会默认安装 npm（node 包管理工具），所以我们不用单独安装 npm，打开命令行，执行以下命令安装 GitBook：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g gitbook-cli</span><br></pre></td></tr></table></figure>

<p>使用<strong>Git Bash</strong>操作如下图：</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-3ef32e72168040b1.png" alt="img"></p>
<p>好了，准备好了三件套工具之后，就是来看看怎么编写<strong>GitBook</strong>了。</p>
<h2 id="编写GitBook"><a href="#编写GitBook" class="headerlink" title="编写GitBook"></a>编写GitBook</h2><h3 id="创建电子书的文件夹目录"><a href="#创建电子书的文件夹目录" class="headerlink" title="创建电子书的文件夹目录"></a>创建电子书的文件夹目录</h3><blockquote>
<p>想象一下，现在你准备构建一本书籍，你在硬盘上新建了一个叫 mybook 的文件夹，按照以前的做法，你会新建一个 Word 文档，写上标题，然后开始巴滋巴滋地笔耕。</p>
</blockquote>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-4c42d4ea26ffe4d4.png" alt="img"></p>
<h3 id="初始化Gitbook"><a href="#初始化Gitbook" class="headerlink" title="初始化Gitbook"></a>初始化Gitbook</h3><blockquote>
<p>但是现在有了 GitBook，你首先要做的是在 mybook 文件夹下执行以下命令：</p>
</blockquote>
<p>使用<code>gitbook init</code>初始化gitbook，操作如下：</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-325fdbbe1bad6026.png" alt="img"></p>
<p>执行完后，你会看到多了两个文件 —— README.md 和 SUMMARY.md，它们的作用如下：</p>
<ul>
<li>README.md —— 书籍的介绍写在这个文件里</li>
<li>SUMMARY.md —— 书籍的目录结构在这里配置</li>
</ul>
<h3 id="使用Typora来编写框架内容"><a href="#使用Typora来编写框架内容" class="headerlink" title="使用Typora来编写框架内容"></a>使用Typora来编写框架内容</h3><p>这时候，我们启动恭候多时的 Typora 来编辑这两个文件了：</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-637f36f709e63f81.png" alt="img"></p>
<p>编辑 SUMMARY.md 文件，内容修改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目录</span></span><br><span class="line"></span><br><span class="line">* [前言](README.md)</span><br><span class="line">* [第一章](Chapter1/README.md)</span><br><span class="line">  * [第1节：衣](Chapter1/衣.md)</span><br><span class="line">  * [第2节：食](Chapter1/食.md)</span><br><span class="line">  * [第3节：住](Chapter1/住.md)</span><br><span class="line">  * [第4节：行](Chapter1/行.md)</span><br><span class="line">* [第二章](Chapter2/README.md)</span><br><span class="line">* [第三章](Chapter3/README.md)</span><br><span class="line">* [第四章](Chapter4/README.md)</span><br></pre></td></tr></table></figure>

<p>显示如下：</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-a0e40da1d8ae2f1a.png" alt="img"></p>
<h3 id="重新使用gitbook根据目录，初始化篇章"><a href="#重新使用gitbook根据目录，初始化篇章" class="headerlink" title="重新使用gitbook根据目录，初始化篇章"></a>重新使用gitbook根据目录，初始化篇章</h3><p>然后我们回到命令行，在 mybook 文件夹中再次执行 <code>gitbook init</code> 命令。GitBook 会查找 SUMMARY.md 文件中描述的目录和文件，如果没有则会将其创建。</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-92aaec1127fbe9c8.png" alt="img"></p>
<p>Typora 是所见即所得（实时渲染）的 Markdown 编辑器，这时候它是这样的：</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-e1fb9ef8f3b32226.png" alt="img"></p>
<h3 id="启动服务，预览书籍"><a href="#启动服务，预览书籍" class="headerlink" title="启动服务，预览书籍"></a>启动服务，预览书籍</h3><p>接着我们执行 <code>gitbook serve</code> 来预览这本书籍，执行命令后会对 Markdown 格式的文档进行转换，默认转换为 html 格式，最后提示 “Serving book on <a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A4000%2F" target="_blank" rel="noopener">http://localhost:4000</a>”。嗯，打开浏览器看一下吧：</p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-a49ea1d4e0bdeb98.png" alt="img"></p>
<p><img src="../../assets/images/2020-07-06-gitbook-use/13423234-ca03c52cfdc1ac64.png" alt="img"></p>
<h2 id="结合-GitHub-Pages"><a href="#结合-GitHub-Pages" class="headerlink" title="结合 GitHub Pages"></a>结合 GitHub Pages</h2><p>GitHub Pages 是 GitHub 提供的静态网站托管服务。</p>
<p>GitHub 上的每个仓库都可以拥有一个 GitHub Pages，对应的 URL 如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">https://<span class="tag">&lt;<span class="name">username</span>&gt;</span>.github.io/<span class="tag">&lt;<span class="name">repository</span>&gt;</span>/</span><br></pre></td></tr></table></figure>

<p>GitHub Pages 的静态资源支持下面 3 个来源：</p>
<ul>
<li><code>master</code> 分支</li>
<li><code>master</code> 分支的 <code>/docs</code> 目录</li>
<li><code>gh-pages</code> 分支</li>
</ul>
<p><img src="../../assets/images/2020-07-06-gitbook-use/1624919-00837dbbb587799c.jpg" alt="img"></p>
<p>执行下面命令，将 <code>_book</code> 目录推送到 GitHub 仓库的 <code>gh-pages</code> 分支。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout --orphan gh-pages</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> code .nojekyll</span></span><br></pre></td></tr></table></figure>

<p>或者在生成静态网页时，将保存的目录指定为 <code>./docs</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gitbook build ./ ./docs</span></span><br></pre></td></tr></table></figure>

<p>然后直接推送到 GitHub 仓库的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>github actions 简单使用</title>
    <url>/tool-2020-07-11-github-actions/</url>
    <content><![CDATA[<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>如果你是一个前端项目，可以使用 <code>Node.js</code> 的模板，点击 <code>Set up this workflow</code></p>
<p><img src="../../assets/images/2020-07-11-github-actions/v2-93f521330d963d903561c0575d2d8fac_720w.jpg" alt="v2-93f521330d963d903561c0575d2d8fac_720w"></p>
<p>此时生成了一个文件 <code>.github/workflows/nodejs.yaml</code>，修改内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Git Action Test</span><br><span class="line"># on: 用来指定启动触发的事件，push 则表示在监听到 git push 到指定分支时触发。如此之外还可以是 pull_request。</span><br><span class="line">on: [push]   </span><br><span class="line"></span><br><span class="line">#jobs:一个 CI&#x2F;CD 的工作流有许多 jobs 组成，比如最典型的 job 是 lint，test，build 或者 deploy。</span><br><span class="line">#所有的 job 都是并行的,如果想顺序执行，可以这样 build-job: needs: test-job。</span><br><span class="line">jobs:         </span><br><span class="line">  build:</span><br><span class="line">	#runs-on用来指定执行系统环境，不仅有常用的 Linux 发行版，还可以是 macOS 或 Windows。</span><br><span class="line">    runs-on: ubuntu-latest  </span><br><span class="line"> 	# steps 表示每个 job 需要执行的步骤，比如这里我分成了四步：拉取分支 → 安装 Node 环境 → 构建项目 → 上传 COS。</span><br><span class="line">    steps:  </span><br><span class="line">    #Action 是组成工作流最核心最基础的元素。每个 Action 可以看作封装的独立脚本，有自己的操作逻辑，我们只需要 uses 并通过 with 传入参数即可。</span><br><span class="line">    - uses: actions&#x2F;checkout@v1 </span><br><span class="line">    - name: Use Node.js 10.x</span><br><span class="line">      uses: actions&#x2F;setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: 10.x</span><br><span class="line">    - name: npm install, build</span><br><span class="line">      run: |</span><br><span class="line">        npm install</span><br><span class="line">        npm run build --if-present</span><br><span class="line">      env:</span><br><span class="line">        CI: true</span><br></pre></td></tr></table></figure>

<p>执行 <code>git push</code> 操作，此时可以在 <code>github</code> 的 <code>Actions</code> 标签页看到执行结果</p>
<h1 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h1><p>如何在 <code>github action</code> 上访问敏感数据？如使用 <code>ssh</code> 登录时如何维护密码。</p>
<p>我们可以在 github repo 上依次点击 <code>Settings</code> -&gt; <code>Secrets</code> 设置 <code>secret</code></p>
<p><img src="../../assets/images/2020-07-11-github-actions/v2-51c0ee11b4bc61312d8e1af14d906432_720w.jpg" alt="v2-51c0ee11b4bc61312d8e1af14d906432_720w"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- name: setup aliyun oss</span><br><span class="line">  uses: manyuanrong&#x2F;setup-ossutil@master</span><br><span class="line">  with:</span><br><span class="line">    endpoint: oss-cn-beijing.aliyuncs.com</span><br><span class="line">    access-key-id: $&#123;&#123; secrets.OSS_KEY_ID &#125;&#125;</span><br><span class="line">    access-key-secret: $&#123;&#123; secrets.OSS_KEY_SECRET &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>secret</code> 就是一种 <code>context</code>，描述 CI/CD 一个 <code>workflow</code> 中的上下文信息，使用 <code>$</code> 语法表示。除了 <code>secret</code>，还有</p>
<ul>
<li><code>github</code>: <code>workflow</code> 的信息，如 <code>github.sha</code> 可以获取当前的 <code>commit SHA</code>，我们可以利用它为 <code>sentry</code> 或者 <code>docker image</code> 打入版本号</li>
<li><code>env</code>: 环境变量</li>
<li><code>job</code>: 当前执行 <code>job</code> 的信息，如 <code>job.status</code> 表示当前 <code>job</code> 的执行状态</li>
<li><code>matrix</code>: 描述一些构建信息，如 <code>node</code> 以及 <code>os</code> 版本号</li>
</ul>
<p>更多 <code>context</code> 信息可以参考官方文档 <strong>Contexts and expression syntax for GitHub Actions[4]</strong></p>
<h1 id="自动创建项目Release"><a href="#自动创建项目Release" class="headerlink" title="自动创建项目Release"></a>自动创建项目Release</h1><p>有些项目在发布新版本时，一般都会创建一个<code>Github Release</code>，并且把对应编译好之后的文件上传到<code>Release</code>的资源列表中，例如：<br><img src="../../assets/images/2020-07-11-github-actions/2659679572-62492fa02f19b6f9.png" alt="2659679572-62492fa02f19b6f9"></p>
<p>如果这个使用手动操作的话，不仅步骤重复又繁琐(每次都要编译出各个操作系统对应的发行包再进行上传)，而且最蛋疼的是对于国内的网络环境来说，上传文件速度简直不能忍，好不容易上传了一大半搞不好就因为网络原因又要重新上传，相信用过的人都深有体会。</p>
<p>我就在想如果能用<code>Github Actions</code>来创建<code>Release</code>,并且做对应的编译和上传，那上面的问题都可以迎刃而解了，于是在官方市场搜索了一下<code>Release</code>关键字，果然已经有提供对应的<code>actions</code>了：</p>
<ul>
<li><a href="https://github.com/actions/create-release" target="_blank" rel="noopener">create-release</a>: 用于创建 release</li>
<li><a href="https://github.com/actions/upload-release-asset" target="_blank" rel="noopener">upload-release-asset</a>: 用于上传资源到对应的 release 中</li>
</ul>
<p>接着创建一个<code>Github仓库</code>，我测试的仓库地址是<a href="https://github.com/monkeyWie/github-actions-demo" target="_blank" rel="noopener">https://github.com/monkeyWie/github-actions-demo</a>，项目用 go 语言写的，代码非常简单就是两个 hello world 级别的代码，里面包含了普通的 go 程序和 cgo 程序。</p>
<p>项目的构建流程是在项目<code>git push --tags</code>的时候，触发 workflow，通过<code>Github Actions</code>编译出来<code>Windows、Linux、macOS</code>三个操作系统对应的 64 位可执行文件，再根据<code>tag name</code>和<code>tag message</code>来创建对应的<code>Github Release</code>，并将编译好的文件上传。</p>
<p>同样的创建一个<code>.github/workflows/main.yml</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: CI</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    # Sequence of patterns matched against refs&#x2F;tags</span><br><span class="line">    tags:</span><br><span class="line">      - &quot;v*&quot; # Push events to matching v*, i.e. v1.0, v20.15.10</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">      - name: Checkout source</span><br><span class="line">        uses: actions&#x2F;checkout@v1</span><br><span class="line">      - name: Use Golang</span><br><span class="line">        uses: actions&#x2F;setup-go@v1</span><br><span class="line">        with:</span><br><span class="line">          go-version: &quot;1.13.x&quot;</span><br><span class="line">      - name: Build normal</span><br><span class="line">        run: |</span><br><span class="line">          CGO_ENABLED&#x3D;0 GOOS&#x3D;windows GOARCH&#x3D;amd64 go build -o normal-windows-x64.exe cmd&#x2F;normal&#x2F;main.go</span><br><span class="line">          CGO_ENABLED&#x3D;0 GOOS&#x3D;linux GOARCH&#x3D;amd64 go build -o normal-linux-x64 cmd&#x2F;normal&#x2F;main.go</span><br><span class="line">          CGO_ENABLED&#x3D;0 GOOS&#x3D;darwin GOARCH&#x3D;amd64 go build -o normal-darwin-x64 cmd&#x2F;normal&#x2F;main.go</span><br><span class="line">          zip normal-windows-x64.zip normal-windows-x64.exe</span><br><span class="line">          zip normal-linux-x64.zip normal-linux-x64</span><br><span class="line">          zip normal-darwin-x64.zip normal-darwin-x64</span><br><span class="line">      - name: Build cgo</span><br><span class="line">        run: |</span><br><span class="line">          go get github.com&#x2F;monkeyWie&#x2F;xgo</span><br><span class="line">          ~&#x2F;go&#x2F;bin&#x2F;xgo -targets&#x3D;windows&#x2F;amd64,linux&#x2F;amd64,darwin&#x2F;amd64 -ldflags&#x3D;&quot;-w -s&quot; -pkg&#x3D;cmd&#x2F;cgo&#x2F;main.go -out&#x3D;cgo .</span><br><span class="line">          mv cgo-windows-* cgo-windows-x64.exe</span><br><span class="line">          mv cgo-linux-* cgo-linux-x64</span><br><span class="line">          mv cgo-darwin-* cgo-darwin-x64</span><br><span class="line">          zip cgo-windows-x64.zip cgo-windows-x64.exe</span><br><span class="line">          zip cgo-linux-x64.zip cgo-linux-x64</span><br><span class="line">          zip cgo-darwin-x64.zip cgo-darwin-x64</span><br><span class="line">      - name: Create Release</span><br><span class="line">        id: create_release</span><br><span class="line">        uses: monkeyWie&#x2F;create-release@master</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          tag_name: $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">          release_name: Release $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">          draft: false</span><br><span class="line">          prerelease: false</span><br><span class="line"></span><br><span class="line">      - name: Upload Release normal windows</span><br><span class="line">        uses: actions&#x2F;upload-release-asset@v1.0.1</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it&#39;s ID to get its outputs object, which include a &#96;upload_url&#96;. See this blog post for more info: https:&#x2F;&#x2F;jasonet.co&#x2F;posts&#x2F;new-features-of-github-actions&#x2F;#passing-data-to-future-steps</span><br><span class="line">          asset_path: .&#x2F;normal-windows-x64.zip</span><br><span class="line">          asset_name: normal-$&#123;&#123; steps.create_release.outputs.tag &#125;&#125;-windows-x64.zip</span><br><span class="line">          asset_content_type: application&#x2F;zip</span><br><span class="line">      - name: Upload Release normal linux</span><br><span class="line">        uses: actions&#x2F;upload-release-asset@v1.0.1</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it&#39;s ID to get its outputs object, which include a &#96;upload_url&#96;. See this blog post for more info: https:&#x2F;&#x2F;jasonet.co&#x2F;posts&#x2F;new-features-of-github-actions&#x2F;#passing-data-to-future-steps</span><br><span class="line">          asset_path: .&#x2F;normal-linux-x64.zip</span><br><span class="line">          asset_name: normal-$&#123;&#123; steps.create_release.outputs.tag &#125;&#125;-linux-x64.zip</span><br><span class="line">          asset_content_type: application&#x2F;zip</span><br><span class="line">      - name: Upload Release normal darwin</span><br><span class="line">        uses: actions&#x2F;upload-release-asset@v1.0.1</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it&#39;s ID to get its outputs object, which include a &#96;upload_url&#96;. See this blog post for more info: https:&#x2F;&#x2F;jasonet.co&#x2F;posts&#x2F;new-features-of-github-actions&#x2F;#passing-data-to-future-steps</span><br><span class="line">          asset_path: .&#x2F;normal-darwin-x64.zip</span><br><span class="line">          asset_name: normal-$&#123;&#123; steps.create_release.outputs.tag &#125;&#125;-darwin-x64.zip</span><br><span class="line">          asset_content_type: application&#x2F;zip</span><br><span class="line"></span><br><span class="line">      - name: Upload Release cgo windows</span><br><span class="line">        uses: actions&#x2F;upload-release-asset@v1.0.1</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it&#39;s ID to get its outputs object, which include a &#96;upload_url&#96;. See this blog post for more info: https:&#x2F;&#x2F;jasonet.co&#x2F;posts&#x2F;new-features-of-github-actions&#x2F;#passing-data-to-future-steps</span><br><span class="line">          asset_path: .&#x2F;cgo-windows-x64.zip</span><br><span class="line">          asset_name: cgo-$&#123;&#123; steps.create_release.outputs.tag &#125;&#125;-windows-x64.zip</span><br><span class="line">          asset_content_type: application&#x2F;zip</span><br><span class="line">      - name: Upload Release cgo linux</span><br><span class="line">        uses: actions&#x2F;upload-release-asset@v1.0.1</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it&#39;s ID to get its outputs object, which include a &#96;upload_url&#96;. See this blog post for more info: https:&#x2F;&#x2F;jasonet.co&#x2F;posts&#x2F;new-features-of-github-actions&#x2F;#passing-data-to-future-steps</span><br><span class="line">          asset_path: .&#x2F;cgo-linux-x64.zip</span><br><span class="line">          asset_name: cgo-$&#123;&#123; steps.create_release.outputs.tag &#125;&#125;-linux-x64.zip</span><br><span class="line">          asset_content_type: application&#x2F;zip</span><br><span class="line">      - name: Upload Release cgo darwin</span><br><span class="line">        uses: actions&#x2F;upload-release-asset@v1.0.1</span><br><span class="line">        env:</span><br><span class="line">          GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;</span><br><span class="line">        with:</span><br><span class="line">          upload_url: $&#123;&#123; steps.create_release.outputs.upload_url &#125;&#125; # This pulls from the CREATE RELEASE step above, referencing it&#39;s ID to get its outputs object, which include a &#96;upload_url&#96;. See this blog post for more info: https:&#x2F;&#x2F;jasonet.co&#x2F;posts&#x2F;new-features-of-github-actions&#x2F;#passing-data-to-future-steps</span><br><span class="line">          asset_path: .&#x2F;cgo-darwin-x64.zip</span><br><span class="line">          asset_name: cgo-$&#123;&#123; steps.create_release.outputs.tag &#125;&#125;-darwin-x64.zip</span><br><span class="line">          asset_content_type: application&#x2F;zip</span><br></pre></td></tr></table></figure>

<p>构建流程如下：</p>
<ol>
<li>监听 tag name 为<code>v</code>开头的 push</li>
<li>运行一个 job，在<code>ubuntu</code>虚拟机环境下</li>
<li>拉取源码，安装<code>golang 1.13.x</code>环境</li>
<li>使用<code>go build</code>交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩</li>
<li>使用<code>xgo</code>交叉编译出不同操作系统下 64 位可执行文件，并使用 zip 压缩</li>
<li>使用<code>monkeyWie/create-release@master</code>创建 Release，其中会用到<code>$</code>，这是<code>Github Actions</code>内置的一个<a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/virtual-environments-for-github-actions#github_token-secret" target="_blank" rel="noopener">秘钥</a>，用于授权访问你自己的 github 存储库，原理就是使用这个<code>TOKEN</code>调用<code>Github API</code>来进行创建 release，还有一个<code>$</code>也是<code>Github Actions</code>内置的一个<a href="https://help.github.com/en/github/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context" target="_blank" rel="noopener">变量</a>，然后通过 action 的<code>with</code>进行参数传递。</li>
<li>使用<code>actions/upload-release-asset@v1.0.1</code>上传文件，这里使用了两个表达式<code>$</code>和<code>$</code>，可以获取到指定<code>action</code>的输出，第一个是获取创建好的 release 对应的上传地址，第二个是获取对应的 tag(例如：v1.0.0)，这样就可以在把上传的文件带上版本号。因为这个<code>action</code>不支持多个文件上传，所以就写了多个 action 进行上传。</li>
</ol>
<h1 id="ssh命令"><a href="#ssh命令" class="headerlink" title="ssh命令"></a>ssh命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Publish</span><br><span class="line">on: [push]</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    name: SSH command</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - name: git fetch</span><br><span class="line">      uses: appleboy&#x2F;ssh-action@master</span><br><span class="line">      with:</span><br><span class="line">        host: $&#123;&#123; secrets.SERVER_HOST &#125;&#125;</span><br><span class="line">        username: $&#123;&#123; secrets.SERVER_USERNAME &#125;&#125;</span><br><span class="line">        password: $&#123;&#123; secrets.SERVER_PASSWORD &#125;&#125;</span><br><span class="line">        command_timeout: 10m</span><br><span class="line">        script: |</span><br><span class="line">          git fetch --all</span><br><span class="line">          git reset --hard origin&#x2F;master</span><br><span class="line">  build:</span><br><span class="line">    name: ...</span><br><span class="line">    runs-on: ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h1 id="dotFx"><a href="#dotFx" class="headerlink" title="dotFx"></a>dotFx</h1><p><a href="https://dotnet.github.io/docfx/tutorial/docfx_getting_started.html" target="_blank" rel="noopener">https://dotnet.github.io/docfx/tutorial/docfx_getting_started.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: docfx build</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - dev</span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    name: Build</span><br><span class="line">    runs-on: windows-latest</span><br><span class="line">    steps:</span><br><span class="line">      # Check out the branch that triggered this workflow to the &#39;source&#39; subdirectory</span><br><span class="line">      - name: Checkout Code</span><br><span class="line">        uses: actions&#x2F;checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          ref: dev</span><br><span class="line">          path: source</span><br><span class="line">      - name: install DocFX</span><br><span class="line">        run: &quot;&amp; choco install docfx -y&quot;</span><br><span class="line">      # Run a build</span><br><span class="line">      - name: Build docs</span><br><span class="line">        run: &quot;&amp; docfx .&#x2F;docfx.json&quot;</span><br><span class="line">        working-directory: .&#x2F;source</span><br><span class="line">      # Check out gh-pages branch to the &#39;docs&#39; subdirectory</span><br><span class="line">      - name: Checkout docs</span><br><span class="line">        uses: actions&#x2F;checkout@v2</span><br><span class="line">        with:</span><br><span class="line">          ref: gh-pages</span><br><span class="line">          path: docs</span><br><span class="line">      # Sync the site</span><br><span class="line">      - name: Clear docs repo</span><br><span class="line">        run: Get-ChildItem -Force -Exclude .git | ForEach-Object &#123; Remove-Item -Recurse -Verbose -Force $_ &#125;</span><br><span class="line">        working-directory: .&#x2F;docs</span><br><span class="line">      - name: Sync new content</span><br><span class="line">        run: Copy-Item -Recurse -Verbose -Force &quot;$env:GITHUB_WORKSPACE&#x2F;source&#x2F;_site&#x2F;*&quot; &quot;$env:GITHUB_WORKSPACE&#x2F;docs&quot;</span><br><span class="line">        working-directory: .&#x2F;docs</span><br><span class="line">        # update docs</span><br><span class="line">      - name: Commit to gh-pages and push</span><br><span class="line">        run: |</span><br><span class="line">          $ErrorActionPreference &#x3D; &quot;Continue&quot;</span><br><span class="line">          git add -A</span><br><span class="line">          git diff HEAD --exit-code</span><br><span class="line">          if ($LASTEXITCODE -eq 0) &#123;</span><br><span class="line">            Write-Host &quot;No changes to commit!&quot;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            git config --global user.name &quot;github-actions-docfx[bot]&quot;</span><br><span class="line">            git config --global user.email &quot;weihanli@outlook.com&quot;</span><br><span class="line">            git commit -m &quot;Updated docs from commit $env:GITHUB_SHA on $env:GITHUB_REF&quot;</span><br><span class="line">            git remote set-url origin https:&#x2F;&#x2F;x-access-token:$&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;@github.com&#x2F;$&#123;&#123; github.repository &#125;&#125;</span><br><span class="line">            git push origin gh-pages</span><br><span class="line">          &#125;</span><br><span class="line">        working-directory: .&#x2F;docs</span><br></pre></td></tr></table></figure>



<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node</span><br><span class="line"># For more information see: https:&#x2F;&#x2F;help.github.com&#x2F;actions&#x2F;language-and-framework-guides&#x2F;using-nodejs-with-github-actions</span><br><span class="line"></span><br><span class="line">name: Hexo </span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [14.x]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - name: 迁出main</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with: </span><br><span class="line">        path: main</span><br><span class="line">        submodules: &#39;recursive&#39;</span><br><span class="line"></span><br><span class="line">    - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">      uses: actions&#x2F;setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: 安装hexo</span><br><span class="line">      run : |</span><br><span class="line">        npm install -g hexo-cli</span><br><span class="line">  </span><br><span class="line">    - name: 生成博客</span><br><span class="line">      run : |</span><br><span class="line">        cd main</span><br><span class="line">        npm install</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line">      </span><br><span class="line">    - name: 迁出gh-pages</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        path: gh-pages</span><br><span class="line">        ref: gh-pages</span><br><span class="line">        </span><br><span class="line">    - name: 部署到gh-pages</span><br><span class="line">      env:</span><br><span class="line">        TZ: Asia&#x2F;Shanghai</span><br><span class="line">      run: |</span><br><span class="line">        cp -rf main&#x2F;public&#x2F;* gh-pages</span><br><span class="line">        cd gh-pages</span><br><span class="line">        git config --global user.name &quot;zhepama&quot;</span><br><span class="line">        git config --global user.email &quot;zhepama@gmail.com&quot;</span><br><span class="line">        git add .</span><br><span class="line">        git commit -m &quot;Auto Delopy at &#96;date +&quot;%Y-%m-%d %H:%M&quot;&#96;&quot;</span><br><span class="line">        git push origin gh-pages</span><br></pre></td></tr></table></figure>

<h1 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node</span><br><span class="line"># For more information see: https:&#x2F;&#x2F;help.github.com&#x2F;actions&#x2F;language-and-framework-guides&#x2F;using-nodejs-with-github-actions</span><br><span class="line"></span><br><span class="line">name: GitBook</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [12.18.2]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - name: 迁出main</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with: </span><br><span class="line">        path: main</span><br><span class="line">        submodules: &#39;recursive&#39;</span><br><span class="line"></span><br><span class="line">    - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">      uses: actions&#x2F;setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: 安装gitbook</span><br><span class="line">      run : |</span><br><span class="line">        npm install -g gitbook-cli</span><br><span class="line">  </span><br><span class="line">    - name: 生成书籍</span><br><span class="line">      run : |</span><br><span class="line">        cd main&#x2F;Docs</span><br><span class="line">        gitbook install</span><br><span class="line">        gitbook build</span><br><span class="line">      </span><br><span class="line">    - name: 迁出gh-pages</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        path: gh-pages</span><br><span class="line">        ref: gh-pages</span><br><span class="line">        </span><br><span class="line">    - name: 部署到gh-pages</span><br><span class="line">      env:</span><br><span class="line">        TZ: Asia&#x2F;Shanghai</span><br><span class="line">      run: |</span><br><span class="line">        cp -rf main&#x2F;Docs&#x2F;_book&#x2F;* gh-pages</span><br><span class="line">        cd gh-pages</span><br><span class="line">        git config --global user.name &quot;zhepama&quot;</span><br><span class="line">        git config --global user.email &quot;zhepama@gmail.com&quot;</span><br><span class="line">        git add .</span><br><span class="line">        git commit -m &quot;Auto Delopy at &#96;date +&quot;%Y-%m-%d %H:%M&quot;&#96;&quot;</span><br><span class="line">        git push origin gh-pages</span><br></pre></td></tr></table></figure>





<h1 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h1><p><a href="https://github.com/marketplace" target="_blank" rel="noopener">https://github.com/marketplace</a></p>
<p><a href="https://docs.github.com/cn/actions/configuring-and-managing-workflows/using-environment-variables" target="_blank" rel="noopener">https://docs.github.com/cn/actions/configuring-and-managing-workflows/using-environment-variables</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>sync</tag>
        <tag>JS</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用hexo建立博客并部署到github</title>
    <url>/tool-2020-07-12-hexo-github/</url>
    <content><![CDATA[<h1 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v</span><br><span class="line"></span><br><span class="line"># 初始化一个博客</span><br><span class="line">cd igiven.github.io</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">#添加主题</span><br><span class="line">git submodule add https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br><span class="line">git submodule add https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus.git themes&#x2F;icarus</span><br><span class="line"></span><br><span class="line">#添加插件https:&#x2F;&#x2F;github.com&#x2F;sisyphsu&#x2F;hexo-enhancer#readme</span><br><span class="line">#如果不能生成,则删除db.json  ..或者hexo clean</span><br><span class="line">yarn add hexo-enhancer</span><br><span class="line">yarn add hexo-excerpt</span><br><span class="line">#本地服务器</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>



<h2 id="GITHUB-ACTIONS"><a href="#GITHUB-ACTIONS" class="headerlink" title="GITHUB ACTIONS"></a>GITHUB ACTIONS</h2><p>添加此action前记得先添加分支gh-pages,并设置github的pages为该分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout --orphan gh-pages</span><br><span class="line"># .nojekyll 的空文件来禁用 Jekyll 构建过程，然后按照静态站点生成器的说明在 本地构建站点。</span><br><span class="line">touch .nojekyll</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-07-12-hexo-github/image-20200715164950805.png" alt="image-20200715164950805"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># This workflow will do a clean install of node dependencies, build the source code and run tests across different versions of node</span><br><span class="line"># For more information see: https:&#x2F;&#x2F;help.github.com&#x2F;actions&#x2F;language-and-framework-guides&#x2F;using-nodejs-with-github-actions</span><br><span class="line"></span><br><span class="line">name: Node.js CI</span><br><span class="line"></span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: [ master ]</span><br><span class="line">  pull_request:</span><br><span class="line">    branches: [ master ]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    strategy:</span><br><span class="line">      matrix:</span><br><span class="line">        node-version: [14.x]</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - name: 迁出main</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with: </span><br><span class="line">        path: main</span><br><span class="line">        submodules: &#39;recursive&#39;</span><br><span class="line"></span><br><span class="line">    - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">      uses: actions&#x2F;setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: $&#123;&#123; matrix.node-version &#125;&#125;</span><br><span class="line">    </span><br><span class="line">    - name: 安装hexo</span><br><span class="line">      run : |</span><br><span class="line">        npm install -g hexo</span><br><span class="line">  </span><br><span class="line">    - name: 生成博客</span><br><span class="line">      run : |</span><br><span class="line">        cd main</span><br><span class="line">        npm install</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line">        ls</span><br><span class="line">      </span><br><span class="line">    - name: 迁出gh-pages</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line">      with:</span><br><span class="line">        path: gh-pages</span><br><span class="line">        ref: gh-pages</span><br><span class="line">        </span><br><span class="line">    - name: 部署到gh-pages</span><br><span class="line">      env:</span><br><span class="line">        TZ: Asia&#x2F;Shanghai</span><br><span class="line">      run: |</span><br><span class="line">        cp -rf main&#x2F;public&#x2F;* gh-pages</span><br><span class="line">        cd gh-pages</span><br><span class="line">        git config --global user.name &quot;zhepama&quot;</span><br><span class="line">        git config --global user.email &quot;zhepama@gmail.com&quot;</span><br><span class="line">        git add .</span><br><span class="line">        git commit -m &quot;Auto Delopy at &#96;date +&quot;%Y-%m-%d %H:%M&quot;&#96;&quot;</span><br><span class="line">        git push origin gh-pages</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>终端下设置代理</title>
    <url>/tool-2020-07-13-terminal-proxy/</url>
    <content><![CDATA[<h1 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd命令行:(不用socks5)(临时设置)(也可放置环境变量)</span><br><span class="line">set http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">set https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>



<h1 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$env:http_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">$env:https_proxy&#x3D;&quot;http:&#x2F;&#x2F;127.0.0.1:1080&quot;</span><br><span class="line">curl -vv http:&#x2F;&#x2F;www.google.com</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-07-13-cons/image-20200716004313442.png" alt="image-20200716004313442"></p>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export http_proxy&#x3D;127.0.0.1:1080</span><br><span class="line">export ftp_proxy&#x3D;127.0.0.1:1080</span><br><span class="line">export https_proxy&#x3D;127.0.0.1:1080</span><br></pre></td></tr></table></figure>



<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line">git config --global https.proxy http:&#x2F;&#x2F;127.0.0.1:1080</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
        <tag>C</tag>
        <tag>代理</tag>
        <tag>proxy</tag>
        <tag>powershell</tag>
      </tags>
  </entry>
  <entry>
    <title>发现nuget包太占用C盘，怎么办？</title>
    <url>/tool-2020-08-30-nuget-is-big/</url>
    <content><![CDATA[<h1 id="如何发现的？"><a href="#如何发现的？" class="headerlink" title="如何发现的？"></a>如何发现的？</h1><h4 id="查看C盘存储"><a href="#查看C盘存储" class="headerlink" title="查看C盘存储"></a>查看C盘存储</h4><ol>
<li>打开所有设置-&gt;系统-&gt;存储-&gt;选择C盘<br><img src="../../assets/images/2020-08-30-nuget-is-big/7777310-8ce825574a3c0e8b.png" alt="image.png"></li>
<li>查看C盘使用情况，可以查看“其他”中情况<br><img src="../../assets/images/2020-08-30-nuget-is-big/7777310-b854451afc8d311b.png" alt="image.png"></li>
<li>发现.nuget文件夹占用的空间很大，这是由于VS的默认nuget包路径：C:\Users{UserName}.nuget\packages</li>
</ol>
<h1 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h1><p>NuGet 的行为由一个或多个 NuGet.Config (XML) 文件（可存在于项目范围、用户范围和计算机范围的级别）中的累积设置驱动。</p>
<ol>
<li><p>在解决方案文件夹中，设置应用于子文件夹中的所有项目。 请注意，如果配置文件位于项目文件夹中，则对该项目没有任何影响</p>
</li>
<li><p>设置应用于所有操作，但可被任何项目级的设置替代。Windows：<code>%appdata%\NuGet\NuGet.Config</code><br> Mac/Linux：<code>~/.config/NuGet/NuGet.Config</code> 或 <code>~/.nuget/NuGet/NuGet.Config</code></p>
</li>
<li><p>设置虽然适用于计算机上的所有操作，但会被任何用户级或项目级设置覆盖。Windows：<code>%ProgramFiles(x86)%\NuGet\Config</code>Windows: <code>%ProgramFiles(x86)%\NuGet\Config</code><br> Mac/Linux：<code>$XDG_DATA_HOME</code>。 Mac/Linux: <code>$XDG_DATA_HOME</code>. 如果 <code>$XDG_DATA_HOME</code> 的值是 null 或为空，将使用 <code>~/.local/share</code> 或 <code>/usr/local/share</code>（因 OS 版本而异）</p>
</li>
</ol>
<p>发现占用空间资源比较大的时用户级别的nuget包..我们只要把这个文件夹移动到其他驱动器就可以.一下两者都行建议第二种.因为nuget.exe还需要安装</p>
<p>1.可以直接使用命令行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nuget config -set repositoryPath&#x3D;D:\Users\zhepama\.nuget\packages</span><br></pre></td></tr></table></figure>

<p>2.直接修改配置文件<code>C:\Users\{user}\AppData\Roaming\NuGet\NuGet.Config</code>添加globalPackagesFolder节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;packageSources&gt;</span><br><span class="line">      &lt;add key&#x3D;&quot;nuget.org&quot; value&#x3D;&quot;https:&#x2F;&#x2F;api.nuget.org&#x2F;v3&#x2F;index.json&quot; protocolVersion&#x3D;&quot;3&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;packageSources&gt;</span><br><span class="line">  &lt;config&gt; </span><br><span class="line">      &lt;add key&#x3D;&quot;globalPackagesFolder&quot; value&#x3D;&quot;D:\Users\zhepama\.nuget\packages&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;config&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>



<h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><ul>
<li><a href="https://docs.microsoft.com/zh-cn/nuget/consume-packages/configuring-nuget-behavior" target="_blank" rel="noopener">常见的 NuGet 配置 | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/zh-cn/nuget/reference/nuget-config-file" target="_blank" rel="noopener">nuget.config 文件引用 | Microsoft Docs</a></li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用蒙版将两个图过渡融合</title>
    <url>/tool-2020-09-03-ps-ronghe-pics/</url>
    <content><![CDATA[<p>1、首先打开PS软件，然后在PS中打开需要处理的图片。</p>
<p><img src="../../assets/images/2020-09-03-ps-ronghe-pics/55e736d12f2eb93848c1edf4db628535e5dd6f0c" alt=""></p>
<p>2、接下来将另一张图片拖入PS中，使其位于第一张图片上方，根据自己的的需要调整位置。</p>
<p><img src="../../assets/images/2020-09-03-ps-ronghe-pics/8ad4b31c8701a18be32d8549902f07082938fef6" alt=""></p>
<p>3、接下来在页面右下方选择“添加矢量蒙版”小图标，点击小图标给第二张图片加上矢量蒙版。</p>
<p><img src="../../assets/images/2020-09-03-ps-ronghe-pics/b58f8c5494eef01fde1c8ec3eefe9925bc317da8" alt=""></p>
<p>4、然后在左边工具栏中选择“渐变工具”，在上方工具栏中按下图红色箭头所指从设置。</p>
<p><img src="../../assets/images/2020-09-03-ps-ronghe-pics/f2deb48f8c5494ee13da991f23f5e0fe99257e38" alt=""></p>
<p>5、最后在图片上按住鼠标从左向右拉到另一个位置松开，就可以将两张图边缘融合在一起了。</p>
<p><img src="../../assets/images/2020-09-03-ps-ronghe-pics/342ac65c103853434bee16279d13b07eca808897" alt=""></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>蒙版，其实就是ps运用黑、白和不同程度的灰色来控制画面显示的程度，就好像拿一块板子蒙着你的眼睛一样，黑色是完全不透光的木板，白色是一块玻璃板，灰色是一块半透明的玻璃板，黑色你完全看不到后面的情况，白色你会完全看到后面，而半透明玻璃你能看到后面，但是是不清晰的.</p>
<p><strong>蒙版根据黑白灰,将图片处理成透明,半透明,和不透明.</strong></p>
<p>所以除了渐变工具.还可以用画笔工具.只要涂抹为黑白就可以.</p>
<h3 id="应用图层蒙版是不能执行的"><a href="#应用图层蒙版是不能执行的" class="headerlink" title="应用图层蒙版是不能执行的?"></a>应用图层蒙版是不能执行的?</h3><p>因为你的图层是智能图层，你先要栅格化之后，才能执行你需要的操作~</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>unity商店下载资源迁移</title>
    <url>/tool-2020-11-15-unity-is-big/</url>
    <content><![CDATA[<p>使用cmd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mklink &#x2F;J &quot;C:\Users\zhepama\AppData\Roaming\Unity\Asset Store-5.x&quot; &quot;E:\Asset\Asset Store-5.x&quot;</span><br></pre></td></tr></table></figure>







<p><a href="https://forum.unity.com/threads/asset-store-download-folder.83620/page-2" target="_blank" rel="noopener">https://forum.unity.com/threads/asset-store-download-folder.83620/page-2</a></p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>关于coding的pages介绍</title>
    <url>/tool-2020-11-16-coding-pages/</url>
    <content><![CDATA[<p>他是收费的..收费的..收费的..</p>
<p>和腾讯云的相关产品</p>
<ol>
<li><a href="https://console.cloud.tencent.com/sls" target="_blank" rel="noopener">https://console.cloud.tencent.com/sls</a>  主要是部署的时候使用</li>
<li><a href="https://console.cloud.tencent.com/cdn" target="_blank" rel="noopener">https://console.cloud.tencent.com/cdn</a>  如果你使用了自己的域名…则会使用cdn</li>
<li><a href="https://console.cloud.tencent.com/cos5" target="_blank" rel="noopener">https://console.cloud.tencent.com/cos5</a>  你生产的网站实际上是放在这个里面的.</li>
</ol>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>一些常用的dns服务器</title>
    <url>/tool-2021-05-06-dns/</url>
    <content><![CDATA[<h3 id="微软DNS服务器——可以长期信赖的稳定服务器。"><a href="#微软DNS服务器——可以长期信赖的稳定服务器。" class="headerlink" title="微软DNS服务器——可以长期信赖的稳定服务器。"></a>微软DNS服务器——可以长期信赖的稳定服务器。</h3><p>主用：4.2.2.1</p>
<p>备用：4.2.2.2</p>
<p>如果你使用win10,且要经常登录微软账号.一定要设置一个</p>
<h3 id="国内公共DNS服务提供商："><a href="#国内公共DNS服务提供商：" class="headerlink" title="国内公共DNS服务提供商："></a>国内公共DNS服务提供商：</h3><ul>
<li><p>百度DNS服务器——延迟很小，毕竟是大品牌，响应速度也不错，口碑不错。</p>
<p>​    主用：180.76.76.76</p>
</li>
<li><p>腾讯DNS服务器——延迟小，响应快，口碑不错。</p>
<p>​    主用：119.29.29.29</p>
<p>​    备用：182.254.116.116</p>
</li>
<li><p>阿里DNS服务器——延迟小，响应快，口碑不错。</p>
<p>​    主用：223.5.5.5</p>
<p>​    备用：223.6.6.6</p>
</li>
<li><p>CNNIC中国互联网络信息中心 DNS服务器——国家队产品，地址好记，经常用来做网络连通性测试的。</p>
<p>​    主用：1.2.4.8</p>
<p>​    备用：202.98.0.68</p>
</li>
</ul>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity 导出 Android 64-bit 版本</title>
    <url>/unity-2019-06-20-unity-android-x64/</url>
    <content><![CDATA[<h2 id="导出说明"><a href="#导出说明" class="headerlink" title="导出说明"></a>导出说明</h2><p>Unity supports x64 since 2017 LTS. To enable it you can go to File &gt; Build Settings &gt; Player Settings.</p>
<p>There under “Other Settings” you have to change your Script Backend to IL2CPP, and you will have the ARM64 checkbox active. Check it.</p>
<p><img src="../../assets/images/2019-06-20-unity-android-x64/2019-06-20-04-48-21.png" alt=""></p>
<p>And then you can either select to generate Split APKs by Target Architecture</p>
<p><img src="../../assets/images/2019-06-20-unity-android-x64/2019-06-20-04-48-48.png" alt=""></p>
<p>or in your Build Settings dialog choose to Build App Bundle (Google Play)</p>
<p><img src="../../assets/images/2019-06-20-unity-android-x64/2019-06-20-04-49-44.png" alt=""></p>
<p>Hope it helps, you will need to have the Android NDK for this.</p>
<p>如果选择Build ，Unity会生成AAB文件，该文件可以直接发布到Google Play。</p>
<p>如果选择Build and Run，Unity会生成AAB文件，该文件会为关联设备生成临时APK文件，然后安装APK文件到设备并运行应用程序。</p>
<p>如果选择Build 并希望手动安装应用程序到设备上，可以使用Google提供的bundletool utility ,你可在Unity安装目录中的<code>Editor/Data/PlaybackEngines/AndroidPlayer/Tools</code>目录下找到它。</p>
<p>请注意，当构建应用程序包时，菜单<code>Edit &gt; Setting &gt; Player</code>下的<code>Split APKs by target architecture</code> 会被禁用，因为生成的应用程序包应包含所有支持目标的库。</p>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>在开发期间，为了减少使用构建和运行时的迭代次数，可以禁用应用程序包的生成功能，并使用常规的APK文件，因为从应用程序包生成APK需要额外时间，之后才会部署到设备上。</p>
<p>应用程序包还可以从Android Studio生成，它使用从Unity导出的Gradle项目。为此，你需要使用Android Studio 3.2或更高版本，并选择<code>Build &gt; Build Bundle(s) / APK(s) &gt; Build Bundle(s)</code>。</p>
<p>如果目标商店不支持Android App Bundles，你可以使用Player settings中的<code>Split APKs by target architecture</code>选项，从而根据终端用户设备的CPU架构提供APK文件，或使用bundletool，该工具可以构建支持运行在任何环境的“通用APK”文件</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://connect.unity.com/p/unity-2018-3-betazhong-de-android-app-bundle-aab-zhi-chi" target="_blank" rel="noopener">https://connect.unity.com/p/unity-2018-3-betazhong-de-android-app-bundle-aab-zhi-chi</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity的il2cpp</title>
    <url>/unity-2019-06-20-unity-il2cpp-debugger/</url>
    <content><![CDATA[<ol>
<li><p>unity是运行在mono下的,il2cpp有自己的运行时,il2cpp不是运行在mono下的不是mono的aot</p>
</li>
<li><p>mono的gc和.net的gc是不同的,il2cpp运行时实现了自己的垃圾回收(Boehm-Demers-Weiser garbage collector)</p>
</li>
<li><p>编译和运行时是两个阶段,可以用csc.exe编译然后运行在mono上, .NET 4.x可以使用就是这个原理</p>
<p>Note that the <strong>.rsp</strong> file needs to match the compiler being invoked. For example:</p>
<ul>
<li>when targeting the .NET 3.5 Equivalent (deprecated) scripting runtime version, <strong>mcs</strong> is used with <code>mcs.rsp</code>, and</li>
<li>when targeting the .NET 4.x Eqivalent scripting runtime version compiler, <strong>csc</strong> is used with <code>csc.rsp</code>.</li>
</ul>
</li>
</ol>
<p>大约在一年以前，我们写了一篇博客讨论Unity中脚本将来会是个什么样子，在那篇博客中我们提到了崭新的IL2CPP后端，并许诺其会为Unity带来更高效和更适合于各个平台的虚拟机。在2015年的一月份，我们正式发布了第一个使用IL2CPP的平台：iOS 64-bit。而随着Unity 5的发布，又带给大家另一个使用IL2CPP的平台：WebGL。感谢我们社区中用户的大量宝贵的反馈，我们在接下来的时间里根据这些反馈得以更新IL2CPP，发布补丁版本，从而持续的改进IL2CPP的编译器和运行时库。</p>
<p>我们没有停止改进IL2CPP的打算，但是在目前这个时间点上，我们觉得可以回过头来抽出点时间告诉大家一些IL2CPP的内部工作机制。在接下来的几个月的时间里，我们打算对以下话题（或者还有其他未列出的话题）进行讨论，来做一个IL2CPP深入讲解系列。目前准备讨论的话题有：</p>
<p>1.基础 - 工具链和命令行参数（本篇博文）<br> 2.IL2CPP生成代码介绍<br> 3.IL2CPP生成代码调试小窍门<br> 4.方法调用介绍（一般方法调用和虚方法调用等）</p>
<ol>
<li>通用代码共享的实现<br> 6.P/invoke(Platform Invocation Service)对于类型（types）和方法（methods）的封装<br> 7.垃圾回收器的集成<br> 8.测试框架（Testing frameworks）及其使用</li>
</ol>
<p>为了能让这个系列的讨论成为可能，我们会涉及到一些将来肯定会进行改动的IL2CPP的实现细节。但这也没有关系，通过这些讨论，我们希望能给大家提供一些有用和有趣的信息。</p>
<h2 id="什么是IL2CPP？"><a href="#什么是IL2CPP？" class="headerlink" title="什么是IL2CPP？"></a>什么是IL2CPP？</h2><p>从技术层面上来说，我们说的IL2CPP包含了两部分：一个进行 预先编译（译注：ahead-of-time，又叫AOT，以下一律使用AOT缩写）的编译器。</p>
<h2 id="一个支持虚拟机的运行时库"><a href="#一个支持虚拟机的运行时库" class="headerlink" title="一个支持虚拟机的运行时库"></a>一个支持虚拟机的运行时库</h2><p>AOT编译器将由.NET 输出的中间语言(IL)代码生成为C++代码。运行时库则提供诸如垃圾回收，与平台无关的线程，IO以及内部调用（C++原生代码直接访问托管代码结构）这样的服务和抽象层。</p>
<h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><p>IL2CPP AOT编译器实际的执行文件是il2cpp.exe。在Windows平台你可以在Unity安装路径的Editor\Data\il2cpp目录下找到。对于OSX平台，它位于Unity安装路径的Contents/Frameworks/il2cpp/build目录内。 il2cpp.exe这个工具是一个托管代码可执行文件，其完全由C#写成。在开发IL2CPP的过程中，我们同时使用.NET和Mono编译器对其进行编译。</p>
<p>il2cpp 接受来自Unity自带的或者由Mono编译器产生的托管程序集，将这些程序集转换成C++代码。这些转换出的C++代码最终由部署目标平台上的C++编译器进行编译。</p>
<p>你可以参照下图理解IL2CPP工具链的作用：</p>
<p><img src="../../assets/images/2019-06-20-unity-il2cpp-debugger/il2cpp-toolchain-smaller.png" alt="il2cpp toolchain smaller"> </p>
<h2 id="运行时库"><a href="#运行时库" class="headerlink" title="运行时库"></a>运行时库</h2><p>IL2CPP的另外一个部分就是对虚拟机提供支持的运行时库。我们基本上是用C++代码来实现整个运行时库的（好吧，其实里面还是有一些和平台相关的代码使用了程序集，这个只要你知我知便好，不要告诉别人 ）。我们把运行时库称之为libli2cpp，它是作为一个静态库被连接到最终的游戏可执行文件中。这么做的一个主要的好处是可以使得整个IL2CPP技术是简单并且是可移植的。</p>
<p>你能通过查看随Unity一起发布的libil2cpp头文件来窥探其代码组织方式（Windows平台，头文件在Editor\Data\PlaybackEngines\webglsupport\BuildTools\Libraries\libil2cpp\include目录中。OSX平台，头文件在Contents/Frameworks/il2cpp/libil2cpp目录中）。举个例子，由il2cpp产生的C++代码和libil2cpp之间的接口API，存在于codegen/il2cpp-codegen.h这个文件中。</p>
<p>运行时的另外一个重要的部分，就是垃圾收集器。在Unity 5中，我们使用libgc垃圾收集器。它是一个典型的贝姆垃圾收集器（Boehm-Demers-Weiser garbage collector）。（译注：相对使用保守垃圾回收策略）。然而我们的libil2cpp被设计成可以方便使用其他垃圾回收器。因此我们现在也在研究集成微软开源的垃圾回收器（Microsoft GC）。对于垃圾回收器这一点，我们会在后续的一篇中专门的讨论，这里就不多说了。</p>
<h2 id="il2cpp是如何执行的？"><a href="#il2cpp是如何执行的？" class="headerlink" title="il2cpp是如何执行的？"></a>il2cpp是如何执行的？</h2><p>让我们从一个简单的例子入手。这里使用Unity的版本是5.0.1，在Windows环境并且建立一个全新的空项目。然后创建一个带MonoBehaviour的脚本文件，将其作为组件加入到Main Camera上。代码也是非常的简单，输出Hello World：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> :</span> MonoBehaviour &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    Debug.Log(<span class="string">"Hello, IL2CPP!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我切换到WebGL平台进行项目生成的时候，我们可以用Process Explorer来对il2cpp的命令行进行观察，得到以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe&quot; &quot;C:\Program Files\Unity\Editor\Data\il2cpp&#x2F;il2cpp.exe&quot; --copy-level&#x3D;None --enable-generic-sharing --enable-unity-event-support --output-format&#x3D;Compact --extra-types.file&#x3D;&quot;C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt&quot; &quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll&quot; &quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll&quot; &quot;C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput&quot;</span><br></pre></td></tr></table></figure>

<p>嗯，这个真是老太太的裹脚布 - 又臭又长……，所以让我们把命令分拆一下，Unity运行的是这个可执行文件：</p>
<figure class="highlight plain"><figcaption><span>Files\Unity\Editor\Data\MonoBleedingEdge\bin\mono.exe"```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">下一个参数是il2cpp.exe工具本身：</span><br><span class="line">&#96;&#96;&#96; &quot;C:\Program Files\Unity\Editor\Data\il2cpp&#x2F;il2cpp.exe&quot;</span><br></pre></td></tr></table></figure>

<p>请注意剩下的参数其实都是传递给il2cpp.exe的而不是mono.exe。上面的例子里传递了5个参数给il2cpp.exe：<br> <code>–copy-level=None</code></p>
<p>指明il2cpp.exe不对生成的C++文件进行copy操作<br><code>–enable-generic-sharing</code><br> 告诉IL2CPP如果可以，对通用方法进行共享。这个可以减少代码并降低最后二进制文件的尺寸</p>
<p><code>–enable-unity-event-support</code><br> 确保和Unity events相关的，通过反射机制来运作的代码，能够正确生成。</p>
<p><code>–output-format=Compact</code><br> 在生成C++代码时为里面的类型和方法使用更短的名字。这会使得C++代码难以阅读，因为原来在IL中的名字被更短的取代了。但好处是可以让C++编译器运行的更快。</p>
<p><code>–extra-types.file=”C:\Program Files\Unity\Editor\Data\il2cpp\il2cpp_default_extra_types.txt”</code></p>
<p>使用默认的（也是空的）额外类型文件。il2cpp.exe会将在这个文件中出现的基本类型或者数组类型看作是在运行时生成的而不是一开始出现在IL代码中来对待。</p>
<p>需要注意的是这些参数可能会在以后的Unity版本中有所变化。我们现在还没有稳定到把il2cpp.exe的命令行参数整理固定下来的阶段。</p>
<p>最后，我们有由两个文件组成的一个列表和一个目录在这个长长的命令行中：</p>
<figure class="highlight plain"><figcaption><span>Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\Assembly-CSharp.dll”</span></figcaption><table><tr><td class="code"><pre><span class="line">“C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\Managed\UnityEngine.UI.dll”</span><br><span class="line"></span><br><span class="line">“C:\Users\Josh Peterson\Documents\IL2CPP Blog Example\Temp\StagingArea\Data\il2cppOutput”</span><br></pre></td></tr></table></figure>

<p>il2cpp.exe工具可以接收一个由IL程序集组成的列表。在上面这个例子中，程序集包含了项目中的简单脚本程序集：Assembly-CSharp.dll，和GUI程序集：UnityEngine.UI.dll。大家可能会注意到这里面明显少了什么：UnityEngine.dll到哪去了？系统底层的mscorlib.dll也不见了踪影。实际上，il2cpp.exe会在内部自动引用这些程序集。你当然也可以把这些放入列表中，但他们不是必须的。你只需要提及那些根程序集（那些没有被其他任何程序集引用到的程序集），剩下的il2cpp.exe会根据引用关系自动加入。</p>
<p>裹脚布的最后一块是一个目录，il2cpp.exe会将最终的C++代码生成到这里。如果你还保持着一颗好奇的心，可以看看这个目录中产生的文件。这些文件是我们下一个讨论的主题。在你审视这些代码前，可以考虑将WebGL构建设置中的“Development Player”选项勾上。这么做会移除–output-format=Compact命令行参数从而让C++代码中的类型和方法的名字更加可读。</p>
<p>尝试在WebGL或者iOS构建设置中进行些改变。这样你会发现传递给il2cpp.exe的参数也会相应的发生变化。例如，将“Enable Exceptions” 设置成“Full” 会将–emit-null-checks，–enable-stacktrace，和 –enable-array-bounds-check这三个参数加入il2cpp.exe命令行。</p>
<h2 id="IL2CPP没做的事情"><a href="#IL2CPP没做的事情" class="headerlink" title="IL2CPP没做的事情"></a>IL2CPP没做的事情</h2><p>我想指出IL2CPP有一向挑战我们没有接受,而且我们也高兴我们忽略了它。我们没有尝试重写整个C#标准库。当你使用IL2CPP后端构建Unity项目的时候，所有在mscorlib.dll，System.dll等中的C#标准库和原来使用Mono编译时候的一模一样。</p>
<p>我们可以依赖健壮的且久经考验的C#标准库，所以当处理有关IL2CPP的bug的时候，我们可以很肯定的说问题出在AOT编译器或者运行时库这两个地方而不是在其他地方。</p>
<h2 id="我们如何开发，测试，发布IL2CPP"><a href="#我们如何开发，测试，发布IL2CPP" class="headerlink" title="我们如何开发，测试，发布IL2CPP"></a>我们如何开发，测试，发布IL2CPP</h2><p>自从我们在一月份的4.6.1 p5版本中首次引入IL2CPP以来，我们已经连续发布了6个Unity版本和7个补丁（Unity版本号跨越4.6和5.0）。在这些发布中我们修正了超过100个bug。</p>
<p>为了确保持续的改进得以实施，我们内部只保留一份最新的开发代码在主干分之（trunk branch）上，在发布各个版本之前，我们会将IL2CPP的改动挂到一个特定的分之下，然后进行测试，确保所有的bug已经正确的修正了。我们的QA和维护工作组为此付出了惊人的努力才得以保证发布版本的快速迭代。（译注：感觉是版本管理的标准的开发流程）</p>
<p>提供高质量Bug的用户社区被证明是一个无价之宝。我们非常感谢用户的反馈来帮助我们改进IL2CPP，并且希望这类反馈越多越好。</p>
<p>我们的IL2CPP研发组有很强烈的“测试优先”意识。我们时常使用“Test Driven Design”方法，在没有进行足够全面的测试的情况下，几乎不会进行代码的合并工作。这个策略用在IL2CPP项目上非常的棒。我们现在所面对的大部分bug并不是意想不到的行为产生的，而是由意想不到的特殊情况产生的。（例如在一个32位的索引数组中使用了64位的指针从而导致C++编译器失败）面对这种类型的bug我们可以快速的并且很自信的进行修正。</p>
<p>有了社区的帮助，我们非常努力的让IL2CPP既快又稳定。顺便说一句，如果你对我刚才说的这些有兴趣，我们正在招人（嗯…..我只是这么一说）</p>
<h2 id="好戏连台"><a href="#好戏连台" class="headerlink" title="好戏连台"></a>好戏连台</h2><p>关于IL2CPP我们还有很多可以说的。下一次我们会深入到il2cpp.exe代码生成的细节中。看看对于C++编译器来说，由il2cpp.exe生成的代码会是个什么样子。</p>
<h1 id="IL2CPP-脚本限制"><a href="#IL2CPP-脚本限制" class="headerlink" title="IL2CPP 脚本限制"></a>IL2CPP 脚本限制</h1><h2 id="System-Reflection-Emit"><a href="#System-Reflection-Emit" class="headerlink" title="System.Reflection.Emit"></a>System.Reflection.Emit</h2><p>AOT 平台无法实现 <code>System.Reflection.Emit</code> 命名空间中的任何方法。<code>System.Reflection</code> 的其余部分是可接受的，只要编译器可以推断通过反射使用的代码需要在运行时存在。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>AOT 平台可能会由于使用了反射而遇到序列化和反序列化问题。如果仅通过反射将某个类型或方法作为序列化或反序列化的一部分使用，则 AOT 编译器无法检测到需要为该类型或方法生成代码。</p>
<p>这是我们常遇到的问题..一个是scriptobject的asset,一个是网络协议都是序列化数据</p>
<ol>
<li>odin,最佳模式新建一个aot场景,将需要的scriptobject放在该场景.或者声明序列化字段</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OdinAOTSetting : Sirenix.OdinInspector.SerializedMonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;ScriptableObject&gt; Configs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    public UnityEngine.Color Color;</span><br><span class="line"></span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    public CityMapLandType CityMapLandType;</span><br><span class="line"></span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, InventoryItemConfig&gt; InventoryItemConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, LootTableConfig&gt; LootTableConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, MerchantConfig&gt; MerchantConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, LandConfig&gt; LandConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, MapConfig&gt; MapConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;long, NPCConfig&gt; NPCConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;long, QuestConfig&gt; QuestConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;string, RedeemCodeConfig&gt; RedeemCodeConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, BuffConfig&gt; BuffConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, ProjectileConfig&gt; ProjectileConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;int, SkillConfig&gt; SkillConfigs;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;string, AttrAsset&gt; AttrAssets;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;string, StatAsset&gt; StatAssets;</span><br><span class="line">    [NonSerialized, OdinSerialize]</span><br><span class="line">    Dictionary&lt;string, StatusEffectAsset&gt; StatusEffectAssets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>网络协议Json,使用字段,而不是使用属性(get,set),il2cpp 在运行时会剥离去除Get属性，</p>
</li>
<li><p>网络协议protobuf,虽然protobuf本身是支持Dictionary的,但是aot就不能使用了..未找到解决办法 ,用class代替</p>
</li>
</ol>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>每个泛型实例实际上都是一个独立的类型，<code>List&lt;A&gt;</code> 和 <code>List&lt;B&gt;</code>是两个完全没有关系的类型，这意味着，如果在运行时无法通过JIT来创建新类型的话，代码中没有直接使用过的泛型实例都会在运行时出现问题。</p>
<p>在ILRuntime中解决这个问题有两种方式，一个是使用CLR绑定，把用到的泛型实例都进行CLR绑定。另外一个方式是在Unity主工程中，建立一个类，然后在里面定义用到的那些泛型实例的public变量。这两种方式都可以告诉IL2CPP保留这个类型的代码供运行中使用。</p>
<p>因此建议大家在实际开发中，尽量使用热更DLL内部的类作为泛型参数，因为DLL内部的类型都是ILTypeInstance，只需处理一个就行了。此外如果泛型模版类就是在DLL里定义的的话，那就完全不需要进行任何处理。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>跟泛型实例一样，<code>foo.Bar&lt;TypeA&gt;</code> 和<code>foo.Bar&lt;TypeB&gt;</code>是两个完全不同的方法，需要在主工程中显式调用过，IL2CPP才能够完整保留，因此需要尽量避免在热更DLL中调用Unity主工程的泛型方法。如果在iOS上实际运行遇到报错，可以尝试在Unity的主工程中随便写一个static的方法，然后对这个泛型方法调用一下即可，这个方法无需被调用，只是用来告诉IL2CPP我们需要这个方法</p>
<h2 id="AnimatorController-等"><a href="#AnimatorController-等" class="headerlink" title="AnimatorController 等"></a>AnimatorController 等</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">错误信息#</span><br><span class="line">Could not produce class with ID #</span><br><span class="line">Could not produce class with ID XXX.</span><br><span class="line">This could be caused by a class being stripped from the build even though it is needed. Try disabling &#39;Strip Engine Code&#39; in Player Settings.:&lt;LoadWWWIEnumerator&gt;c__Iterator99:MoveNext()</span><br></pre></td></tr></table></figure>

<p>如果提示的ID的是Editor的，比如 AnimatorController(ID 91)属于Editor包里的，不能用link.xm加回来，可以在<strong>Resource</strong>下建一个空的prefab,在上面挂一个AnimatorController，打包时留下这个prefab就可以确保这个类不被strip掉了。</p>
<p><strong>参考 :</strong></p>
<ul>
<li><a href="https://forum.unity.com/threads/could-not-produce-class-with-id-91-ios.267548/" target="_blank" rel="noopener">Could not produce class with ID 91 - iOS - Unity Forum</a></li>
<li><a href="https://docs.unity3d.com/cn/2020.2/Manual/ClassIDReference.html" target="_blank" rel="noopener">YAML 类 ID 参考 - Unity 手册 (unity3d.com)</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>不要用dynamic关键字</li>
<li>没有使用的字段都不会被编译..</li>
</ul>
<h1 id="托管代码剥离"><a href="#托管代码剥离" class="headerlink" title="托管代码剥离"></a>托管代码剥离</h1><p>IL2CPP在打包时会自动对Unity工程的DLL进行裁剪，将代码中没有引用到的类型裁剪掉，以达到减小发布后ipa包的尺寸的目的。然而在实际使用过程中，很多类型有可能会被意外剪裁掉，造成运行时抛出找不到某个类型的异常。特别是通过反射等方式在编译时无法得知的函数调用，在运行时都很有可能遇到问题。</p>
<p>Unity提供了一个方式来告诉Unity引擎，哪些类型是不能够被剪裁掉的。具体做法就是在Unity工程的Assets目录中建立一个叫link.xml的XML文件，然后按照下面的格式指定你需要保留的类型：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">linker</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"UnityEngine"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">assembly</span> <span class="attr">fullname</span>=<span class="string">"Assembly-CSharp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">namespace</span> <span class="attr">fullname</span>=<span class="string">"MyGame.Utils"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span> <span class="attr">fullname</span>=<span class="string">"MyGame.SomeClass"</span> <span class="attr">preserve</span>=<span class="string">"all"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">assembly</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">linker</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="IL2CPP限制"><a href="#IL2CPP限制" class="headerlink" title="IL2CPP限制"></a>IL2CPP限制</h2><p>将游戏导出到 iOS 等平台时，Unity 将使用其 IL2CPP 引擎将 IL“转换”为 C++ 代码，然后使用目标平台的本机编译器进行编译。 在此方案中，有几个不支持的 .NET 功能，例如反射的部分内容和使用 <code>dynamic</code> 关键字。 虽然可在自己的代码中使用这些功能，但使用第三方 DLL 和 SDK 时可能会遇到问题，这些 DLL 和 SDK 并非使用 Unity 和 IL2CPP 编写。 有关此主题的详细信息，请参阅 Unity 站点上的<a href="https://docs.unity3d.com/Manual/ScriptingRestrictions.html" target="_blank" rel="noopener">脚本限制</a>文档。</p>
<p>此外，如之前 Json.NET 示例中所述，Unity 将尝试在 IL2CPP 导出过程中裁剪掉未使用的代码。 虽然这通常不是问题，但对于使用反射的库，它可能会意外地删除在导出时无法确定是否被调用而在运行时可能被调用的属性或方法。 若要解决这些问题，请添加一个 link.xml 文件到项目中，该文件中包含的程序集和命名空间列表不会执行裁剪过程。 有关完整详细信息，请参阅<a href="https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html" target="_blank" rel="noopener">有关字节码裁剪的 Unity 文档</a>。</p>
<h2 id="编译速度优化"><a href="#编译速度优化" class="headerlink" title="编译速度优化"></a>编译速度优化</h2><ol>
<li>增量编译</li>
<li>关闭实时保护</li>
<li>使用ssd</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://docs.microsoft.com/en-us/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019</a></li>
<li><a href="https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/IL2CPP-BytecodeStripping.html</a></li>
<li><a href="https://docs.unity3d.com/Manual/ScriptingRestrictions.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ScriptingRestrictions.html</a></li>
<li><a href="https://www.jianshu.com/p/7cfcb7b0cfe7" target="_blank" rel="noopener">https://www.jianshu.com/p/7cfcb7b0cfe7</a></li>
<li><a href="https://blogs.unity3d.com/cn/2015/05/06/an-introduction-to-ilcpp-internals/" target="_blank" rel="noopener">https://blogs.unity3d.com/cn/2015/05/06/an-introduction-to-ilcpp-internals/</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>googlePlay 发布问题</title>
    <url>/unity-2019-06-23-googlplay-pulish/</url>
    <content><![CDATA[<h1 id="问题-隐私声明"><a href="#问题-隐私声明" class="headerlink" title="问题 隐私声明"></a>问题 隐私声明</h1><p>使用这个站点<a href="https://app-privacy-policy-generator.firebaseapp.com/" target="_blank" rel="noopener">https://app-privacy-policy-generator.firebaseapp.com/</a> 根据app的名称，类型，平台等等，选择对应的选项，右边按钮还包含对应的第三方隐私服务链接，如果你用到的话，比如google play service, firebase等等，那么就勾选上。最后点击GENERATE，就会生成一个适合你自己app的privacy-policy页面了。<br>最后的最后，记得将这个url输入到google play后台的隐私设置区域，点击保存，重新发布app等候google play团队的审核。一两个小时就好了。</p>
<p><a href="https://blog.usejournal.com/how-to-fix-advertising-id-policy-violation-in-google-play-store-6d9cf92d335d" target="_blank" rel="noopener">https://blog.usejournal.com/how-to-fix-advertising-id-policy-violation-in-google-play-store-6d9cf92d335d</a></p>
<h1 id="问题-1002"><a href="#问题-1002" class="headerlink" title="问题 -1002"></a>问题 -1002</h1><p>Google Play应用需要授予”允许后台弹窗”的权限</p>
<h1 id="问题-此商品无法在您设备所在的国家地区安装"><a href="#问题-此商品无法在您设备所在的国家地区安装" class="headerlink" title="问题  此商品无法在您设备所在的国家地区安装"></a>问题  此商品无法在您设备所在的国家地区安装</h1><ul>
<li>删除家庭内容..</li>
<li>使用vpn切换到指定国家</li>
<li>googleplay–账号里切换地区</li>
</ul>
<h1 id="问题-无法购买您要的商品"><a href="#问题-无法购买您要的商品" class="headerlink" title="问题 无法购买您要的商品"></a>问题 无法购买您要的商品</h1><p>做Google Play 支付， 遇到“无法购买您要的商品”的问题，在网上搜了些答案，下面罗列了一些</p>
<ol>
<li><p>保证 versionCode 和版本号与你上传的apk的包的一样。</p>
</li>
<li><p>保证后台和你传入的购买商品的 id 一致。</p>
</li>
<li><p>确保你所使用的账号是在测试人员里。</p>
</li>
</ol>
<p>在”APK”页面里，有一个“选择使用网址”，把这个网址给你的测试人员，让你的测试人员用他的google账号点进去，点那个“成为测试人员”（前提是你把他加进了测试人员列表），还需要把连接地址发送给测试人员，必须要测试人员点击同意参加测试才行！！</p>
<h1 id="问题-无法使用该应用-此应用的测试版尚未发布，或者无法通过此帐号使用。"><a href="#问题-无法使用该应用-此应用的测试版尚未发布，或者无法通过此帐号使用。" class="headerlink" title="问题 无法使用该应用,此应用的测试版尚未发布，或者无法通过此帐号使用。"></a>问题 无法使用该应用,此应用的测试版尚未发布，或者无法通过此帐号使用。</h1><p><a href="https://play.google.com/apps/testing/com.zhepama.gyj" target="_blank" rel="noopener">https://play.google.com/apps/testing/com.zhepama.gyj</a>  发给测试人员激活..记住..登录的用户一定是测试人员</p>
<h1 id="问题-此版本的应用未配置为通过googleplay-结算"><a href="#问题-此版本的应用未配置为通过googleplay-结算" class="headerlink" title="问题 此版本的应用未配置为通过googleplay 结算"></a>问题 此版本的应用未配置为通过googleplay 结算</h1><p>造成这个错误的原因有两个:</p>
<ul>
<li>第一个是打包的时候，versionCode的值比提交到google play后台的版本要高。 </li>
<li>第二个就是：打包的时候，和google play后台上的包的签名不一致。</li>
</ul>
<h1 id="问题-关于如何测试"><a href="#问题-关于如何测试" class="headerlink" title="问题  关于如何测试"></a>问题  关于如何测试</h1><p>先使用release版本发布到googleplay.测试的时候可以使用debug版本,先测试下基本功能..查看哪里报错..</p>
<p>apk可以使用谷歌提供的测试地址下载</p>
<h3 id="以下是Google-IAB测试的要求清单。"><a href="#以下是Google-IAB测试的要求清单。" class="headerlink" title="以下是Google IAB测试的要求清单。"></a>以下是Google IAB测试的要求清单。</h3><h4 id="先决条件："><a href="#先决条件：" class="headerlink" title="先决条件："></a>先决条件：</h4><ul>
<li>AndroidManifest必须包含“com.android.vending.BILLING”权限 。</li>
<li>APK内置于发行模式 。</li>
<li>APK已使用发行证书进行 签名 。</li>
<li>至少一次将APK上传到Alpha / Beta版本的渠道（以前 - 作为草稿）到开发者控制台。 （需要一段时间〜2h-24h ）。</li>
<li>IAB 产品已发布 ，其状态设置为活动 。</li>
<li>测试帐户被添加到开发者控制台中。</li>
</ul>
<h4 id="测试要求："><a href="#测试要求：" class="headerlink" title="测试要求："></a>测试要求：</h4><ul>
<li>测试APK 与上传到开发者控制台的版本号相同 。</li>
<li>测试APK的签名与上传到dev.console的证书相同 。</li>
<li>测试帐户 （不是开发人员） - 是设备上的主要帐户 。</li>
<li>测试帐户作为测试者选择加入，并与有效的付款方式相关联 。 （ @Kyone ）</li>
<li>PS： 使用发行证书进行调试  </li>
</ul>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="">https : //stackoverflow.com/a/15754187/1321401</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>关于unity的适配问题</title>
    <url>/unity-2019-08-09-unity2d-shipei/</url>
    <content><![CDATA[<p>先说明一些基本的概念：</p>
<p><strong>1.屏幕的宽高比Aspect Ratio = 屏幕宽度/屏幕高度</strong></p>
<p><strong>2.Unity2D中摄像机镜头的尺寸决定了我们实际看到游戏内容的多少，在编辑器中我们可以通过调整摄像机Camera的orthographicSize属性值来调整摄像机的大小。</strong></p>
<p>如下图所示，当摄像机orthographicSize属性值等于当前屏幕高度单位的一半时，摄像机大小正好与屏幕大小相等。注意这里提到的是屏幕单位高度的一半，这个数值是经过像素到单位比即Pixels To Units换算的，Unity2D中这个比例的默认值是100，即100像素等于1单位。如果我们的游戏屏幕有640像素高，那么实际换算成单位高度则是6.4个单位，当我们摄像机的orthographicSize值是3.2时，摄像机大小刚好与屏幕大小相等。</p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/041527387365011.png" alt="img"></p>
<p>可以通过此选项调整每张图片的像素单位比</p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/041505358774753.png" alt="img"></p>
<h3 id="Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？"><a href="#Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？" class="headerlink" title="Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？"></a>Unity编辑器中只能直接调整摄像机的高度，那摄像机的宽度是如何确定的呢？</h3><p>答案就是我们最前面提到的屏幕宽高比。Unity会根据当前屏幕实际的宽高比和摄像机的orthographicSize值来计算出摄像机的宽度值，即：</p>
<p><strong>摄像机实际宽度 = 摄像机orthographicSize * 2 * 屏幕宽高比</strong></p>
<p>也即是</p>
<p><strong>摄像机实际宽度 = 摄像机高度 * 屏幕宽高比</strong></p>
<p>我举个例子说明一下，iPhone4的屏幕像素为640*960，宽高比为2:3，假设Pixels To Units值为100，那么如果设摄像机高度size值为4.8，那么摄像机实际宽度按照公式算出6.4，刚好就是屏幕的单位宽度。</p>
<h1 id="场景适配"><a href="#场景适配" class="headerlink" title="场景适配"></a>场景适配</h1><h2 id="2d场景和3d摄像机的适配"><a href="#2d场景和3d摄像机的适配" class="headerlink" title="2d场景和3d摄像机的适配"></a>2d场景和3d摄像机的适配</h2><ol>
<li><p>因为需要引入3d的内容所以 worldcamera,使用了透视摄像机</p>
</li>
<li><p>透视摄像机旋转了15度使其可以看到地面..因为是透视相机,这就造成了2d角色在相机移动后会发生偏移的问题..这个时候需要将2d角色始终面向相机.所以2d单位的容器也需要旋转15度</p>
</li>
<li><p>为什么不单独使用一个正交摄像机看角色?因为这样的画,地面和角色不是用一个相机,且其中一个使用的是透视,会造成人物移动后,地面和角色形成视差,造成其他角色看起来不像站在地面上一样</p>
</li>
</ol>
<h2 id="场景和ui位置的适配"><a href="#场景和ui位置的适配" class="headerlink" title="场景和ui位置的适配"></a>场景和ui位置的适配</h2><h3 id="3d形象如何展现在ui中"><a href="#3d形象如何展现在ui中" class="headerlink" title="3d形象如何展现在ui中"></a>3d形象如何展现在ui中</h3><p>直接将3d物品拖到ui中然后添加rect transform属性,3d物品会根据ui的位置改变而改变</p>
<p>然后可能会出现看不到3d对象的问题.这个可能和canvas的plane distance有关,即摄像机和canvas的z的距离</p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/image-20200828173613476.png" alt="image-20200828173613476"></p>
<p>用3d视图看下</p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/image-20200828173814986.png" alt="image-20200828173814986"></p>
<p>这个时候是看不到cube的</p>
<p>注意: 想用canvas中的ui去遮挡3d物品是做不到的,sortingGroup也不会有用处..如下图想用绿色盖住cube,是做不到的.因为他们在摄像机的显示是按照z去排的</p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/image-20200828174105986.png" alt="image-20200828174105986"></p>
<h3 id="根据场景位置设置ui位置"><a href="#根据场景位置设置ui位置" class="headerlink" title="根据场景位置设置ui位置.."></a>根据场景位置设置ui位置..</h3><p>比如竖屏游戏.有一半是场景一半是ui,如何让ui去准确的盖住场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Vector3 WorldToCanvasPosition(Camera objectCamera, Vector3 objectTransformPosition, RectTransform CanvasRect)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Get the position on the canvas</span><br><span class="line">    Vector3 ViewportPosition &#x3D; objectCamera.WorldToViewportPoint(objectTransformPosition);</span><br><span class="line">    Vector3 result &#x3D; new Vector3(</span><br><span class="line">    ((ViewportPosition.x * CanvasRect.sizeDelta.x) - (CanvasRect.sizeDelta.x * 0.5f)),</span><br><span class="line">    ((ViewportPosition.y * CanvasRect.sizeDelta.y) - (CanvasRect.sizeDelta.y * 0.5f)), 0);</span><br><span class="line"></span><br><span class="line">    return CanvasRect.TransformPoint(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Vector3 WorldToCanvasPosition(Camera objectCamera, Vector3 objectTransformPosition, RectTransform CanvasRect, Canvas Canvas, Camera UICamera)</span><br><span class="line"> &#123;</span><br><span class="line">     Vector3 screenPoint &#x3D; RectTransformUtility.WorldToScreenPoint(objectCamera, objectTransformPosition);</span><br><span class="line"></span><br><span class="line">     RectTransformUtility.ScreenPointToLocalPointInRectangle(CanvasRect, screenPoint, Canvas.renderMode &#x3D;&#x3D; RenderMode.ScreenSpaceOverlay ? null : UICamera, out Vector2 result);</span><br><span class="line"></span><br><span class="line">     return CanvasRect.TransformPoint(result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;0.3盖住半个单位的地形</span><br><span class="line">var pos &#x3D; CameraUtils.WorldToCanvasPosition(this.mainCamera, new Vector3(boardRoot.position.x, boardRoot.position.y, boardRoot.position.z), rect);</span><br><span class="line">var perUnit &#x3D; rect.sizeDelta.y &#x2F; (2f * this.uiCamera.orthographicSize);</span><br><span class="line">(notification.Body as RectTransform).offsetMax &#x3D; new Vector2(0, -(this.uiCamera.orthographicSize - pos.y) * perUnit);</span><br></pre></td></tr></table></figure>





<h1 id="UGUI的适配"><a href="#UGUI的适配" class="headerlink" title="UGUI的适配"></a>UGUI的适配</h1><p>锚点是解决ui控件在canvas里面位置的问题.而Canvas Scaler主要是设置canvas(ui控件)显示的大小(缩放)问题</p>
<h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p> 锚点这个概念在Unity文档的多分辨率适配中被明确的提到其作用。简单的说，就是定位。如果一个物体相对于屏幕位置左上角，那么无论屏幕分辨率怎么变化，它始终位于左上角。同理，如果是在（0,0）原点，那么也始终在中心原点。我对锚点定义为，锚点，是相对于父节点的偏移量，这个偏移量随屏幕分辨率变化而按比例变化，如果将分辨率的宽，高，看做归一化的数值（即0~1，实际UGUI就是这么做的），那么锚点是指一个偏移百分比。所以有了锚点，子节点在相对于父节点的位置上保持不变的。 </p>
<p>如图，参考分辨率960<em>640，我改变GameView的分辨率为800</em>468，图中绿色背景大小960<em>640，红色Image大小100</em>100，红色图片的锚点为左上，轴点为左上，在参考分辨率下，红色正方形的左上顶点距离Canvas左上顶点距离（50，-150） </p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/php2Hv6xD.1469191739.png" alt="img"></p>
<p><img src="../../assets/images/2019-08-09-unity2d-shipei/phpwptKbd.1469191746.png" alt="img"></p>
<p>​    当我将屏幕分辨率切换为800*468后， </p>
<p>​    因为我选的Screen Match Mode为Weight = 0，所以在800 * 468分辨率下的实际屏幕高度为 960 * （468/800）= 561.6。 </p>
<p>​    又因为我的UI Scale Mode选的是Scale with Screen Size随屏幕尺寸变化，这个时候的缩放比是由宽度决定的，960/800 = 1.2 ,所以红色正方形此时的高度为100 / 1.2= 83.333 </p>
<p>​    红色正方向锚点y轴坐标 = 参考锚点位置 * 缩放比 = 150 * 1.2 = 125，</p>
<h2 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h2><p>看名字就知道..是设置canvas如何根据屏幕进行缩放</p>
<p>UGUI的屏幕自适应，是通过Canvas Scaler来做的，根据屏幕的分辨率，计算出canvas的大小，同时计算ScaleXY,通过Size + Scale来控制Canvas的变换，UI作为canvas的子物体，也会跟随着一起变化；为了保证UI的位置，需要在设计UI的时候，利用锚点来保证UI与边缘或角落的距离，</p>
<h3 id="固定像素-Constant-Pixel-Size"><a href="#固定像素-Constant-Pixel-Size" class="headerlink" title="固定像素 (Constant Pixel Size)"></a>固定像素 (Constant Pixel Size)</h3><p>忽略屏幕的大小根据UI元素的实际像素显示 ,像素大小始终不变，即一个100<em>100的图片在任何的分辨率下都占用100</em>100的像素。一般PC上会使用这种方式，因为PC端分辨率差异并不大。</p>
<h3 id="根据屏幕大小进行缩放-Screen-Match-Mode"><a href="#根据屏幕大小进行缩放-Screen-Match-Mode" class="headerlink" title="根据屏幕大小进行缩放(Screen Match Mode)"></a>根据屏幕大小进行缩放(Screen Match Mode)</h3><p>此项会根据设备真实分辨率与设计分辨率来对Canvas进行缩放。有三种模式：</p>
<ol>
<li>Match Width or Height</li>
</ol>
<p>根据宽或者高来对Canvas进行缩放，比如设备分辨率为1920<em>900，设计分辨率为1280</em>720，此时，如果采用宽进行匹配那么可以通过公式计算出此时应该缩放多少倍，公式如下：</p>
<p>缩放因子：1920/1280 = 1.5</p>
<p>缩放后的Canvas的宽为：1920（刚好能够完全显示）</p>
<p>缩放后的Canvas的高为：720*1.5 = 1080</p>
<p>由于设备的高为900所以会导致高度上的一部分不会被显示出来</p>
<p>2.Expand</p>
<p>适配的计算公式同上，只是在此模式下会保证设计分辨率下的东西能够全部显示出来，及选择设备分辨率和设计分辨率的宽、高比中选择最小值作为缩放因子。</p>
<p>3.Shrink</p>
<p>和Expand恰好相反，在此模式下不会留黑边但是会导致显示不完全。及选择设备分辨率和设计分辨率的宽、高比中选择最大值作为缩放因子。</p>
<p>UiScaleMode一般选择Scale With Screen Size，并设置好设计分辨率。其他两个选项都是固定像素大小。</p>
<p>Screen Match Mode中一般选择Expand，它可以保证ui中的所有元素都在屏幕内部。 相对比的一个选项是Shrink，它可以保证不留空白边。</p>
<p>3、多分辨率的思路是Scaler中选择Expand保证所有ui元素在屏幕内部。少部分界面，如主界面、战斗界面等根据需要设置Anchors中的全屏拉伸。注意，这里的拉伸的含义仅仅是设置Panel的宽、高，并不影响子控件的缩放，但是会影响其布局。</p>
<h3 id="固定物理大小-Constant-Physical-Size"><a href="#固定物理大小-Constant-Physical-Size" class="headerlink" title="固定物理大小(Constant Physical Size)"></a>固定物理大小(Constant Physical Size)</h3><p>忽略屏幕大小和分辨率根据UI的实际物理大小来显示。</p>
<h1 id="刘海屏的适配"><a href="#刘海屏的适配" class="headerlink" title="刘海屏的适配"></a>刘海屏的适配</h1><p>待续</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://blog.csdn.net/shitangdejiaozi/article/details/88964850" target="_blank" rel="noopener">Unity记录-UGUI的屏幕自适应原理和应用_shitangdejiaozi的博客-CSDN博客</a></li>
<li><a href="https://www.jianshu.com/p/8ead0701d8ef" target="_blank" rel="noopener">Android刘海屏适配方案总结 - 简书 (jianshu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>PHP</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>一次精通 RectTransform</title>
    <url>/unity-2019-08-10-ugui-RectTransform/</url>
    <content><![CDATA[<h2 id="在編輯器中快速設定-RectTransform"><a href="#在編輯器中快速設定-RectTransform" class="headerlink" title="在編輯器中快速設定 RectTransform"></a>在編輯器中快速設定 RectTransform</h2><p>快速控制器的基本操作我們就不在這裡贅述，基本上都可以在 Unity 網站裡找到很好的教學文件與影片。</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/4B112FCB-1D5E-41FC-A19D-AA5322C52414.png" alt="img"></p>
<h2 id="RectTransform-的控制精髓：錨點們-Anchor-Points"><a href="#RectTransform-的控制精髓：錨點們-Anchor-Points" class="headerlink" title="RectTransform 的控制精髓：錨點們 Anchor Points"></a>RectTransform 的控制精髓：錨點們 Anchor Points</h2><p>在透過快速設定器修改 RectTransform 的過程中，你會發現右上區域會隨著不同的配置出現不同的屬性設定如下圖：</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/B30BC54C-DA7C-4882-9B3C-FA194FE9ACA5.png" alt="img"></p>
<p>Pos X 與 Left、Pos Y 與 Top、Width 與 Right、Height 與 Bottom 這四對屬性個別不會同時出現，有 Pos X 就沒有 Left，有 Width 就沒有 Right，那麼他們出現的規則是什麼呢？</p>
<p>簡單來說其實就是：</p>
<p>「當兩個錨點的某一維度值相等時，該維度的尺寸則是固定的（跟 Parent 尺寸無關），反之該維度的尺寸則是相對於 Parent 的尺寸而變化。」</p>
<p>其實全部都取決於控制 <em>RectTransform</em> 型態最重要的屬性「最大與最小錨點們（Min / Max Anchors）」，而快速設定器其實也只是在幫你快速的調整這兩個錨點的值，所以只要了解這兩個設定值關係與行為，其實你已經完全掌握了 <em>RectTransform</em> ，而依照上述邏輯，透過兩個錨點所產生出的配置型態總共有四種：</p>
<p>A. 當兩錨點 x, y 維度的值都相等時。<br>B. 當兩錨點 x 維度的值不相等、y 維度值相等時。<br>C. 當兩錨點 x 維度的值相等、y 維度值不相等時。<br>D. 當兩錨點 x, y 維度的值都不相等時。</p>
<h3 id="A-當兩錨點-x-y-維度的值都相等時："><a href="#A-當兩錨點-x-y-維度的值都相等時：" class="headerlink" title="A. 當兩錨點 x, y 維度的值都相等時："></a>A. 當兩錨點 x, y 維度的值都相等時：</h3><p>當兩錨點 x, y 值都相等時，代表此物件的寬高尺寸都是固定值，所以我們會透過 PosX、PosY、Width 以及 Height 來定義此物件的顯示方式，PosX 與 PosY 則分別表示錨點到物件 Pivot 點的位移，而此物件的實際顯示區域則會受到 Pivot 的 x, y 值設定所影響。</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/static-anchors.png" alt="img"><br><img src="../../assets/images/2019-08-10-ugui-RectTransform/ezgif-1-eea893f81f2e.gif" alt="img"></p>
<h3 id="B-當兩錨點-x-維度的值不相等、y-維度值相等時："><a href="#B-當兩錨點-x-維度的值不相等、y-維度值相等時：" class="headerlink" title="B. 當兩錨點 x 維度的值不相等、y 維度值相等時："></a>B. 當兩錨點 x 維度的值不相等、y 維度值相等時：</h3><p>當兩錨點 x 維度的值不相等、y 維度值相等時，代表 x 維度的尺寸會受到 Parent 的尺寸影響，在 x 維度上則是使用間距（Padding）的概念來排版，所以會用到 Left、PosY、Right 以及 Height，實際的 Width 是由 Left 與 Right 來控制。</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/anchor_x1.png" alt="img"><br><img src="../../assets/images/2019-08-10-ugui-RectTransform/anchor_x.gif" alt="img"></p>
<h3 id="C-當兩錨點-x-維度的值相等、y-維度值不相等時："><a href="#C-當兩錨點-x-維度的值相等、y-維度值不相等時：" class="headerlink" title="C. 當兩錨點 x 維度的值相等、y 維度值不相等時："></a>C. 當兩錨點 x 維度的值相等、y 維度值不相等時：</h3><p>當兩錨點 x 維度的值相等、y 維度值不相等時，代表 y 維度的尺寸會受到 Parent 的尺寸影響，在 y 維度上則是使用間距（Padding）的概念來排版，所以會用到 PosX、Top、Width 以及 Bottom，實際的 Height 是由 Top 與 Bottom 來控制。</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/anchor_y1.png" alt="img"><br><img src="../../assets/images/2019-08-10-ugui-RectTransform/anchor_y.gif" alt="img"></p>
<h3 id="D-當兩錨點-x-y-維度的值都不相等時："><a href="#D-當兩錨點-x-y-維度的值都不相等時：" class="headerlink" title="D. 當兩錨點 x, y 維度的值都不相等時："></a>D. 當兩錨點 x, y 維度的值都不相等時：</h3><p>當兩錨點 x, y 維度的值都不相等時，代表物件的寬高尺寸都會受到 Parent 的影響，完全是使用四個方向的間距來定義此物件的顯示區域 Left、Top、Right 以及 Bottom。</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/anchor_xy.png" alt="img"><br><img src="../../assets/images/2019-08-10-ugui-RectTransform/anchor_xy.gif" alt="img"></p>
<h1 id="一些术语解释"><a href="#一些术语解释" class="headerlink" title="一些术语解释"></a>一些术语解释</h1><h3 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h3><p>物體自身的支點，影響物體的旋轉、縮放、位置，改變 UI Pivot 必須先開啟控制面板的 Pivot 按鈕，如下圖</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/Pivot_01.png" alt="Pivot_01">，</p>
<p>Pivot (0.5, 0.5)<br><img src="../../assets/images/2019-08-10-ugui-RectTransform/Pivot_02.gif" alt="Pivot_02"></p>
<p>Pivot (0, 1)<br><img src="../../assets/images/2019-08-10-ugui-RectTransform/Pivot_03.gif" alt="Pivot_03"></p>
<p>它是一个X,Y值范围是0到1的点，这个点的会在<strong>Anchor</strong>（锚点）计算位置的时候会使用到，下面用一张图来解释<strong>Pivot</strong>点的位置</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/84177-b27df7bbe9d3c829.webp" alt="img"></p>
<p>pivot和text的填充</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/image-20200420000104602.png" alt="image-20200420000104602"></p>
<p>当pivot为0.5和0.5时数字的填充时以中心点向上下方向扩展rect</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/image-20200420000313192.png" alt="image-20200420000313192"></p>
<p>一般来讲,动态改变文本,为了使其按照从上到下,可以把pivot设置在左上角  0,1</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/image-20200420000549965.png" alt="image-20200420000549965"></p>
<p>点击上方的pivot可以切换pivot的所在位置</p>
<p>center :rect的中心点</p>
<p>pivot:pivot的点所在位置</p>
<p>这同样适用于layout,下图设置成0,1.在中间位置添加panel,他会向下扩充,加上verticallayoutgroup和contentsizefitter两个组件</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/image-20200420013535477.png" alt="image-20200420013535477"></p>
<p>设置成0.5,0.5.他会向上下扩充</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/image-20200420013708207.png" alt="image-20200420013708207"></p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li><code>position</code>世界坐标是三维的全局坐标,一般作为基准坐标</li>
<li><code>localPosition</code> 相对于父级物体的相对位置</li>
<li><code>anchoredPosition</code> 相对位置，但是相对的是自身的Anchor</li>
<li><code>anchoredPosition3D</code>  相对位置，但是相对的是自身的Anchor</li>
</ul>
<p>关于<code>position</code>和<code>localPosition</code>，它们的值根其所属的Canvas的渲染模式有关。</p>
<ul>
<li><p>在Screen Space——Overlay的模式下，由于Canvas的世界尺寸与其像素尺寸在数值上相等，因此其rectTransform的position与其在屏幕空间的坐标在数值上也相等。这种模式下，要获取某个RectTransform的屏幕坐标，直接使用position就可以。</p>
</li>
<li><p>在Screen Space——Camera的模式和World Space下，RectTransform的渲染与摄像机有关，在获取其屏幕坐标时，需要利用canvas.worldCamera，或者transform.TransformPoint等坐标转换函数进行坐标转换。</p>
</li>
</ul>
<p>关于<code>anchoredPosition</code>和<code>anchoredPositoin3D</code>都可以认为是以像素为单位。</p>
<ul>
<li>当锚点全部重合时，<code>anchoredPosition</code>代表的就是自身Pivot到Anchor的向量。</li>
</ul>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/20171218185814418.png" alt=""></p>
<ul>
<li>当Anchor不重合时,Pivot相对于四个锚点<strong>中点</strong>的坐标</li>
</ul>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/20171218185822581.png" alt=""></p>
<h3 id="offsetMin-和-offsetMax"><a href="#offsetMin-和-offsetMax" class="headerlink" title="offsetMin 和 offsetMax"></a>offsetMin 和 offsetMax</h3><p><code>offsetMax</code>是<strong>RectTransform右上角</strong>相对于<strong>右上Anchor</strong>的距离；<code>offsetMin</code>是<strong>RectTransform左下角</strong>相对于<strong>左下Anchor</strong>的距离。<em>這就是為什麼 offsetMax 的值跟編輯器中 Top、Right 值剛好正負相反的原因。</em></p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/84177-3bd3ac83352a431b.webp" alt="img"></p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/84177-6feb68ae67ceaae8.webp" alt="img"></p>
<h3 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h3><p>如果想要获取一个RectTransform的矩形信息，应该使用rectTransform.rect属性。</p>
<p>rect属性同样是一个计算出来的值，但是它表示的是该rectTransform对应的矩形的相关信息。</p>
<p>rect 的 x 和 y 返回左下角相对于pivot的距离,w 和 h 返回本身的宽高.</p>
<p>注意:<strong>Awake中Rectangle还没有初始化出来,所以不要在awake中获取rect</strong></p>
<h3 id="anchorMin-和-anchorMax"><a href="#anchorMin-和-anchorMax" class="headerlink" title="anchorMin 和 anchorMax"></a>anchorMin 和 anchorMax</h3><p>这个是针对锚点的,锚点时相对于父容器定义的,所以这两个属性也是相对于父容器的.分别指锚点占父容器尺寸的百分比位置.</p>
<h3 id="sizeDelta"><a href="#sizeDelta" class="headerlink" title="sizeDelta"></a>sizeDelta</h3><p>sizeDelta是个由引擎计算出来的值，这个值很容易被错误地使用。要正确地使用sizeDelta，就要先理解它是怎么算出来的。</p>
<blockquote>
<p>The size of this RectTransform relative to the distances between the anchors.<br>If the anchors are together, sizeDelta is the same as size. If the anchors are in each of the four corners of the parent, the sizeDelta is how much bigger or smaller the rectangle is compared to its parent.</p>
</blockquote>
<p><em>sizeDelta</em>是<code>offsetMax-offsetMin</code>的结果。在锚点全部重合的情况下，它的值就是面板上的<em>（Width，Height）</em>。在锚点完全不重合的情况下，它是相对于父矩形的尺寸。</p>
<p>一个常见的错误是，当<em>RectTransform</em>的锚点并非全部重合时，使用<em>sizeDelta</em>作为这个<em>RectTransform</em>的尺寸。此时拿到的结果一般来说并非预期的结果。</p>
<p>所以 <em>RectTransform</em> 宽和高真正的計算方法是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GUI.Label(new Rect(20, 20, 600, 40), &quot;Rect : &quot; + rect.rect);</span><br><span class="line">var width &#x3D;  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;</span><br><span class="line">var height &#x3D; (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;</span><br><span class="line">GUI.Label(new Rect(20, 60, 600, 40), $&quot;width :&#123;width&#125; height:&#123;height&#125; &quot;);</span><br></pre></td></tr></table></figure>

<p>意思就是 sizeDelta 個別維度的值是跟兩錨點個別維度的差值相關，所以只有當兩錨點某的維度的值相等的時候，sizeDelta 在此維度的值才會剛好等於最後顯示的 size 大小。</p>
<h1 id="代码修改坐标及大小"><a href="#代码修改坐标及大小" class="headerlink" title="代码修改坐标及大小"></a>代码修改坐标及大小</h1><p><strong>1.改变RectTransform的top</strong> 注意offsetMax`是<strong>RectTransform右上角</strong>相对于<strong>右上Anchor</strong>的距离,所以top的值应该是一个负值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetComponent&lt;RectTransform&gt;().offsetMax &#x3D; new Vector2(GetComponent&lt;RectTransform&gt;().offsetMax.x, top);</span><br></pre></td></tr></table></figure>

<p><strong>2.改变RectTransform的bottom</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetComponent&lt;RectTransform&gt;().offsetMin &#x3D; new Vector2(GetComponent&lt;RectTransform&gt;().offsetMin.x, bottom);</span><br></pre></td></tr></table></figure>

<p><strong>3.改变RectTransform的width，height</strong> ,会根据上面的计算公式重新计算得出width和height,所以如果锚点不是在同一个点的情况下,你设置的值和实际的值是有很大区别的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetComponent&lt;RectTransform&gt;().sizeDelta &#x3D; new Vector2(width, height);</span><br></pre></td></tr></table></figure>

<p>例如:</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/1566677675284.png" alt="1566677675284"></p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/1566678423941.png" alt="1566678423941"></p>
<p>当使用脚本直接改变大小后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rect.sizeDelta &#x3D; new Vector2(750, 200);</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/1566677736663.png" alt="1566677736663"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var width &#x3D;  (rect.anchorMax.x - rect.anchorMin.x) * parent.rect.width + rect.sizeDelta.x;</span><br><span class="line">var height &#x3D; (rect.anchorMax.y - rect.anchorMin.y) * parent.rect.height + rect.sizeDelta.y;</span><br></pre></td></tr></table></figure>

<p>他的宽和高经过了运算使其分别为1500,1534</p>
<p><strong>4.改变RectTransform的pos</strong> 注意anchoredPosition是相对于锚点的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GetComponent&lt;RectTransform&gt;().anchoredPosition3D &#x3D; new Vector3(posx,posy,posz);</span><br><span class="line">GetComponent&lt;RectTransform&gt;().anchoredPosition &#x3D; new Vector2(posx,posy);</span><br></pre></td></tr></table></figure>

<p><strong>5.使用SetSizeWithCurrentAnchors函数来进行设定，其中Horizontal和Vertical分别对应宽和高。此函数受当前锚点和中心点的影响。</strong>由于会受到<code>povit</code>的影响设置的高度是根据povit进行上下缩小的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rt &#x3D; gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">rt.SetSizeWithCurrentAnchors(RectTransform.Axis.Horizontal, 100);</span><br><span class="line">rt.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 30);</span><br></pre></td></tr></table></figure>
<p>上面同样的示例:</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/1566678433363.png" alt="1566678433363"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rect.SetSizeWithCurrentAnchors(RectTransform.Axis.Vertical, 200);</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/1566678329701.png" alt="1566678329701"></p>
<p>可以看到它围绕着<code>pivot</code>上下都缩减了180</p>
<p><strong>6.使用SetInsetAndSizeFromParentEdge函数来进行设定。此函数不受锚点和中心的影响，其中第一个参数代表对齐方式，第二个参数为距离边界的距离，第三个参数为宽度。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rt &#x3D; gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">rt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Right, 0, 100);</span><br><span class="line">rt.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Bottom, 0, 30);</span><br></pre></td></tr></table></figure>


<h1 id="recttransform的一些其他操做"><a href="#recttransform的一些其他操做" class="headerlink" title="recttransform的一些其他操做"></a>recttransform的一些其他操做</h1><h3 id="Blue-Print-Mode-藍圖模式-、-Raw-Edit-Mode-原始编辑模式"><a href="#Blue-Print-Mode-藍圖模式-、-Raw-Edit-Mode-原始编辑模式" class="headerlink" title="Blue Print Mode(藍圖模式) 、 Raw Edit Mode(原始编辑模式)"></a>Blue Print Mode(藍圖模式) 、 Raw Edit Mode(原始编辑模式)</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="../../assets/images/2019-08-10-ugui-RectTransform/BluePrint_RawEdit_01.png" alt="BluePrint_RawEdit_01"></h2><h4 id="Blue-Print-Mode-藍圖模式"><a href="#Blue-Print-Mode-藍圖模式" class="headerlink" title="Blue Print Mode (藍圖模式)"></a>Blue Print Mode (藍圖模式)</h4><p>忽略了物體的 Local Rotation 和 Local Scale，方便以原來的旋轉與大小調整物體</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/BluePrintMode_m2-1024x711.png" alt="img"></p>
<h4 id="Raw-Edit-Mode-原始编辑模式"><a href="#Raw-Edit-Mode-原始编辑模式" class="headerlink" title="Raw Edit Mode (原始编辑模式)"></a>Raw Edit Mode (原始编辑模式)</h4><p>在 Inspector 中調整 Pivot 和 Anchor 時，物體會維持目前的位置與大小(Inspector 中數值部分)，調整情形如下，請注意數值部分</p>
<p>Inspector 中調整  Pivot</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/RawEditMode_02.gif" alt="RawEditMode_02"></p>
<p>Inspector 中調整  Anchor</p>
<p><img src="../../assets/images/2019-08-10-ugui-RectTransform/RawEditMode_01.gif" alt="RawEditMode_01"></p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul>
<li><a href="http://docs.unity3d.com/Manual/UIBasicLayout.html" target="_blank" rel="noopener">Unity – Manual: Basic Layout</a></li>
<li><a href="http://tsubakit1.hateblo.jp/entry/2014/12/19/033946" target="_blank" rel="noopener">UnityのuGUIのレイアウト調整機能について解説してみる（RectTransform入門）</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>一次精通 eventmanager</title>
    <url>/unity-2019-08-11-ugui-eventmanager/</url>
    <content><![CDATA[<h1 id="OnMouse事件"><a href="#OnMouse事件" class="headerlink" title="OnMouse事件"></a>OnMouse事件</h1><p>我们先来看看eventmanager之前unity处理事件的方法,首当其冲的就是MonoBehavior上的事件回调，可以参看<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/MonoBehaviour.html">MonoBehaviour</a>文档。这是一系列的OnMouse开头的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OnMouseDown</span><br><span class="line">OnMouseDrag</span><br><span class="line">OnMouseEnter</span><br><span class="line">OnMouseExit</span><br><span class="line">OnMouseOver</span><br><span class="line">OnMouseUp</span><br></pre></td></tr></table></figure>

<p>这个处理方式有以下几个特点：</p>
<ul>
<li>MonoBehavior所在的GameObject需要有Collider碰撞组件，并且Physics.queriesHitTriggers设置为True，这个在Edit -&gt; Physics Settings -&gt; Physics or Physics2D中设置。</li>
<li>或者MonoBehavior所在的GameObject存在GUIElement。</li>
<li>OnMouse处理函数可以是协程。</li>
<li>GameObject所有MonoBehavior实现OnMouse的函数都会调用。</li>
<li>Collider或GUIElement的层级顺序，会遮挡事件的传递。</li>
</ul>
<p>按照官方的解释，这是GUI事件的一部分，参看<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/EventFunctions.html">EventFunctions</a>。设计的初衷也是为了GUI服务的。参看<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/ExecutionOrder.html">ExecutionOrder</a>最后的unity执行流程图，会发现OnMouse事件是一个独立的Input Event。</p>
<p><img src="../../assets/images/2019-08-11-ugui-eventmanager/20171106145111819.png" alt="img"></p>
<p>可以看到，OnMouse事件在，Physics事件之后，Update之前，记住这个顺序，后面会用到。并且，这是引擎本身回调的，就引擎使用而言可以看成是，消息驱动。至于引擎的实现，可是轮询也可以是消息驱动。</p>
<h4 id="在Update中輪詢Input物件"><a href="#在Update中輪詢Input物件" class="headerlink" title="在Update中輪詢Input物件"></a>在Update中輪詢Input物件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExampleClass : MonoBehaviour</span><br><span class="line">&#123; </span><br><span class="line">    public void Update() </span><br><span class="line">    &#123; </span><br><span class="line">       if (Input.GetButtonDown(&quot;Fire1&quot;)) </span><br><span class="line">       &#123; </span><br><span class="line">            Debug.Log(Input.mousePosition); </span><br><span class="line">       &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是官方的例子，Input拥有各种输入设备的数据信息。每一帧不断的检测，查看有没有需要处理的输入信息，利用GameObject本身的层级顺序来控制Update的调用顺序，从而控制了Input的处理顺序。</p>
<p>Input的信息由引擎自己设置的，明显Unity需要实现不同平台的事件处理，然后对Input进行设置。另外有一个InputManager面板用来配置Input相关属性的，在Edit -&gt; Physics Settings -&gt; Input中。</p>
<p>由前面的执行流程图可知，OnMouse事件会在Update之前调用，当然我们也可以在OnMouse中使用Input，这样就变成了消息驱动，而不是轮询了。但这样的缺点是，事件必须由touch或pointer碰撞触发，比如键盘或控制器按钮的事件就没有办法捕获了。</p>
<h1 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h1><p>EventSystem组件主要负责处理输入、射线投射以及发送事件。一个场景中只能有一个EventSystem组件，并且需要BaseInputModule类型组件的协助才能工作。EventSystem在一开始的时候会把自己所属对象下的BaseInputModule类型组件加到一个内部列表，并且在每个Update周期通过接口UpdateModules接口调用这些基本输入模块的UpdateModule接口，然后BaseInputModule会在UpdateModule接口中将自己的状态修改成’Updated’，之后BaseInputModule的Process接口才会被调用。</p>
<p>BaseInputModule是一个基类模块，负责发送输入事件（点击、拖拽、选中等）到具体对象。EventSystem下的所有输入模块都必须继承自BaseInputModule组件。StandaloneInputModule和TouchInputModule组件是系统提供的标准输入模块和触摸输入模块，我们可以通过继承BaseInputModule实现自己的输入模块。</p>
<p>BaseRaycaster也是一个基类，前面说的输入模块要检测到鼠标事件必须有射线投射组件才能确定目标对象。系统实现的射线投射类组件有PhysicsRaycaster, Physics2DRaycaster, GraphicRaycaster。这个模块也是可以自己继承BaseRaycaster实现个性化定制。</p>
<p> <strong>总的来说，EventSystem负责管理，BaseInputModule负责输入，BaseRaycaster负责确定目标对象，目标对象负责接收事件并处理，然后一个完整的事件系统就有了。</strong></p>
<h1 id="EventSystem與OnMouse的區別"><a href="#EventSystem與OnMouse的區別" class="headerlink" title="EventSystem與OnMouse的區別"></a>EventSystem與OnMouse的區別</h1><ul>
<li><p>OnMouse 会先于 EventSystem 触发。因为EventSystem的源码显示，其在Update中去轮询检测处理Input的输入。而OnMouse事件先于Update调用。</p>
</li>
<li><p>OnMouse脚本需要在同一个GameObject上挂载Collider才能检测。EventSystem的脚本会根据子节点的Collider来触发(平行节点不行)。</p>
</li>
<li><p>Rigidbody有个特点，会把子节点所有的Collider统一检测和处理。也就是说，OnMouse脚本与RigidBody在一起就可以检测所有的子节点Collider，而不再需要同级的Collider。而EventSystem的脚本则不依赖于Rigidbody，都可以检测子节点的Collider。</p>
</li>
<li><p>OnMouse依赖于Tag为MainCamera相机的Culling Mask来过滤射线。EventSystem则是依赖挂载Physics Raycaster的相机。</p>
</li>
</ul>
<p>另外，当在有Collider的子节点都挂载OnMouse或EventSystem事件的时候，只会触发一次事件。但在同一个GameObject上挂载多个脚本，就会触发多次。</p>
<h1 id="Unity-Raycasters-和事件处理"><a href="#Unity-Raycasters-和事件处理" class="headerlink" title="Unity Raycasters 和事件处理"></a>Unity Raycasters 和事件处理</h1><p>Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。</p>
<p>在 Unity Raycasters 中有三种类型的 Raycasters:</p>
<ul>
<li>Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体</li>
<li>Physics 2D Raycaster - 用于检测 2D 物体</li>
<li>Physics Raycaster - 用于检测 3D 物体</li>
</ul>
<p>接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。</p>
<p>Raycast 在 Event System 流程中所处的位置大致如下图:</p>
<p><img src="../../assets/images/2019-08-11-ugui-eventmanager/unity_event_system_raycaster.png" alt="unity_event_system_raycaster.png"></p>
<h3 id="unity的事件处理"><a href="#unity的事件处理" class="headerlink" title="unity的事件处理"></a>unity的事件处理</h3><p>当 Event System 处理输入事件并找到合适的接收者，将该接收者作为参数执行 ExecuteEvents 类中的 <code>Execute</code> 或 <code>ExecuteHierarchy</code> 方法；如果此时该接收对象 GameObject 绑定了 EventTrigger 组件，由于 EventTrigger 类实现了所有常用的 UI 事件接口(即实现了 <code>IEventSystemHandler</code> 接口)，因此会执行 EventTrigger 类中相应事件接口对应的方法，转而执行 EventTrigger 类的 <code>Execute</code> 方法，最终回调在编辑器中设定的方法。</p>
<p>所以如果当一个点击事件被触发,首先会拿到射线检测返回的gameobject，然后搜索当前的<strong>gameobejct以及其父节点</strong>上面是否有实现了IPointerDownHandler的接口的控件，如果有实现了的就把newPressed赋值为这个控件的gameobject，如果没有，就去搜索实现了IPointerClickHandler这个接口的控件，如果没有在自身上找到的话，会依次地向父节点层层搜索，直到找到为止，然后依然是把newPressed赋值为这个控件的gameobject。接着会按照类似的方式去搜索自身以及父节点上是否有实现了IDragHandler的组件，如果有的话紧接着便会去触发OnPointerDown和OnDrag方法。</p>
<p>当鼠标按下并抬起的时候，首先会触发IPointerUpHandler接口中的函数OnPointerUp()，然后会再次搜索当前gameobject以及其父节点上是否有实现了IPointerClickHandler接口的控件，如果有的的话，会和之前存下来的newPressd进行比较，看两者是否为同一个gameobject。如果两者为同一个gameobject的话就会触发Click事件。</p>
<p>因此我们需要注意，如果一个物体没有父节点的话，那么只实现IPointerClickHandler接口便是可以接收到点击事件的。如果他有父节点，父节点挂载的脚本也是只实现IPointerClickHandler接口的话，点击事件也是可以接收到的。但是如果父节点实现了IPointerDownHandler和IPointerClickHandler接口，子节点只实现IPointerClickHandler接口的话，两者便会都接收不到点击事件，需要子节点也实现IPointerDownHandler这个接口才行。</p>
<p><img src="../../assets/images/2019-08-11-ugui-eventmanager/unity_event_trigger_2.jpeg" alt="unity_event_trigger_2.jpeg"></p>
<p><strong>事件透传</strong></p>
<p>如果事件被接收后,就不会再被父节点的监听处理,如果需要,则得使用message手动触发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line"> </span><br><span class="line">public class Test : MonoBehaviour,IPointerClickHandler ,IPointerDownHandler,IPointerUpHandler</span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;监听按下</span><br><span class="line">    public void OnPointerDown(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.pointerDownHandler);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;监听抬起</span><br><span class="line">    public void OnPointerUp(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.pointerUpHandler);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;监听点击</span><br><span class="line">    public void OnPointerClick(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.submitHandler);</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.pointerClickHandler);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;把事件透下去</span><br><span class="line">    public void  PassEvent&lt;T&gt;(PointerEventData data,ExecuteEvents.EventFunction&lt;T&gt; function)</span><br><span class="line">        where T : IEventSystemHandler</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;RaycastResult&gt; results &#x3D; new List&lt;RaycastResult&gt;();</span><br><span class="line">        EventSystem.current.RaycastAll(data, results); </span><br><span class="line">        GameObject current &#x3D; data.pointerCurrentRaycast.gameObject ;</span><br><span class="line">        for(int i &#x3D;0; i&lt; results.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(current!&#x3D; results[i].gameObject)</span><br><span class="line">            &#123;</span><br><span class="line">                ExecuteEvents.Execute(results[i].gameObject, data,function);</span><br><span class="line">                &#x2F;&#x2F;RaycastAll后ugui会自己排序，如果你只想响应透下去的最近的一个响应，这里ExecuteEvents.Execute后直接break就行。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件忽略</strong></p>
<p>如果需要当前节点及子节点都不响应UI事件</p>
<ul>
<li>勾选Raycast Targe </li>
<li>在当前节点上添加一个组件CanvasGroup，然后取消其Interactable和Blocks Raycasts的勾选</li>
<li>添加脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">public class TouchIgnore : MonoBehaviour, ICanvasRaycastFilter</span><br><span class="line">&#123;</span><br><span class="line">	public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>事件阻止</strong></p>
<p>父子之间阻止向父级传递事件,只要在该对象加上一个EventTrigger起就可以了,代表这个事件已经被处理了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.GameObject.GetOrAddComponent&lt;EventTrigger&gt;()</span><br></pre></td></tr></table></figure>
<p>比如一个案例,点击最顶级的遮罩(白色部分)窗口关闭,但是点击到窗口内部(红色部分)不做处理<br><img src="../../assets/images/2019-08-11-ugui-eventmanager/image-20200727011714966.png" alt="image-20200727011714966"></p>
<p><strong>ugui事件和射线穿透的问题</strong></p>
<p>eventsystem也是向场景发送射线,然后找到<strong>第一个</strong>触碰的有<strong>Raycast Target</strong>的game object.然后在向这个gameobject的父级去找.</p>
<p>所有如果ui即使全屏了,但是没有设置Raycast Target,仍然会穿透ui.射线会检测到下面的立方体,如图:</p>
<p><img src="../../assets/images/2019-08-11-ugui-eventmanager/image-20200727010842873.png" alt="image-20200727010842873"></p>
<p><strong>事件和handler的连接触发方式</strong></p>
<ol>
<li><p>对于某些ui组件，可以直接设置其对自己产生的事件的handler，如button的onpointerclick</p>
</li>
<li><p>对于任何ui组件，都可以使用eventtrigger这个component，这个trigger放置在产生事件的UI组件上，里面包含了一个事件的类型，以及这个类型关联的处理函数，处理函数可以使用两种函数参数，一种是使用int string简单类型，一种是使用BaseEventData类型，因为当event发生时，会跟随者把这个事件包装成一个PointerEventData类型的参数送进来，里面包含ui事件的详细信息，包括鼠标在哪，而对于前一种简单类型，在编辑器上可以填写当事件发生时传什么参数，这就好比qt的signal和slot连接。</p>
</li>
<li><p>强制让某个事件发生在某个handler上（也就是强制某个handler执行）：调用ExecuteEvents.Execute&lt;<strong>ICustomMessageTarget</strong>&gt;(target, null, (x,y)=&gt;x.Message1());</p>
<p>这个调用将执行target身上所有继承 了ICustomMessageTarget接口的mono的Message1函数，个人认为这个和给target发送Message1 的sendmessage没什么区别，可能是我还没有立即好这个接口。</p>
</li>
</ol>
<p><strong>自定义事件处理</strong></p>
<p>建立一個 Script，繼承 Event Interfaces，這裡是IPointerDownHandler(點下事件)，<a href="http://docs.unity3d.com/Manual/SupportedEvents.html" target="_blank" rel="noopener">看更多 Event 請點我</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line"> </span><br><span class="line">public class EventTest : MonoBehaviour, IPointerDownHandler</span><br><span class="line">&#123;</span><br><span class="line">    public void OnPointerDown(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        print(gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="阻止手动发送射线穿透ugui问题"><a href="#阻止手动发送射线穿透ugui问题" class="headerlink" title="阻止手动发送射线穿透ugui问题"></a>阻止手动发送射线穿透ugui问题</h2><p>UGUI 提供了一个检测是否点击在UI上的方法<br>EventSystem.current.IsPointerOverGameObject();<br>在EventSystem的标准输入Standalone Input Model下是正常的，</p>
<p>但是在Touch Input Module输入模式下不正常</p>
<p>参考网络资料，解决办法(直接上<a href="http://blog.csdn.net/andyhebear/article/details/51433748" target="_blank" rel="noopener">源码</a>):</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointerCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//UGUI 提供了一个检测是否点击在UI上的方法</span></span><br><span class="line">    <span class="comment">//EventSystem.current.IsPointerOverGameObject();</span></span><br><span class="line">    <span class="comment">//但是该方法在PC上检测正常，结果拿到Android真机测试上，永远检测不到。</span></span><br><span class="line">    <span class="comment">//方法一， 使用该方法的另一个重载方法，使用时给该方法传递一个整形参数</span></span><br><span class="line">    <span class="comment">// 该参数即使触摸手势的 id</span></span><br><span class="line">    <span class="comment">// int id = Input.GetTouch(0).fingerId;</span></span><br><span class="line">    <span class="comment">//public static bool IsPointerOverGameObject(int fingerID) &#123;</span></span><br><span class="line">    <span class="comment">//    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(fingerID);//移动输入模式下一样不行</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPointerOverGameObject</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//if (Input.touchCount &gt; 0) &#123;</span></span><br><span class="line">                        </span><br><span class="line">        <span class="comment">//    int id = Input.GetTouch(0).fingerId;</span></span><br><span class="line">        <span class="comment">//    return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject(id);//安卓机上不行</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//else &#123;</span></span><br><span class="line">            <span class="comment">//return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();</span></span><br><span class="line">            PointerEventData eventData = <span class="keyword">new</span> PointerEventData(UnityEngine.EventSystems.EventSystem.current);</span><br><span class="line">            eventData.pressPosition = Input.mousePosition;</span><br><span class="line">            eventData.position = Input.mousePosition;</span><br><span class="line"> </span><br><span class="line">            List&lt;RaycastResult&gt; list = <span class="keyword">new</span> List&lt;RaycastResult&gt;();</span><br><span class="line">            UnityEngine.EventSystems.EventSystem.current.RaycastAll(eventData, list);</span><br><span class="line">            <span class="comment">//Debug.Log(list.Count);</span></span><br><span class="line">            <span class="keyword">return</span> list.Count &gt; <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法二 通过UI事件发射射线</span></span><br><span class="line">    <span class="comment">//是 2D UI 的位置，非 3D 位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPointerOverGameObject</span>(<span class="params">Vector2 screenPosition</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化点击事件</span></span><br><span class="line">        PointerEventData eventDataCurrentPosition = <span class="keyword">new</span> PointerEventData(UnityEngine.EventSystems.EventSystem.current);</span><br><span class="line">        <span class="comment">//将点击位置的屏幕坐标赋值给点击事件</span></span><br><span class="line">        eventDataCurrentPosition.position = <span class="keyword">new</span> Vector2(screenPosition.x, screenPosition.y);</span><br><span class="line"> </span><br><span class="line">        List&lt;RaycastResult&gt; results = <span class="keyword">new</span> List&lt;RaycastResult&gt;();</span><br><span class="line">        <span class="comment">//向点击处发射射线</span></span><br><span class="line">        EventSystem.current.RaycastAll(eventDataCurrentPosition, results);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> results.Count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法三 通过画布上的 GraphicRaycaster 组件发射射线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsPointerOverGameObject</span>(<span class="params">Canvas canvas, Vector2 screenPosition</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//实例化点击事件</span></span><br><span class="line">        PointerEventData eventDataCurrentPosition = <span class="keyword">new</span> PointerEventData(EventSystem.current);</span><br><span class="line">        <span class="comment">//将点击位置的屏幕坐标赋值给点击事件</span></span><br><span class="line">        eventDataCurrentPosition.position = screenPosition;</span><br><span class="line">        <span class="comment">//获取画布上的 GraphicRaycaster 组件</span></span><br><span class="line">        GraphicRaycaster uiRaycaster = canvas.gameObject.GetComponent&lt;GraphicRaycaster&gt;();</span><br><span class="line"> </span><br><span class="line">        List&lt;RaycastResult&gt; results = <span class="keyword">new</span> List&lt;RaycastResult&gt;();</span><br><span class="line">        <span class="comment">// GraphicRaycaster 发射射线</span></span><br><span class="line">        uiRaycaster.Raycast(eventDataCurrentPosition, results);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> results.Count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// For Details =&gt; https://blog.csdn.net/andyhebear/article/details/51433748</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>网友解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Cast a ray to test if Input.mousePosition is over any UI object in EventSystem.current. This is a replacement</span><br><span class="line">&#x2F;&#x2F;&#x2F; for IsPointerOverGameObject() which does not work on Android in 4.6.0f3</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private static bool IsPointerOverUIObject()</span><br><span class="line">&#123;</span><br><span class="line">    if (EventSystem.current &#x3D;&#x3D; null)</span><br><span class="line">        return false;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Referencing this code for GraphicRaycaster https:&#x2F;&#x2F;gist.github.com&#x2F;stramit&#x2F;ead7ca1f432f3c0f181f</span><br><span class="line">    &#x2F;&#x2F; the ray cast appears to require only eventData.position.</span><br><span class="line">    PointerEventData eventDataCurrentPosition &#x3D; new PointerEventData(EventSystem.current);</span><br><span class="line">    eventDataCurrentPosition.position &#x3D; new Vector2(Input.mousePosition.x, Input.mousePosition.y);</span><br><span class="line"> </span><br><span class="line">    List&lt;RaycastResult&gt; results &#x3D; new List&lt;RaycastResult&gt;();</span><br><span class="line">    EventSystem.current.RaycastAll(eventDataCurrentPosition, results);</span><br><span class="line"> </span><br><span class="line">    return results.Count &gt; 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Cast a ray to test if screenPosition is over any UI object in canvas. This is a replacement</span><br><span class="line">&#x2F;&#x2F;&#x2F; for IsPointerOverGameObject() which does not work on Android in 4.6.0f3</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private bool IsPointerOverUIObject(Canvas canvas, Vector2 screenPosition)</span><br><span class="line">&#123;</span><br><span class="line">    if (EventSystem.current &#x3D;&#x3D; null)</span><br><span class="line">        return false;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; Referencing this code for GraphicRaycaster https:&#x2F;&#x2F;gist.github.com&#x2F;stramit&#x2F;ead7ca1f432f3c0f181f</span><br><span class="line">    &#x2F;&#x2F; the ray cast appears to require only eventData.position.</span><br><span class="line">    PointerEventData eventDataCurrentPosition &#x3D; new PointerEventData(EventSystem.current);</span><br><span class="line">    eventDataCurrentPosition.position &#x3D; screenPosition;</span><br><span class="line"> </span><br><span class="line">    GraphicRaycaster uiRaycaster &#x3D; canvas.gameObject.GetComponent&lt;GraphicRaycaster&gt;();</span><br><span class="line">    List&lt;RaycastResult&gt; results &#x3D; new List&lt;RaycastResult&gt;();</span><br><span class="line">    uiRaycaster.Raycast(eventDataCurrentPosition, results);</span><br><span class="line">    return results.Count &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































<h1 id="Message-System（改进的消息系统）"><a href="#Message-System（改进的消息系统）" class="headerlink" title="Message System（改进的消息系统）"></a>Message System（改进的消息系统）</h1><h3 id="传统方式进行-Message-通信"><a href="#传统方式进行-Message-通信" class="headerlink" title="传统方式进行 Message 通信"></a>传统方式进行 Message 通信</h3><p>传统消息通信，通常我们会使用 GameObject 类中的 <code>SendMessage</code>、<code>SendMessageUpwards</code> 和 <code>BroadcastMessage</code> 方法</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">SendMessage</th>
<th align="center">SendMessageUpwards</th>
<th align="center">BroadcastMessage</th>
</tr>
</thead>
<tbody><tr>
<td align="center">自身节点</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">兄弟节点</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">父/祖先节点</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">子/孙节点</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
</tbody></table>
<h3 id="Messaging-System"><a href="#Messaging-System" class="headerlink" title="Messaging System"></a>Messaging System</h3><p>在 UGUI 的 Event System 中，所有的事件通信都是用了 Messaging System 来实现，它也解决了传统方式进行 Message 通信中可能会遇到的一些问题。下面就来让我们好好看看这套 Messaging System。</p>
<p>首先，要想让 Component 能够从 Messaging System 接收消息，Component 要实现 <code>IEventSystemHandler</code> 这个接口。<code>IPointerDownHandler</code>等都继承了<code>IEventSystemHandler</code> 接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ICustomMessageTarget : IEventSystemHandler</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; functions that can be called via the messaging system</span><br><span class="line">    void Message1();</span><br><span class="line">    void Message2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现这个接口 , 把这个脚本挂在某个物体上，这里假设为物体AAA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomMessageTarget : MonoBehaviour, ICustomMessageTarget</span><br><span class="line">&#123;</span><br><span class="line">    public void Message1()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log (&quot;Message 1 received&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Message2()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log (&quot;Message 2 received&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任何脚本中使用ExecuteEvents静态类发送Message，来执行接口中定义的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecuteEvents.Execute&lt;ICustomMessageTarget&gt;(target, null, (x,y)&#x3D;&gt;x.Message1());</span><br></pre></td></tr></table></figure>

<p>Excute泛型方法，有3个参数，第一个参数是发送message的gameobject对象，只有当对象上有<code>IEventSystemHandler</code>实现类的时候才可以，这个例子中自然就是AAA物体。</p>
<p>ExecuteEvents静态类还有其他方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventSystems.ExecuteEvents.CanHandleEvent    判断给定的gameobejct是否能处理这个事件</span><br><span class="line">EventSystems.ExecuteEvents.Execute     执行事件</span><br><span class="line">EventSystems.ExecuteEvents.ExecuteHierarchy  是递归寻找适合的gameobject，并执行事件 </span><br><span class="line">EventSystems.ExecuteEvents.GetEventHandler   </span><br><span class="line">EventSystems.ExecuteEvents.ValidateEventData</span><br></pre></td></tr></table></figure>

<h1 id="eventsystem-处理Physics"><a href="#eventsystem-处理Physics" class="headerlink" title="eventsystem 处理Physics"></a>eventsystem 处理Physics</h1><p>首先，我们看一个官方文档的说明 <a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/Raycasters.html">Raycasters</a>。</p>
<blockquote>
<p>If multiple Raycasters are used then they will all have casting happen against them and the results will be sorted based on distance to the elements.</p>
</blockquote>
<p>当多个Raycaster被使用的时候，结果会按照元素之间的距离排序，然后事件就会按照这个顺序被传递。</p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a><strong>第一步</strong></h2><p><img src="../../assets/images/2019-08-11-ugui-eventmanager/v2-733f4cd159b935aeb26518e97b902a7d_hd.jpg" alt="img"></p>
<p>在相机上添加Physics2DRaycaster，我这里只需要对Physics2D检测，如果是3D就用Physics3DRaycaster。Physics Raycaster 依赖一个相机，如果没有会自动添加。我挂载在相机上，射线检测就会依赖这个相机。</p>
<p>这里我用在GameCamera上面，当然也可以放在UICamera上面，Physics Raycaster挂载在哪个相机上面，射线就依赖这个相机的Culling Mask。</p>
<p>另外需要注意的是，Physics Raycaster所在的相机层级，也就是Depth，会影响到事件传递的顺序。比如，UI Camera层级高于Game Camera，就会永远先出发UI上的事件。同样，OnMouse事件会默认依赖Main Camera的层级。</p>
<h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a><strong>第二步</strong></h2><p>给需要碰撞检测的GameObject，添加Collider和EventSystem的事件处理回调接口。注意GameObject的Layer也要与Camera和Raycaster一致，才能正确被检测到。</p>
<p><img src="../../assets/images/2019-08-11-ugui-eventmanager/v2-3c1713c6226906982501aa7c4dd8252d_hd.jpg" alt="img"></p>
<p>事件接口实现脚本(图中的Test)需要Collider，事件才能正确回调，并且GameObject和相机的距离决定了Collider的层级，也就是事件阻挡关系。</p>
<h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a><strong>第三步</strong></h2><p>这样一来，EventSystem的SupportEvents的接口全部被应用到了Physics上面。也就不再需要自己手动去调用射线去检测Physics碰撞了。那么，还隐含着一个事情就是，EventSystem的IsPointerOverGameObject()就无法在判断对UI的点击了。因为现在点击到Physics也会让这个函数返回True。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Raycasters 剖析</title>
    <url>/unity-2019-08-12-ugui-Raycasters/</url>
    <content><![CDATA[<p>Raycasters 用来检测当前事件发送给哪个对象，检测原理就是 Raycast。当给定一个屏幕坐标系中的位置，Raycasters 就会利用射线检测寻找潜在的对象，并返回一个离当前屏幕最近的对象。</p>
<p>在 Unity Raycasters 中有三种类型的 Raycasters:</p>
<ul>
<li>Graphic Raycaster - 存在于 Canvas 下，用于检测 Canvas 中所有的物体</li>
<li>Physics 2D Raycaster - 用于检测 2D 物体</li>
<li>Physics Raycaster - 用于检测 3D 物体</li>
</ul>
<p>接下来，就来分析一下各个类型 Raycaster 的源码来看看其的工作流程。</p>
<p>Raycast 在 Event System 流程中所处的位置大致如下图:</p>
<p><img src="../../assets/images/2019-08-12-ugui-Raycasters/unity_event_system_raycaster.png" alt="unity_event_system_raycaster.png"></p>
<h2 id="BaseRaycaster-类"><a href="#BaseRaycaster-类" class="headerlink" title="BaseRaycaster 类"></a>BaseRaycaster 类</h2><p>Unity Raycasters 中的三个 Raycaster 类都继承自 BaseRaycaster。首先就来看看 BaseRaycaster 类。</p>
<p>BaseRaycaster 类很简单，它包含一个抽象方法 <code>Raycast</code>，定义如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract void Raycast(PointerEventData eventData, List&lt;RaycastResult&gt; resultAppendList);</span><br></pre></td></tr></table></figure>

<p>这个方法供子类覆写以实现对不同类别的物体进行射线检测。BaseRaycaster 类还继承自 UIBehaviour 类，因此它还覆写了 <code>OnEnable</code> 和 <code>OnDisable</code> 方法，在 <code>OnEnable</code> 方法中向 RaycasterManager 类注册了自己，在 <code>OnDisable</code> 方法中从 RaycasterManager 类移除了自己的注册。</p>
<p>另外该类中还包含了 eventCamera、sortOrderPriority、renderOrderPriority 等属性，在射线检测物体时会用到。</p>
<h2 id="Physics-Raycaster"><a href="#Physics-Raycaster" class="headerlink" title="Physics Raycaster"></a>Physics Raycaster</h2><p>Physics Raycaster 用于检测场景中的 3D 物体对象。</p>
<p>PhysicsRaycaster 类继承自 BaseRaycaster，既然是射线检测那么最重要的方法莫过于 <code>Raycast</code>，接下来就一起看看这个方法。</p>
<p>在 <code>Raycast</code> 方法中，首先使用传入的 PointerEventData 参数调用 <code>ComputeRayAndDistance</code> 方法，计算得到从当前射线检测使用的 Camera 的近裁剪面处出发，穿过屏幕事件发生处位置的一条射线；这个方法还会计算一个射线检测使用的最大距离 <code>distanceToClipPlane</code>。</p>
<p><code>ComputeRayAndDistance</code> 内部使用了 Camera 类的 <code>ScreenPointToRay</code> 方法将某点转换成一条射线，根据得到的射线的方向以及 Camera 的 farClipPlane 和 nearClipPlane 求得检测最大距离 <code>distanceToClipPlane</code>。具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ComputeRayAndDistance(PointerEventData eventData, out Ray ray, out float distanceToClipPlane)</span><br><span class="line">&#123;</span><br><span class="line">    ray &#x3D; eventCamera.ScreenPointToRay(eventData.position);</span><br><span class="line">    float projectionDirection &#x3D; ray.direction.z;</span><br><span class="line">    &#x2F;&#x2F; 这里加了个保护，因为 projectionDirection 近似为 0 的时候不能被除，因此 distanceToClipPlane 取 Mathf.Infinity 无限大</span><br><span class="line">    distanceToClipPlane &#x3D; Mathf.Approximately(0.0f, projectionDirection) ? Mathf.Infinity : Mathf.Abs((eventCamera.farClipPlane - eventCamera.nearClipPlane) &#x2F; projectionDirection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是进行射线检测了，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hits &#x3D; ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, finalEventMask);</span><br></pre></td></tr></table></figure>

<p>这里的 <code>ReflectionMethodsCache</code> 类里面缓存了一些通过反射得到的射线检测相关的类方法。在上面的代码中使用了 <code>raycast3DAll</code> 这个代理，最终执行的是 Physics 类的 <code>RaycastAll</code> 方法。传入的三个参数就是射线 ray，最大检测距离 distanceToClipPlane 以及需要检测的层 finalEventMask，返回结果就是检测成功得到的 RaycastHit 数组。第三个参数 finalEventMask 定义如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int finalEventMask</span><br><span class="line">&#123;</span><br><span class="line">    get &#123; return (eventCamera !&#x3D; null) ? eventCamera.cullingMask &amp; m_EventMask : kNoEventMaskSet; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，射线检测的时候可以设置哪些 layer 可以接收检测碰撞。上面定义的 finalEventMask 就是需要检测的 layer，如果当前 raycaster 所在的对象有 Camera 组件，那么 finalEventMask 就是摄像机设置的渲染的所有层(<code>eventCamera.cullingMask &amp; m_EventMask</code>)，否则就是默认所有的层(<code>int kNoEventMaskSet = -1</code>)都可以接收射线碰撞检测。</p>
<p>然后对检测得到的 RaycastHit 数组按照 distance 由小到大排序。最后将这些射线检测结果依次拼装成 RaycastResult 并返回给 Event System，这里的 RaycastResult 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。</p>
<h2 id="Physics2D-Raycaster"><a href="#Physics2D-Raycaster" class="headerlink" title="Physics2D Raycaster"></a>Physics2D Raycaster</h2><p>Physics2DRaycaster 类继承自 PhysicsRaycaster，主要就是 <code>Raycast</code> 方法中的一点点细小的区别。</p>
<p>第一，在进行射线检测的时候，Physics2DRaycaster 中最后调用的是 Physics2D 的 <code>GetRayIntersectionAll</code> 方法。</p>
<p>第二处同 PhysicsRaycaster 的不同之处是在返回构造 RaycastResult 时，填充的部分值不一样，包括以下几个:</p>
<ul>
<li>distance，这个值是摄像机到射线检测碰撞点的距离，而在 PhysicsRaycaster 中是 RaycastHit 的 <code>distance</code> 值(射线起点在近裁剪面发出到碰撞点的距离)。</li>
<li>sortingLayer，这个值是当前对象 SpriteRenderer 组件中的 <code>sortingLayerID</code> 值，在 PhysicsRaycaster 为 0。</li>
<li>sortingOrder，这个同样为当前对象 SpriteRenderer 组件中的 <code>sortingOrder</code> 值，在 PhysicsRaycaster 为 0。</li>
</ul>
<h2 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h2><p>Graphic Raycaster 用于射线检测 Canvas 中的 Graphic 对象物体，通常绑定在 Canvas 所在的对象身上。</p>
<h3 id="属性或方法"><a href="#属性或方法" class="headerlink" title="属性或方法"></a>属性或方法</h3><p>GraphicRaycaster 类的成员属性很少，除了继承 BaseRaycaster 类的一些属性和方法外，它还拥有以下一些常用的属性或方法:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Ignore Reversed Graphics</code></td>
<td>射线检测时是否忽略背向的 Graphics</td>
</tr>
<tr>
<td><code>Blocked Objects</code></td>
<td>哪些类型的对象会阻挡 Graphic raycasts</td>
</tr>
<tr>
<td><code>Blocking Mask</code></td>
<td>哪些 Layer 会阻挡 Graphic raycasts(对 <code>Blocked Objects</code> 指定的对象生效)</td>
</tr>
</tbody></table>
<p>不同于 PhysicsRaycaster 和 Physics2DRaycaster 类中直接使用父类的 <code>sortOrderPriority</code> 方法和 <code>renderOrderPriority</code>，GraphicRaycaster 覆写了这两个方法，并且当 Canvas 的 render mode 设置为 <code>RenderMode.ScreenSpaceOverlay</code> 时，上面两个方法分别返回 canvas 的 sortingOrder 以及 rootCanvas 的 renderOrder。</p>
<p>对于 eventCamera 的 get 方法，如果 Canvas 的 render mode 设置为 <code>RenderMode.ScreenSpaceOverlay</code> 或者 <code>enderMode.ScreenSpaceCamera</code> 并且 Canvas 的 worldCamera 未设置时，返回 null，否则返回 Canvas 的 worldCamera 或者 Main Camera。</p>
<h3 id="GraphicRaycaster-Raycast"><a href="#GraphicRaycaster-Raycast" class="headerlink" title="GraphicRaycaster.Raycast"></a>GraphicRaycaster.Raycast</h3><p>接下来就来到最重要的覆写的 <code>Raycast</code> 方法。</p>
<p>首先调用 <code>GraphicRegistry.GetGraphicsForCanvas</code> 方法获取当前 Canvas 下所有的 Graphic(canvasGraphics，这些 Graphics 在进行射线检测的时候会用到)。</p>
<p>紧接着就是 MultiDisplay 的一些检测，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int displayIndex;</span><br><span class="line">var currentEventCamera &#x3D; eventCamera;</span><br><span class="line">if (canvas.renderMode &#x3D;&#x3D; RenderMode.ScreenSpaceOverlay || currentEventCamera &#x3D;&#x3D; null)</span><br><span class="line">    displayIndex &#x3D; canvas.targetDisplay;</span><br><span class="line">else</span><br><span class="line">    displayIndex &#x3D; currentEventCamera.targetDisplay;</span><br><span class="line">var eventPosition &#x3D; Display.RelativeMouseAt(eventData.position);</span><br><span class="line">if (eventPosition !&#x3D; Vector3.zero)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 当前平台支持 MultiDisplay</span><br><span class="line">    int eventDisplayIndex &#x3D; (int)eventPosition.z;</span><br><span class="line">    if (eventDisplayIndex !&#x3D; displayIndex)</span><br><span class="line">        return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 当前平台不支持 MultiDiplay</span><br><span class="line">    eventPosition &#x3D; eventData.position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，当平台支持 MultiDisplay 时，如果用户操作的不是当前的 Display，那么所有的其他 Display 上产生的事件都会被舍弃。</p>
<p>然后将屏幕坐标转换到 Camera 视窗坐标下。如果 eventCamera 不为空，则使用 <code>Camera.ScreenToViewportPoint</code> 方法转换坐标，否则直接使用当前 Display 的宽高除以 eventPosition 转换为视窗坐标([0,1]之间)。转换后的坐标若超出 Cmera 的范围(0 - 1)，则舍弃该事件。</p>
<h4 id="Blocked-Objects-和-Blocked-Mask-出场"><a href="#Blocked-Objects-和-Blocked-Mask-出场" class="headerlink" title="Blocked Objects 和 Blocked Mask 出场"></a>Blocked Objects 和 Blocked Mask 出场</h4><p>前面讲到 GraphicRaycaster 可以设置 Blocked Objects 和 Blocked Mask 来指定射线检测阻挡，下面一步就到了使用这两个属性来阻断射线检测部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (canvas.renderMode !&#x3D; RenderMode.ScreenSpaceOverlay &amp;&amp; blockingObjects !&#x3D; BlockingObjects.None)</span><br><span class="line">&#123;</span><br><span class="line">    float distanceToClipPlane</span><br><span class="line">    &#x2F;&#x2F; 计算 distanceToClipPlane...</span><br><span class="line">    if (blockingObjects &#x3D;&#x3D; BlockingObjects.ThreeD || blockingObjects &#x3D;&#x3D; BlockingObjects.All)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ReflectionMethodsCache.Singleton.raycast3D !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            var hits &#x3D; ReflectionMethodsCache.Singleton.raycast3DAll(ray, distanceToClipPlane, (int)m_BlockingMask);</span><br><span class="line">            if (hits.Length &gt; 0)</span><br><span class="line">                hitDistance &#x3D; hits[0].distance;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果 blockingObjects 包含 BlockingObjects.TwoD，使用 ReflectionMethodsCache.Singleton.getRayIntersectionAll 方法再次计算 hitDistance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 Canvas renderMode 不为 <code>RenderMode.ScreenSpaceOverlay</code> 并且设置了 blockingObjects，此时就会 Blocked Objects 和 Blocked Mask 就会生效。</p>
<ul>
<li>如果 blockingObjects 包含了 <code>BlockingObjects.ThreeD</code> 那么则会使用 <code>ReflectionMethodsCache.Singleton.raycast3DAll</code> 方法计算 hitDistance(PhysicsRaycaster 中也使用的该方法进行射线检测)。</li>
<li>如果 blockingObjects 也包含了 <code>BlockingObjects.TwoD</code>，那么会使用 <code>ReflectionMethodsCache.Singleton.getRayIntersectionAll</code> 方法(Physics2DRaycaster 射线检测使用)再计算 hitDistance。</li>
</ul>
<p>具体的计算过程大致是: 这上面的代码中 raycast3DAll 时指定了射线检测层 <code>m_BlockingMask</code>，这个参数就是自定义设定的 <code>Blocking Mask</code>，属于 block mask 的对象在这里就会就行射线检测，并得到最小的一个 hitDistance；<strong>后面对所有的 Graphics 进行射线检测时，如果检测结果 distance 大于 hitDistance，那么那个结果会被舍弃</strong>。如此一来，<code>Blocking Mask</code> 就起到了阻挡的作用，属于这个 layer 的所有对象的一旦被射线检测成功并得到 hitDistance，PhysicsRaycaster 最后的射线检测结果都只会包含这个 hitDistance 距离以内的对象。</p>
<h4 id="GraphicRaycaster-类重载了-“真”-Raycast-方法"><a href="#GraphicRaycaster-类重载了-“真”-Raycast-方法" class="headerlink" title="GraphicRaycaster 类重载了 “真” Raycast 方法"></a>GraphicRaycaster 类重载了 “真” Raycast 方法</h4><p>终于可以进行真真切切的 Graphic Raycast 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void Raycast(Canvas canvas, Camera eventCamera, Vector2 pointerPosition, IList&lt;Graphic&gt; foundGraphics, List&lt;Graphic&gt; results)</span><br><span class="line">&#123;</span><br><span class="line">    int totalCount &#x3D; foundGraphics.Count;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; totalCount; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Graphic graphic &#x3D; foundGraphics[i];</span><br><span class="line">        &#x2F;&#x2F; depth 为 -1 说明没有被 canvas 处理(未被绘制)</span><br><span class="line">        &#x2F;&#x2F; raycastTarget 为 false 说明当前 graphic 不需要被射线检测</span><br><span class="line">        &#x2F;&#x2F; graphic.canvasRenderer.cull 为 true，忽略当前 graphic 的 CanvasRender 渲染的物体</span><br><span class="line">        if (graphic.depth &#x3D;&#x3D; -1 || !graphic.raycastTarget || graphic.canvasRenderer.cull)</span><br><span class="line">            continue;</span><br><span class="line">        &#x2F;&#x2F; 从指定的 eventCamera 计算 pointerPosition 是否在 graphic 的 Rectangle 区域内 </span><br><span class="line">        if (!RectTransformUtility.RectangleContainsScreenPoint(graphic.rectTransform, pointerPosition, eventCamera))</span><br><span class="line">            continue;</span><br><span class="line">        if (graphic.Raycast(pointerPosition, eventCamera))</span><br><span class="line">        &#123;</span><br><span class="line">            s_SortedGraphics.Add(graphic);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s_SortedGraphics.Sort((g1, g2) &#x3D;&gt; g2.depth.CompareTo(g1.depth));</span><br><span class="line">    &#x2F;&#x2F; return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在循环中对每一个 Graphic 首先进行了初步的筛选，满足条件的 Graphic 才会调用其 <code>Raycast</code> 方法，这里的条件筛选包括 deth、raycastTarget 设置、位置信息是否满足等。</p>
<h4 id="Graphic-Raycast"><a href="#Graphic-Raycast" class="headerlink" title="Graphic.Raycast"></a>Graphic.Raycast</h4><p>对 Canvas 下所有的 graphic 遍历，满足条件则进行射线检测。Graphic 射线检测过程如下:</p>
<p>整个检测过程是在一个循环中实现的，从当前 Graphic 节点开始不断向上<strong>递归</strong>，直至向上再没有节点或者节点绑定的组件中有被射线检测出来结果而返回。</p>
<p>对于节点对象，首先获取其绑定的所有组件，依次<strong>遍历</strong>判断组件:</p>
<ul>
<li>当组件是 <code>Canvas</code> 并且其 overrideSorting 为 <code>true</code> 则指定: 若在当前节点绑定的一系列的组件中都未能成功唤起检测，则当前节点组件<strong>遍历</strong>结束后将跳出节点<strong>递归</strong>并默认返回 <code>true</code>。</li>
<li>如果组件是实现了 <code>ICanvasRaycastFilter</code> 接口，则判断组件是否是 <code>CanvasGroup</code>。若是 <code>CanvasGroup</code> 且设置了 ignoreParentGroups 为 <code>true</code>，那么对于接下来的所有 CanvasGroup 组件将不会调用 <code>IsRaycastLocationValid</code> 方法检测；若 CanvasGroup 都未设置 <code>ignoreParentGroups</code>或者不包含 CanvasGroup 组件，则直接调用组件实现的 <code>IsRaycastLocationValid</code> 方法计算是否射线检测成功。</li>
</ul>
<p>从整个 Graphic.Raycast 检测过程可以看出，检测是自当前 graphic 节点开始，一旦检测到某个节点添加实现了 <code>ICanvasRaycastFilter</code> 接口且 <code>IsRaycastLocationValid</code> 方法返回 <code>false</code> 则此 graphic 检测失败并结束检测；否则还会继续向上递归检测父节点，当所有节点(绑定了 Canvas 组件并设置了 <code>Canvas.overrideSorting</code> 为 <code>true</code>的节点会截止此次检测)都射线检测成功或是不需要使用 <code>IsRaycastLocationValid</code> 方法进行检测，则此次 Graphic.Raycast 成功。</p>
<h4 id="Graphic-Raycast-成功的对象深度排序"><a href="#Graphic-Raycast-成功的对象深度排序" class="headerlink" title="Graphic.Raycast 成功的对象深度排序"></a>Graphic.Raycast 成功的对象深度排序</h4><p>对所有射线检测成功的 graphics 按照深度 depth 从小到大排序。</p>
<h4 id="Reversed-Graphics-过滤"><a href="#Reversed-Graphics-过滤" class="headerlink" title="Reversed Graphics 过滤"></a>Reversed Graphics 过滤</h4><p>最后对检测结果再过滤。如果设置了 <code>Ignore Reversed Graphics</code> 为 true，则将背向 Camera 的对象过滤掉，这里面又分为两种情况:</p>
<ul>
<li><p>Camera 为空，直接判断当前 Graphic 方向与正方向 <code>Vector3.forward</code> 是否相交，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var dir &#x3D; go.transform.rotation * Vector3.forward;</span><br><span class="line">appendGraphic &#x3D; Vector3.Dot(Vector3.forward, dir) &gt; 0;</span><br></pre></td></tr></table></figure>

<p>首先将 <code>Vector3.forward</code> 绕着当前 Graphic 的 rotation 旋转得到 Graphic 的正方向，然后通过点积判断 Graphic 正方向是否与默认正方向(没有 Camera 所以默认正方向为 <code>Vector3.forward</code>)相交。点积大于 0 则相交，说明当前 Graphic 可以加入射线加测结果中。</p>
</li>
<li><p>当 Camera 不为空，就使用 Camera 的正方向与 Graphic 的正方向比较是否相交。</p>
</li>
</ul>
<h4 id="distance-检测是最终一道坎"><a href="#distance-检测是最终一道坎" class="headerlink" title="distance 检测是最终一道坎"></a>distance 检测是最终一道坎</h4><p><code>Ignore Reversed Graphics</code> 检测完，对结果进行 distance 计算:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float distance &#x3D; 0;</span><br><span class="line">if (currentEventCamera &#x3D;&#x3D; null || canvas.renderMode &#x3D;&#x3D; RenderMode.ScreenSpaceOverlay)</span><br><span class="line">    distance &#x3D; 0;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    Transform trans &#x3D; go.transform;</span><br><span class="line">    Vector3 transForward &#x3D; trans.forward;</span><br><span class="line">    distance &#x3D; (Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) &#x2F; Vector3.Dot(transForward, ray.direction));</span><br><span class="line">    if (distance &lt; 0)</span><br><span class="line">        continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Render Mode 为 <code>RenderMode.ScreenSpaceOverlay</code> 或者 Camera 为 null，distance 为 0；否则就计算 Graphic 和 Camera 之间的向量在 Graphic 正方向上的投影以及计算射线方向在 Graphic 正方向上的投影，两者相除就得到最终的 distance。</p>
<p>如果 distance 小于 hitDistance(设置的 Blocked Objects 和 Blocked Mask 产生)，则结果通过最终的测试可被用作事件的接收者之一。</p>
<h3 id="射线检测前后的一些操作"><a href="#射线检测前后的一些操作" class="headerlink" title="射线检测前后的一些操作"></a>射线检测前后的一些操作</h3><p>首先来看看这些 Raycaster 被唤起的部分，也就是最开始的流程图中的第三步。Input Module 中使用 Raycaster 处理射线检测，真正的 Raycaster 实施代码又回到了 EventSystem 类中的 <code>RaycastAll</code> 方法，具体代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void RaycastAll(PointerEventData eventData, List&lt;RaycastResult&gt; raycastResults)</span><br><span class="line">&#123;</span><br><span class="line">    raycastResults.Clear();</span><br><span class="line">    var modules &#x3D; RaycasterManager.GetRaycasters();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; modules.Count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        var module &#x3D; modules[i];</span><br><span class="line">        if (module &#x3D;&#x3D; null || !module.IsActive())</span><br><span class="line">            continue;</span><br><span class="line">        module.Raycast(eventData, raycastResults);</span><br><span class="line">    &#125;</span><br><span class="line">    raycastResults.Sort(s_RaycastComparer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景中可以存在一个或多个 Raycaster。当存在多个时，如果需要发起射线检测，那么每个处于 Active 状态的 Raycaster 都会工作，所有 Raycaster 检测得到的结果都会存放在 <code>raycastResults</code> 中(这些 RaycastResult 都是在各自射线检测器中根据 distance 从小到大排过序的)。方法最后使用自定义 Comparer 对所有的 RaycastResult 排序。<code>s_RaycastComparer</code> 有以下几种比较流程:</p>
<ul>
<li>两个 RaycastResult 检测所在的 Raycaster 不同</li>
</ul>
<p>首先比较两个对象的 Camera 的 depth。在渲染中，Camera depth 越小会越先渲染，越大越往后渲染，因此对于射线检测来说，Camera 的 depth 越大，它对应的物体应该先于 Camera depth 小的物体进行射线检测，检测得到的结果也应排在前面。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (lhsEventCamera.depth &lt; rhsEventCamera.depth)</span><br><span class="line">    return 1;</span><br><span class="line">if (lhsEventCamera.depth &#x3D;&#x3D; rhsEventCamera.depth)</span><br><span class="line">    return 0;</span><br><span class="line">return -1;</span><br></pre></td></tr></table></figure>

<p>当 Camera depth 相等的时候，使用 <code>sortOrderPriority</code> 进行比较。优先级数值越大，越先被射线检测选中，所以这里的 <code>CompareTo</code> 方法使用的是右边的参数去比较左边的参数，最终的结果就是按照从大到小(降序)的顺序排列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return rhs.module.sortOrderPriority.CompareTo(lhs.module.sortOrderPriority);</span><br></pre></td></tr></table></figure>

<p>在 PhysicsRaycaster 和 Physics2DRaycaster 类中没有覆写 <code>sortOrderPriority</code> 方法，因此都返回基类的 <code>int.MinValue</code>；但在 GraphicRaycaster 类中覆写了此方法，当对应的 Canvas 的 renderMode 设置为 <code>RenderMode.ScreenSpaceOverlay</code> 时，此时的 <code>sortOrderPriority</code> 返回 Canvas 的 sortingOrder(Sort Order越大越在上层)，否则同样也是返回基类设置的 <code>int.MinValue</code>，这是因为在 <code>RenderMode.ScreenSpaceOverlay</code> 模式下，所有的 distance 都将是 0。</p>
<p>当 sortOrderPriority 相同，再使用 renderOrderPriority 比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return rhs.module.renderOrderPriority.CompareTo(lhs.module.renderOrderPriority);</span><br></pre></td></tr></table></figure>

<p>renderOrderPriority 和 sortOrderPriority 类似，仅在 GraphicRaycaster 类中被覆写，也只有在 Canvas 的 renderMode 设置为 <code>RenderMode.ScreenSpaceOverlay</code> 时才返回 <code>canvas.rootCanvas.renderOrder</code>，这是因为 Canvas 在其他几种 renderMode 下，渲染的先后顺序都和距离摄像机的距离有关。所以 renderOrderPriority 比较也是按照从大到小的顺序得到最终的结果。</p>
<ul>
<li>同属于一个 Raycaster 检测得到，但是它们的 sortingLayer 不一样</li>
</ul>
<p>对于 PhysicsRaycaster 检测得到的对象，sortingLayer 都为 0。</p>
<p>对于 Physics2DRaycaster 检测得到的对象，如果对象上挂载有 SpriteRenderer 组件，那么 sortingLayer 对应的 sortingLayerID，否则也为 0。</p>
<p>对于 GraphicRaycaster 检测所得，sortingLayer 就是所在 Canvas 的 sortingLayerID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rid &#x3D; SortingLayer.GetLayerValueFromID(rhs.sortingLayer);</span><br><span class="line">var lid &#x3D; SortingLayer.GetLayerValueFromID(lhs.sortingLayer);</span><br><span class="line">return rid.CompareTo(lid);</span><br></pre></td></tr></table></figure>

<p>通过 <code>SortingLayer.GetLayerValueFromID</code> 方法计算 sortingLayer 最终的 sorting layer 值，同样是按照降序排列，因此计算得到的 sorting layer 值越大越先排在前面。</p>
<ul>
<li>sortingLayer 也相同，使用 sortingOrder 比较</li>
</ul>
<p>sortingOrder 和 sortingLayer 类似，PhysicsRaycaster 检测得到的对象 sortingOrder 为 0；Physics2DRaycaster 检测得到的对象是 SpriteRenderer 中的 sortingOrder；GraphicRaycaster 检测所得是所在 Canvas 的 sortingOrder。最终 sortingOrder 越大的对象越排前面。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return rhs.sortingOrder.CompareTo(lhs.sortingOrder);</span><br></pre></td></tr></table></figure>

<ul>
<li>sortingOrder 相同，使用 depth 比较</li>
</ul>
<p>PhysicsRaycaster 和 Physics2DRaycaster 中 depth 都被设置为了 0；GraphicRaycaster 检测所得的对象的 depth 就是继承自 Graphic 类的对象所在的 Graphic 的 depth，即 Canvas 下所有 Graphic 深度遍历的顺序。比较同样也是按照降序进行的，因此越嵌套在靠近 Canvas 的对象越排在前面。</p>
<ul>
<li>depth 相同，使用 distance 比较</li>
</ul>
<p>PhysicsRaycaster 中的 distance 就是 RaycastHit 的 distance(射线起点到射线碰撞点的距离)。</p>
<p>Physics2DRaycaster 类中返回的是 Camera 的位置和射线碰撞点之间的距离。</p>
<p>GraphicRaycaster 类中 distance <a href="http://geomalgorithms.com/a06-_intersect-2.html" target="_blank" rel="noopener">计算</a>如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var go &#x3D; m_RaycastResults[index].gameObject;</span><br><span class="line">Transform trans &#x3D; go.transform;</span><br><span class="line">Vector3 transForward &#x3D; trans.forward;</span><br><span class="line">&#x2F;&#x2F; TODO why user DOT to caculate distance?</span><br><span class="line">distance &#x3D; Vector3.Dot(transForward, trans.position - currentEventCamera.transform.position) &#x2F; Vector3.Dot(transForward, ray.direction);</span><br></pre></td></tr></table></figure>

<p>距离 distance 越小越靠前。</p>
<ul>
<li>最后如果上述情况都不能满足，使用 index 比较。先被射线检测到的对象排在前面。</li>
</ul>
<p>Raycaster 后段部分的流程: 取排过序的 RaycastResult 中第一个结果作为响应事件的输入事件的 pointerCurrentRaycast，根据它来在 Messaging System 中分发事件，大致代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 Raycast 结果中对应的 GameObject</span><br><span class="line">var currentOverGo &#x3D; pointerEvent.pointerCurrentRaycast.gameObject;</span><br><span class="line">&#x2F;&#x2F; 分发事件</span><br><span class="line">ExecuteEvents.ExecuteHierarchy(currentOverGo, pointerEvent, ExecuteEvents.pointerDownHandler);</span><br></pre></td></tr></table></figure>

<p>Raycaster 在 Event System 中的作用和流程基本就是上述的内容。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>代理</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>ugui的eventsystem源码解读</title>
    <url>/unity-2019-08-12-ugui-eventsystem-sourcecode/</url>
    <content><![CDATA[<h2 id="为什么想看看事件系统的实现"><a href="#为什么想看看事件系统的实现" class="headerlink" title="为什么想看看事件系统的实现"></a><strong>为什么想看看事件系统的实现</strong></h2><p>很简单，策划又提奇奇怪怪的需求了！比如这些事件要穿透啦，那些事件要做特殊处理啦！之类的……</p>
<p>依旧先贴出源码地址：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//bitbucket.org/Unity-Technologies/ui">Unity-Technologies / UI - Bitbucketbitbucket.org</a></p>
<h2 id="入手点"><a href="#入手点" class="headerlink" title="入手点"></a><strong>入手点</strong></h2><p>好那么我们从何处入手呢？当然是我们的EventTrigger了！我们都知道，我们可以通过实现以下接口来实现事件捕捉：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-fed09bee3103f18eb1ee5938dbfdc812_hd.jpg" alt="img">大家都爱用的EventTrigger</p>
<p>具体怎么做我想大家已经明白了，也就是实现上线的接口中的函数，例如我要监听点击事件我就实现一下IPointerClickHandler然后挂在物体上就好了。这个技巧在很早的时候我在雨松的文章第一次看到，那时候也是4.6时期UGUI刚出来的时候发现的。由于和当初的NGUI很像所以被大家广泛使用，但是也会发现如果全部实现了接口但是不实现的话可能会影响上层例如ScrollView的监听，下面我们看下去也可以知道到底是为啥。</p>
<h2 id="顺藤摸瓜"><a href="#顺藤摸瓜" class="headerlink" title="顺藤摸瓜"></a><strong>顺藤摸瓜</strong></h2><p>既然我们已经找到了这个宝贝，那我们就可以通过查找引用大法，顺藤摸瓜看看到底是什么地方在调用我们实现的接口。</p>
<p>最后理出来所有事件的入口其实都是放在<strong>EventSystem</strong>当中，而具体处理则是放在了<strong>InputModule</strong>里面。在刚刚Enable的时候会更新输入模块列表，也就是我们可以看到的StandaloneInputModule以及TouchInputModule：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-8df2e07d1b1c5d050ce04c0afd436b16_hd.jpg" alt="img">初始化InputModule</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-054935593d03e1601cdf74d9e29839b0_hd.jpg" alt="img">Unity自己提供的各种InputModule</p>
<p>在EventSystem的Update当中就会分别调用这些InputModule</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-8f1c906ba904af7ef5d374a45992a9e7_hd.jpg" alt="img">EventSystem主循环</p>
<p>首先Tick所有的输入模块，然后选出一个当前在使用的输入模块中的Process进行处理。</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-0e03e0e59611f1fac21575bb3cc56b8f_hd.jpg" alt="img">EventSystem处理函数</p>
<p>最前面是判断是否处于聚焦状态，其实也就只是应用程序的聚焦状态。其中中间是针对Navigation也就是类似于通过键盘上下左右或者手柄进行UI位置切换的操作。最下面两句才是针对所有的Touch以及Mouse的操作的处理。</p>
<h2 id="触摸事件处理"><a href="#触摸事件处理" class="headerlink" title="触摸事件处理"></a><strong>触摸事件处理</strong></h2><p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-88eee10ae51d59b799637945e8117fce_hd.jpg" alt="img">处理输入事件</p>
<p>首先看看，首先获取Pointer数据，然后对该数据进行处理。</p>
<h2 id="首先处理点击事件-ProcessTouchPress"><a href="#首先处理点击事件-ProcessTouchPress" class="headerlink" title="首先处理点击事件 ProcessTouchPress"></a><strong>首先处理点击事件 ProcessTouchPress</strong></h2><p>首先判断是为按下事件还是释放事件</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-9947ebbae68433f48ef3a929a8b2001c_hd.jpg" alt="img">处理点击事件</p>
<h2 id="按下的情形"><a href="#按下的情形" class="headerlink" title="按下的情形"></a>按下的情形</h2><p>首先找到Raycast找到的对象如果为按下事件，如果按下的对象并不是之前Hover的对象，则触发进入事件。然后就处理PointerDown事件，如果找不到该事件的话就触发PointerClick事件。如果多次点击的话还会增加PointerEventData的clickTime，双击间隔是固定为0.3秒钟。同时保存下拖拽初始状态，如果有相对应的处理方法IInitializePotentialDragHandler的话就一起触发。</p>
<h2 id="放开的情形"><a href="#放开的情形" class="headerlink" title="放开的情形"></a>放开的情形</h2><p>首先触发PointUp事件。之后寻找PointClick事件，并且触发。如果不存在的话那就查看是否存在Drag事件并且执行，最后再执行PointerExit事件。</p>
<h2 id="之后处理Move以及Drag事件"><a href="#之后处理Move以及Drag事件" class="headerlink" title="之后处理Move以及Drag事件"></a><strong>之后处理Move以及Drag事件</strong></h2><p>主要还是触发Enter、Exit以及BeginDrag还有Drag等逻辑，比较业务向也就不再写了。</p>
<h2 id="点击事件处理"><a href="#点击事件处理" class="headerlink" title="点击事件处理"></a><strong>点击事件处理</strong></h2><p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e45c89369a8c438b54d3b8169863a8d6_hd.jpg" alt="img"></p>
<p>写得比Touch更加紧凑，左键中建以及右键的处理都是分开的。而且实现方式与Touch也太像了，所以也就不再赘述了。</p>
<h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a><strong>射线检测</strong></h2><p>射线检测绝对是其中非常重要的一个东西，在NGUI中我们都知道事件触发靠射线检测，同样在UGUI中射线检测也是同样的存在。</p>
<p>我们在上面的Touch事件处理的地方会看到这么一段代码：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-c17f0ef64287112427f0a1f74ed2b323_hd.jpg" alt="img"></p>
<p>通过射线raycast来检测我们的射线数据中包含哪些东西。并且取其中的第一个并且进行事件触发。这个数据我们可以具体看RaycastResult这个类：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-942bda4b880dac3f71dfe3c00285c067_hd.jpg" alt="img">射线检测的结果</p>
<p>而具体cast的步骤则在下面这个函数中，其实是依次调用所有的Raycaster中的射线检测。</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-116715b89672f76517469347d2d35ae1_hd.jpg" alt="img"></p>
<p>我们会去Raycaster Manager中寻找所有的Raycaster。所有Raycast在Enable的时候就会自动注册到Raycaster Manager中</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-61ed280285611f5e56d858e174fb8846_hd.jpg" alt="img"></p>
<p>现在就明白Graphic Raycaster是用来做什么的了吧。当然除了Graphic Raycaster以外还有各种各样的Raycaster:</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-6307b8a8e615d5c840203f91244d0e74_hd.jpg" alt="img">Unity内部提供的各类Raycaster</p>
<p>我们这里就只着重看一下Graphic Raycaster</p>
<h2 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a><strong>Graphic Raycaster</strong></h2><p>核心方法就是经过重写的Raycaster，这个函数帮助我们检测画布上被射线触发的地方并且返回结果。</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e1049a6eef487dc07f5163b2f5df3a51_hd.jpg" alt="img"></p>
<p>其实就是普通的射线检测，无非需要针对多屏幕、以及不同的Block模式进行判断，最终调用的是另外一个Raycast。</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-d37195700a8277f762d5da5382e23fd5_hd.jpg" alt="img">找到被射线穿过的Graphic</p>
<p>获得射线所穿过的Graphic，将这些结果逐一加入到Result当中。在放入到Result之前会将这些Graphic根据深度进行排序。当然最终结果的筛选规则会有更多，例如是否在摄像机后面、是否大于最大射线距离等等。最终得到的就是我们最终射线结果。</p>
<h2 id="如何执行事件"><a href="#如何执行事件" class="headerlink" title="如何执行事件"></a><strong>如何执行事件</strong></h2><h2 id="直接调用事件-ExecuteEvents-Execute"><a href="#直接调用事件-ExecuteEvents-Execute" class="headerlink" title="直接调用事件 ExecuteEvents.Execute"></a><strong>直接调用事件 ExecuteEvents.Execute</strong></h2><p>核心方法为ExecuteEvents.Execute，如果需要触发事件就调用该方法吧！我们需要向其中传3个参数：</p>
<ul>
<li>一个是传递的GameObject，也就是挂载事件的对象。</li>
<li>第二个参数则是PointEventData，这个参数最终会传给事件处理函数，通常是UGUI自己对输入进行处理并且输出的。</li>
<li>最后一个参数就是一个传入的delegate，用于接收各种EventData，最后经由一个验证函数来获得具体的EventData。</li>
</ul>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-de00fc2cb10360aede52694d0cb5710c_hd.jpg" alt="img"></p>
<p>接下来我们就看一下具体是如何针对一个GameObject进行事件调用的：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-d6090585e8a6f6c36c638d487b363ec1_hd.jpg" alt="img"></p>
<p>首先调用GetEventList然后获得具体有哪些Handler，然后逐一进行调用。如果handler的数量大于0则返回true。</p>
<p>我们看一下获取EventList的规则：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-2d6a993c83da534a4c0ec78939d144b4_hd.jpg" alt="img"></p>
<p>其实也只是判断了一下是否为IEventSystemHandler这么简单。</p>
<h2 id="向上查找"><a href="#向上查找" class="headerlink" title="向上查找"></a><strong>向上查找</strong></h2><p>在很多地方例如Click事件触发的时候往往不是在该射线检测到的GameObject上，而是会向上查找Handler:</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-e50bb99557b9d0a2b43b77f5a92abda2_hd.jpg" alt="img"></p>
<p>其中核心方法就是<strong>GetEventHandler</strong>，我们看看其中的实现：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-ffd1913afa8218040803d0dd1889f696_hd.jpg" alt="img"></p>
<p>获得UGUI会从射线检测到的GameObject开始，不断向上查找，直到根为止，如果找到则返回，如果找不到可以处理的相应事件则直接返回Null。</p>
<h2 id="事件链"><a href="#事件链" class="headerlink" title="事件链"></a><strong>事件链</strong></h2><p>除了获取EventHandler这种情形之外，还有触发GameObject树结构中所有挂载事件的物体。这个时候就有了我们上面看到的<strong>ExecuteHierarchy</strong>，它的作用就是调用Hierarchy中所有挂载事件的GameObject。</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-0c8983d7cf4d5e22c296ca5af93ac859_hd.jpg" alt="img"></p>
<p>我们看到，该函数首先获取事件链，然后逐个进行触发，比较重要的就是获取事件链的过程：</p>
<p><img src="../../assets/images/2019-08-12-ugui-eventsystem-sourcecode/v2-3c2ddef8ca9458a8235db5cb8278bcb3_hd.jpg" alt="img"></p>
<p>从下往上进行遍历，将所有拥有事件的对象通通都调用一遍就是这个事件链的本质。</p>
<h2 id="事件触发机制总结"><a href="#事件触发机制总结" class="headerlink" title="事件触发机制总结"></a><strong>事件触发机制总结</strong></h2><p>不同的组件触发事件的方法都不一样，比如我们上面 看到的OnPointDown是用事件链，而PointClick则是使用的向上查找。我们要防止类似于PointClick这类事件，因为如果下层已经实现了该回调则上层回调则再也无法被调用到，因为已经被下层拦截，所以也不要一口气把所有的事件全给重载了，要用的时候再加呗。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>总的来说UGUI的事件系统并不复杂，各个部分还是较为清晰的，如果我们的UI编写当中遇到了问题，或者我们要自己魔改一个组件出来都可以通过看源码来进行解决。</p>
<p>了解了其中原理之后就算是事件穿透之类的也完全可以通过源码实现来倒推解决方案，不用到处搜索解决方案了！</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>关于addressable那些事</title>
    <url>/unity-2019-09-01-addressable/</url>
    <content><![CDATA[<p>在本文中将详细的描述Addressable对于内存的管理，如果正确的卸载资源</p>
<h2 id="镜像资源的加载与卸载"><a href="#镜像资源的加载与卸载" class="headerlink" title="镜像资源的加载与卸载"></a>镜像资源的加载与卸载</h2><p>Addressables是否能够正确的清理内存主要的取决于是否正确的进行镜像资源的加载与卸载，而如何做到这点又取决于加载的资源的类型与使用加载的方法。<code>Addressables.Release</code>方法可以接受加载到的对象，也可以接受加载时返回的操作句柄(<code>AsyncOperationHandle</code>).比如，进行场景创建时，加载后返回一个<code>AsyncOperationHandle&lt;SceneInstance&gt;</code>，你可以通过返回的句柄或者<code>handle.Result</code>(在这种情况下返回的Result为<code>SceneInstance</code>对象)进行场景的的释放。</p>
<p>接下来将详细的描述一下不同资源的释放方式及规则。</p>
<h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>此处的资源指的是使用<code>Addressables.LoadAssetAsync</code> 或者 <code>Addressables.LoadAssetsAsync</code>加载的资源。<br>使用上述的两个方法会将资源加载到内存中，但是并不实例化它，每次调用后对应的资源的引用记数都会增加1。如果您使用<code>LoadAssetAsync</code>对同一个“地址”的资源调用了3次，您将会得到三个不同的<code>AsyncOperationHandle</code>的实例，同时这些实例均引用相同的底层操作，对就应的底层操作的引用记数会变成3。如果资源加载成功，加载到的资源将会被存储到<code>AsyncOperationHandle.Result</code>中，您可以使用Unity的方法进行实例化<code>Object.instantite</code>，但是这种操作方式不会造成Adressables的引用记数发生变化。</p>
<p>使用<code>Addressables.Release</code>方法可以进行卸载，调用后引用记数会减1，一旦资源的引用记数为0，那么它会被彻底的卸载掉。</p>
<h2 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h2><p>可以使用<code>Addressables.LoadSceneAsync</code>进行场景的加载，同时可以在参数中指定使用<code>Single</code>或者<code>Additive</code>模式，如果指定使用<code>Single</code>模式，那么当前所在打开的场景都会被关闭。</p>
<p>可以使用<code>Addressables.UnloadSceneAsync</code>进行场景的卸载，或者打开新场景时使用<code>Single</code>模式。</p>
<p>当想要打开一个新场景时可以使用上述Addressables提供的方法或者使用 <code>SceneManager.LoadScene</code>/<code>SceneManager.LoadSceneAsync</code>，一个新场景的打开会关闭当前的场景，那么对应的引用记数也会正确的减少。</p>
<h2 id="GameObject的实例化"><a href="#GameObject的实例化" class="headerlink" title="GameObject的实例化"></a>GameObject的实例化</h2><p>GameObject的实例化相对其它的资源有些特殊，在Unity中使用<code>Resources.Load</code>其实只是将Prefab的数据加载到了内存中，并未真正的实例化，所以需要再次调用<code>Object.instantite</code>才能正确的得到需要的GameObject，在Addressables中也是这样的，不过Addressable提供了一些便利的方法<code>Addressables.InstantiateAsync</code>可以直接得到对应的GameObject。</p>
<p>当使用<code>Addressables.InstantiateAsync</code>加载一个Prefab时，Addressable会自动实例化，同时在加载的过程中Addressable在加载Prefab的同时也会加载其依赖，将所有的引用记数全部增加。对同一“地址”的资源调用<code>InstantiateAsync</code>三次，将会使其依赖的所有资源的引用记数均增加为3.但是与三次调用<code>LoadAssetAsync</code>不同的是每次调用<code>InstantiateAsync</code>将会得到一个指向同一个操作的<code>AsyncOperationHandle</code>,这是因为每一个<code>InstantiateAsync</code>都将得到一个唯一的实例。与其它调用方法的另外一个区别在于<code>InstantiateAsync</code>有一个可选参数<code>trackHandle</code>，如果将其设置为false，在<code>AsyncOperationHandle</code>释放前，您必须自己保管着此对象，在此期间您可以执行一些操作。这种方法可以提高效率但是需要更多格外的代码来实现。</p>
<p>关闭实例所在场景或者使用<code>Addressables.ReleaseInstance</code>可以卸载掉实例化的对象。</p>
<p>如果您在加载时将<code>trackHandle</code>设置为false,那么您只能通过调用<code>Addressables.ReleaseInstance</code>并将返回的句柄做为参数，而不能再使用真实的GameObject做为参数进行释放了。</p>
<p>关于<code>Addressables.ReleaseInstance</code>格外的说明：如果调用<code>Addressables.ReleaseInstance</code>方法来释放一个实例,但是此实例不是由Addressable创建或者说在使用Addressable创建时设置了<code>trackHandle=false</code>，此方法调用后将会返回false，以表示Addressable无法释放此实例</p>
<p>使用<code>Addressables.InstantiateAsync</code>方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，使用此方法就不再合适，可以考虑使用<code>Addressables.LoadAssetAsync</code>进行资源的加载，同时自己保存返回的结果，然后再使用<code>GameObject.Instantiate()</code>进行实例化，同时当所有的GameObject不再使用后，再通过<code>Addessables.Release</code>方法将保存的结果进行释放。使用此种方法虽然可以提高部分性能，但是需要对其增加格外的管理。</p>
<p>使用<code>Addressables.InstantiateAsync</code>方法本身会有一些格外的开销，如果您需要实例化同一个对象很多次，比如说一帧内实例化100个，可以考虑使用Addressable进行资源的加载</p>
<h2 id="Addressable分析工具"><a href="#Addressable分析工具" class="headerlink" title="Addressable分析工具"></a>Addressable分析工具</h2><p>通过<em>Window-&gt;Asset Management-&gt;Addressable Profiler</em>可以打开Addressable的分析工具，在使用此工具前需要将配置中的<em>Send Profiler Events</em>打开（默认情况下配置文件为Assets/AddressableAssetsData/AddressableAssetSettings)</p>
<p><img src="../../assets/images/2019-09-01-addressable/sendprofilerevent.png" alt="Send Profiler Events"></p>
<p>窗口中显示了Addressable操作的引用记数，包括加载的AssetBundle及加载的资源等等。</p>
<ul>
<li>白色的竖线表示选择的当前的帧</li>
<li>蓝色的背景当前加载的资源</li>
<li>绿色的部分表示引用记数</li>
</ul>
<p><img src="../../assets/images/2019-09-01-addressable/profiler.png" alt="Profiler"></p>
<h2 id="内存清理时机"><a href="#内存清理时机" class="headerlink" title="内存清理时机"></a>内存清理时机</h2><p>即使一个资源的不再被引用也不代表此资源被卸载了，因为一个AssetBundle中可能包含有多个资源，比如：一个名称”stuff”的AssetBundle中包含有三个资源”tree”,“tank”,“cow”，当资源”tree”被加载后，能够看到”tree”的引用记录会是1，同时”stuff”的引用记数也是1，接着如果加载了”tank”资源，此时”tree”与”tank”的引用记数均为1，同时”stuff”的记数会是2。接下来卸载资源”tree”，则”tree”的引用记数将会减少为0，在”Addressable Profiler”中对应于”tree”的记录将会被删除，但是此时由于AssetBundle对应的”stuff”并未被卸载，因为还有其它的在使用此AssetBundle。使用AssetBundle时可以从AssetBundle中加载部分内容，但是不能部分卸载AssetBundle，只有AssetBundle中的任何资源都不再被使用时，此AssetBundle才会被卸载</p>
<p>当使用Unity的<code>Resources.UnloadUnusedAssets</code> (查看<a href="https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)时，上述描述中的&quot;tree&quot;将会被卸载掉，但是由于我们无法检测到此操作，所以我们只能反映引用记数的变化，而不是真正内存中内容的变化。" target="_blank" rel="noopener">https://docs.unity3d.com/ScriptReference/Resources.UnloadUnusedAssets.html)时，上述描述中的&quot;tree&quot;将会被卸载掉，但是由于我们无法检测到此操作，所以我们只能反映引用记数的变化，而不是真正内存中内容的变化。</a></p>
<p>需要注意的是：使用<code>Resources.UnloadUnusedAssets</code>是一个很费时的操作，一般情况下不建议频繁使用，只有在场景切换时进行调用</p>
<p>此段文字有些绕口，简单来说就是由于一个AssetBundle中包含有多个资源，其中的多个资源被加载出来后，只有所有的资源均不再使用时才会正确的卸载掉AssetBundle，同时对于加载出来的资源一般情况下，即使不再使用后也不是立即卸载的，依赖于引擎底层的实现。在Unity中通过使用<code>Resources.UnloadUnusedAssets</code>可以将不再使用的资源给卸载掉，但是由于此接口过于耗时，并不推荐频繁使用。可以使用的情况一般有：1 进行场景切换时，2 在某些大资源被销毁时，比如说：某此UI界面占用资源特别多，当此UI界面关闭时可以调用。</p>
<h3 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h3><ul>
<li>不要想着用异步加载ui..那会很卡..会出现莫名其妙的事情</li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>sync</tag>
        <tag>UNITY</tag>
        <tag>addressable</tag>
      </tags>
  </entry>
  <entry>
    <title>关于spriteAtlas打包那些事</title>
    <url>/unity-2019-09-01-spriteAtlas/</url>
    <content><![CDATA[<h3 id="UGUI的合图是在什么时候发生的？"><a href="#UGUI的合图是在什么时候发生的？" class="headerlink" title="UGUI的合图是在什么时候发生的？"></a>UGUI的合图是在什么时候发生的？</h3><p>Unity合大图的时机是根据设置来的。<em>Edit-&gt;ProjectSetting-&gt;Editor</em></p>
<p><img src="../../assets/images/2019-09-01-spriteAtlas/1567211125212.png" alt="1567211125212"></p>
<p>如上图，可以在打包的时候合，也可以编辑器运行的时候就合。Editor中合成的大图是放在缓存目录里：<code>Library/AtlasCache</code>。</p>
<ul>
<li>Enabled For Builds  （Unity将精灵打包到Sprite Atlas中，仅用于已发布的版本。Editor和Play模式引用原始源纹理而不是Sprite Atlas中的纹理。）。</li>
<li>Always Enabled   （默认情况下启用此选项。Unity将选定的纹理打包到Sprite Atlases中，Sprite在运行时引用打包的Textures。但是，Sprites将在Editor模式期间引用原始未压缩的纹理。）。</li>
</ul>
<p>简单的说:</p>
<ul>
<li>如果想测试spritepacker是否生效以及代码相关..这时候选择Always Enabled..可以理解为生产模式</li>
<li>如果平时开发Enabled For Builds,只有打包的时候才构建..可以理解为开发模式</li>
</ul>
<h3 id="Include-in-Build到底干了什么？"><a href="#Include-in-Build到底干了什么？" class="headerlink" title="Include in Build到底干了什么？"></a>Include in Build到底干了什么？</h3><p>勾选了Include in Build后，图集资源会被打进App包体里（不是AssetBundle包）。如果图集是AssetBundle包管理的，最好不要勾选它，会造成资源双份。至于哪些资源会双份，需要实验下看看。</p>
<h3 id="禁用Include-in-Build-使用Late-Binding"><a href="#禁用Include-in-Build-使用Late-Binding" class="headerlink" title="禁用Include in Build,使用Late Binding"></a>禁用Include in Build,使用Late Binding</h3><ol>
<li>只要精灵打包到任何精灵图集内，但精灵图集未绑定为默认图集（例如未选中“Include in build”选项），精灵便会在场景中不可见。</li>
<li>用户可以监听回调 SpriteAtlas.atlasRequested。</li>
<li>此委托方法将提供一个要绑定的图集标签和一个接受 SpriteAtlas 资源的 System.Action。用户应按任意方式（脚本引用、Resources.load、资源包）加载该资源，并将该资源提供给 System.Action。</li>
</ol>
<p>注意:</p>
<ul>
<li>SpriteAtlas.atlasRequested只会请求一次无论成功还是失败,所以要确保你的atlasRequested回调一定能返回正确的值</li>
<li>当使用addressable异步加载spriteatlas的时候,也会触发SpriteAtlas.atlasRequested,这个时候内存中可能会存在两份资源的引用..记得释放其中的一份</li>
</ul>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li><a href="https://connect.unity.com/doc/Manual/SpriteAtlas" target="_blank" rel="noopener">https://connect.unity.com/doc/Manual/SpriteAtlas</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
        <tag>addressable</tag>
      </tags>
  </entry>
  <entry>
    <title>ilruntime的研究</title>
    <url>/unity-2019-09-02-ilruntime/</url>
    <content><![CDATA[<p>C#代码在编写后，是需要执行编译的，才能起效，这样如果在手机端，没有对应的编译环境，那么对应的c#代码就无法实现热更。ILRuntime实现的基础，也是基于AssetBundle的资源热更新方式，将需要热更新的c#代码打包成DLL，在每次完成资源打包后，对应的DLL会被作为资源热更新出去。这样就规避了编译相关的环节，实现了热更。</p>
<h1 id="AppDomain"><a href="#AppDomain" class="headerlink" title="AppDomain"></a>AppDomain</h1><p>我们运行一个.NET应用程序或者一个运行库宿主时，OS会首先建立一个进程，然后会在进程中加载CLR(这个加载一般是通过调用_CorExeMain或者_CorBindToRuntimeEx方法来实现)，在加载CLR时会创建一个默认的AppDomain，它是CLR的运行单元，程序的Main方法就是在这里执行，这个默认的AppDomain是唯一且不能被卸载的，当该进程消灭时，默认AppDomain才会随之消失。</p>
<p>一个进程中可以有多个AppDomain，且它们直接是相互隔离的，我们的Assembly是不能单独执行的，它必须被加载到某个AppDomain中，要想<strong>卸载一个Assembly</strong>就只能卸载其AppDomain。</p>
<blockquote>
<p>无法删除WindowsApplication1: 访问被拒绝<br>请确定磁盘末被写保护<br>而且文件末被使用  </p>
</blockquote>
<p>除非你关掉作业管理服务器，然后再操作，显然这样做是很不合理的。</p>
<p>并且默认AppDomain是不能被卸载的，那么我们该怎么办呢，我想到的方法是动态的加载Assembly，新建一个AppDomain，让Assembly加载到这个新AppDomain中然后执行，当执行完后卸载这个新的AppDomain即可。核心思想就是：<strong>如果程序集被加载到默认应用程序域中，则当进程运行时将无法从内存中卸载该程序集。但是，如果打开另一个应用程序域来加载和执行程序集，则卸载该应用程序域时也会同时卸载程序集。使用此技术最小化长时间运行的进程的工作集</strong>。</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525160300209-2123986426.png" alt="img"></p>
<ol>
<li><p>AppDomain vs 进程<br>AppDomain被创建在进程中，一个进程内可以有多个AppDomain。一个AppDomain只能属于一个进程。</p>
</li>
<li><p>AppDomain vs 线程<br>其实两者本来没什么好对比的。AppDomain是个静态概念，只是限定了对象的边界；线程是个动态概念，它可以运行在不同的AppDomain。一个AppDomain内可以创建多个线程，但是不能限定这些线程只能在本AppDomain内执行代码。CLR中的System.Threading.Thread对象其实是个soft thread，它并不能被操作系统识别；操作系统能识别的是hard thread。一个soft thread只属于一个AppDomain，穿越AppDomain的是hard thread。当hard thread访问到某个AppDomain时,一个AppDomain就会为之产生一个soft thread。<br>hard thread有thread local storage(TLS)，这个存储区被CLR用来存储这个hard thread当前对应AppDomain引用以及softthread引用。当一个hard thread穿越到另外一个AppDomain时，TLS中的这些引用也会改变。<br>当然这个说法很可能是和CLR的实现相关的。</p>
</li>
<li><p>AppDomain vs Assembly<br>Assembly是.Net程序的基本部署单元，它可以为CLR提供用于识别类型的元数据等等。Assembly不能单独执行，它必须被加载到AppDomain中，然后由AppDomain创建程序集中的对象。一个Assembly可以被多个AppDomain加载，一个AppDomain可以加载多个Assembly。每个AppDomain引用到某个类型的时候需要把相应的assembly在各自的AppDomain中初始化。因此，每个AppDomain会单独保持一个类的静态变量。</p>
</li>
<li><p>AppDomain vs 对象<br>任何对象只能属于一个AppDomain。AppDomain用来隔离对象，不同AppDomain之间的对象必须通过Proxy(reference type)或者Clone(value type)通信。引用类型需要继承System.MarshalByRefObject才能被Marshal/UnMarshal(Proxy)。值类型需要设置Serializable属性才能被Marshal/UnMarshal(Clone)。</p>
</li>
<li><p>AppDomain vs Assembly Code<br>AppDomain和程序集的源代码是什么关系呢？每个程序集的代码会分别装载到各个AppDomain中？<br>首先我们要把程序集分3类<br>1.mscorlib，这是每个.net程序都要引用到的程序集。<br>2.GAC，这个是强命名的公用程序集，可以被所有的.net程序引用。<br>3.Assembly not in GAC，这是普通的assembly，可以不是强命名，不放到GAC中。<br>启动CLR，进入entry point时可以设置LoaderOptimization属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[LoaderOptimization(LoaderOptimization.MultiDomain]</span><br><span class="line">static void Main()</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../assets/images/2019-09-02-ilruntime/20160504151602702.png" alt="img"></p>
<p>LoaderOptimization属性可以设置三个不同的枚举值，来设置针对前面说的三种程序集的代码存放以及访问方式。</p>
<ul>
<li><p>SingleDomain，由于只启动一个AppDomain，那么code就被直接装载到了AppDomain中，访问静态变量更快捷。</p>
</li>
<li><p>MultiDomain，所有的Assembly代码是进程级别的，因此所有的AppDomain只访问一份代码。这大大减少了程序占用的内存，但是由于程序集的静态变量仍然在各个AppDomain中，因此代码访问静态变量需要先得到AppDomain的引用再进行转换，速度会受到影响。</p>
</li>
<li><p>MultiDomainHost，只有GAC代码是共享的，非GAC的Assembly依然会加载到被使用的AppDomain中，这样提高了静态变量的访问速度，当然也增加了程序占用的内存。 </p>
<p>不管是哪种方式，mscorlib始终是process级别的，即只有一份mscorlib代码在内存中。</p>
</li>
</ul>
</li>
</ol>
<h1 id="使用dll进行热更"><a href="#使用dll进行热更" class="headerlink" title="使用dll进行热更"></a>使用dll进行热更</h1><p>文章并不是完全的实现热更新,实现的是windows和android平台下，对于dll文件的热更新。对于IOS为什么不能热更新，我们后续会讨论到，先看看安卓和windows下 dll的热更新步骤。</p>
<ul>
<li><p>新建一个ClassLibrary（类库）的工程，在其中实现对应的类和方法；</p>
</li>
<li><p>将该工程导出为DLL；</p>
</li>
<li><p>将DLL改为bytes文件，存入Unity工程中的StreamingAssets文件夹下；</p>
</li>
<li><p>在工程运行的时候，读取StreamingAssets下的Dll文件，用Assembly.Load(byte[] bytes )的方法，将DLL文件读取出来，进而执行相关的操作。这一步的代码为：</p>
</li>
</ul>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525160707418-392942905.png" alt="img"></p>
<p>unity工程在执行的时候，会构建一个默认的appDomain，Assembly.Load，其实就是在这个程序域上加载Dll,所以相关的实质和前面一个部分相差不大，这就是c#热更新在unity中的应用(IOS不包括)。</p>
<h3 id="ios不能基于以上热更的原因"><a href="#ios不能基于以上热更的原因" class="headerlink" title="ios不能基于以上热更的原因"></a>ios不能基于以上热更的原因</h3><p>只要我们设定mono的编译模式为full-aot（比如打IOS安装包的时候），则在运行时试图使用JIT编译时，mono自身的JIT编译器就会禁止<strong><em>生成新的代码</em></strong>(不要混淆Reflection.Emit和反射)这种行为进而报告这个异常。JIT编译的过程根本还没开始，就被自己扼杀了。</p>
<p><strong>JIT——just in time，即时编译。</strong></p>
<blockquote>
<p>一个程序在它运行的时候创建并且运行了全新的代码，而并非那些最初作为这个程序的一部分保存在硬盘上的固有的代码。就叫JIT。</p>
</blockquote>
<p>IOS并非把JIT禁止了。或者换个句式讲，IOS封了内存（或者堆）的可执行权限，相当于变相的封锁了JIT这种编译方式。</p>
<h1 id="ILRuntime"><a href="#ILRuntime" class="headerlink" title="ILRuntime"></a>ILRuntime</h1><blockquote>
<p>ILRuntime借助Mono.Cecil库来读取DLL的PE信息，以及当中类型的所有信息，最终得到方法的IL汇编码，然后通过内置的IL解译执行虚拟机来执行DLL中的代码</p>
</blockquote>
<h3 id="借助Mono-Ceil库来读取DLL的PE信息以及当中类型的所有信息"><a href="#借助Mono-Ceil库来读取DLL的PE信息以及当中类型的所有信息" class="headerlink" title="借助Mono.Ceil库来读取DLL的PE信息以及当中类型的所有信息"></a>借助Mono.Ceil库来读取DLL的PE信息以及当中类型的所有信息</h3><p>这一步是如何实现的，跟随源代码做一个详细的跟踪。</p>
<p>首先，是构建一个全局的appDomain(这儿不是程序域的意思，只是取其名字意思来表示)</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525183908084-111024744.png" alt="img"></p>
<p> 基于WWW的方式加载AssetBundle或者DLL/PDB后，接下来是将其封入到MemoryStream中，将dll和pdb的bytes都存入到内存流中后，执行其内部实现的LoadAssembly方法。</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525183929820-235902445.png" alt="img"></p>
<p>关键的是第一行，从Mono中加载模块：</p>
<p> <img src="../../assets/images/2019-09-02-ilruntime/656520-20180525183948767-1521954007.png" alt="img"></p>
<p>进一步跟踪：</p>
<p>ReadImageFrom的操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184006047-408828631.png" alt="img"></p>
<p> 其中ImageReader最终来自BinaryReader:</p>
<p> <img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184022207-1494733614.png" alt="img"></p>
<p>那么接下来的ReadImage操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184038682-930110102.png" alt="img"></p>
<p>这四个操作，是最核心的操作，分别读取DLL的PE的各个信息，这样我们就进入下一个步骤。</p>
<h3 id="最终得到方法的IL汇编码"><a href="#最终得到方法的IL汇编码" class="headerlink" title="最终得到方法的IL汇编码"></a>最终得到方法的IL汇编码</h3><p>让我们分拆来看看这几个读取函数的实现</p>
<p>1）ReadOptionalHeaders</p>
<p>主要读取PE的相关信息，不做过多解释，可以参看源码阅读理解；</p>
<p>2）ReadSections</p>
<p>读取分块数据</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184056941-656677137.png" alt="img"></p>
<p>封装一个Section，然后去执行读取，然后赋值给section的Data，注意回退了Index</p>
<h3 id="ReadCLIHeader"><a href="#ReadCLIHeader" class="headerlink" title="ReadCLIHeader"></a>ReadCLIHeader</h3><p>这步比较简单</p>
<p> <img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184110212-726126206.png" alt="img"></p>
<p>4) ReadMetadata</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184136211-1306602825.png" alt="img"></p>
<p>核心是两个操作，一个是ReadMetadataStream，就是根据不同的标识符来新建不同的存储结构；一个是ReadTableHeap:</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184150898-1035213362.png" alt="img"></p>
<p>初始化heap中的Table后，进行一次Compute，获取size:</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180525184214923-1218850507.png" alt="img"></p>
<p>然后填充size:</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/v2-07369c744923a79035a3729bbc488943_hd.jpg" alt="img"></p>
<p>基于这四步操作，我们可以将IL的汇编码存储到Image中，然后进一步执行后续的CreateModule操作:</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/v2-0a604dfba776c9c99f2e72627724c340_hd.jpg" alt="img"></p>
<p>具体到，就是：</p>
<p> <img src="../../assets/images/2019-09-02-ilruntime/v2-b252bba4e6d01e512c2305c5c7b355c5_hd.jpg" alt="img"></p>
<p>其中的ReadModule为：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/v2-32399e9573a7779ecbf82743b30fc184_hd.jpg" alt="img"></p>
<p>具体的读取manifest和Module内部数据，可以参看源码。</p>
<h3 id="基于LoadedTypes来实现反射方法的调用"><a href="#基于LoadedTypes来实现反射方法的调用" class="headerlink" title="基于LoadedTypes来实现反射方法的调用"></a>基于LoadedTypes来实现反射方法的调用</h3><p>在ILRuntime中，不能基于System.Type来直接获取热更新DLL中的类，只有基于唯一的appDomain实例，基于LoadedTypes这种来获取热更新中的DLL，基于代码来分析，更为详细：</p>
<p>首先，加载获取该DLL中的指定类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var it &#x3D; appDomain.LoadedTypes[&quot;HotFix_Project.InstanceClass&quot;]</span><br></pre></td></tr></table></figure>

<p>跟踪LoadedTypes：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Dictionary&lt;string, IType&gt; LoadedTypes&#123;get&#123;return mapType.InnerDictionary;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪看mapType.InnerDictionary:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadSafeDictionary&lt;string, IType&gt; mapType &#x3D; new ThreadSafeDictionary&lt;string, IType&gt;();</span><br></pre></td></tr></table></figure>

<p>这个mapType是什么时候装配的？</p>
<p>来自于文章二中的LoadAssembly的后续操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144431337-1618869539.png" alt="img"></p>
<p>那么这个module.GetTypes是如何操作的？</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144453022-436088052.png" alt="img"></p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144501605-1680011964.png" alt="img"></p>
<p>分别基于协程来return type以及其nestedTypes，关键是看Types是怎么获取的：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144515817-1301453461.png" alt="img"></p>
<p>关键是read操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144530095-1073548484.png" alt="img"></p>
<p>继续跟进Read操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144543549-1339229040.png" alt="img"></p>
<p>关键是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mtypes &#x3D; metadata.Types</span><br></pre></td></tr></table></figure>

<p>后续都是对其的封装和填充，对于metadata的填充，来自于InitializeTypeDefinitions这个操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144611448-160157189.png" alt="img"></p>
<p>关键操作是ReadType这个操作：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144626456-2070945940.png" alt="img"></p>
<p>构建一个内部定义的类，然后做数据填充，看看关键的几个属性的设置：BaseType ,设置其父类型，fields<em>range/methods_range</em> 是对属性范围和方法范围的设置：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144639749-1842647497.png" alt="img"></p>
<p>所以基本方法还是ReadListRange:</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144651716-2020934616.png" alt="img"></p>
<p>在这儿，我们最终回到了文章二中对于IL虚拟机中的tableHeap的引用，最后实现了和文章二的首尾呼应。</p>
<p>好了，收起思绪，回到最开始的，获取类，这样获得的一个类，这样得到的一个类，继承自IType，在Unity主工程中，则需要System.Type才能继续使用反射接口，其对于的封装来自昱这个ILType封装的ReflectionType， 其中的ILRuntimeType继承自Type类：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144705308-507336274.png" alt="img"></p>
<p>基于其，可以直接调用System.Type的GetConstructor方法，构建实例，归并几个代码，可以表示为（直接使用的实例源代码）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var it &#x3D; appDomain.LoadedTypes[&quot;HotFix_Project.InstanceClass&quot;];</span><br><span class="line">var type &#x3D; it.ReflectionType;</span><br><span class="line">var ctor &#x3D; type.GetConstructor(new System.Type[0]);</span><br><span class="line">var obj &#x3D; ctor.Invoke(null);</span><br></pre></td></tr></table></figure>

<p>对应可以得到DLL中该类的构造函数的调用：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144743649-1121461434.png" alt="img"></p>
<h3 id="基于appDomain内嵌的Invoke来实现反射"><a href="#基于appDomain内嵌的Invoke来实现反射" class="headerlink" title="基于appDomain内嵌的Invoke来实现反射"></a>基于appDomain内嵌的Invoke来实现反射</h3><p>在ILRuntime中，在appDomain中内嵌了一套Invoke的实现，可以在Unity工程中直接调用来实现对热更新DLL中类的方法的调用：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144758068-1015276210.png" alt="img"></p>
<p>关键操作就是2步： GetType和 GetMethod，获取类型的过程，和前面有点类似，就是对mapType中存储的获取，如果没有，则进行查找和填充，这儿重点说说方法是如何获取的：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144811489-2012923950.png" alt="img"></p>
<p>粗看就是从methods中取出来，做相应的检查，如果通过则返回，那么初始化操作看看：</p>
<p> <img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144823104-1803890663.png" alt="img"></p>
<p>最后还是从definition.Methods中取出，逐个遍历其中的方法做一个分类存储，如果有静态构造函数，且满足对于的参数条件，则执行一次静态构造。</p>
<p>回到开始，在获取到类和方法的相关信息后，就可以执行对于的参数检验，然后执行反射：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144840373-1429288247.png" alt="img"></p>
<p>可见，就是获取到一个IL的解释器，然后执行相应的反射，具体Run怎么执行，就不继续深入贴图了，有兴趣的可以持续跟踪（基本思路就是对stack的操作，塞入各个参数，然后执行一次操作，塞入结果，然后退回）</p>
<p>对于ILRuntime的反射基本就先研究到这儿，如果要应用到自己的项目中，可以继续深入研究一下代码，看看实现的具体细节。这儿附上开源的相关文档：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//ourpalm.github.io/ILRuntime/public/v1/guide/reflection.html">ILRuntime中的反射</a></p>
<h3 id="热更新DLL和Unity主工程的相互调用"><a href="#热更新DLL和Unity主工程的相互调用" class="headerlink" title="热更新DLL和Unity主工程的相互调用"></a>热更新DLL和Unity主工程的相互调用</h3><p>基于前面的反射，我们可以基本理出热更DLL和unity主工程的交互本质: 基于IL虚拟机或者.net本身反射来实现交互，对于热更新DLL，其调用unity主工程，则主要是在热更新工程中添加对于unity工程的Assembly-CSharp的引用：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144900607-89436059.png" alt="img"></p>
<p>基于这个引用，可以调用其中类的各自方法，举两个类来测试：</p>
<p>一个不继承自MonoBehaviour：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144913680-316348813.png" alt="img"></p>
<p>一个继承自MonoBehaviour:</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144932643-1419524295.png" alt="img"></p>
<p>这两个Unity主工程中的类以及其中的方法，在热更新DLL中调用：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528144946464-1425100319.png" alt="img"></p>
<p>可以在Unity主工程中得到输出：</p>
<p><img src="../../assets/images/2019-09-02-ilruntime/656520-20180528145001101-1886163550.png" alt="img"></p>
<p>看一下track可以大概了解整个反射的执行过程。</p>
<p>对于Unity执行热更DLL中的调用，就是第一部分的反射实例。</p>
<h1 id="热修复HOTFIX"><a href="#热修复HOTFIX" class="headerlink" title="热修复HOTFIX"></a>热修复HOTFIX</h1><p>腾讯开源的Unity热更解决方案xLua有一个非常吸引人的特性就是Hotfix，其原理是使用Mono.Cecil库对进行C#层编译出来的dll程序集进行IL代码注入。其作者也在知乎的回答中简单说明了原理：<a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/54344452/answer/139413144" target="_blank" rel="noopener">如何评价腾讯在Unity下的xLua（开源）热更方案？ - 车雄生的回答 - 知乎</a></p>
<blockquote>
<p><strong>Mono.Ceil</strong></p>
<p>一个可加载并浏览现有程序集并进行动态修改并保存的.NET框架。可以静态注入程序集（注入后生成新的程序集）和动态注入程序集（注入后不改变目标程序集，只在运行时改变程序集行为。可以通过其实现AOP等高级功能</p>
</blockquote>
<p>Unity的代码在修改之后会自动编译到Library\ScriptAssemblies下的两个Assembly中，所以我会尝试着将代码注入到其中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test : MonoBehaviour&#123;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">       InjectMod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void InjectMod () &#123;</span><br><span class="line">       Debug.Log(&quot;Heihei asdasd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Test绑定到场景物体上，运行后我们会发现输出<code>Heihei asdasd</code>，就像我们预期的一样。 然后我们尝试着将代码注入到该函数中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static bool hasGen &#x3D; false;</span><br><span class="line">[PostProcessBuild(1000)]</span><br><span class="line">private static void OnPostprocessBuildPlayer(BuildTarget buildTarget, string buildPath)</span><br><span class="line">&#123;</span><br><span class="line">   hasGen &#x3D; false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[PostProcessScene]</span><br><span class="line">public static void TestInjectMothodOnPost()</span><br><span class="line">&#123;</span><br><span class="line">   if (hasGen &#x3D;&#x3D; true) return;</span><br><span class="line">   hasGen &#x3D; true;</span><br><span class="line"></span><br><span class="line">   TestInjectMothod();</span><br><span class="line">&#125;</span><br><span class="line">[InitializeOnLoadMethod]</span><br><span class="line">public static void TestInjectMothod()</span><br><span class="line">&#123;</span><br><span class="line">   var assembly &#x3D; AssemblyDefinition.ReadAssembly(@&quot;D:\Documents\Unity5Projects\UnityDllInjector\Library\ScriptAssemblies\Assembly-CSharp.dll&quot;);</span><br><span class="line">   var types &#x3D; assembly.MainModule.GetTypes();</span><br><span class="line">   foreach(var type in types)</span><br><span class="line">   &#123;</span><br><span class="line">      foreach(var Method in type.Methods)</span><br><span class="line">      &#123;</span><br><span class="line">         if(Method.Name &#x3D;&#x3D; &quot;InjectMod&quot;)</span><br><span class="line">         &#123;</span><br><span class="line">            InjectMethod(Method, assembly);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   var writerParameters &#x3D; new WriterParameters &#123; WriteSymbols &#x3D; true &#125;;</span><br><span class="line">   assembly.Write(@&quot;D:\Documents\Unity5Projects\UnityDllInjector\Library\ScriptAssemblies\Assembly-CSharp.dll&quot;, new WriterParameters());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先看<code>TestInjectMothod</code>,这是我们在编辑器下进行注入的函数，这里我们需要注意的是，每当我们修改代码之后我们注入的结果会被覆盖掉，所以我们在每次修改代码之后都需要进行注入，所以我们这里添加了标签：<code>InitializeOnLoadMethod</code>这个标签的意思是，当初始化的时候都进行执行，所以编译完成之后就会自动执行。</p>
<p>然后我们看前面两个函数，这两个函数是为了在打包时进行注入而存在的，其中hasGen是为了防止重复注入而定义的flag。</p>
<p>然后我们查看一下我们的注入方法<code>InjectMethod</code>,在这个函数中我们可以看到，我们首先将我们所需要的函数导入，然后插入到方法的最前端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static void InjectMethod(MethodDefinition method, AssemblyDefinition assembly)</span><br><span class="line">&#123;</span><br><span class="line">   var firstIns &#x3D; method.Body.Instructions.First();</span><br><span class="line">   var worker &#x3D; method.Body.GetILProcessor();</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;获取Debug.Log方法引用</span><br><span class="line">   var hasPatchRef &#x3D; assembly.MainModule.Import(</span><br><span class="line">   typeof(Debug).GetMethod(&quot;Log&quot;, new Type[] &#123; typeof(string) &#125;));</span><br><span class="line">   &#x2F;&#x2F;插入函数</span><br><span class="line">   var current &#x3D; InsertBefore(worker, firstIns, worker.Create(OpCodes.Ldstr, &quot;Inject&quot;));</span><br><span class="line">   current &#x3D; InsertBefore(worker, firstIns, worker.Create(OpCodes.Call, hasPatchRef));</span><br><span class="line">   &#x2F;&#x2F;计算Offset</span><br><span class="line">   ComputeOffsets(method.Body);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 语句前插入Instruction, 并返回当前语句</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private static Instruction InsertBefore(ILProcessor worker, Instruction target, Instruction instruction)</span><br><span class="line">&#123;</span><br><span class="line">   worker.InsertBefore(target, instruction);</span><br><span class="line">   return instruction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 语句后插入Instruction, 并返回当前语句</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private static Instruction InsertAfter(ILProcessor worker, Instruction target, Instruction instruction)</span><br><span class="line">&#123;</span><br><span class="line">   worker.InsertAfter(target, instruction);</span><br><span class="line">   return instruction;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算注入后的函数偏移值</span><br><span class="line">private static void ComputeOffsets(MethodBody body)</span><br><span class="line">&#123;</span><br><span class="line">   var offset &#x3D; 0;</span><br><span class="line">   foreach (var instruction in body.Instructions)</span><br><span class="line">   &#123;</span><br><span class="line">      instruction.Offset &#x3D; offset;</span><br><span class="line">      offset +&#x3D; instruction.GetSize();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待编译完成，并且运行程序，我们发现在输出原来的语句之前多了一句“Inject”<br>可是我们在查看代码的时候并没有发生任何改变，这是因为我们只修改了dll而并非修改源代码。 </p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li><p>ILRuntime并没有创建一个Appdomain,只是取其名字意思.始终工作在默认的AppDomain</p>
</li>
<li><p>ILRuntime中使用Unity项目的委托,需要创建<strong>DelegateAdapter</strong></p>
</li>
<li><p>ILRuntime中继承Unity项目中的类,需要实现<strong>继承适配器</strong></p>
</li>
<li><p>通常情况下，如果要从热更DLL中调用Unity主工程或者Unity的接口，是需要通过反射接口来调用的，包括市面上不少其他热更方案，也是通过这种方式来对CLR方接口进行调用的。(反射一个类,然后创建对象,然后保存到runtime中,调用方法也是通过反射)</p>
<p>但是这种方式有着明显的弊端，最突出的一点就是通过反射来调用接口调用效率会比直接调用低很多，再加上反射传递函数参数时需要使用<code>object[]</code>数组，这样不可避免的每次调用都会产生不少GC Alloc。众所周知GC Alloc高意味着在Unity中执行会存在较大的性能问题。</p>
<p>ILRuntime通过CLR方法绑定机制，可以<code>选择性</code>的对经常使用的CLR接口进行直接调用，从而尽可能的消除反射调用开销以及额外的<code>GC Alloc</code></p>
<p>CLR绑定借助了ILRuntime的CLR重定向机制来实现，因为实质上也是将对CLR方法的反射调用重定向到我们自己定义的方法里面来。</p>
</li>
</ul>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/use" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/dotnet/framework/app-domains/use</a></li>
<li><a href="https://www.cnblogs.com/murongxiaopifu/p/4278947.html" target="_blank" rel="noopener">https://www.cnblogs.com/murongxiaopifu/p/4278947.html</a></li>
<li><a href="https://www.cnblogs.com/murongxiaopifu/p/4211964.html" target="_blank" rel="noopener">https://www.cnblogs.com/murongxiaopifu/p/4211964.html</a></li>
<li><a href="https://www.cnblogs.com/zblade/p/9100146.html" target="_blank" rel="noopener">https://www.cnblogs.com/zblade/p/9100146.html</a></li>
<li><a href="http://ourpalm.github.io/ILRuntime/public/v1/guide/bind.html" target="_blank" rel="noopener">http://ourpalm.github.io/ILRuntime/public/v1/guide/bind.html</a></li>
<li><a href="https://www.jianshu.com/p/4bef7f66aefd" target="_blank" rel="noopener">https://www.jianshu.com/p/4bef7f66aefd</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>unity的宏以及添加net框架中未引用的dll</title>
    <url>/unity-2019-09-02-unity-reference-dll/</url>
    <content><![CDATA[<h1 id="unity默认的-defind宏变量"><a href="#unity默认的-defind宏变量" class="headerlink" title="unity默认的#defind宏变量"></a>unity默认的#defind宏变量</h1><table>
<thead>
<tr>
<th align="left"><strong>Property:</strong></th>
<th align="left"><strong>Function:</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>UNITY_EDITOR</strong></td>
<td align="left">#define directive for calling Unity Editor scripts from your game code.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_EDITOR_WIN</strong></td>
<td align="left">#define directive for Editor code on Windows.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_EDITOR_OSX</strong></td>
<td align="left">#define directive for Editor code on Mac OS X.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_STANDALONE_OSX</strong></td>
<td align="left">#define directive for compiling/executing code specifically for Mac OS X (including Universal, PPC and Intel architectures).</td>
</tr>
<tr>
<td align="left"><strong>UNITY_STANDALONE_WIN</strong></td>
<td align="left">#define directive for compiling/executing code specifically for Windows standalone applications.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_STANDALONE_LINUX</strong></td>
<td align="left">#define directive for compiling/executing code specifically for Linux standalone applications.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_STANDALONE</strong></td>
<td align="left">#define directive for compiling/executing code for any standalone platform (Mac OS X, Windows or Linux).</td>
</tr>
<tr>
<td align="left"><strong>UNITY_WII</strong></td>
<td align="left">#define directive for compiling/executing code for the Wii console.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_IOS</strong></td>
<td align="left">#define directive for compiling/executing code for the iOS platform.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_IPHONE</strong></td>
<td align="left">Deprecated. Use <strong>UNITY_IOS</strong> instead.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_ANDROID</strong></td>
<td align="left">#define directive for the Android platform.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_PS4</strong></td>
<td align="left">#define directive for running <strong>PlayStation 4</strong>  code.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_XBOXONE</strong></td>
<td align="left">#define directive for executing <strong>Xbox One</strong>  code.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_TIZEN</strong></td>
<td align="left">#define directive for the Tizen platform.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_TVOS</strong></td>
<td align="left">#define directive for the Apple TV platform.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_WSA</strong></td>
<td align="left">#define directive for <strong>Universal Windows Platform</strong> . Additionally, <strong>NETFX_CORE</strong> is defined when compiling C# files against .NET Core and using .NET <strong>scripting backend</strong> .</td>
</tr>
<tr>
<td align="left"><strong>UNITY_WSA_10_0</strong></td>
<td align="left">#define directive for Universal Windows Platform. Additionally <strong>WINDOWS_UWP</strong> is defined when compiling C# files against .NET Core.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_WINRT</strong></td>
<td align="left">Same as <strong>UNITY_WSA</strong>.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_WINRT_10_0</strong></td>
<td align="left">Equivalent to <strong>UNITY_WSA_10_0</strong></td>
</tr>
<tr>
<td align="left"><strong>UNITY_WEBGL</strong></td>
<td align="left">#define directive for <strong>WebGL</strong> .</td>
</tr>
<tr>
<td align="left"><strong>UNITY_FACEBOOK</strong></td>
<td align="left">#define directive for the Facebook platform (WebGL or Windows standalone).</td>
</tr>
<tr>
<td align="left"><strong>UNITY_ADS</strong></td>
<td align="left">#define directive for calling Unity Ads methods from your game code. Version 5.2 and above.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_ANALYTICS</strong></td>
<td align="left">#define directive for calling Unity <strong>Analytics</strong>  methods from your game code. Version 5.2 and above.</td>
</tr>
<tr>
<td align="left"><strong>UNITY_ASSERTIONS</strong></td>
<td align="left">#define directive for assertions control process.</td>
</tr>
</tbody></table>
<h2 id="在-NET-4-x-和-NET-Standard-2-0-配置文件之间进行选择"><a href="#在-NET-4-x-和-NET-Standard-2-0-配置文件之间进行选择" class="headerlink" title="在 .NET 4.x 和 .NET Standard 2.0 配置文件之间进行选择"></a>在 .NET 4.x 和 .NET Standard 2.0 配置文件之间进行选择</h2><p>一旦切换到 .NET 4.x 等效脚本运行时，可使用 PlayerSettings 中的下拉菜单指定“Api Compatibility Level”（“Edit &gt; Project Settings &gt; Player”）。 有两种选项：</p>
<ul>
<li><strong>.NET Standard 2.0</strong>。 此配置文件与 .NET Foundation 发布的 <a href="https://github.com/dotnet/standard/blob/master/docs/versions/netstandard2.0.md" target="_blank" rel="noopener">.NET Standard 2.0 配置文件</a>匹配。 Unity 建议新项目使用 .NET Standard 2.0。 它比 .NET 4.x 小，有利于尺寸受限的平台。 此外，Unity 承诺在 Unity 支持的所有平台上支持此配置文件。</li>
<li><strong>.NET 4.x</strong>。 此配置文件提供对最新 .NET 4 API 的访问权限。 它包括 .NET Framework 类库中提供的所有代码，并且支持 .NET Standard 2.0 配置文件。 如果 .NET Standard 2.0 配置文件中未包含项目所需的部分 API，请使用 .NET 4.x 配置文件。 但此 API 的某些部分并非在所有 Unity 平台上均受支持。</li>
</ul>
<p>可在 Unity 的<a href="https://blogs.unity3d.com/2018/03/28/updated-scripting-runtime-in-unity-2018-1-what-does-the-future-hold/" target="_blank" rel="noopener">博客文章</a>中阅读有关这些选项的更多信息。</p>
<h3 id="使用-NET-4-x-API-兼容级别时添加程序集引用"><a href="#使用-NET-4-x-API-兼容级别时添加程序集引用" class="headerlink" title="使用 .NET 4.x API 兼容级别时添加程序集引用"></a>使用 .NET 4.x API 兼容级别时添加程序集引用</h3><p>在“API 兼容级别”下拉列表中使用 .NET Standard 2.0 设置时，将引用和使用 API 配置文件中的所有程序集。 但是，在使用较大的 .NET 4.x 配置文件时，默认情况下不会引用 Unity 附带的某些程序集。 若要使用这些 API，必须手动添加程序集引用。 可在 Unity 编辑器安装的 MonoBleedingEdge/lib/mono 目录中查看 Unity 附带的程序集：</p>
<p><img src="../../assets/images/2019-09-02-unity-reference-dll/vstu_monobleedingedge.png" alt="MonoBleedingEdge 目录"></p>
<p>例如，如果使用的是 .NET 4.x 配置文件且希望使用 <code>HttpClient</code>，则必须为 System.Net.Http.dll 添加程序集引用。 如果没有它，编译器将报错，指示缺少程序集引用：</p>
<p><img src="../../assets/images/2019-09-02-unity-reference-dll/vstu_missing-reference.png" alt="缺少程序集引用"></p>
<p>每次打开 Unity 项目时 Visual Studio 都会为其重新生成 .csproj 和 .sln 文件。 因此，无法直接在 Visual Studio 中添加程序集引用，因为它们将在重新打开项目时丢失。 相反，必须使用名为 mcs.rsp 的特殊文本文件：</p>
<ol>
<li>在 Unity 项目的根Assets目录中创建名为 mcs.rsp 的新文本文件。</li>
<li>在空文本文件的第一行，输入：<code>-r:System.Net.Http.dll</code>，然后保存文件。 可将“System.Net.Http.dll”替换为可能缺少引用的任何包含的程序集。</li>
<li>重启 Unity 编辑器。</li>
</ol>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://docs.microsoft.com/zh-cn/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/visualstudio/cross-platform/unity-scripting-upgrade?view=vs-2019</a></li>
<li><a href="https://docs.unity3d.com/Manual/PlatformDependentCompilation.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/PlatformDependentCompilation.html</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>xlua注入源码解读</title>
    <url>/unity-2019-09-03-xlua-inject/</url>
    <content><![CDATA[<ul>
<li><strong>让C#代码支持热更的流程</strong></li>
</ul>
<ol>
<li>Generate Code<br>这一步主要根据是根据C#类中需要支持热更的方法生成其对应的委托方法，但是并不是每个方法对应一个委托，而是根据调用参数和返回参数公用委托。</li>
<li>Hotfix Inject<br>这一步主要是对Unity编译出的Dll中的C#类添加判断条件，以此来选择调用Lua中的修复方法还是直接执行C#代码</li>
</ol>
<ul>
<li><strong>Generate Code 实现和生成结果</strong><br>在Gen代码阶段，对热更生效的部分逻辑，基本就是根据之前在代码中标记了HotfixAttribute的类进行收集，然后使用XLua的模板代码生成器，生成对应名为DelegateBridge类。__Gen_Delegate_Imp这个就是到时候要重复使用到的映射到Lua中function的委托。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> __Gen_Delegate_Imp0()</span><br><span class="line">&#123;</span><br><span class="line">    RealStatePtr L = luaEnv.rawL;</span><br><span class="line">    <span class="keyword">int</span> errFunc = LuaAPI.pcall_prepare(L, errorFuncRef, luaReference);</span><br><span class="line">    PCall(L, <span class="number">0</span>, <span class="number">0</span>, errFunc);</span><br><span class="line">    LuaAPI.lua_settop(L, errFunc - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生成的代码就是先设置errorFuncRef（异常回调），luaReference（Lua方法）。如果在XLua中设置了热更修复代码，那么就会在C#中生成一个DelegateBridge，而其luaReference的指向就是Lua中的方法，所以这个只能调用指定的__Gen_Delegate_Imp，调用其他会报错。</p>
<ul>
<li><strong>Hotfix Inject</strong><br>这一步是在Unity为C#代码生成完对应dll之后，由XLua再来对dll注入一些判断条件式来完成是否进行Lua调用的行为。<br>判断方法很简单，检查对应类静态字段是否有DelegateBridge对象。<br>实现如下：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">injectMethod</span>(<span class="params">MethodDefinition method, HotfixFlagInTool hotfixType</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">var</span> type = method.DeclaringType;</span><br><span class="line">            <span class="keyword">bool</span> isFinalize = (method.Name == <span class="string">"Finalize"</span> &amp;&amp; method.IsSpecialName);</span><br><span class="line">            <span class="comment">//__Gen_Delegate_Imp 方法引用</span></span><br><span class="line">            MethodReference invoke = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">int</span> param_count = method.Parameters.Count + (method.IsStatic ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//根据返回值和参数个数类型，查找对应的委托方法</span></span><br><span class="line">            <span class="keyword">if</span> (!findHotfixDelegate(method, <span class="keyword">out</span> invoke, hotfixType))</span><br><span class="line">            &#123;</span><br><span class="line">                Error(<span class="string">"can not find delegate for "</span> + method.DeclaringType + <span class="string">"."</span> + method.Name + <span class="string">"! try re-genertate code."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invoke == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"unknow exception!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            invoke = injectAssembly.MainModule.Import(invoke);</span><br><span class="line">            <span class="comment">//插入的类静态字段，用来标记对应的方法是否有对应的Lua注入</span></span><br><span class="line">            FieldReference fieldReference = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//方法中的变量定义</span></span><br><span class="line">            VariableDefinition injection = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">bool</span> isIntKey = hotfixType.HasFlag(HotfixFlagInTool.IntKey) &amp;&amp; !type.HasGenericParameters &amp;&amp; isTheSameAssembly;</span><br><span class="line">            <span class="comment">//isIntKey = !type.HasGenericParameters;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isIntKey)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//新建变量，加入方法体的变量组中</span></span><br><span class="line">                injection = <span class="keyword">new</span> VariableDefinition(invoke.DeclaringType);</span><br><span class="line">                method.Body.Variables.Add(injection);</span><br><span class="line">                <span class="comment">//获取这个方法对应的委托名，因为有重载方法存在，所以之前已经注入的过的方法会在这边获取时候计数加1，</span></span><br><span class="line">                <span class="comment">//比如第一个重载获取的是__Hotfix0，那么下一个重载会是__Hotfix1，判断是否注入就是是否设置对应FieldReference。</span></span><br><span class="line">                <span class="keyword">var</span> luaDelegateName = getDelegateName(method);</span><br><span class="line">                <span class="keyword">if</span> (luaDelegateName == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Error(<span class="string">"too many overload!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建对应的静态Field名字就是上面取到的luaDelegateName </span></span><br><span class="line">                FieldDefinition fieldDefinition = <span class="keyword">new</span> FieldDefinition(luaDelegateName, Mono.Cecil.FieldAttributes.Static | Mono.Cecil.FieldAttributes.Private,</span><br><span class="line">                    invoke.DeclaringType);</span><br><span class="line">                type.Fields.Add(fieldDefinition);</span><br><span class="line">                fieldReference = fieldDefinition.GetGeneric();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> ignoreValueType = hotfixType.HasFlag(HotfixFlagInTool.ValueTypeBoxing);</span><br><span class="line">            <span class="comment">//IL插入位置，现在定位的是方法体的第一行</span></span><br><span class="line">            <span class="keyword">var</span> insertPoint = method.Body.Instructions[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//获取IL处理器</span></span><br><span class="line">            <span class="keyword">var</span> processor = method.Body.GetILProcessor();</span><br><span class="line">            <span class="comment">//构造函数的处理逻辑先跳过这边不做分析</span></span><br><span class="line">            <span class="keyword">if</span> (method.IsConstructor)</span><br><span class="line">            &#123;</span><br><span class="line">                insertPoint = findNextRet(method.Body.Instructions, insertPoint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Dictionary&lt;Instruction, Instruction&gt; originToNewTarget = <span class="keyword">new</span> Dictionary&lt;Instruction, Instruction&gt;();</span><br><span class="line">            HashSet&lt;Instruction&gt; noCheck = <span class="keyword">new</span> HashSet&lt;Instruction&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (insertPoint != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//isIntKey这边用到的是Xlua中的AutoIdMap，这边只对最基础的功能做分析，这边就分析基础的注入了。</span></span><br><span class="line">                Instruction firstInstruction;</span><br><span class="line">                <span class="keyword">if</span> (isIntKey)</span><br><span class="line">                &#123;</span><br><span class="line">                    firstInstruction = processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count);</span><br><span class="line">                    processor.InsertBefore(insertPoint, firstInstruction);</span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, hotfixFlagGetter));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//创建第一条IL语句，获取类的静态Field压入方法栈中，其实就是之前luaDelegateName获取的字段</span></span><br><span class="line">                    firstInstruction = processor.Create(OpCodes.Ldsfld, fieldReference);</span><br><span class="line">                    <span class="comment">//插入insertPoint之前</span></span><br><span class="line">                    processor.InsertBefore(insertPoint, firstInstruction);</span><br><span class="line">                    <span class="comment">//创建并插入IL，获取栈顶的值并压入到对应的变量中，injection就是我们之前创建的新建变量</span></span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Stloc, injection));</span><br><span class="line">                    <span class="comment">//创建并插入IL，压入变量体中的值到栈</span></span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建跳转语句，为false时候直接跳转insertPoint,</span></span><br><span class="line">                <span class="comment">//这边OpCodes.Brfalse看起来是布尔值判断，其实也会判断是否为null</span></span><br><span class="line">                <span class="keyword">var</span> jmpInstruction = processor.Create(OpCodes.Brfalse, insertPoint);</span><br><span class="line">                processor.InsertBefore(insertPoint, jmpInstruction);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isIntKey)</span><br><span class="line">                &#123;</span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldc_I4, bridgeIndexByKey.Count));</span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, delegateBridgeGetter));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//创建并插入IL,再次压入变量的值，因为上面做完判断后，栈顶的值就会被弹出，所以这边要再次压入</span></span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldloc, injection));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; param_count; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; ldargs.Length)</span><br><span class="line">                    &#123;</span><br><span class="line">                        processor.InsertBefore(insertPoint, processor.Create(ldargs[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">256</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg_S, (<span class="keyword">byte</span>)i));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldarg, (<span class="keyword">short</span>)i));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; !method.IsStatic &amp;&amp; type.IsValueType)</span><br><span class="line">                    &#123;</span><br><span class="line">                        processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ldobj, type));</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//对值类型进行Box</span></span><br><span class="line">                    <span class="keyword">if</span> (ignoreValueType)</span><br><span class="line">                    &#123;</span><br><span class="line">                        TypeReference paramType;</span><br><span class="line">                        <span class="keyword">if</span> (method.IsStatic)</span><br><span class="line">                        &#123;</span><br><span class="line">                            paramType = method.Parameters[i].ParameterType;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            paramType = (i == <span class="number">0</span>) ? type : method.Parameters[i - <span class="number">1</span>].ParameterType;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (paramType.IsValueType)</span><br><span class="line">                        &#123;</span><br><span class="line">                            processor.InsertBefore(insertPoint, processor.Create(OpCodes.Box, paramType));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//创建并插入IL，调用invoke方法，因为之前已经压入injection的值，DelegateBridge的对象</span></span><br><span class="line">                processor.InsertBefore(insertPoint, processor.Create(OpCodes.Call, invoke));</span><br><span class="line">                <span class="comment">//普通方法，加入返回操作</span></span><br><span class="line">                <span class="keyword">if</span> (!method.IsConstructor &amp;&amp; !isFinalize)</span><br><span class="line">                &#123;</span><br><span class="line">                    processor.InsertBefore(insertPoint, processor.Create(OpCodes.Ret));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!method.IsConstructor)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    originToNewTarget[insertPoint] = firstInstruction;</span><br><span class="line">                    noCheck.Add(jmpInstruction);</span><br><span class="line">                &#125;</span><br><span class="line">                insertPoint = findNextRet(method.Body.Instructions, insertPoint);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (method.IsConstructor)</span><br><span class="line">            &#123;</span><br><span class="line">                fixBranch(processor, method.Body.Instructions, originToNewTarget, noCheck);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isFinalize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.Body.ExceptionHandlers.Count == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidProgramException(<span class="string">"Finalize has not try-catch? Type :"</span> + method.DeclaringType);</span><br><span class="line">                &#125;</span><br><span class="line">                method.Body.ExceptionHandlers[<span class="number">0</span>].TryStart = method.Body.Instructions[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isIntKey)</span><br><span class="line">            &#123;</span><br><span class="line">                bridgeIndexByKey.Add(method);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">string</span> <span class="title">getDelegateName</span>(<span class="params">MethodDefinition method</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="keyword">string</span> fieldName = method.Name;</span><br><span class="line">            <span class="keyword">if</span> (fieldName.StartsWith(<span class="string">"."</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                fieldName = fieldName.Substring(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">string</span> ccFlag = method.IsConstructor ? <span class="string">"_c"</span> : <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">string</span> luaDelegateName = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">var</span> type = method.DeclaringType;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_OVERLOAD; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span> tmp = ccFlag + <span class="string">"__Hotfix"</span> + i + <span class="string">"_"</span> + fieldName;</span><br><span class="line">                <span class="keyword">if</span> (!type.Fields.Any(f =&gt; f.Name == tmp)) <span class="comment">// injected</span></span><br><span class="line">                &#123;</span><br><span class="line">                    luaDelegateName = tmp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> luaDelegateName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>xlua.hotfix</strong>在完成生成代码和注入后，只要在Lua中调用xlua.hotfix或util.hotfix<em>ex方法就可以实现C#代码热更了。</em>hotfix和hotfixex的区别在与是否可以调用原C#代码，其实ex的实现也是调用了hotfix，在下面将分析hotfix和hotfix_ex的实现原理。<br>先分析下hotfix的Lua代码，代码在第一篇文章中的实例化lua中：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init_xlua.lua</span><br><span class="line">xlua.hotfix &#x3D; function(cs, field, func)</span><br><span class="line">           &#x2F;&#x2F;判空</span><br><span class="line">           if func &#x3D;&#x3D; nil then func &#x3D; false end</span><br><span class="line">           &#x2F;&#x2F;检查并且统一转化为table</span><br><span class="line">           &#x2F;&#x2F;因为在Xlua中可以一次传一个方法，或者一次传一组方法</span><br><span class="line">           local tbl &#x3D; (type(field) &#x3D;&#x3D; &#39;table&#39;) and field or &#123;[field] &#x3D; func&#125;</span><br><span class="line">           &#x2F;&#x2F;遍历需要hotfix的代码，key是方法名，v是对应的func</span><br><span class="line">           for k, v in pairs(tbl) do</span><br><span class="line">               &#x2F;&#x2F;构造函数的hotfix，这边不做分析了，原理一样</span><br><span class="line">               local cflag &#x3D; &#39;&#39;</span><br><span class="line">               if k &#x3D;&#x3D; &#39;.ctor&#39; then</span><br><span class="line">                   cflag &#x3D; &#39;_c&#39;</span><br><span class="line">                   k &#x3D; &#39;ctor&#39;</span><br><span class="line">               end</span><br><span class="line">               &#x2F;&#x2F;检查v的类型</span><br><span class="line">               local f &#x3D; type(v) &#x3D;&#x3D; &#39;function&#39; and v or nil</span><br><span class="line">               &#x2F;&#x2F;调用access函数，其在初始化注册，最终实现在C#中下文解析实现</span><br><span class="line">               xlua.access(cs, cflag .. &#39;__Hotfix0_&#39;..k, f) -- at least one</span><br><span class="line">               &#x2F;&#x2F;尝试给重载方法也添加上function如果有重载的话</span><br><span class="line">               pcall(function()</span><br><span class="line">                   for i &#x3D; 1, 99 do</span><br><span class="line">                       xlua.access(cs, cflag .. &#39;__Hotfix&#39;..i..&#39;_&#39;..k, f)</span><br><span class="line">                   end</span><br><span class="line">               end)</span><br><span class="line">           end</span><br><span class="line">           &#x2F;&#x2F;设置私有访问</span><br><span class="line">           xlua.private_accessible(cs)</span><br><span class="line">         end</span><br></pre></td></tr></table></figure>

<p><strong>XLuaAccess在C#中的实现：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;xlua.access(cs, cflag .. &#39;__Hotfix0_&#39;..k, f)</span><br><span class="line"></span><br><span class="line"> public static int XLuaAccess(RealStatePtr L)</span><br><span class="line"> &#123;</span><br><span class="line">     try</span><br><span class="line">     &#123;</span><br><span class="line">         </span><br><span class="line">         ObjectTranslator translator &#x3D; ObjectTranslatorPool.Instance.Find(L);</span><br><span class="line">         &#x2F;&#x2F;获取对应的CS类Type</span><br><span class="line">         Type type &#x3D; getType(L, translator, 1);</span><br><span class="line">         object obj &#x3D; null;</span><br><span class="line">         if (type &#x3D;&#x3D; null &amp;&amp; LuaAPI.lua_type(L, 1) &#x3D;&#x3D; LuaTypes.LUA_TUSERDATA)</span><br><span class="line">         &#123;</span><br><span class="line">             obj &#x3D; translator.SafeGetCSObj(L, 1);</span><br><span class="line">             if (obj &#x3D;&#x3D; null)</span><br><span class="line">             &#123;</span><br><span class="line">                 return LuaAPI.luaL_error(L, &quot;xlua.access, #1 parameter must a type&#x2F;c# object&#x2F;string&quot;);</span><br><span class="line">             &#125;</span><br><span class="line">             type &#x3D; obj.GetType();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (type &#x3D;&#x3D; null)</span><br><span class="line">         &#123;</span><br><span class="line">             return LuaAPI.luaL_error(L, &quot;xlua.access, can not find c# type&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;将cflag .. &#39;__Hotfix0_&#39;..k 转为fieldName，这个字段就是之前Inject时候创建的类静态字段名</span><br><span class="line">         string fieldName &#x3D; LuaAPI.lua_tostring(L, 2);</span><br><span class="line"></span><br><span class="line">         BindingFlags bindingFlags &#x3D; BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static;</span><br><span class="line">         &#x2F;&#x2F;这边访问一定是Set所以后面就不分析了，这边就是反射获取对应的FieldInfo，重点在于translator.GetObject方法。</span><br><span class="line">         if (LuaAPI.lua_gettop(L) &gt; 2) &#x2F;&#x2F; set</span><br><span class="line">         &#123;</span><br><span class="line">             var field &#x3D; type.GetField(fieldName, bindingFlags);</span><br><span class="line">             if (field !&#x3D; null)</span><br><span class="line">             &#123;</span><br><span class="line">                 field.SetValue(obj, translator.GetObject(L, 3, field.FieldType));</span><br><span class="line">                 return 0;</span><br><span class="line">             &#125;</span><br><span class="line">             var prop &#x3D; type.GetProperty(fieldName, bindingFlags);</span><br><span class="line">             if (prop !&#x3D; null)</span><br><span class="line">             &#123;</span><br><span class="line">                 prop.SetValue(obj, translator.GetObject(L, 3, prop.PropertyType), null);</span><br><span class="line">                 return 0;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             ...</span><br><span class="line">         &#125;</span><br><span class="line">         return LuaAPI.luaL_error(L, &quot;xlua.access, no field &quot; + fieldName);</span><br><span class="line">     &#125;</span><br><span class="line">     catch (Exception e)</span><br><span class="line">     &#123;</span><br><span class="line">         return LuaAPI.luaL_error(L, &quot;c# exception in xlua.access: &quot; + e);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;为了减少篇幅，只展示必要代码</span><br><span class="line"> public object GetObject(RealStatePtr L, int index, Type type)</span><br><span class="line"> &#123;</span><br><span class="line">     int udata &#x3D; LuaAPI.xlua_tocsobj_safe(L, index);</span><br><span class="line"></span><br><span class="line">     if (udata !&#x3D; -1)</span><br><span class="line">     &#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;&#x2F;一些特殊值类型的返回</span><br><span class="line">         ...</span><br><span class="line">         return (objectCasters.GetCaster(type)(L, index, null));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;为了减少篇幅，只展示必要代码</span><br><span class="line"> public ObjectCast GetCaster(Type type)</span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     ObjectCast oc;</span><br><span class="line">     &#x2F;&#x2F;缓存行为，继续分析第一次获取的caster委托</span><br><span class="line">     if (!castersMap.TryGetValue(type, out oc))</span><br><span class="line">     &#123;</span><br><span class="line">         oc &#x3D; genCaster(type);</span><br><span class="line">         castersMap.Add(type, oc);</span><br><span class="line">     &#125;</span><br><span class="line">     return oc;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;为了减少篇幅，只展示必要代码</span><br><span class="line"> private ObjectCast genCaster(Type type)</span><br><span class="line"> &#123;</span><br><span class="line">     </span><br><span class="line">     ObjectCast fixTypeGetter &#x3D; (RealStatePtr L, int idx, object target) &#x3D;&gt;</span><br><span class="line">     &#123;</span><br><span class="line">         if (LuaAPI.lua_type(L, idx) &#x3D;&#x3D; LuaTypes.LUA_TUSERDATA)</span><br><span class="line">         &#123;</span><br><span class="line">             object obj &#x3D; translator.SafeGetCSObj(L, idx);</span><br><span class="line">             return (obj !&#x3D; null &amp;&amp; type.IsAssignableFrom(obj.GetType())) ? obj : null;</span><br><span class="line">         &#125;</span><br><span class="line">         return null;</span><br><span class="line">     &#125;; </span><br><span class="line">     if ...</span><br><span class="line">     &#x2F;&#x2F;在Inject代码时候我们已经知道其字段类型就是DelegateBridge，所以会返回的就是这个表达式</span><br><span class="line">     else if (typeof(DelegateBridgeBase).IsAssignableFrom(type))</span><br><span class="line">     &#123;</span><br><span class="line">         return (RealStatePtr L, int idx, object target) &#x3D;&gt;</span><br><span class="line">         &#123;</span><br><span class="line">             &#x2F;&#x2F;缓存行为，分析CreateDelegateBridge</span><br><span class="line">             object obj &#x3D; fixTypeGetter(L, idx, target);</span><br><span class="line">             if (obj !&#x3D; null) return obj;</span><br><span class="line"></span><br><span class="line">             if (!LuaAPI.lua_isfunction(L, idx))</span><br><span class="line">             &#123;</span><br><span class="line">                 return null;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             return translator.CreateDelegateBridge(L, null, idx);</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;为了减少篇幅，只展示必要代码</span><br><span class="line"> public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx)</span><br><span class="line"> &#123;</span><br><span class="line">     &#x2F;&#x2F;这边只是查找是否这个方法已经有缓存了，有的话直接返回，没有就要Create，我们继续分析Create的事。</span><br><span class="line">     LuaAPI.lua_pushvalue(L, idx);</span><br><span class="line">     LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);</span><br><span class="line">     &#x2F;&#x2F;不为null就是已经生成过，就直接从缓存获取</span><br><span class="line">     if (!LuaAPI.lua_isnil(L, -1))</span><br><span class="line">     &#123;</span><br><span class="line">         retrun ...</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;&#x2F;弹出刚刚查询过的nil值</span><br><span class="line">         LuaAPI.lua_pop(L, 1);</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;开始生成对应的DelegateBridge</span><br><span class="line">     &#x2F;&#x2F;压入idx对应的值，idx对应的值是Lua中的function</span><br><span class="line">     LuaAPI.lua_pushvalue(L, idx);</span><br><span class="line">     &#x2F;&#x2F;获取function对应的引用id</span><br><span class="line">     int reference &#x3D; LuaAPI.luaL_ref(L);</span><br><span class="line">     &#x2F;&#x2F;再次压入idx对应的值，idx对应的值是Lua中的function</span><br><span class="line">     LuaAPI.lua_pushvalue(L, idx);</span><br><span class="line">     &#x2F;&#x2F;压入function对应的引用id</span><br><span class="line">     LuaAPI.lua_pushnumber(L, reference);</span><br><span class="line">     &#x2F;&#x2F;将栈顶的两个值以字典形式存在全局变量表中，这个的作用就是上面的代码查询是否已经在lua中缓存。</span><br><span class="line">     LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);</span><br><span class="line">     DelegateBridgeBase bridge;</span><br><span class="line">     try</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;&#x2F;创建DelegateBridge，注意这边的reference，这个就是对应了lua中修复的lua函数，</span><br><span class="line">         &#x2F;&#x2F;我们在Inject时候call的方法会使用到这个参数。</span><br><span class="line">         bridge &#x3D; new DelegateBridge(reference, luaEnv);</span><br><span class="line">     &#125;</span><br><span class="line">     catch(Exception e)</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;&#x2F;异常情况下的，清场操作</span><br><span class="line">         LuaAPI.lua_pushvalue(L, idx);</span><br><span class="line">         LuaAPI.lua_pushnil(L);</span><br><span class="line">         LuaAPI.lua_rawset(L, LuaIndexes.LUA_REGISTRYINDEX);</span><br><span class="line">         LuaAPI.lua_pushnil(L);</span><br><span class="line">         LuaAPI.xlua_rawseti(L, LuaIndexes.LUA_REGISTRYINDEX, reference);</span><br><span class="line">         throw e;</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F;因为hotfix时候，delegateType传进来是个null，后续代码不会被调用到，就不做分析了。</span><br><span class="line">     if (delegateType &#x3D;&#x3D; null)</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;&#x2F;缓存到字典中，注意这里是弱引用所以会被回收，被回收后，需要从lua中查询到对应引用值，然后再生产。</span><br><span class="line">         delegate_bridges[reference] &#x3D; new WeakReference(bridge);</span><br><span class="line">         return bridge;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样在进行调用hotfix后，对应的要修复的类的静态字段就会被设置上对应的DelegateBridge对象，然后在C#代码执行到对应的需要热更修复的方法时候，会先执行我们注入的IL代码，检查是否有对应的DelegateBridge。那么就是调用DelegateBridge中对应的方法，方法中包含的reference就是Lua对应的function，这样就执行到了lua中去，实现了热更。</p>
<ul>
<li><strong>util.hotfix_ex的实现</strong><br>其实现直白的来讲就是在调用util.hotfix_ex(functionB)时候，真正设置的是一个中间函数A，它被设置为对应方法的热更修复函数。<br>在调用A进行热更时候，它先设置这个方法的热更方法为空，然后调用原先设置的functionB，当functionB调用完后，然后再设置回热更方法为A，那么就能实现在热更修复方法functionB中调用原先的方法。<br>因为设置这些参数都是带反射的，所以在高频场景是有性能消耗的。<br>代码实现如下：</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">hotfix_ex</span><span class="params">(cs, field, func)</span></span></span><br><span class="line">    <span class="comment">--断言，检查参数</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">type</span>(field) == <span class="string">'string'</span> <span class="keyword">and</span> <span class="built_in">type</span>(func) == <span class="string">'function'</span>, <span class="string">'invalid argument: #2 string needed, #3 function needed!'</span>)</span><br><span class="line">    <span class="comment">--创建中间函数，就是上文提到的A</span></span><br><span class="line">    <span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func_after</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="comment">--先将需要热更修复的方法设置为nil，那么再调用方法时候会执行的就是之前方法</span></span><br><span class="line">        xlua.hotfix(cs, field, <span class="literal">nil</span>)</span><br><span class="line">        <span class="comment">--执行func，就是上文提到的functionB</span></span><br><span class="line">        <span class="keyword">local</span> ret = &#123;func(...)&#125;</span><br><span class="line">        <span class="comment">---重新将需要热更修复的方法设置为中间函数A</span></span><br><span class="line">        xlua.hotfix(cs, field, func_after)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">unpack</span>(ret)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">--设置需要热更修复为中间函数A</span></span><br><span class="line">    xlua.hotfix(cs, field, func_after)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结束语</strong>整个Hotfix的实现也分析完了，后续的文章将继续分析，XLua中的各种优化技巧实现，比如无GC传值，模板生成技术。</li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速的注入汇编</title>
    <url>/unity-2019-09-04-mono-cecil-inject/</url>
    <content><![CDATA[<p>写汇编码比较麻烦,可以试下下面的方法,先写好你要注入的代码,然后编译好,使用ilsyp查看…选择到要注入的代码再使用Reflexil工具查看</p>
<ol>
<li>使用ilsyp</li>
<li>使用reflexil就能看到他的汇编码</li>
</ol>
<p><img src="../../assets/images/2019-09-04-mono.cecil-inject/1567660270933.png" alt="1567660270933"></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>2D游戏视差背景的实现</title>
    <url>/unity-2019-09-13-Parallax-2d/</url>
    <content><![CDATA[<h4 id="什么是视差背景？"><a href="#什么是视差背景？" class="headerlink" title="什么是视差背景？"></a>什么是视差背景？</h4><p>视差效果，原本是一个天文学术语，当我们观察星空时，离我们远的星星移动速度较慢，离我们近的星星移动速度则较快。当我们坐在车上向车窗外看时，也会有这样的感觉，远处的群山似乎没有在动，而近处的稻田却在飞速掠过。</p>
<p>简单地说，视差背景其实就是通过多层次的背景来模拟透视视差效果：就是当发生移动时，离照相机越近的背景移动越快；反之越慢。这样，我们的背景就会形成类似于透视视差的效果。</p>
<p>那么，既然需要透视效果，为何不直接使用透视投影来做呢？这个原因是如果使用透视投影来产生视差的话，我们的远景必须真的是一个非常大的背景，你如果想模拟出一百倍于近景的远景，那么可能就需要相应尺寸的背景贴图。这种做法显然是做不到的。当然，如果是3D 背景的话有其他方式，不过对于2D 游戏而言，最直接有效的还是多层次背景模拟出视差效果。我们这里也主要聊聊如果通过多层次背景滚动的方式实现视差效果。</p>
<p>在整个视差背景实现过程中，需要完成两个主要工作：</p>
<ol>
<li>实现单层背景的滚动；</li>
<li>复合多层背景的滚动，实现视差效果；</li>
</ol>
<h4 id="实现单层背景的滚动"><a href="#实现单层背景的滚动" class="headerlink" title="实现单层背景的滚动"></a>实现单层背景的滚动</h4><p>背景滚动是实现视差效果的核心也是最重要的问题。背景滚动存在横向和纵向两种。所有使用视差背景的游戏都会有横向滚动的情况，而纵向滚动则未必都会有。我们这里以横向滚动来介绍背景滚动。我们有四种常规方式可以实现背景的滚动：</p>
<ol>
<li>通过移动一个四边形顶点的 UV 移动形成滚动，之后就称之为 UV 滚动方式；</li>
<li>通过滚动移动多个连续的背景精灵形成滚动，之后就称之为精灵滚动方式；</li>
<li>添加背景层照相机，移动照相机形成滚动，之后就称之为照相机移动方式；</li>
<li>精灵滚动方式和照相机移动方式混合使用，之后就称之为混合滚动方式；</li>
</ol>
<p>为了更好地解释这几种实现方式，需要几张图片用于介绍：</p>
<p>我们使用一个黄框精灵代表屏幕取景区域：</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/u-101952876756Yj6.png" alt="img"></p>
<p>接下来是三张可拼接的背景精灵：</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/u-101952876820zdg.png" alt="img">)<img src="../../assets/images/2019-09-13-Parallax-2d/u-101952876827Lvz.png" alt="img">)<img src="../../assets/images/2019-09-13-Parallax-2d/u-101952876811twL.png" alt="img"></p>
<h5 id="UV-滚动方式："><a href="#UV-滚动方式：" class="headerlink" title="UV 滚动方式："></a>UV 滚动方式：</h5><p>使用 UV 坐标移动形成滚动的效果看起来是这样的：</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/u-101952876924lOw.gif" alt="img"></p>
<p>在 UV 坐标移动的方法中，我们只是用一个和照相机取景区域一样大的精灵作为背景渲染区域。然后通过调整它的 UV 坐标和采样方式实现平铺背景以及背景滚动。具体实现步骤：</p>
<ol>
<li>准备一个覆盖整个屏幕的四边形顶点，并使用它显示背景贴图；</li>
<li>调整 UV 坐标和纹理之间的采样方式，以实现纹理连续显示；</li>
<li>移动时，修改四个顶点的 UV 坐标形成滚动；</li>
</ol>
<p>因为我们只使用一张精灵，我们区域采样的方式就是通过 UV 坐标。因此此方式下 UV 坐标存在两个作用：</p>
<ol>
<li>UV 坐标的整数部分标记了当前采样位置使用哪一张背景贴图；</li>
<li>UV 坐标小数部分为选中背景贴图的采样 UV 坐标；</li>
</ol>
<p>因此，此精灵的 UV 坐标必定会大于[0,1]区间。</p>
<p>如果背景使用的背景贴图只有一张的话，这个问题很容易解决。我们只要设置图形 API（OpenGL 或 DirectX，这里以 OpenGL 为例）的纹理包装类型（即所谓的 wrapping 类型）即可。所谓的包装类型即指定了当 UV 坐标值在[ 0,1 ]区间之外时，如何获取纹理。那么这里，我们需要让一张纹理重复出现。在 OpenGL 中，我们需要调用此函数来完成包装类型的设置：glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );稍微解释一下此函数：glTexParameteri 函数会对指定的纹理的参数进行设置。我们这里针对2D 纹理（第一参数 GL_TEXTURE_2D）的 x 方向即横向（第二参数 GL_TEXTURE_WRAP_S）的包装模式设置为重复出现的方式（第三参数 GL_REPEAT）。</p>
<p>不过如果背景是多张不同的纹理连续出现的话，就不能使用上面的方法解决了。这个时候我们需要编写一个简单的 shader 在 shader 中完成 UV 坐标映射。这里截取出演示 demo 中，获取纹理相关的 shader 代码（GLSL 代码）提供大家参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;我们有三张背景贴图，对 UV 坐标对3取模，得到使用哪一种背景贴图。             </span><br><span class="line">int _index &#x3D; int( mod( v_TexCoord.x, 3.0 ));</span><br><span class="line">&#x2F;&#x2F;使用此贴图并使用 UV 坐标的小数部分进行像素采样。            </span><br><span class="line">gl_FragData[0] &#x3D; texture( u_BackgroundTextures[_index], fract(v_TexCoord));</span><br></pre></td></tr></table></figure>

<p>UV 方式有着非常良好的性能，但是缺点就是只能处理简单的平铺背景，对于有着复杂结构或是效果的滚动背景没有办法使用。</p>
<h5 id="精灵滚动方式："><a href="#精灵滚动方式：" class="headerlink" title="精灵滚动方式："></a>精灵滚动方式：</h5><p>使用精灵滚动形成滚动的效果看起来是这样的：</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/u-10195287789913d.gif" alt="img"></p>
<p>这种方式应该是比较直接的。我们首先使用背景精灵拼接出背景取景区域覆盖到的背景区域。然后在发生背景移动时，我们依然不需要移动背景取景区域，而是通过滚动移动所有的背景精灵来实现背景移动的效果。</p>
<p>这种方式实现简单直接，但缺点是发生背景移动时，需要对所有的背景精灵进行移动。对于结构复杂元素较多的背景需要占用更多的性能。</p>
<h5 id="照相机移动方式："><a href="#照相机移动方式：" class="headerlink" title="照相机移动方式："></a>照相机移动方式：</h5><p>使用照相机移动形成滚动的效果看起来是这样的：</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/u-101952878215omm.gif" alt="img"></p>
<p>这种方式与精灵滚动方式正好相反。在这种方式下，我们需要使用背景精灵拼接出完整的背景。同时在背景移动时，不移动背景精灵转而移动背景取景区域来实现背景移动效果。</p>
<p>这种方式在移动过程中由于只需要移动背景照相机，所以有种很好的移动性能。但是为了使用此方法。我们需要预先将整个背景全部拼接。这样导致同时存在过多的背景精灵在场景中。如果使用的游戏引擎没有场景管理器或是场景管理器性能不佳的情况下，此方式反而会带来额外的性能消耗。</p>
<h5 id="混合滚动方式："><a href="#混合滚动方式：" class="headerlink" title="混合滚动方式："></a>混合滚动方式：</h5><p>使用混合滚动方式形成的滚动效果看起来是这样的：</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/u-101952878467iBp.gif" alt="img"></p>
<p>顾名思义，混合移动混合了精灵移动和照相机移动两种方式。我们在移动背景取景区域的同时，适时地滚动背景精灵。使得背景取景区域内的背景正确。</p>
<p>这种方式结合了精灵滚动方式和照相机移动方式。避免了精灵滚动方式移动过程中，因为需要移动所有背景精灵带来的额外性能开销；也避免了照相机移动方式中，需要预先构建完整的背景而导致场景中存在过多的背景精灵带来的额外性能开销。当然，和照相机移动方式一样，避免不了每一层背景都需要有一个独立的背景照相机。同时在代码实现良好的情况下，性能比前两者都要好。</p>
<h4 id="四种方式的优劣"><a href="#四种方式的优劣" class="headerlink" title="四种方式的优劣"></a>四种方式的优劣</h4><h5 id="平均性能："><a href="#平均性能：" class="headerlink" title="平均性能："></a>平均性能：</h5><p>UV 滚动方式只使用了一个四边形并且移动时也只是单纯改变了 UV 采样方式。它的性能是最好的；其次是混合滚动方式；照相机移动方式有更多的空间开销，同时此开销对性能的影响与游戏引擎的场景管理模块密切关联；精灵方式则有最大的移动性能消耗。</p>
<h5 id="对复杂背景的支持："><a href="#对复杂背景的支持：" class="headerlink" title="对复杂背景的支持："></a>对复杂背景的支持：</h5><p>即四种方式所实现的背景可以有多复杂。UV 滚动方式碍于实现只能做简单的平铺背景的滚动效果；精灵滚动方式和混合滚动方式可以实现更为复杂一点的背景，可以在简单的平铺背景之上加入一些其他背景精灵元素；而照相机移动方式对背景的构建没有要求，它可以支持非常复杂的背景。</p>
<h5 id="是否可以无限延伸："><a href="#是否可以无限延伸：" class="headerlink" title="是否可以无限延伸："></a>是否可以无限延伸：</h5><p>理论上四种方式都可以实现无限延伸。但是对于照相机移动方式来说，实现起来会比较麻烦。而另外三种方式都是循环利用同一个背景，所以天然支持无限延伸的背景。</p>
<h5 id="复合多层背景的滚动，实现视差效果："><a href="#复合多层背景的滚动，实现视差效果：" class="headerlink" title="复合多层背景的滚动，实现视差效果："></a>复合多层背景的滚动，实现视差效果：</h5><p>有了上面的工作，这一步也是顺其自然就可以完成：</p>
<p>我们首先要构建多层背景，多层背景可以同时只是用一种滚动方式；也可以不同层背景使用不同的滚动方式。比如最远的背景由于基本上都是简单的平铺可以使用 UV 滚动方式构建；而再近一点细节较多的背景层可以考虑后几种滚动方式构建背景。</p>
<p>之后是移动，我们需要根据每一层背景的距离决定其在移动过程中的移动速度。速度如何决定并没有统一的方法或是模式。总之，这一点听听美术们的意见是比较合适的。</p>
<h3 id="Unity混合模式1"><a href="#Unity混合模式1" class="headerlink" title="Unity混合模式1"></a>Unity混合模式1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Weiva Parallax</span><br><span class="line">&#x2F;&#x2F;&#x2F; 2D 视差效果</span><br><span class="line">&#x2F;&#x2F;&#x2F; 本组件背景视差效果是根据背景对象的世界坐标z值来计算。默认参数中的背景数组第一个元素为最远平面，</span><br><span class="line">&#x2F;&#x2F;&#x2F; 既与摄像机同步的平面，该对象之间的背景根据z值进行视差计算。也可以单独设置参数 synZ 强制设置最</span><br><span class="line">&#x2F;&#x2F;&#x2F; 远平面。大于最远平面的 z 值将会反超摄像机移动。</span><br><span class="line">&#x2F;&#x2F;&#x2F; weivain@qq.com</span><br><span class="line">&#x2F;&#x2F;&#x2F; www.weiva.com</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class WVParallax : MonoBehaviour &#123;</span><br><span class="line"> </span><br><span class="line">    [Header(&quot;背景图片对象，Element 0 为与摄像机同步的背景层&quot;)]</span><br><span class="line">    public Transform[] backgrounds;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 主摄像机</span><br><span class="line">    private Transform cam;</span><br><span class="line">    &#x2F;&#x2F; 上一帧摄像机的位置</span><br><span class="line">    private Vector3 previousCamPos;</span><br><span class="line">    &#x2F;&#x2F; 摄像机同步背景层的 z 值</span><br><span class="line">    [Header(&quot;摄像机同步背景层Z值，若0为背景层0&quot;)]</span><br><span class="line">    public float synZ&#x3D;0f;</span><br><span class="line">    [Header(&quot;偏移x系数&quot;)]</span><br><span class="line">    public float parallaxScaleX&#x3D;1f;</span><br><span class="line">    [Header(&quot;偏移y系数&quot;)]</span><br><span class="line">    public float parallaxScaleY&#x3D;1f;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 初始化</span><br><span class="line">    void Start ()</span><br><span class="line">    &#123;</span><br><span class="line">        cam &#x3D; Camera.main.transform;</span><br><span class="line">        &#x2F;&#x2F; 上一帧摄像机的位置</span><br><span class="line">        previousCamPos &#x3D; cam.position;</span><br><span class="line">        if(synZ &#x3D;&#x3D; 0 &amp;&amp; null !&#x3D; backgrounds[0])</span><br><span class="line">        &#123;</span><br><span class="line">            synZ &#x3D; backgrounds[0].position.z;</span><br><span class="line">        &#125;</span><br><span class="line">        if(synZ &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            synZ &#x3D; 100f;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    &#x2F;&#x2F; 每一帧执行</span><br><span class="line">    void Update ()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 获得摄像机和上一帧的偏移值</span><br><span class="line">        float parallax &#x3D; previousCamPos.x - cam.position.x;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;摄像机偏移矢量</span><br><span class="line">        Vector3 camMove &#x3D; cam.position - previousCamPos;</span><br><span class="line">        camMove.x *&#x3D; parallaxScaleX;</span><br><span class="line">        camMove.y *&#x3D; parallaxScaleY;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;同步背景</span><br><span class="line">        for (int i &#x3D; 0; i &lt; backgrounds.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (null &#x3D;&#x3D; backgrounds[i]) continue;</span><br><span class="line"> </span><br><span class="line">            Vector3 targetToMove &#x3D; backgrounds[i].position + camMove * (backgrounds[i].position.z&#x2F;synZ);</span><br><span class="line">            backgrounds[i].position &#x3D; targetToMove;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 更新上一帧摄像机的位置</span><br><span class="line">        previousCamPos &#x3D; cam.position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unity混合模式2"><a href="#Unity混合模式2" class="headerlink" title="Unity混合模式2"></a>Unity混合模式2</h3><p>在Unity官方2D游戏Demo中已使用到了视差滚动技术，笔者对此 Demo 中的视差滚动技术进行了研究，Demo 中使用 BackgroundParallax 脚本实现了视差功能，笔者编写此脚本代码说明。</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/424-1024x415.jpg" alt="4"></p>
<p>官方 demo <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/2d-platformer-11228" target="_blank" rel="noopener">链接</a></p>
<p>BackgroundParallax脚本代码说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class BackgroundParallax : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">	public Transform[] backgrounds;				&#x2F;&#x2F; Array of all the backgrounds to be parallaxed.</span><br><span class="line">	public float parallaxScale;					&#x2F;&#x2F; The proportion of the camera&#39;s movement to move the backgrounds by.</span><br><span class="line">	public float parallaxReductionFactor;		&#x2F;&#x2F; How much less each successive layer should parallax.</span><br><span class="line">	public float smoothing;						&#x2F;&#x2F; How smooth the parallax effect should be.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	private Transform cam;						&#x2F;&#x2F; Shorter reference to the main camera&#39;s transform.</span><br><span class="line">	private Vector3 previousCamPos;				&#x2F;&#x2F; The postion of the camera in the previous frame.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void Awake ()</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; Setting up the reference shortcut.</span><br><span class="line">		cam &#x3D; Camera.main.transform;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void Start ()</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; The &#39;previous frame&#39; had the current frame&#39;s camera position.</span><br><span class="line">		previousCamPos &#x3D; cam.position;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	void Update ()</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; The parallax is the opposite of the camera movement since the previous frame multiplied by the scale.</span><br><span class="line">		float parallax &#x3D; (previousCamPos.x - cam.position.x) * parallaxScale;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; For each successive background...</span><br><span class="line">		for(int i &#x3D; 0; i &lt; backgrounds.Length; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			&#x2F;&#x2F; ... set a target x position which is their current position plus the parallax multiplied by the reduction.</span><br><span class="line">			float backgroundTargetPosX &#x3D; backgrounds[i].position.x + parallax * (i * parallaxReductionFactor + 1);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Create a target position which is the background&#39;s current position but with it&#39;s target x position.</span><br><span class="line">			Vector3 backgroundTargetPos &#x3D; new Vector3(backgroundTargetPosX, backgrounds[i].position.y, backgrounds[i].position.z);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; Lerp the background&#39;s position between itself and it&#39;s target position.</span><br><span class="line">			backgrounds[i].position &#x3D; Vector3.Lerp(backgrounds[i].position, backgroundTargetPos, smoothing * Time.deltaTime);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Set the previousCamPos to the camera&#39;s position at the end of this frame.</span><br><span class="line">		previousCamPos &#x3D; cam.position;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="结合透视和正交相机在Unity2D游戏中制作视差效果"><a href="#结合透视和正交相机在Unity2D游戏中制作视差效果" class="headerlink" title="结合透视和正交相机在Unity2D游戏中制作视差效果"></a>结合透视和正交相机在Unity2D游戏中制作视差效果</h2><p>在开发MimpiDreams时，我们知道我们想用背景和前景做丰富的视差层。在Steam版本中，有几个图层来管理。所以我们想出了一个可能并不是独一无二的方法，不过在这里还是想概括一下。</p>
<p>在unity中有好多使用一个正交相机并用脚本移动图层来设置视差层级的教程。还有一些建议用透视相机和对象的Z轴深度。如果这么做了，设置合适的精灵排序就会变的困难，并且还不能使用优化技术和其他想在MimpiDreams中使用的透视相机的特性。经典的 Mimpi 只用了透视相机来创建，对此我们还有一些<a href="http://www.manew.com/forum-ask-1.html" target="_blank" rel="noopener">问题</a>。为了节省填充率我们使用了不透明的对象，不过不得不用Z轴偏移来放置它们以免Z方向有冲突。然而，由于对它们应用了透视视角，它们就以不同的速度移动了。</p>
<p>最好的方法是获得两者的优势。设置透视相机来渲染视差层，用正交相机来渲染有角色，平台，拼图等的主平面。</p>
<p>当为视差使用透视相机时，就很容易设置它们了。在正交视差中，需要基于相机的距离来缩放每一个对象并放在适当的位置。Toby: The SecretMine的作者Lukáš Navrátil告诉我他差不多会花掉一半的工作时间来设置正交视差层。随着我们技术的结合，他可以做的更快。</p>
<p>我和我的同事Jaroslav Stehlík一起开发了这种技术。现在让我们看一下如何设置。</p>
<p><strong>Camera and Scene Setup</strong> <strong>相机和场景设置</strong><br>层级视图很简单。将视差相机放在主相机的下边，这样它们会一起移动。</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/181708eqz39rii9vrvuopx.png.thumb.jpg" alt="img"></p>
<p><strong>Main Camera</strong></p>
<p><strong>主相机</strong></p>
<p>Clear Flags: Don’tclear</p>
<p>Culling Mask:everything except parallax layer</p>
<p>Projection:Orthographic</p>
<p>Depth: -1</p>
<p><strong>Parallax Camera Near</strong></p>
<p><strong>近距离视差相机</strong></p>
<p>Clear Flags: Depthonly</p>
<p>Culling Mask:Parallax</p>
<p>Projection:Perspective</p>
<p>Clipping Planes</p>
<p>Near: 0.01</p>
<p>Far: 10</p>
<p>Depth: 0</p>
<p><strong>Parallax Camera Far</strong></p>
<p><strong>远距离视差相机</strong></p>
<p>Clear Flags: SolidColor (or whatever else you want to use as a background)</p>
<p>Culling Mask:Parallax</p>
<p>Projection:Perspective</p>
<p>Clipping Planes</p>
<p>Near: 10</p>
<p>Far: 500</p>
<p>Depth: -2</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/camera.png" alt="img"></p>
<p>主相机会渲染除正交模式中视差层级之外的所有东西。这需要熟练使用“CullingMask”。“Clipping Planes”解决基于Z轴方向哪个视差对象被哪个视差相机渲染的问题，因此前景在正交平面之前，背景则在它的后边。相机放在Z轴-10的位置，所以在Z &lt; 0的视差中的所有东西都会被近处的相机渲染，在Z &gt; 0位置的对象就会被远处的相机渲染。“Depth”决定相机被渲染的正确顺序。</p>
<p>现在在编辑器中需要把所有的视差对象放入视差层中，并将其他所有对象移出该层。</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/cameraview.png" alt="img"></p>
<p>你需要考虑正交相机的尺寸和视角设置的透视区域。尤其想在游戏中使用变焦的时候，需要基于主相机的正交尺寸来设置视差的相机视角区域。关键是通常有一个特殊的平面（这个案例中为Z = 0），即视差层会和正交透视有同样的移动速度。这点很重要，因为稍后可以移动和缩放相机并且它会表现的很自然。在Mimpi Dreams开发初期，我们没有意识到那些并在视差设置中出现一些错误。我们不可以稍后更改它，因为它会复位所有的视差层。最后，由于我们没有过多的使用缩放，所以并没有产生多大影响。在下一个工程中，我们肯定会用这个设置。</p>
<p>这里有一段可以设置缩放的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public float GetFieldOfView(float orthoSize, float distanceFromOrigin)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; orthoSize</span><br><span class="line">    float a &#x3D; orthoSize;</span><br><span class="line">    &#x2F;&#x2F; distanceFromOrigin</span><br><span class="line">    float b &#x3D; Mathf.Abs(distanceFromOrigin);</span><br><span class="line"> </span><br><span class="line">    float fieldOfView &#x3D; Mathf.Atan(a &#x2F; b)  * Mathf.Rad2Deg * 2f;</span><br><span class="line">    return fieldOfView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想在Z轴移动相机，则需要更新视差相机的裁剪平面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; distanceFromOrigin</span><br><span class="line">float b &#x3D; Mathf.Abs(mainCamera.transform.position.z);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;change clipping planes based on main camera z-position</span><br><span class="line">farCamera.nearClipPlane &#x3D; b;</span><br><span class="line">farCamera.farClipPlane &#x3D; mainCamera.farClipPlane;</span><br><span class="line">nearCamera.farClipPlane &#x3D; b;</span><br><span class="line">nearCamera.nearClipPlane &#x3D; mainCamera.nearClipPlane;</span><br></pre></td></tr></table></figure>

<p>如何变焦相机有两个选择。</p>
<p>可以在Z轴移动主相机（并重新计算裁剪平面），或者可以改变主相机的正交尺寸（并重新计算视差相机的视角区域）。两个选择给出不同的效果，改变正交尺寸是更自然的选择。或者，可以结合这两种技术，看下边的视频。</p>
<p><strong>unity 实例</strong></p>
<p>Jaroslav准备并给出了你们可以尝试并学习的unity工程。感谢unity提供精选案例的免费资源！</p>
<p>可以从Github下载案例工程。</p>
<p>工程是用Unity 5.3.3f1制作的。</p>
<p>还要看一下展示案例的视频。</p>
<p><a href="https://www.youtube.com/watch?v=ptdweDDyB8o&feature=youtu.be" target="_blank" rel="noopener"><img src="../../assets/images/2019-09-13-Parallax-2d/0%5B1%5D.jpg" alt=""></a></p>
<p><strong>编辑工作流程</strong><br>在视差层设置对象最好的方法是在编辑模式下去播放游戏。可以移动角色（和相机）让玩家看到它并调整对象至实际视口。唯一的问题是播放模式下在unity中做出的更改不会保存。然而可以在播放模式下拷贝编辑过的对象并粘贴到编辑器中然后保存。我们创建一个有子集的“content”。这个content是在播放模式下编辑和复制过的。退出播放模式后，这个原始的content会被删除，新的content从剪切板粘贴过来，然后预制件就可以使用了。</p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/181709gdpgid33t93vjfyf.png.thumb.jpg" alt="img"></p>
<p>还有，不要忘记将新的对象放到视差层中。还可以编写或者使用一些编辑器工具来帮助你保存和自动完成对象层级设置。</p>
<p>上边的案例实在编辑模式下执行的，所以可以在编辑器中用它来设置。不过我们在MimpiDreams中使用了这个工作流程，因为这对于美术设计在场景中移动很容易，并且他可以自己调整层级。</p>
<p><strong>Summary</strong> <strong>总结</strong></p>
<p><img src="../../assets/images/2019-09-13-Parallax-2d/181711j5s29z585k932ot6.gif" alt="img"></p>
<p><strong>Some advantages of this solution</strong> <strong>这种解决方案的优势：</strong></p>
<p>本地基本设置（脚本仅仅为了变焦）</p>
<p>案例中更好的表现</p>
<p>静态批处理，因为层级不会移动</p>
<p>简单的编辑工作流程</p>
<p><strong>Disadvantages</strong> <strong>劣势:</strong></p>
<p>会产生更多的draw calls</p>
<p>我们介绍了和Mimpi Dreams中制作视差效果不同的制作方法。你可能需要自定义一些东西。例如，我们显示所有摄像机的渲染纹理，不过在这边文章中，我想介绍最简单的设置。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">[ExecuteInEditMode]</span><br><span class="line">public class CameraParallax : MonoBehaviour &#123;</span><br><span class="line"></span><br><span class="line">    public Camera mainCamera;</span><br><span class="line">    public Camera farCamera;</span><br><span class="line">    public Camera nearCamera;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        InitCameras();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void LateUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        UpdateCameras();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void InitCameras()</span><br><span class="line">    &#123;</span><br><span class="line">        if(farCamera !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            farCamera.transform.localPosition &#x3D; Vector3.zero;</span><br><span class="line">            farCamera.transform.rotation &#x3D; Quaternion.identity;</span><br><span class="line">            farCamera.transform.localScale &#x3D; Vector3.one;</span><br><span class="line">            farCamera.orthographic &#x3D; false;</span><br><span class="line">            farCamera.clearFlags &#x3D; CameraClearFlags.SolidColor;</span><br><span class="line">            farCamera.depth &#x3D; -2;</span><br><span class="line">            farCamera.transparencySortMode &#x3D; TransparencySortMode.Orthographic;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(mainCamera !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            mainCamera.orthographic &#x3D; true;</span><br><span class="line">            mainCamera.clearFlags &#x3D; CameraClearFlags.Nothing;</span><br><span class="line">            mainCamera.depth &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(nearCamera !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            nearCamera.transform.localPosition &#x3D; Vector3.zero;</span><br><span class="line">            nearCamera.transform.rotation &#x3D; Quaternion.identity;</span><br><span class="line">            nearCamera.transform.localScale &#x3D; Vector3.one;</span><br><span class="line">            nearCamera.orthographic &#x3D; false;</span><br><span class="line">            nearCamera.clearFlags &#x3D; CameraClearFlags.Depth;</span><br><span class="line">            nearCamera.depth &#x3D; 0;</span><br><span class="line">            nearCamera.transparencySortMode &#x3D; TransparencySortMode.Orthographic;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void UpdateCameras()</span><br><span class="line">    &#123;</span><br><span class="line">        if(mainCamera &#x3D;&#x3D; null || farCamera &#x3D;&#x3D; null || nearCamera &#x3D;&#x3D; null) return;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; orthoSize</span><br><span class="line">        float a &#x3D; mainCamera.orthographicSize;</span><br><span class="line">        &#x2F;&#x2F; distanceFromOrigin</span><br><span class="line">        float b &#x3D; Mathf.Abs(mainCamera.transform.position.z);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;change clipping planes based on main camera z-position</span><br><span class="line">        farCamera.nearClipPlane &#x3D; b;</span><br><span class="line">        farCamera.farClipPlane &#x3D; mainCamera.farClipPlane;</span><br><span class="line">        nearCamera.farClipPlane &#x3D; b;</span><br><span class="line">        nearCamera.nearClipPlane &#x3D; mainCamera.nearClipPlane;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;update field fo view for parallax cameras</span><br><span class="line">        float fieldOfView &#x3D; Mathf.Atan(a &#x2F; b)  * Mathf.Rad2Deg * 2f;</span><br><span class="line">        nearCamera.fieldOfView &#x3D; farCamera.fieldOfView &#x3D; fieldOfView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原文链接：</p>
<ul>
<li><p><a href="http://www.gamasutra.com/blogs/MichalBerlinger/20160323/268657/Combining_Perspective_and_Orthographic_Camera_for_Parallax_Effect_in_2D_Game.php" target="_blank" rel="noopener">http://www.gamasutra.com/blogs/MichalBerlinger/20160323/268657/Combining_Perspective_and_Orthographic_Camera_for_Parallax_Effect_in_2D_Game.php</a></p>
</li>
<li><p><a href="https://github.com/MichalBerlinger/ParallaxDemo" target="_blank" rel="noopener">https://github.com/MichalBerlinger/ParallaxDemo</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>unity使用代理</title>
    <url>/unity-2019-11-15-unity-proxy/</url>
    <content><![CDATA[<p>Unity的AssetStore下载package的时候经常抽风，而且开了代理工具的全局代理依然无效。</p>
<p>检索网络后得知，这是因为它下载的时候不检测IE代理设置，而是取环境变量中HTTPS_proxy和HTTP_proxy的值，所以添加这两个变量并指定其为你的代理服务地址就可以了。</p>
<p>具体步骤：</p>
<pre><code>打开 系统属性-&gt;高级-&gt;环境变量
新建 HTTPS_PROXY 和 HTTP_PROXY 系统变量，设置其为你的代理服务地址

例如公司的代理IP是：127.0.0.1 端口：1080 
变量名：HTTPS_PROXY
变量值：http://127.0.0.1:1080    这里也是http..因为ss没开https

变量名：HTTP_PROXY
变量值：http://127.0.0.1:1080</code></pre><p><img src="../../assets/images/2019-11-15-unity-proxy/20190515220955161%5B1%5D.png" alt=""></p>
<p>需要注意的是设置完成后可能需要重启Unity才会生效。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>代理</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章搞定Entitas</title>
    <url>/unity-2020-01-01-unity-entitas/</url>
    <content><![CDATA[<h1 id="Entitas執行流程"><a href="#Entitas執行流程" class="headerlink" title="Entitas執行流程"></a>Entitas執行流程</h1><p><img src="../../assets/images/2020-01-01-unity-entitas/1362861-20190531225036556-1995562595%5B1%5D.png" alt=""></p>
<p>​      也就是说整个ECS系统的内部数据维护(Group、Collector、EntityIndex)复杂度主要放在Entity的修改上了。<br>​      在给一个Entity添加一个Component时，不仅仅是对Entity进行了修改，还会通过事件将这个添加传递给Context，Context遍历所有Group，找到满足这次修改条件的Group，对所有受到影响的Group进行修改。然后再通过Group将这次修改事件分发到Collector或其他监听该Group的模块中去。<br>  这种方式带来的好处十分明显，那就是获取一种类型的Entity（也就是一个Group），只有第一次会遍历所有的Entity生成这个Group，之后再获取该类型Entity的复杂度就只有O(1)。<br>  但是也有一定的隐患，当Group和Collector比较少时，这不是一个高消耗操作，但是Group、Collector很多，且在每一帧对Entity进行频繁修改的时候。这可能会成为一个高消耗操作。</p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><p>  1. 在销毁一个Entity时，会移除Entity身上所有的Component，然后再进行回收。在移除Component时可能会通过Group把这个移除事件发送到监听Remove行为的Collector中，Collector会持有这个被销毁的Entity。所以在filter、或execute时不能直接依赖Collector的收集条件，还需要对Entity的Component做独立的判断。<br>  其实任何时候filter都需要对Entity的Component做判断，因为Collector收集的Entity很可能在其他地方被改变。</p>
<p>  2. Entity不应该被ECS系统外的模块持有，因为系统外对Entity的持有不会被自动引用计数（可以自己添加）。可能会导致一个Entity被销毁然后又从池子中重新取出来， 外部模块对这个Entity的引用没有改变，但已经可能不是自己持有的那个Entity了。<br>  需要避免在外界持有Entity或通过持有uuid间接从context中持有这个Entity。</p>
<p>  3. 在replaceComponent时，发送了Remove、Add、Update三个事件，而不是只发送了Update事件。</p>
<p>  4. 在代码生成时，对单Componet的Matcher进行了缓存，如游戏中常用的Postion和Name等Component，但是对组合Component的Matcher没有进行缓存。所在在两个不同的ReactiveSystem中使用Matcher相同的Collector时，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1,2代表Postion和Name的Index</span><br><span class="line">&#x2F;&#x2F;在使用代码生成时会生成类似Matcher.Position、Matcher.Name的静态函数，方便开发者使用</span><br><span class="line">context.CreateCollector(Matcher.AllOf(1,2));</span><br></pre></td></tr></table></figure>

<p>这样会生成两个Matcher相同的Group实例。<br>如果在意这一点的话可以自己对Matcher进行缓存。</p>
<ol start="5">
<li>在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用<code>不可修改</code>（immutable）component的感觉。</li>
</ol>
<h1 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h1><p>在Context中可以对Entity进行快速过滤，它能不断的更新以保持当前的组中的Entity是最新的。假设Context有上千个Entities，但只有两个Entities拥有PositionComponent，那只要向Context询问特定的组就能立刻获取到所有符合的Entity。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gameContext.GetGroup(GameMatcher.Position).GetEntities();</span><br></pre></td></tr></table></figure>

<p>Group和Group所过滤到的entities会被缓存下来，所以即使多次调用GetGroup方法，也是非常高效的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gameContext.GetEntities(GameMatcher.Movable)</span><br></pre></td></tr></table></figure>

<p>内部也是通过Groups的方式来实现。Groups 拥有以下事件OnEntityAdded, OnEntityRemoved 和 OnEntityUpdated来直接响应Entity的变化。</p>
<h1 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h1><p>Collector是Group的一个观察者类,Collector提供了一种简单的方法来处理Group中Entity变化的反应。假设你需要收集和处理所有entities，他们的PositionComponent被添加或替换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var group &#x3D; gameContext.GetGroup(GameMatcher.Position);</span><br><span class="line">var collector &#x3D; group.CreateCollector(GroupEvent.Added);</span><br></pre></td></tr></table></figure>

<p>之后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach (var e in collector.collectedEntities) &#123;</span><br><span class="line">    &#x2F;&#x2F; do something with all the entities</span><br><span class="line">    &#x2F;&#x2F; that have been collected to this point of time</span><br><span class="line">&#125;</span><br><span class="line">collector.ClearCollectedEntities();</span><br></pre></td></tr></table></figure>

<p>我们还可以注销这个Collector</p>
<p>collector.Deactivate();</p>
<h1 id="ReactiveSystem"><a href="#ReactiveSystem" class="headerlink" title="ReactiveSystem"></a>ReactiveSystem</h1><ul>
<li>响应式的系统就像执行式系统一样，会每隔一段时间或是在每一个<code>Update</code>中被触发</li>
<li>响应式系统的<code>Execute(List entities)</code> 方法只会在收集器距离上一次<code>Execute</code>收集到新的Entity才会被执行。</li>
<li>gettrigger使用Collector根据event建立一个group的entity列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override ICollector&lt;GameEntity&gt; GetTrigger(IContext&lt;GameEntity&gt; context) &#123;</span><br><span class="line">	return context.CreateCollector(GameMatcher.Destroyed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected override bool Filter(GameEntity entity) &#123;</span><br><span class="line">	return entity.isDestroyed;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">public void Execute() &#123;</span><br><span class="line">    if (_collector.count !&#x3D; 0) &#123;</span><br><span class="line">        foreach (var e in _collector.collectedEntities) &#123;</span><br><span class="line">            if (Filter(e)) &#123;</span><br><span class="line">                e.Retain(this);</span><br><span class="line">                _buffer.Add(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _collector.ClearCollectedEntities();</span><br><span class="line"></span><br><span class="line">        if (_buffer.Count !&#x3D; 0) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Execute(_buffer);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; _buffer.Count; i++) &#123;</span><br><span class="line">                    _buffer[i].Release(this);</span><br><span class="line">                &#125;</span><br><span class="line">                _buffer.Clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码:</p>
<p>我们在<code>GetTrigger</code>方法中返回了一个监测了<code>Destroyed</code>Entity的Collector。在<code>context.CreateCollector(GameMatcher.Destroyed)</code> 中，我们不需要指定当一个Entity何时应当被收集的事件，因为默认就是会收集在<code>Added</code>情况下被通知到的Entity。所以当我们增加一个<code>Destroyed</code>组件到一个Entity上时，这个Entity会<code>添加</code>到<code>Destroyed</code>的group里面，并因此被对应的collector收集到对应的reactive system里面。</p>
<p>如下面的代码,AddDebugMessage就会被DebugMessageSystem收集了…</p>
<p>执行RemoveDebugMessage()但是DebugMessageSystem仍然收集着呢,但是该实体已经没有了组件DebugMessage.所以需要过滤下Filter(GameEntity entity)否则收集的数据会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Entitas;</span><br><span class="line"></span><br><span class="line">public class HelloWorldSystem : IInitializeSystem</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; always handy to keep a reference to the context </span><br><span class="line">    &#x2F;&#x2F; we&#39;re going to be interacting with it</span><br><span class="line">    readonly GameContext _context;</span><br><span class="line"></span><br><span class="line">    public HelloWorldSystem(Contexts contexts)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; get the context from the constructor</span><br><span class="line">        _context &#x3D; contexts.game;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; create an entity and give it a DebugMessageComponent with</span><br><span class="line">        &#x2F;&#x2F; the text &quot;Hello World!&quot; as its data</span><br><span class="line"></span><br><span class="line">        var e &#x3D; _context.CreateEntity();</span><br><span class="line">        e.AddDebugMessage(&quot;Hello World!&quot;);</span><br><span class="line">        e.RemoveDebugMessage(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using Entitas;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class DebugMessageSystem : ReactiveSystem&lt;GameEntity&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public DebugMessageSystem(Contexts contexts) : base(contexts.game)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override ICollector&lt;GameEntity&gt; GetTrigger(IContext&lt;GameEntity&gt; context)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; we only care about entities with DebugMessageComponent </span><br><span class="line">        return context.CreateCollector(GameMatcher.DebugMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override bool Filter(GameEntity entity)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; good practice to perform a final check in case </span><br><span class="line">        &#x2F;&#x2F; the entity has been altered in a different system.</span><br><span class="line">        return entity.hasDebugMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void Execute(List&lt;GameEntity&gt; entities)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; this is the list of entities that meet our conditions</span><br><span class="line">        foreach (var e in entities)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; we can safely access their DebugMessage component</span><br><span class="line">            &#x2F;&#x2F; then grab the string data and print it</span><br><span class="line">            Debug.Log(e.debugMessage.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>























<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h3 id="关于replace都干了什么"><a href="#关于replace都干了什么" class="headerlink" title="关于replace都干了什么"></a>关于replace都干了什么</h3><p>Group具有事件 <code>OnEntityAdded</code>, <code>OnEntityRemoved</code> and <code>OnEntityUpdated</code> 可以直接对组的更改做出反应。</p>
<p>看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void UpdateEntity(TEntity entity, int index, IComponent previousComponent, IComponent newComponent) &#123;</span><br><span class="line">           if (_entities.Contains(entity)) &#123;</span><br><span class="line">               if (OnEntityRemoved !&#x3D; null) &#123;</span><br><span class="line">                   OnEntityRemoved(this, entity, index, previousComponent);</span><br><span class="line">               &#125;</span><br><span class="line">               if (OnEntityAdded !&#x3D; null) &#123;</span><br><span class="line">                   OnEntityAdded(this, entity, index, newComponent);</span><br><span class="line">               &#125;</span><br><span class="line">               if (OnEntityUpdated !&#x3D; null) &#123;</span><br><span class="line">                   OnEntityUpdated(</span><br><span class="line">                       this, entity, index, previousComponent, newComponent</span><br><span class="line">                   );</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>在Entitas-CSharp中，我们不会真的删除或者添加一个Component。生成出来的代码会先向用户请求新的值，触发移除component的事件，设置一个新的值给这个component，然后触发一次增加component的事件。用这个方法，我们就避免了内存的分配以及模拟了一个在使用<code>不可修改</code>（immutable）component的感觉。</p>
<h3 id="group和collect-还有event应该在什么地方添加"><a href="#group和collect-还有event应该在什么地方添加" class="headerlink" title="group和collect,还有event应该在什么地方添加."></a>group和collect,还有event应该在什么地方添加.</h3><ul>
<li>在系统中的构造函数中</li>
<li>在entitan的system初始化Initialize前</li>
</ul>
<p>因为初始化系统大多会有add,remove等动作.为了保持你的group,还有collect,还有event能够监听到.</p>
<p>所以最好在Initialize前</p>
<h1 id="Jenny"><a href="#Jenny" class="headerlink" title="Jenny"></a>Jenny</h1><p>jenny使用了roslyn, DataProviders需要更改下,否则会报错..</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jenny.SearchPaths &#x3D; Assets\Plugins\DesperateDevs\Editor\Plugins, \</span><br><span class="line">                    Assets\Plugins\Entitas\Editor\Plugins, \</span><br><span class="line">                    Jenny\Plugins\Entitas.Roslyn</span><br><span class="line"></span><br><span class="line">Jenny.Plugins &#x3D; DesperateDevs.CodeGeneration.Plugins, \</span><br><span class="line">                DesperateDevs.CodeGeneration.Unity.Plugins, \</span><br><span class="line">                Entitas.CodeGeneration.Plugins, \</span><br><span class="line">                Entitas.Roslyn.CodeGeneration.Plugins, \</span><br><span class="line">                Entitas.VisualDebugging.CodeGeneration.Plugins</span><br><span class="line"></span><br><span class="line">Jenny.PreProcessors &#x3D; DesperateDevs.CodeGeneration.Plugins.ValidateProjectPathPreProcessor, \</span><br><span class="line">                      DesperateDevs.CodeGeneration.Plugins.TargetFrameworkProfilePreProcessor</span><br><span class="line"></span><br><span class="line">Jenny.DataProviders &#x3D; Entitas.CodeGeneration.Plugins.ContextDataProvider, \</span><br><span class="line">                      Entitas.Roslyn.CodeGeneration.Plugins.CleanupDataProvider, \</span><br><span class="line">                      Entitas.Roslyn.CodeGeneration.Plugins.ComponentDataProvider, \</span><br><span class="line">                      Entitas.Roslyn.CodeGeneration.Plugins.EntityIndexDataProvider</span><br><span class="line"></span><br><span class="line">Jenny.CodeGenerators &#x3D; Entitas.CodeGeneration.Plugins.ComponentContextApiGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ComponentEntityApiGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ComponentEntityApiInterfaceGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ComponentGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ComponentLookupGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ComponentMatcherApiGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ContextAttributeGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ContextGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ContextMatcherGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.ContextsGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EntityGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EntityIndexGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EventEntityApiGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EventListenerComponentGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EventListenertInterfaceGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EventSystemGenerator, \</span><br><span class="line">                       Entitas.CodeGeneration.Plugins.EventSystemsGenerator, \</span><br><span class="line">                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemGenerator, \</span><br><span class="line">                       Entitas.Roslyn.CodeGeneration.Plugins.CleanupSystemsGenerator, \</span><br><span class="line">                       Entitas.VisualDebugging.CodeGeneration.Plugins.ContextObserverGenerator, \</span><br><span class="line">                       Entitas.VisualDebugging.CodeGeneration.Plugins.FeatureClassGenerator</span><br><span class="line"></span><br><span class="line">Jenny.PostProcessors &#x3D; DesperateDevs.CodeGeneration.Plugins.AddFileHeaderPostProcessor, \</span><br><span class="line">                       DesperateDevs.CodeGeneration.Plugins.CleanTargetDirectoryPostProcessor, \</span><br><span class="line">                       DesperateDevs.CodeGeneration.Plugins.MergeFilesPostProcessor, \</span><br><span class="line">                       DesperateDevs.CodeGeneration.Plugins.NewLinePostProcessor, \</span><br><span class="line">                       DesperateDevs.CodeGeneration.Plugins.UpdateCSProjPostProcessor, \</span><br><span class="line">                       DesperateDevs.CodeGeneration.Plugins.WriteToDiskPostProcessor, \</span><br><span class="line">                       DesperateDevs.CodeGeneration.Plugins.ConsoleWriteLinePostProcessor</span><br><span class="line"></span><br><span class="line">Jenny.Server.Port &#x3D; 3333</span><br><span class="line">Jenny.Client.Host &#x3D; localhost</span><br><span class="line">DesperateDevs.CodeGeneration.Plugins.ProjectPath &#x3D; Assembly-CSharp.csproj</span><br><span class="line">Entitas.CodeGeneration.Plugins.Assemblies &#x3D; Library&#x2F;ScriptAssemblies&#x2F;Assembly-CSharp.dll</span><br><span class="line">Entitas.CodeGeneration.Plugins.Contexts &#x3D; Game, \</span><br><span class="line">                                          Unit, \</span><br><span class="line">                                          Combat, \</span><br><span class="line">                                          Config, \</span><br><span class="line">                                          Input</span><br><span class="line"></span><br><span class="line">Entitas.CodeGeneration.Plugins.IgnoreNamespaces &#x3D; true</span><br><span class="line">DesperateDevs.CodeGeneration.Plugins.TargetDirectory &#x3D; Assets&#x2F;Scripts&#x2F;World</span><br></pre></td></tr></table></figure>

<p>一般来说.先运行Jenny-Auto-Import.bat.再运行Jenny-Server.bat就可以了</p>
<p>查看所有命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.\Jenny\Jenny.exe help</span><br></pre></td></tr></table></figure>



<p>以VStudio为例，创建一个外部工具：</p>
<p><img src="../../assets/images/2020-01-01-unity-entitas/v2-d49876b0ae0100844a372dfb16508b27_hd.jpg" alt="img"></p>
<p>再之后，想要生成代码只需要保持运行<code>Jenny Server</code> 然后在VS中运行<code>工具/Jenny</code> 就可以了，这个方法可以让你专注于VS而无需切换回Unity。</p>
<p><code>jenny.exe client gen</code>需要服务器才能使用</p>
<p><code>jenny gen</code> 不开服务器直接可以使用</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://www.jianshu.com/c/e8e4c3f4280c" target="_blank" rel="noopener">https://www.jianshu.com/c/e8e4c3f4280c</a></li>
<li><a href="https://github.com/OneYoungMean/Entitas-CSharp-OYM/wiki" target="_blank" rel="noopener">https://github.com/OneYoungMean/Entitas-CSharp-OYM/wiki</a></li>
<li><a href="https://github.com/sschmid/Entitas-CSharp" target="_blank" rel="noopener">https://github.com/sschmid/Entitas-CSharp</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>React</tag>
        <tag>entitas</tag>
      </tags>
  </entry>
  <entry>
    <title>unity攻击范围检测的方式区别</title>
    <url>/unity-2020-01-11-unity-attack-range-detection-type/</url>
    <content><![CDATA[<h4 id="1-利用碰撞器的触发器Trigger"><a href="#1-利用碰撞器的触发器Trigger" class="headerlink" title="1.利用碰撞器的触发器Trigger"></a>1.利用碰撞器的触发器Trigger</h4><p>  这种是比较基础的做法，利用OnTriggerEntry函数，当目标进入触发器时触发。例如玩家有一把剑，我要做攻击判定的话，我就可以在剑上挂一个触发器，设定好大小，当播放动画时，随着剑的挥动，目标会进入Trigger的范围，此时就会调用OnTriggerEntry函数。但是这样做有个弊端，如果挥舞速度太快，检测会有问题；还有就是必须满足“进入”这个条件，也就是说如果原来目标就在触发器范围内，或者触发器在目标内，是不会触发函数的。所以这种方法不太适用于3D游戏。</p>
<p>  不过这种方法也不是不能用，只是适用条件有限，在2D游戏上，结合上Animation的录制功能，通过动画来改变Trigger的大小，这样就可以触发OnTriggerEntry函数一次或者多次，这样也是可以做出不错效果的。在3D游戏中，可以在人物前面放置一个大小合适Trigger当做攻击范围，再结合动画事件进行攻击判定，不过这样做的缺点是攻击范围大小恒定，如果人物的攻击范围大小不一，就要创建很多空子物体来设定Trigger范围，脚本也不好管理。</p>
<h4 id="2-利用数学判断"><a href="#2-利用数学判断" class="headerlink" title="2.利用数学判断"></a>2.利用数学判断</h4><p>  可以定义两个向量作为攻击范围，向量有方向也有长度，攻击范围是可以确定的。例如设定两个向量，向量1为Transform.forward的左偏45度，向量2为Transform.forward的右偏45度，长度均为5。此时攻击范围为半径为5，度数为90°的扇形。此时就可以计算敌人是不是在攻击范围内，可以通过Vector3.Angle来计算（角度制），Vector3.Distance来计算距离。</p>
<p>  这种方法的局限在于1.如何获取到敌人的游戏物体，可以通过触发器也可以遍历你的敌人列表。2.当敌人体积过大时，有可能身体的一部分已经进入攻击范围，但是postion没有进入攻击范围，此时判定就会出现错误。看情况使用。</p>
<h4 id="3-利用射线Raycast"><a href="#3-利用射线Raycast" class="headerlink" title="3.利用射线Raycast"></a>3.利用射线Raycast</h4><p>  使用Physics.Raycast()这个方法来发射射线，当射线碰到物体，或者碰到指定Laymask层的物体，或者一定距离后就会返回，返回值是Bool类型。通过out关键字来输出碰撞到的物体的信息，变量类型为RaycastHit。例如我定义一个射线Ray ray =new Ray(), 一个射线返回RaycastHit hit，那么就应该这么使用Physics.Raycast(ray,out hit),表示碰到物体，就会返回ture，物体信息储存在hit中。没有碰到，就会范围false，hit为null。这个方法还有很多重载，可以自己查阅API，根据情况使用。</p>
<p>  这种方法是射击游戏的常用判断方法，可以结合lineRender来渲染子弹飞过的特效。不过这种方法也不是万能的，它的局限在于射出射线的点只有一个，用来做射击游戏的攻击判定是非常合适的，但是不能用来做判定比较严格的游戏。为什么呢，因为射击游戏的发射方向是可以根据准星调整的，视觉上的判定也是准星方向，如果是动作游戏，rpg游戏之类的，攻击类型多样，就会出现差错。例如一个从上至下的斩击，攻击范围应该是竖着的一条线，那么射线应该怎发射呢？如果直直的往前发射，那么当敌人蹲下的时候，就会检测不到。你或许会想做成动作模式不就完了吗？（就是类似于龙之谷的操作方式），也是不行的，判定始终在攻击轨迹中央，和攻击动画和攻击特效有出入。</p>
<h4 id="4-利用射线Linecast"><a href="#4-利用射线Linecast" class="headerlink" title="4.利用射线Linecast"></a>4.利用射线Linecast</h4><p>  这也是Physics的一个方法， Physics.Linecast（）。连接两个点形成线段，如果线段中间有物体，就返回true,否则返回flase，同样，这个方法需要定义一个RaycastHit类型的变量来接收返回数据，具体方法为Physics.Linecast（Vector3 point1, Vector3 point2，out hit）。这种方法需要在武器或者拳头或者其他的需要攻击判定的地方设定一个点，当动画播放时，这个点的世界坐标就会变化，此时我们可以选择记录某几个时间点上判定点的世界坐标，再用Linecast进行判定。一般取判定点的坐标的话我们同样可以利用动画事件。</p>
<p>  这种方法调试的时候最好用lineRender把攻击轨迹渲染出来，或者用Debug.DrawLine()画出来（记得设定存在时间，不然一瞬间就消失了看不到），这样可以方便调整我们取判定点的时间节点，不然可能会疑惑，明明我设定好了，怎么检测不到。这种方法适合于动作游戏，以及一些判定比较精细的游戏。需要注意的一点是，Linecast每一帧都会进行判定，一般我们只需要一个动作判定一次，那么还需要在代码里进行约束。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的2D碰撞检测</title>
    <url>/unity-2020-01-12-Collision-detection/</url>
    <content><![CDATA[<p>“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。</p>
<p>好了，不废话。直入主题——碰撞检测。</p>
<p>在 2D 环境下，常见的碰撞检测方法如下：</p>
<ul>
<li>外接图形判别法<ul>
<li>轴对称包围盒（Axis-Aligned Bounding Box），即无旋转矩形。</li>
<li>圆形碰撞</li>
<li>圆形与矩形（无旋转）</li>
<li>圆形与旋转矩形（以矩形中心点为旋转轴）</li>
</ul>
</li>
<li>光线投射法</li>
<li>分离轴定理</li>
<li>其他<ul>
<li>地图格子划分</li>
<li>像素检测</li>
</ul>
</li>
</ul>
<p>下文将由易到难的顺序介绍上述各种碰撞检测方法：外接图形判别法 &gt; 其他 &gt; 光线投射法 &gt; 分离轴定理。</p>
<p>另外，有一些场景只要我们约定好限定条件，也能实现我们想要的碰撞，如下面的碰壁反弹：</p>
<iframe name="cp_embed_1" src="https://codepen.io/JChehe/embed/WRLLYX?height=270&amp;theme-id=0&amp;slug-hash=WRLLYX&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=Boundary%20collision%20detection&amp;name=cp_embed_1" scrolling="no" frameborder="0" height="270" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="Boundary collision detection" class="cp_embed_iframe " id="cp_embed_WRLLYX" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>当球碰到边框就反弹(如<code>x/y轴方向速度取反</code>)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(ball.left &lt; 0 || ball.right  &gt; rect.width)  ball.velocityX &#x3D; -ball.velocityX</span><br><span class="line">if(ball.top  &lt; 0 || ball.bottom &gt; rect.height) ball.velocityY &#x3D; -ball.velocityY</span><br></pre></td></tr></table></figure>

<p>再例如当一个人走到 <code>100px</code> 位置时不进行跳跃，就会碰到石头等等。</p>
<p>因此，某些场景只需通过设定到适当的参数即可实现碰撞检测。</p>
<h2 id="外接图形判别法"><a href="#外接图形判别法" class="headerlink" title="外接图形判别法"></a>外接图形判别法</h2><h3 id="轴对称包围盒（Axis-Aligned-Bounding-Box）"><a href="#轴对称包围盒（Axis-Aligned-Bounding-Box）" class="headerlink" title="轴对称包围盒（Axis-Aligned Bounding Box）"></a>轴对称包围盒（Axis-Aligned Bounding Box）</h3><p>概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。</p>
<p>算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rect1.x &lt; rect2.x + rect2.width &amp;&amp;</span><br><span class="line">rect1.x + rect1.width &gt; rect2.x &amp;&amp;</span><br><span class="line">rect1.y &lt; rect2.y + rect2.height &amp;&amp;</span><br><span class="line">rect1.height + rect1.y &gt; rect2.y</span><br></pre></td></tr></table></figure>

<p>两矩形间碰撞的各种情况：<br><img src="../../assets/images/2020-01-12-Collision-detection/rectangle_collision.png" alt="轴对称包围盒"></p>
<p>在线运行示例（先点击运行示例以获取焦点，下同）：</p>
<iframe name="cp_embed_2" src="https://codepen.io/JChehe/embed/rjoZdZ?height=215&amp;theme-id=0&amp;slug-hash=rjoZdZ&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=AxisAlignedBoundingBox%20collision%20detection&amp;name=cp_embed_2" scrolling="no" frameborder="0" height="215" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="AxisAlignedBoundingBox collision detection" class="cp_embed_iframe " id="cp_embed_rjoZdZ" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>缺点：</p>
<ul>
<li>相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。</li>
<li>对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。</li>
<li>物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。</li>
</ul>
<p>适用案例：</p>
<ul>
<li>（类）矩形物体间的碰撞。</li>
</ul>
<h3 id="圆形碰撞（Circle-Collision）"><a href="#圆形碰撞（Circle-Collision）" class="headerlink" title="圆形碰撞（Circle Collision）"></a>圆形碰撞（Circle Collision）</h3><p>概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。</p>
<p>两点之间的距离由以下公式可得：<br><img src="../../assets/images/2020-01-12-Collision-detection/two_point_distance.png" alt="两点之间距离"></p>
<p>判断两圆心距离是否小于两半径之和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.sqrt(Math.pow(circleA.x - circleB.x, 2) +</span><br><span class="line">          Math.pow(circleA.y - circleB.y, 2)) </span><br><span class="line">    &lt; circleA.radius + circleB.radius</span><br></pre></td></tr></table></figure>

<p>图例：<br><img src="../../assets/images/2020-01-12-Collision-detection/circle_collision.png" alt="圆形间的碰撞检测"></p>
<p>在线运行示例：</p>
<iframe name="cp_embed_3" src="https://codepen.io/JChehe/embed/EZrorG?height=219&amp;theme-id=0&amp;slug-hash=EZrorG&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=EZrorG&amp;name=cp_embed_3" scrolling="no" frameborder="0" height="219" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="EZrorG" class="cp_embed_iframe " id="cp_embed_EZrorG" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>缺点：</p>
<ul>
<li>与『轴对称包围盒』类似</li>
</ul>
<p>适用案例：</p>
<ul>
<li>（类）圆形的物体，如各种球类碰撞。</li>
</ul>
<h3 id="圆形与矩形（无旋转）"><a href="#圆形与矩形（无旋转）" class="headerlink" title="圆形与矩形（无旋转）"></a>圆形与矩形（无旋转）</h3><p>概念：通过找出矩形上离圆心最近的点，然后通过判断该点与圆心的距离是否小于圆的半径，若小于则为碰撞。</p>
<p>那如何找出矩形上离圆心最近的点呢？下面我们从 x 轴、y 轴两个方向分别进行寻找。为了方便描述，我们先约定以下变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">矩形上离圆心最近的点为变量：closestPoint &#x3D; &#123;x, y&#125;;</span><br><span class="line">矩形 rect &#x3D; &#123;x, y, w, h&#125;; &#x2F;&#x2F; 左上角与宽高</span><br><span class="line">圆形 circle &#x3D; &#123;x, y, r&#125;; &#x2F;&#x2F; 圆心与半径</span><br></pre></td></tr></table></figure>

<p>首先是 x 轴：</p>
<p>如果圆心在矩形的左侧（<code>if(circle.x &lt; rect.x)</code>），那么 <code>closestPoint.x = rect.x</code>。<br><img src="../../assets/images/2020-01-12-Collision-detection/cicle_rectangle_left.png" alt="圆心在矩形的左侧"></p>
<p>如果圆心在矩形的右侧（<code>else if(circle.x &gt; rect.x + rect.w)</code>），那么 <code>closestPoint.x = rect.x + rect.w</code>。<br><img src="../../assets/images/2020-01-12-Collision-detection/circle_rectangle_right.png" alt="圆心在矩形的右侧"></p>
<p>如果圆心在矩形的正上下方（<code>else</code>），那么 <code>closestPoint.x = circle.x</code>。<br><img src="../../assets/images/2020-01-12-Collision-detection/circle_rectangle_center.png" alt="圆心在矩形的正上下方"></p>
<p>同理，对于 y 轴（此处不列举图例）：</p>
<p>如果圆心在矩形的上方（<code>if(circle.y &lt; rect.y)</code>），那么 <code>closestPoint.y = rect.y</code>。</p>
<p>如果圆心在矩形的下方（<code>else if(circle.y &gt; rect.y + rect.h)</code>），那么 <code>closestPoint.y = rect.y + rect.h</code>。</p>
<p>如果圆心在矩形的正左右两侧（<code>else</code>），那么 <code>closestPoint.y = circle.y</code>。</p>
<p>因此，通过上述方法即可找出矩形上离圆心最近的点了，然后通过『两点之间的距离公式』得出『最近点』与『圆心』的距离，最后将其与圆的半径相比，即可判断是否发生碰撞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var distance &#x3D; Math.sqrt(Math.pow(closestPoint.x - circle.x, 2) + Math.pow(closestPoint.y - circle.y, 2))</span><br><span class="line"></span><br><span class="line">if(distance &lt; circle.r) return true &#x2F;&#x2F; 发生碰撞</span><br><span class="line">else return false &#x2F;&#x2F; 未发生碰撞</span><br></pre></td></tr></table></figure>

<p>在线运行示例：</p>
<iframe name="cp_embed_4" src="https://codepen.io/JChehe/embed/aWqpdo?height=277&amp;theme-id=0&amp;slug-hash=aWqpdo&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=Circle%20and%20Rectangle&amp;name=cp_embed_4" scrolling="no" frameborder="0" height="277" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="Circle and Rectangle" class="cp_embed_iframe " id="cp_embed_aWqpdo" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>缺点：</p>
<ul>
<li>矩形需是轴对称的，即不能旋转。</li>
</ul>
<h3 id="圆形与旋转矩形（以矩形中心为旋转轴）"><a href="#圆形与旋转矩形（以矩形中心为旋转轴）" class="headerlink" title="圆形与旋转矩形（以矩形中心为旋转轴）"></a>圆形与旋转矩形（以矩形中心为旋转轴）</h3><p>概念：即使矩形以其中心为旋转轴进行了旋转，但是判断它与圆形是否发生碰撞的本质还是找出矩形上离圆心的最近点。</p>
<p>对于旋转后的矩形，要找出其离圆心最近的点，视乎有些困难。其实，我们可以将我们思想的范围进行扩大：将矩形的旋转看作是整个画布的旋转。那么我们将画布（即 Canvas）反向旋转『矩形旋转的角度』后，所看到的结果就是上一个方法“圆形与矩形（无旋转）”的情形。因此，我们只需求出画布旋转后的圆心位置，即可使用『圆形与矩形（无旋转）』的判断方法了。</p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/circle_and_rotated_rect.png" alt="绕矩形中心旋转后的画布"></p>
<p>先给出可直接套用的公式，从而得出旋转后的圆心坐标：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x’ &#x3D; cos(β) * (cx – centerX) – sin(β) * (cy – centerY) + centerX</span><br><span class="line">y’ &#x3D; sin(β) * (cx – centerX) + cos(β) * (cy – centerY) + centerY</span><br></pre></td></tr></table></figure>



<p>下面给出该公式的推导过程：</p>
<p>根据下图，计算某个点绕另外一个点旋转一定角度后的坐标。我们设 A(x,y) 绕 B(a,b) 旋转 β 度后的位置为 C(c,d)。</p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/circle_and_rotated_rect_formula.png" alt="某个点绕另外一个点旋转一定角度后的坐标的公式推导"></p>
<ol>
<li>设 A 点旋转前的角度为 δ，则旋转（逆时针）到 C 点后的角度为(δ+β)</li>
<li>由于 |AB| 与 |CB| 相等（即长度），且<ol>
<li>|AB| = y/sin(δ) = x / cos(δ)</li>
<li>|CB| = d/sin(δ + β) = c / cos(δ + β)</li>
</ol>
</li>
<li>半径 r = x / cos(δ) = y / sin(δ) = d / sin(δ + β) = c / cos(δ + β)</li>
<li>由以下三角函数两角和差公式：<ul>
<li>sin(δ + β) = sin(δ)cos(β) + cos(δ)sin(β)</li>
<li>cos(δ + β) = cos(δ)cos(β) - sin(δ)sin(β)</li>
</ul>
</li>
<li>可得出旋转后的坐标：<ul>
<li>c = r * cos(δ + β) = r * cos(δ)cos(β) - r * sin(δ)sin(β) = x * cos(β) - y * sin(β)</li>
<li>d = r * sin(δ + β) = r * sin(δ)cos(β) + r * cos(δ)sin(β) = y * cos(β) + x * sin(β)</li>
</ul>
</li>
</ol>
<p>由上述公式推导后可得：旋转后的坐标 (c,d) 只与旋转前的坐标 (x,y) 及旋转的角度 β 有关。</p>
<p>当然，(c,d) 是旋转一定角度后『相对于旋转点（轴）的坐标』。因此，前面提到的『可直接套用的公式』中加上了矩形的中心点的坐标值。</p>
<p>从图中也可以得出以下结论：A 点旋转后的 C 点总是在圆周（半径为 |AB|）上运动，利用这点可让物体绕旋转点（轴）做圆周运动。</p>
<p>得到旋转后的圆心坐标值后，即可使用『圆形与矩形（无旋转）』方法进行碰撞检测了。</p>
<p>在线运行案例：</p>
<iframe name="cp_embed_5" src="https://codepen.io/JChehe/embed/dWmYjO?height=313&amp;theme-id=0&amp;slug-hash=dWmYjO&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=Circle%20and%20Rotated%20Rectangle%20Collision%20Detection&amp;name=cp_embed_5" scrolling="no" frameborder="0" height="313" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="Circle and Rotated Rectangle Collision Detection" class="cp_embed_iframe " id="cp_embed_dWmYjO" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>优点：</p>
<ul>
<li>相对于圆形与矩形（未旋转）的方法，适用范围更广。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="地图格子划分"><a href="#地图格子划分" class="headerlink" title="地图格子划分"></a>地图格子划分</h3><p>概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。</p>
<p><code>蓝色X</code> 为障碍物：<br><img src="../../assets/images/2020-01-12-Collision-detection/map_cell_collision.png" alt="地图格子碰撞检测"></p>
<p>实现方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过特定标识指定（非）可行区域</span><br><span class="line">map &#x3D; [</span><br><span class="line">  [0, 0, 1, 1, 1, 0, 0, 0, 0],</span><br><span class="line">  [0, 1, 1, 0, 0, 1, 0, 0, 0],</span><br><span class="line">  [0, 1, 0, 0, 0, 0, 1, 0, 0],</span><br><span class="line">  [0, 1, 0, 0, 0, 0, 1, 0, 0],</span><br><span class="line">  [0, 1, 1, 1, 1, 1, 1, 0, 0]</span><br><span class="line">],</span><br><span class="line">&#x2F;&#x2F; 设定角色的初始位置</span><br><span class="line">player &#x3D; &#123;left: 2, top: 2&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移动前（后）判断角色的下一步的动作（如不能前行）</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在线运行示例：</p>
<iframe name="cp_embed_6" src="https://codepen.io/JChehe/embed/pRqqGV?height=268&amp;theme-id=0&amp;slug-hash=pRqqGV&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=map%20cell%20collision%20detection&amp;name=cp_embed_6" scrolling="no" frameborder="0" height="268" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="map cell collision detection" class="cp_embed_iframe " id="cp_embed_pRqqGV" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>缺点：</p>
<ul>
<li>适用场景局限。</li>
</ul>
<p>适用案例：</p>
<ul>
<li>推箱子、踩地雷等</li>
</ul>
<h3 id="像素检测"><a href="#像素检测" class="headerlink" title="像素检测"></a>像素检测</h3><p>概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。</p>
<p>实现方法有多种，下面列举在 Canvas 中的两种实现方式：</p>
<ol>
<li>如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。</li>
<li>利用 canvas 的 <code>globalCompositeOperation = &#39;destination-in&#39;</code> 属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。</li>
</ol>
<p>注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。</p>
<blockquote>
<p>offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是<strong>内存</strong>。渲染到内存比渲染到屏幕更快。—— <a href="http://devbutze.blogspot.com/2014/02/html5-canvas-offscreen-rendering.html" target="_blank" rel="noopener">Offscreen Rendering</a></p>
</blockquote>
<p>当然，我们这里并不是利用 <code>offscreen render</code> 的性能优势，而是利用 <code>offscreen canvas</code> 保存独立物体的像素。换句话说：<strong>onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行</strong>。</p>
<p>另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者<strong>相交区域</strong>，然后只对该区域内的像素进行检测即可。</p>
<p>图例：<br><img src="../../assets/images/2020-01-12-Collision-detection/pixel_collision.png" alt="像素检测"></p>
<p>下面示例展示了第一种实现方式：</p>
<iframe name="cp_embed_7" src="https://codepen.io/JChehe/embed/qRLLzB?height=307&amp;theme-id=0&amp;slug-hash=qRLLzB&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=pixel%20collision%20detection&amp;name=cp_embed_7" scrolling="no" frameborder="0" height="307" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="pixel collision detection" class="cp_embed_iframe " id="cp_embed_qRLLzB" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>缺点：</p>
<ul>
<li>因为需要检查每一像素来判定是否碰撞，性能要求比较高。</li>
</ul>
<p>适用案例：</p>
<ul>
<li>需要以像素级别检测物体是否碰撞。</li>
</ul>
<h2 id="光线投射法（Ray-Casting）"><a href="#光线投射法（Ray-Casting）" class="headerlink" title="光线投射法（Ray Casting）"></a>光线投射法（Ray Casting）</h2><p>概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。</p>
<p>对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线(<code>#1</code>)，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线(<code>#2</code>)，根据两条线的交点位置来判定是否发生碰撞。</p>
<p>抛球进桶图例：<br><img src="../../assets/images/2020-01-12-Collision-detection/ray_casting_collision.png" alt="光线投射法"></p>
<p>在小球飞行的过程中，需要不断计算两直线的交点。</p>
<p>当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中：</p>
<ul>
<li>两直线交点在桶口的左右边沿间</li>
<li>小球位于第二条线（<code>#2</code>）下方</li>
</ul>
<p>在线运行示例：</p>
<iframe name="cp_embed_8" src="https://codepen.io/JChehe/embed/ZLVwwE?height=517&amp;theme-id=0&amp;slug-hash=ZLVwwE&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=ray%20casting%20collision%20detection&amp;name=cp_embed_8" scrolling="no" frameborder="0" height="517" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="ray casting collision detection" class="cp_embed_iframe " id="cp_embed_ZLVwwE" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>优点：</p>
<ul>
<li>适合运动速度快的物体</li>
</ul>
<p>缺点：</p>
<ul>
<li>适用范围相对局限。</li>
</ul>
<p>适用案例：</p>
<ul>
<li>抛球运动进桶。</li>
</ul>
<h2 id="分离轴定理（Separating-Axis-Theorem）"><a href="#分离轴定理（Separating-Axis-Theorem）" class="headerlink" title="分离轴定理（Separating Axis Theorem）"></a>分离轴定理（Separating Axis Theorem）</h2><p>概念：通过判断任意两个 <code>凸多边形</code> 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。</p>
<p>图例：<br><img src="../../assets/images/2020-01-12-Collision-detection/sat_base.png" alt="分离轴定理"></p>
<p>在程序中，遍历所有角度是不现实的。那如何确定 <code>投影轴</code> 呢？其实<strong>投影轴的数量与多边形的边数相等即可。</strong></p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/sat_projection_two.png" alt="https://misc.aotu.io/JChehe/2017-02-13-2d-collision-detection/sat_projection_two.png"></p>
<p>以较高抽象层次判断两个凸多边形是否碰撞：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function polygonsCollide(polygon1, polygon2) &#123;</span><br><span class="line">    var axes, projection1, projection2</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据多边形获取所有投影轴</span><br><span class="line">    axes &#x3D; polygon1.getAxes()</span><br><span class="line">    axes.push(polygon2.getAxes())</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 遍历所有投影轴，获取多边形在每条投影轴上的投影</span><br><span class="line">    for(each axis in axes) &#123;</span><br><span class="line">        projection1 &#x3D; polygon1.project(axis)</span><br><span class="line">        projection2 &#x3D; polygon2.project(axis)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。</span><br><span class="line">        if(!projection1.overlaps(projection2))</span><br><span class="line">            return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码有几个需要解决的地方：</p>
<ul>
<li>如何确定多边形的各个投影轴</li>
<li>如何将多边形投射到某条投影轴上</li>
<li>如何检测两段投影是否发生重叠</li>
</ul>
<h4 id="投影轴"><a href="#投影轴" class="headerlink" title="投影轴"></a>投影轴</h4><p>如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为<strong>边缘向量</strong>。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“<strong>边缘法向量</strong>”。</p>
<p><strong>投影轴</strong>平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。</p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/sat_projection_one.png" alt="投影轴"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。</span><br><span class="line">var v1 &#x3D; new Vector(p1.x, p1.y)</span><br><span class="line">    v2 &#x3D; new Vector(p2.x, p2.y)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。</span><br><span class="line">&#x2F;&#x2F; 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。</span><br><span class="line">&#x2F;&#x2F; 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 &#x3D; 0 可得：(-B,A) 或 (B,-A)。</span><br><span class="line">    axis &#x3D; v1.edge(v2).normal()</span><br></pre></td></tr></table></figure>

<p>以下是向量对象的部分实现，具体可看源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Vector &#x3D; function(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x</span><br><span class="line">    this.y &#x3D; y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vector.prototype &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取向量大小（即向量的模），即两点间距离</span><br><span class="line">    getMagnitude: function() &#123;</span><br><span class="line">        return Math.sqrt(Math.pow(this.x, 2),</span><br><span class="line">                         Math.pow(this.y, 2))</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。</span><br><span class="line">    &#x2F;&#x2F; 后续将会用其计算出投影的长度</span><br><span class="line">    dotProduct: function(vector) &#123;</span><br><span class="line">        return this.x * vector.x + this.y + vector.y</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 向量相减 得到边</span><br><span class="line">    subtarct: function(vector) &#123;</span><br><span class="line">        var v &#x3D; new Vector()</span><br><span class="line">        v.x &#x3D; this.x - vector.x</span><br><span class="line">        v.y &#x3D; this.y - vector.y</span><br><span class="line">        return v</span><br><span class="line">    &#125;,</span><br><span class="line">    edge: function(vector) &#123;</span><br><span class="line">        return this.substract(vector)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 获取当前向量的法向量（垂直）</span><br><span class="line">    perpendicular: function() &#123;</span><br><span class="line">        var v &#x3D; new Vector()</span><br><span class="line">        v.x &#x3D; this.y</span><br><span class="line">        v.y &#x3D; 0 - this.x</span><br><span class="line">        return v</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量</span><br><span class="line">    normalize: function() &#123;</span><br><span class="line">        var v &#x3D; new Vector(0, 0)</span><br><span class="line">            m &#x3D; this.getMagnitude()</span><br><span class="line">        if(m !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">            v.x &#x3D; this.x &#x2F; m</span><br><span class="line">            v.y &#x3D; this.y &#x2F;m</span><br><span class="line">        &#125;</span><br><span class="line">        return v</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; 获取边缘法向量的单位向量，即投影轴</span><br><span class="line">    normal: function() &#123;</span><br><span class="line">        var p &#x3D; this.perpendicular()</span><br><span class="line">        return p .normalize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-01-12-Collision-detection/vector_subtract.png" alt="此处输入图片的描述"><br>向量相减</p>
<p>更多关于向量的知识可通过其它渠道学习。</p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。</p>
<p>判断两多边形的投影是否重合：<code>projection1.max &gt; projection2.min &amp;&amp; project2.max &gt; projection.min</code></p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/sat_project_length.png" alt="此处输入图片的描述"><br>为了易于理解，示例图将坐标轴<code>原点(0,0)</code>放置于三角形<code>边1</code>投影轴的适当位置。</p>
<p>由上述可得投影对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置</span><br><span class="line">var Projection &#x3D; function (min, max) &#123;</span><br><span class="line">    this.min</span><br><span class="line">    this.max</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">projection.prototype &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断两投影是否重叠</span><br><span class="line">    overlaps: function(projection) &#123;</span><br><span class="line">        return this.max &gt; projection.min &amp;&amp; projection.max &gt; this.min</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何得到向量在投影轴上的长度？<br>向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。<br>由于<strong>投影轴</strong>是单位向量（长度为<code>1</code>），投影的长度为 <code>x1 * x2 + y1 * y2</code></p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/dot_product.png" alt="点积"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。</span><br><span class="line">function project &#x3D; function (axis) &#123;</span><br><span class="line">    var scalars &#x3D; [], v &#x3D; new Vector()</span><br><span class="line">    </span><br><span class="line">    this.points.forEach(function (point) &#123;</span><br><span class="line">        v.x &#x3D; point.x</span><br><span class="line">        v.y &#x3D; point.y</span><br><span class="line">        scalars.push(v.dotProduct(axis))</span><br><span class="line">    &#125;)</span><br><span class="line">    return new Projection(Math.min.apply(Math, scalars),</span><br><span class="line">                          Math.max,apply(Math, scalars))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="圆形与多边形之间的碰撞检测"><a href="#圆形与多边形之间的碰撞检测" class="headerlink" title="圆形与多边形之间的碰撞检测"></a>圆形与多边形之间的碰撞检测</h4><p>由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示：</p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/sat_projection_circle.png" alt="圆形与多边形的投影轴"></p>
<p>因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。</p>
<p>而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。</p>
<p>分离轴定理的整体代码实现，可查看以下案例：</p>
<iframe name="cp_embed_9" src="https://codepen.io/JChehe/embed/KabEaw?height=364&amp;theme-id=0&amp;slug-hash=KabEaw&amp;default-tab=result&amp;user=JChehe&amp;embed-version=2&amp;pen-title=SeparatingAxisTheorem&amp;name=cp_embed_9" scrolling="no" frameborder="0" height="364" allowtransparency="true" allowfullscreen="true" allowpaymentrequest="true" title="SeparatingAxisTheorem" class="cp_embed_iframe " id="cp_embed_KabEaw" style="box-sizing: border-box; margin: 0px; padding: 0px; border: 0px; outline: 0px; font-style: inherit; font-family: inherit; font-size: 16px; vertical-align: baseline; width: 1230px; overflow: hidden; display: block;"></iframe>



<p>优点：</p>
<ul>
<li>精确</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适用于凹多边形</li>
</ul>
<p>适用案例：</p>
<ul>
<li>任意凸多边形和圆形。</li>
</ul>
<p>更多关于分离轴定理的资料：</p>
<ul>
<li><a href="http://www.sevenson.com.au/actionscript/sat/" target="_blank" rel="noopener">Separating Axis Theorem (SAT) explanation</a></li>
<li><a href="http://www.metanetsoftware.com/technique/tutorialA.html" target="_blank" rel="noopener">Collision detection and response</a></li>
<li><a href="http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169" target="_blank" rel="noopener">Collision detection Using the Separating Axis Theorem</a></li>
<li><a href="http://www.codezealot.org/archives/55" target="_blank" rel="noopener">SAT (Separating Axis Theorem)</a></li>
<li><a href="http://rocketmandevelopment.com/blog/separation-of-axis-theorem-for-collision-detection/" target="_blank" rel="noopener">Separation of Axis Theorem (SAT) for Collision Detection</a></li>
</ul>
<h4 id="延伸：最小平移向量（MIT）"><a href="#延伸：最小平移向量（MIT）" class="headerlink" title="延伸：最小平移向量（MIT）"></a>延伸：最小平移向量（MIT）</h4><p>通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。</p>
<p><img src="../../assets/images/2020-01-12-Collision-detection/mit.png" alt="最小平移向量"></p>
<h3 id="碰撞性能优化"><a href="#碰撞性能优化" class="headerlink" title="碰撞性能优化"></a>碰撞性能优化</h3><p>若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。</p>
<h4 id="粗略阶段（Broad-Phase）"><a href="#粗略阶段（Broad-Phase）" class="headerlink" title="粗略阶段（Broad Phase）"></a>粗略阶段（Broad Phase）</h4><p>Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供这些信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。</p>
<p>读者若感兴趣，可以自行查阅相关信息。</p>
<h4 id="精细阶段（Narrow-Phase）"><a href="#精细阶段（Narrow-Phase）" class="headerlink" title="精细阶段（Narrow Phase）"></a>精细阶段（Narrow Phase）</h4><p>当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>碰撞检测有多种，选择合适最重要。</p>
<p>完！</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection" target="_blank" rel="noopener">MDN：2D collision detection</a></li>
<li><a href="https://item.jd.com/11231175.html?dist=jd" target="_blank" rel="noopener">《HTML5 Canvas 核心技术：图形、动画与游戏开发》</a></li>
<li><a href="http://lazyfoo.net/SDL_tutorials/lesson19/index.php" target="_blank" rel="noopener">Circular Collision Detection</a></li>
<li><a href="http://www.migapro.com/circle-and-rotated-rectangle-collision-detection/" target="_blank" rel="noopener">Circle and Rotated Rectangle Collision Detection</a></li>
<li><a href="http://www.cnblogs.com/ywxgod/archive/2010/08/06/1793609.html" target="_blank" rel="noopener">推导坐标旋转公式</a></li>
</ul>
<p>感谢您的阅读，本文由 <a href="https://aotu.io/" target="_blank" rel="noopener">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2017/02/16/2d-collision-detection/）" target="_blank" rel="noopener">https://aotu.io/notes/2017/02/16/2d-collision-detection/）</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>地图</tag>
        <tag>游戏开发</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>unity攻击范围检测</title>
    <url>/unity-2020-01-13-unity-attack-detection/</url>
    <content><![CDATA[<h1 id="扇形攻击"><a href="#扇形攻击" class="headerlink" title="扇形攻击"></a>扇形攻击</h1><p>其实这个分为两部分，</p>
<ul>
<li><p>是在扇形距离范围内（也就是不考虑角度，其实是圆形范围内）Vector3.Distance(a, b);计算距离</p>
</li>
<li><p>是扇形角度范围内</p>
</li>
</ul>
<p>计算怪物是否在你的视野范围内其实可以这么看<br><img src="../../assets/images/2020-01-13-unity-attack-detection/80f6c4220d181e73991a8dfdfda32a81.png" alt="【小松教你手游开发】【unity实用技能】计算目标物体是否在自己的扇形视野范围"></p>
<p>Avatar的正方向向量与Avatar到Enemy之间向量的夹角大小是否小于于视线大小的一半。</p>
<p>这样就能判断是否在视线范围内。</p>
<p>所以现在的问题就是这么计算这个夹角</p>
<p>计算的方式是，</p>
<ol>
<li><p>获取Avatar正方向的一个点与Avatar世界坐标相减，获取正方向向量</p>
</li>
<li><p>Enemy的世界坐标与Avatar世界坐标相减，获取Enemy到Avatar的方向向量</p>
</li>
<li><p>调用Vector3.Angle(a, b)计算夹角</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   public GameObject avatar;</span><br><span class="line">   public GameObject enemy;</span><br><span class="line">   </span><br><span class="line">&#x2F;&#x2F;扇形距离 攻击距离  扇形的半径 </span><br><span class="line">   float minDistance &#x3D; 10f;</span><br><span class="line">   &#x2F;&#x2F;扇形的角度 也就是攻击的角度</span><br><span class="line">   float minAngle &#x3D; 120f;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; Update is called once per frame</span><br><span class="line">   void Update ()</span><br><span class="line">   &#123;</span><br><span class="line">       Vector3 avatarPos &#x3D; avatar.transform.position;</span><br><span class="line">       Vector3 enemyPos &#x3D; enemy.transform.position;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F;与敌人的距离</span><br><span class="line">       float distance &#x3D; Vector3.Distance(avatarPos, enemyPos);</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;主角相对于目标的向量</span><br><span class="line">       Vector3 srcLocalVect &#x3D; enemyPos - avatarPos;</span><br><span class="line">       srcLocalVect.y &#x3D; 0;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;获取主角正前方的一个点</span><br><span class="line">       Vector3 forwardLocalPos &#x3D; avatar.transform.forward * 1 + avatarPos;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;获取正方向向量</span><br><span class="line">       Vector3 forwardLocalVect &#x3D; forwardLocalPos - avatarPos;</span><br><span class="line">       forwardLocalVect.y &#x3D; 0;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F;计算角度</span><br><span class="line">       float angle &#x3D; Vector3.Angle(srcLocalVect, forwardLocalVect);</span><br><span class="line"></span><br><span class="line">       if(distance &lt; minDistance &amp;&amp; angle &lt; minAngle&#x2F;2)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(&quot;In EyeSight&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h1 id="长方形范围攻击检测"><a href="#长方形范围攻击检测" class="headerlink" title="长方形范围攻击检测"></a>长方形范围攻击检测</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AttackCHeck : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;要攻击的目标</span><br><span class="line">    public Transform Target;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;计算玩家与敌人的距离</span><br><span class="line">        float distance &#x3D; Vector3.Distance(transform.position, Target.position);</span><br><span class="line">        &#x2F;&#x2F;玩家与敌人的方向向量</span><br><span class="line">        Vector3 temVec &#x3D; Target.position - transform.position;</span><br><span class="line">        &#x2F;&#x2F;与玩家正前方做点积</span><br><span class="line">        float forwardDistance &#x3D; Vector3.Dot(temVec, transform.forward.normalized);</span><br><span class="line">        if (forwardDistance &gt; 0 &amp;&amp; forwardDistance &lt;&#x3D; 10)</span><br><span class="line">        &#123;</span><br><span class="line">            float rightDistance &#x3D; Vector3.Dot(temVec, transform.right.normalized);</span><br><span class="line"></span><br><span class="line">            if (Mathf.Abs(rightDistance) &lt;&#x3D; 3)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;进入攻击范围&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断目标点是否在指定的矩形内（两个随机点确定的矩形）"><a href="#判断目标点是否在指定的矩形内（两个随机点确定的矩形）" class="headerlink" title="判断目标点是否在指定的矩形内（两个随机点确定的矩形）"></a>判断目标点是否在指定的矩形内（两个随机点确定的矩形）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Rectangle01</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Min为当前坐标系中矩形的最小点</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Max为当前坐标系中矩形的最大点</span><br><span class="line">    public Vector2 Min;</span><br><span class="line">    public Vector2 Max;</span><br><span class="line"> </span><br><span class="line">    public bool Contains( Vector2 point)</span><br><span class="line">    &#123;</span><br><span class="line">        if (point.x &lt; this.Min.x)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (point.x &gt; this.Max.x)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (point.y &lt; this.Min.y)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (point.y &gt; this.Max.y)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)</span><br><span class="line">    &#123;</span><br><span class="line">        vertex0 &#x3D; this.Min;</span><br><span class="line">        vertex1 &#x3D; new Vector2(this.Max.x, this.Min.y);</span><br><span class="line">        vertex2 &#x3D; this.Max;</span><br><span class="line">        vertex3 &#x3D; new Vector2(this.Min.x, this.Max.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试   脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestRt01 : MonoBehaviour &#123;</span><br><span class="line"> </span><br><span class="line">    public Transform Point;</span><br><span class="line">    public Transform RtPoint0, RtPoint1;</span><br><span class="line">    public Rectangle01 rtBox;</span><br><span class="line"> </span><br><span class="line">    private const float _pointRadius &#x3D; 0.1f;</span><br><span class="line">  </span><br><span class="line">    private void OnDrawGizmos()</span><br><span class="line">    &#123;</span><br><span class="line">        if (rtBox !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            DrawRt(rtBox);</span><br><span class="line">            Gizmos.DrawSphere(Point.position, _pointRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyDown(KeyCode.Q))</span><br><span class="line">        &#123;</span><br><span class="line">            rtBox &#x3D; CreateFromTwoPoints(RtPoint0.position, RtPoint1.position);</span><br><span class="line">            bool cont &#x3D; rtBox.Contains(Point.position);</span><br><span class="line">            if (cont)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;目标点在矩形范围内&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;目标点不在矩形范围内&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public Rectangle01 CreateFromTwoPoints(Vector2 point0, Vector2 point1)</span><br><span class="line">    &#123;</span><br><span class="line">        Rectangle01 rt &#x3D; new Rectangle01();</span><br><span class="line">        if (point0.x &lt; point1.x)</span><br><span class="line">        &#123;</span><br><span class="line">            rt.Min.x &#x3D; point0.x;</span><br><span class="line">            rt.Max.x &#x3D; point1.x;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            rt.Min.x &#x3D; point1.x;</span><br><span class="line">            rt.Max.x &#x3D; point0.x;</span><br><span class="line">        &#125;</span><br><span class="line">        if (point0.y &lt; point1.y)</span><br><span class="line">        &#123;</span><br><span class="line">            rt.Min.y &#x3D; point0.y;</span><br><span class="line">            rt.Max.y &#x3D; point1.y;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            rt.Min.y &#x3D; point1.y;</span><br><span class="line">            rt.Max.y &#x3D; point0.y;</span><br><span class="line">        &#125;</span><br><span class="line">        return rt;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void DrawRt( Rectangle01 box)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 v0, v1, v2, v3;</span><br><span class="line">        box.CalcVertices(out v0, out v1, out v2, out v3);</span><br><span class="line">        Gizmos.color &#x3D; Color.blue;</span><br><span class="line">        Gizmos.DrawLine(v0, v1);</span><br><span class="line">        Gizmos.DrawLine(v1, v2);</span><br><span class="line">        Gizmos.DrawLine(v2, v3);</span><br><span class="line">        Gizmos.DrawLine(v3, v0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）"><a href="#判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）" class="headerlink" title="判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）"></a>判断目标点是否在某一矩形区域（以任一点为中心的矩形区域）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Box &#123;</span><br><span class="line"> </span><br><span class="line">    public Vector2 Center;</span><br><span class="line">    public Vector2 Axis0;</span><br><span class="line">    public Vector2 Axis1;</span><br><span class="line">    public Vector2 Extents;</span><br><span class="line"> </span><br><span class="line">    public Box(Vector2 center, Vector2 axis0, Vector2 axis1, Vector2 extents)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Center &#x3D; center;</span><br><span class="line">        this.Axis0 &#x3D; axis0;</span><br><span class="line">        this.Axis1 &#x3D; axis1;</span><br><span class="line">        this.Extents &#x3D; extents;</span><br><span class="line">    &#125;</span><br><span class="line">    public bool Contains(Vector2 point)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 vector;</span><br><span class="line">        vector.x &#x3D; point.x - this.Center.x;</span><br><span class="line">        vector.y &#x3D; point.y - this.Center.y;</span><br><span class="line">        float num &#x3D; vector.Dot(ref this.Axis0);</span><br><span class="line">        if (num &lt; -this.Extents.x)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num &gt; this.Extents.x)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        num &#x3D; vector.Dot(ref this.Axis1);</span><br><span class="line">        if (num &lt; -this.Extents.y)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num &gt; this.Extents.y)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void CalcVertices(out Vector2 vertex0, out Vector2 vertex1, out Vector2 vertex2, out Vector2 vertex3)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 vector &#x3D; (Vector2)(this.Axis0 * this.Extents.x);</span><br><span class="line">        Vector2 vector2 &#x3D; (Vector2)(this.Axis1 * this.Extents.y);</span><br><span class="line">        vertex0 &#x3D; (this.Center - vector) - vector2;</span><br><span class="line">        vertex1 &#x3D; (this.Center + vector) - vector2;</span><br><span class="line">        vertex2 &#x3D; (this.Center + vector) + vector2;</span><br><span class="line">        vertex3 &#x3D; (this.Center - vector) + vector2;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static class Vector2ex</span><br><span class="line">&#123;</span><br><span class="line">    public static float Dot(this Vector2 vector, ref Vector2 value)</span><br><span class="line">    &#123;</span><br><span class="line">        return ((vector.x * value.x) + (vector.y * value.y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class TestBox : MonoBehaviour &#123;</span><br><span class="line"> </span><br><span class="line">    public Transform Point;</span><br><span class="line">    public Transform rtBox;</span><br><span class="line">    Box box;</span><br><span class="line">    private const float _pointRadius &#x3D; .11f;</span><br><span class="line">    private void OnDrawGizmos()</span><br><span class="line">    &#123;</span><br><span class="line">        if (box!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            Gizmos.DrawSphere(Point.position, _pointRadius);</span><br><span class="line">            DrawBox(ref box);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyDown(KeyCode.Q))</span><br><span class="line">        &#123;</span><br><span class="line">            box &#x3D; new Box(rtBox.position, rtBox.right, rtBox.up, rtBox.localScale); ;</span><br><span class="line">            bool cont &#x3D; box.Contains(Point.position);</span><br><span class="line">            if (cont)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;目标点在矩形范围内&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;目标点不在矩形范围内&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected void DrawBox(ref Box box)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 v0, v1, v2, v3;</span><br><span class="line"> </span><br><span class="line">        box.CalcVertices(out v0, out v1, out v2, out v3);</span><br><span class="line">        Gizmos.color &#x3D; Color.blue;</span><br><span class="line">        Gizmos.DrawLine(v0, v1);</span><br><span class="line">        Gizmos.DrawLine(v1, v2);</span><br><span class="line">        Gizmos.DrawLine(v2, v3);</span><br><span class="line">        Gizmos.DrawLine(v3, v0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="半圆形攻击范围检测"><a href="#半圆形攻击范围检测" class="headerlink" title="半圆形攻击范围检测"></a>半圆形攻击范围检测</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class AttackCHeck : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;要攻击的目标</span><br><span class="line">    public Transform Target;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;计算玩家与敌人的距离</span><br><span class="line">        float distance &#x3D; Vector3.Distance(transform.position, Target.position);</span><br><span class="line">        &#x2F;&#x2F;玩家与敌人的方向向量</span><br><span class="line">        Vector3 temVec &#x3D; Target.position - transform.position;</span><br><span class="line">        &#x2F;&#x2F;与玩家正前方做点积</span><br><span class="line">        float forwardDistance &#x3D; Vector3.Dot(temVec, transform.forward.normalized);</span><br><span class="line">        if (forwardDistance &gt; 0 &amp;&amp; forwardDistance &lt;&#x3D; 10)</span><br><span class="line">        &#123;</span><br><span class="line">            if (distance &lt;&#x3D; 5)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;进入攻击范围&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="圆形攻击范围"><a href="#圆形攻击范围" class="headerlink" title="圆形攻击范围"></a>圆形攻击范围</h1><p>圆形攻击范围有两种，以玩着荣耀的王昭君大招为例子，</p>
<p>第一种是制定位置施法：新版本的王昭君的大招是指定位置施法的，也就是说在玩家固定施法半径以内可随意放一个圆形的技能。在半径之内的敌人受伤。</p>
<p>第二种是固定位置施法：老版本的王昭君大招是在自身一定半径以内，敌人在这个范围内受伤。</p>
<p>其实两种判断都很简单，只需要判断敌人和SkillPosition之间的距离是否小于半径即可。</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20180425195609483.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 不定点式圆形攻击</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;attacked&quot;&gt;被攻击方&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;skillPosition&quot;&gt;技能释放位置&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;radius&quot;&gt;半径&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">    public bool CircleAttack(Transform attacked,Transform skillPosition, float radius)</span><br><span class="line">    &#123;</span><br><span class="line">        float distance &#x3D; Vector3.Distance(attacked.position, skillPosition.position);</span><br><span class="line">        if (distance &lt; radius)</span><br><span class="line">        &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>方法2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Circle &#123;</span><br><span class="line"> </span><br><span class="line">    public Vector2 Center;</span><br><span class="line">    public float Radius;</span><br><span class="line"> </span><br><span class="line">    public Circle(Vector2 center, float radius)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Center &#x3D; center;</span><br><span class="line">        this.Radius &#x3D; radius;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public bool Contains( Vector2 point)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 vector &#x3D; point - this.Center;</span><br><span class="line">        return (vector.SqrMagnitude() &lt;&#x3D; (this.Radius * this.Radius));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Vector2 Eval(float t)</span><br><span class="line">    &#123;</span><br><span class="line">        return new Vector2(this.Center.x + (this.Radius * Mathf.Cos(t)), this.Center.y + (this.Radius * Mathf.Sin(t)));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h1 id="判断一个点是否在三角形里面"><a href="#判断一个点是否在三角形里面" class="headerlink" title="判断一个点是否在三角形里面"></a>判断一个点是否在三角形里面</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static  bool InTrigon(Vector3 _target,Vector3 _center,Vector3 _left,Vector3 _right)&#123;  </span><br><span class="line">        Vector3 Ctl&#x3D;_left-_center;  </span><br><span class="line">        Vector3 Ctr&#x3D;_right -_center;  </span><br><span class="line">        Vector3 Ctt&#x3D;_target-_center;  </span><br><span class="line">        Vector3 Ltr&#x3D;_right-_left;  </span><br><span class="line">        Vector3 Ltc&#x3D;_right-_center;  </span><br><span class="line">        Vector3 Ltt&#x3D;_left-_target;  </span><br><span class="line">        Vector3 Rtl&#x3D;_left-_right;  </span><br><span class="line">        Vector3 Rtc&#x3D;_center-_right;  </span><br><span class="line">        Vector3 Rtt&#x3D;_target-_right;  </span><br><span class="line">        if(   </span><br><span class="line">           Vector3.Dot(Vector3.Cross(Ctl,Ctr).normalized,Vector3.Cross(Ctl,Ctt).normalized)&#x3D;&#x3D;1&amp;&amp;  </span><br><span class="line">           Vector3.Dot(Vector3.Cross(Ltr,Ltc).normalized,Vector3.Cross(Ltr,Ltt).normalized)&#x3D;&#x3D;1&amp;&amp;  </span><br><span class="line">           Vector3.Dot(Vector3.Cross(Rtc,Rtl).normalized,Vector3.Cross(Rtc,Rtt).normalized)&#x3D;&#x3D;1  </span><br><span class="line">           )  </span><br><span class="line">            return true;  </span><br><span class="line">        else  </span><br><span class="line">            return false;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原理：通过向量之间的对比，利用点乘和差乘实现判断一个点是否在三角形里面。</p>
<p>叉乘： 叉乘结果用右手判断法则。</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Triangle </span><br><span class="line">&#123;</span><br><span class="line">    public enum Orientations</span><br><span class="line">    &#123;</span><br><span class="line">        CW,&#x2F;&#x2F;三个点顺时针</span><br><span class="line">        CCW,&#x2F;&#x2F;三个点逆时针</span><br><span class="line">        None&#x2F;&#x2F;不清楚点的顺序</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Vector2 V0;</span><br><span class="line">    public Vector2 V1;</span><br><span class="line">    public Vector2 V2;</span><br><span class="line">    public Triangle(Vector2 v0, Vector2 v1, Vector2 v2)</span><br><span class="line">    &#123;</span><br><span class="line">        this.V0 &#x3D; v0;</span><br><span class="line">        this.V1 &#x3D; v1;</span><br><span class="line">        this.V2 &#x3D; v2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Triangle CreateTriangle2(Transform v0, Transform v1, Transform v2)</span><br><span class="line">    &#123;</span><br><span class="line">        return new Triangle(v0.position, v1.position, v2.position);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Orientations CalcOrientation(float threshold &#x3D; 1E-05f)</span><br><span class="line">    &#123;</span><br><span class="line">        float num &#x3D; this.CalcDeterminant();</span><br><span class="line">        if (num &gt; threshold)</span><br><span class="line">        &#123;</span><br><span class="line">            return Orientations.CCW;</span><br><span class="line">        &#125;</span><br><span class="line">        if (num &lt; -threshold)</span><br><span class="line">        &#123;</span><br><span class="line">            return Orientations.CW;</span><br><span class="line">        &#125;</span><br><span class="line">        return Orientations.None;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public float CalcDeterminant()</span><br><span class="line">    &#123;</span><br><span class="line">        return ((((((this.V1.x * this.V2.y) + (this.V0.x * this.V1.y)) + (this.V2.x * this.V0.y)) - (this.V1.x * this.V0.y)) - (this.V2.x * this.V1.y)) - (this.V0.x * this.V2.y));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public bool Contains(Vector2 point)</span><br><span class="line">    &#123;</span><br><span class="line">        bool flag &#x3D; (((point.x - this.V1.x) * (this.V0.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V0.x - this.V1.x))) &lt; 0f;</span><br><span class="line">        bool flag2 &#x3D; (((point.x - this.V2.x) * (this.V1.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V1.x - this.V2.x))) &lt; 0f;</span><br><span class="line">        if (flag !&#x3D; flag2)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag3 &#x3D; (((point.x - this.V0.x) * (this.V2.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V2.x - this.V0.x))) &lt; 0f;</span><br><span class="line">        return (flag2 &#x3D;&#x3D; flag3);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 当已经知道 三个顶点的顺序是逆时针方向的时候使用</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;point&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">    public bool ContainsCCW(Vector2 point)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) &gt; 0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) &gt; 0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) &gt; 0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 当已经知道 三个顶点的顺序是顺时针方向的时候使用</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;point&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">    public bool ContainsCW(Vector2 point)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((((point.x - this.V0.x) * (this.V1.y - this.V0.y)) - ((point.y - this.V0.y) * (this.V1.x - this.V0.x))) &lt; 0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((((point.x - this.V1.x) * (this.V2.y - this.V1.y)) - ((point.y - this.V1.y) * (this.V2.x - this.V1.x))) &lt; 0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((((point.x - this.V2.x) * (this.V0.y - this.V2.y)) - ((point.y - this.V2.y) * (this.V0.x - this.V2.x))) &lt; 0f)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class TriangleTest : MonoBehaviour &#123;</span><br><span class="line">    public Transform Point;</span><br><span class="line">    public Transform V0, V1, V2;</span><br><span class="line">    Triangle triangle;</span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyDown(KeyCode.Q))</span><br><span class="line">        &#123;</span><br><span class="line">            triangle &#x3D; Triangle.CreateTriangle2(V0, V1, V2);</span><br><span class="line">            Triangle.Orientations orientation &#x3D; triangle.CalcOrientation();</span><br><span class="line"> </span><br><span class="line">            bool cont &#x3D; false;</span><br><span class="line">            if (orientation &#x3D;&#x3D; Triangle.Orientations.CCW)</span><br><span class="line">            &#123;</span><br><span class="line">                 cont &#x3D; triangle.Contains(Point.position);</span><br><span class="line">                 &#x2F;&#x2F;cont1 &#x3D; triangle.ContainsCCW(Point.position); &#x2F;&#x2F; 如果你知道三角形方向(顶点顺序方向)，就用这个</span><br><span class="line">            &#125;</span><br><span class="line">            else if (orientation &#x3D;&#x3D; Triangle.Orientations.CW)</span><br><span class="line">            &#123;</span><br><span class="line">                 cont &#x3D; triangle.Contains(Point.position);</span><br><span class="line">                 &#x2F;&#x2F;cont1 &#x3D; triangle.ContainsCW(Point.position); &#x2F;&#x2F; 如果你知道三角形方向(顶点顺序方向)，就用这个</span><br><span class="line">            &#125;</span><br><span class="line">            else &#x2F;&#x2F; Degenerate</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;Triangle is degenerate&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cont)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;目标点在矩形范围内&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(&quot;目标点不在矩形范围内&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnDrawGizmos()</span><br><span class="line">    &#123;</span><br><span class="line">        if (triangle!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            DrawTriangle( triangle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    void DrawTriangle( Triangle triangle)</span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color &#x3D; Color.blue;</span><br><span class="line">        Gizmos.DrawLine(triangle.V0, triangle.V1);</span><br><span class="line">        Gizmos.DrawLine(triangle.V1, triangle.V2);</span><br><span class="line">        Gizmos.DrawLine(triangle.V2, triangle.V0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p>其实这些小算法基本上用的全是向量的计算,向量的计算有两种</p>
<h3 id="向量的点乘"><a href="#向量的点乘" class="headerlink" title="向量的点乘"></a>向量的点乘</h3><p>–&gt;A . B = |A| * |B| * cos θ<br>–&gt;点乘应用</p>
<ol>
<li>如果 让 A 等于单位向量 |A| ==1 c点积 等于 B 在 A 上的投影</li>
<li>如果 让 A B等于单位向量 arccos(a.b) == 夹角</li>
</ol>
<h3 id="向量的叉乘"><a href="#向量的叉乘" class="headerlink" title="向量的叉乘"></a>向量的叉乘</h3><p>–&gt;A* B = C C就是A和B的法向量<br>–&gt;叉乘应用</p>
<ol>
<li>c 是有方向 。 通过 左手 定则 可以知道 C 的方向</li>
<li>所以叉乘一般是用来计算方向的</li>
<li>A 和 B 都是单位向量 arcsin(|A*B|) 等于 夹角</li>
</ol>
<h1 id="凸多边形碰撞-分离轴定理算法"><a href="#凸多边形碰撞-分离轴定理算法" class="headerlink" title="凸多边形碰撞(分离轴定理算法)"></a>凸多边形碰撞(分离轴定理算法)</h1><p><strong><em>正文如下：\</em></strong></p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170204235932265.jpg" alt="多边形碰撞"></p>
<p>分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。</p>
<p>我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。</p>
<p>我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：）</p>
<p>当我发现我需要在flash中检测多边形碰撞时，我碰巧地遇到了一个叫“分离轴定理”的方法。但唯一的问题是，为了真正地掌握它，我可费了不少功夫。</p>
<p>在阅读了大量有关碰撞检测的资料，并参看了一些代码示例后，这个方法总算被我领悟了。</p>
<p>为了帮助其他那些不精通数学的开发者，我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍。我还在下文引入了一个使用分离轴定理实现的demo，以及供大家下载并使用的ActionScript 3源代码。<strong>（译者：demo和源代码请到原文中查看和下载）</strong></p>
<p>注意：分离轴定理需要一点数学向量的知识，所以在深究这个算法前，你最好复习一下这方面的内容。</p>
<h1 id="算法简述"><a href="#算法简述" class="headerlink" title="算法简述"></a>算法简述</h1><p>从根本上来讲，分离轴定理（以及其他碰撞算法）的用途就是去检测并判断两个图形之间是否有间隙。分离轴定理中用到的方法使算法本身显得十分独特。</p>
<p>我所听到过分离轴定理的最好类比方式是这样的：</p>
<p>假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205000242395.jpg" alt="投影问题"></p>
<p>如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。</p>
<p>从编程的角度来讲，从每个可能的角度上去检测会使处理变得十分密集。不过幸运的是，由于多边形的性质，你只需要检测其中几个关键的角度。</p>
<p>你需要检测的角度数量就正是这个多边形的边数。也就是说，你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和。举个例子，两个五边形就需要检测10个角度。</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205000357272.jpg" alt="角度选取"></p>
<h1 id="如何在代码中实现"><a href="#如何在代码中实现" class="headerlink" title="如何在代码中实现"></a>如何在代码中实现</h1><p>这是一个简易但比较啰嗦的方法，以下是基本的步骤：</p>
<p><strong>步骤一：</strong>从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205000919294.jpg" alt="步骤一图解"></p>
<p><strong>步骤二：</strong>循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点）</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205001546835.jpg" alt="步骤二图解"></p>
<p><strong>步骤三：</strong>对第二个多边形做同样的处理。</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205001940563.jpg" alt="步骤三图解"></p>
<p><strong>步骤四：</strong>分别得到这两个多边形的投影，并检测这两段投影是否重叠。</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205002051627.jpg" alt="步骤四图解"></p>
<p>如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。</p>
<p>这个算法基本就是如此的。</p>
<p>顺带提一下，如果你记录了哪个轴上的投影重叠值最小（以及重叠了多少），那么你就能用这个值来分开这两个图形。</p>
<h2 id="那么如何处理圆呢？"><a href="#那么如何处理圆呢？" class="headerlink" title="那么如何处理圆呢？"></a>那么如何处理圆呢？</h2><p>在分离轴定理中，检测圆与检测多边形相比，会有点点奇异，但仍然是可以实现的。</p>
<p>最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。</p>
<p><img src="../../assets/images/2020-01-13-unity-attack-detection/20170205002152799.jpg" alt="圆的投影轴"></p>
<p>在这以后就是按套路遍历另一个多边形的每条投影轴，并检测是否有投影重叠。</p>
<p>噢，对了，万一你想知道如何把圆投影到轴上，那你只用简单地把圆心投影上去，然后加上和减去半径就能得到投影长度了。</p>
<h1 id="优点与不足"><a href="#优点与不足" class="headerlink" title="优点与不足"></a>优点与不足</h1><p>和其他的碰撞检测技术一样，分离轴定理算法有它自己的优点和不足。以下是其一些优点和不足的简要概述：</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>（译者：原来老外也喜欢先谈优点啊～&gt;～）</p>
<ul>
<li>分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。</li>
<li>分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……）</li>
</ul>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ul>
<li>分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。</li>
<li>分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。</li>
</ul>
<p>可能这个算法会有更多优点和不足之处，但是我想这应该是最主要的几个了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我希望这篇文章能帮助你了解到分离轴定理算法。我已经尽可能地不提供过多的信息并讲解得十分简明了。（我绝不是数学方面的专家，所以如果我遗漏了什么，我深表歉意）</p>
<p>以下是一些帮助我理解分离轴定理算法的页面：</p>
<ul>
<li><a href="http://www.harveycartel.org/metanet/tutorials/tutorialA.html" target="_blank" rel="noopener">harverycartel.org</a>——有更多详细的表述以及很多很酷的示例。我在这个页面上学到了很多。</li>
<li><a href="http://gpwiki.org/index.php/VB:Tutorials:Building_A_Physics_Engine:Basic_Intersection_Detection" target="_blank" rel="noopener">GPWiki.org</a>——有不错的讲解和代码示例，我用这些代码作为编写自己代码的基础。</li>
<li><a href="http://www.tonypa.pri.ee/vectors/index.html" target="_blank" rel="noopener">Tony Pa</a>——向量教程，学习向量的不错资源。</li>
<li><a href="http://www.gamedev.net/community/forums/topic.asp?topic_id=251638" target="_blank" rel="noopener">GameDev.net forum</a>——一个论坛成员写的分离轴定理碰撞检测系统，带给了我一些计算方面的想法。</li>
</ul>
<p><strong>本文翻译自<a href="http://www.sevenson.com.au/" target="_blank" rel="noopener">@sevenson</a>的文章<a href="http://www.sevenson.com.au/actionscript/sat/" target="_blank" rel="noopener">Separating Axis Theorem (SAT) Explanation</a> 。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class XRect&#123;</span><br><span class="line">    private Vector2 _point0 &#x3D; new Vector2();</span><br><span class="line">    private Vector2 _point1 &#x3D; new Vector2();</span><br><span class="line">    private Vector2 _point2 &#x3D; new Vector2();</span><br><span class="line">    private Vector2 _point3 &#x3D; new Vector2();</span><br><span class="line"></span><br><span class="line">    public List&lt;Vector2&gt; _pointList &#x3D; new List&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">    private float _min &#x3D; 0;</span><br><span class="line">    private float _max &#x3D; 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void UpdatePoint(RectTransform RT)</span><br><span class="line">    &#123;</span><br><span class="line">        float x &#x3D; RT.localPosition.x;</span><br><span class="line">        float y &#x3D; RT.localPosition.y;</span><br><span class="line">        float width &#x3D; RT.sizeDelta.x;</span><br><span class="line">        float height &#x3D; RT.sizeDelta.y;</span><br><span class="line">        float angle &#x3D; RT.localRotation.eulerAngles.z;</span><br><span class="line"></span><br><span class="line">        Vector2 centerV &#x3D; new Vector2(RT.localPosition.x, RT.localPosition.y);</span><br><span class="line"></span><br><span class="line">        _point0 &#x3D; new Vector2(x - width &#x2F; 2, y + height &#x2F; 2);</span><br><span class="line">        _point0 &#x3D; _Transform(_point0,angle,centerV);</span><br><span class="line"></span><br><span class="line">        _point1 &#x3D; new Vector2(x + width &#x2F; 2, y + height &#x2F; 2);</span><br><span class="line">        _point1 &#x3D; _Transform(_point1, angle, centerV);</span><br><span class="line"></span><br><span class="line">        _point2 &#x3D; new Vector2(x + width &#x2F; 2, y - height &#x2F; 2);</span><br><span class="line">        _point2 &#x3D; _Transform(_point2, angle, centerV);</span><br><span class="line"></span><br><span class="line">        _point3 &#x3D; new Vector2(x - width &#x2F; 2, y - height &#x2F; 2);</span><br><span class="line">        _point3 &#x3D; _Transform(_point3, angle, centerV);</span><br><span class="line"></span><br><span class="line">        _pointList.Clear();</span><br><span class="line">        _pointList.Add(_point0);</span><br><span class="line">        _pointList.Add(_point1);</span><br><span class="line">        _pointList.Add(_point2);</span><br><span class="line">        _pointList.Add(_point3);</span><br><span class="line"></span><br><span class="line">        Vector3[] temp &#x3D; new Vector3[4];</span><br><span class="line">        RT.GetLocalCorners(temp);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取投影轴</span><br><span class="line">    public Vector2 GetAxis(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 v &#x3D; _GetEdge(index);</span><br><span class="line"></span><br><span class="line">        Vector2 result &#x3D; new Vector2();</span><br><span class="line"></span><br><span class="line">        result.x &#x3D; v.y;</span><br><span class="line">        result.y &#x3D; 0 - v.x;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ResetProjection(Vector2 axis)</span><br><span class="line">    &#123;</span><br><span class="line">        if (axis.x &#x3D;&#x3D; 0 &amp;&amp; axis.y &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;投影轴数据错误！&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        float projectionX;</span><br><span class="line">        Vector2 v;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; _pointList.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            v &#x3D; _pointList[i];</span><br><span class="line">            if (axis.x &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                projectionX &#x3D; v.y;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (axis.y &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                projectionX &#x3D; v.x;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                projectionX &#x3D; (v.x - axis.x &#x2F; axis.y * v.y) &#x2F; (1 + Mathf.Pow(axis.x &#x2F; axis.y, 2));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (i &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                _min &#x3D; projectionX;</span><br><span class="line">                _max &#x3D; projectionX;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (projectionX &gt; _max)</span><br><span class="line">                &#123;</span><br><span class="line">                    _max &#x3D; projectionX;</span><br><span class="line">                &#125;</span><br><span class="line">                if (projectionX &lt; _min)</span><br><span class="line">                &#123;</span><br><span class="line">                    _min &#x3D; projectionX;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float GetMin()</span><br><span class="line">    &#123;</span><br><span class="line">        return _min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public float GetMax()</span><br><span class="line">    &#123;</span><br><span class="line">        return _max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取边向量</span><br><span class="line">    private Vector2 _GetEdge(int index)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 result &#x3D; new Vector2();</span><br><span class="line">        switch (index)</span><br><span class="line">        &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                result &#x3D; _point1 - _point0;</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                result &#x3D; _point2 - _point1;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                result &#x3D; _point3 - _point2;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                result &#x3D; _point0 - _point3;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Vector2 _Transform(Vector2 v,float angle,Vector2 centerV)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector2 result &#x3D; new Vector2();</span><br><span class="line"></span><br><span class="line">        float initX &#x3D; v.x;</span><br><span class="line">        float initY &#x3D; v.y;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将顶点移动到原点四周</span><br><span class="line">        float centerPointX &#x3D; initX - centerV.x;</span><br><span class="line">        float centerPointY &#x3D; initY - centerV.y;</span><br><span class="line"></span><br><span class="line">        float r &#x3D; angle * Mathf.Deg2Rad;</span><br><span class="line"></span><br><span class="line">        float a &#x3D; Mathf.Cos(r);</span><br><span class="line">        float b &#x3D; Mathf.Sin(r);</span><br><span class="line"></span><br><span class="line">        result.x &#x3D; centerPointX * a + centerPointY * (-b) + centerV.x;</span><br><span class="line">        result.y &#x3D; centerPointX * b + centerPointY * a + centerV.y;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class XCollisionHelper &#123;</span><br><span class="line"></span><br><span class="line">    private static XCollisionHelper _instance;</span><br><span class="line"></span><br><span class="line">    public static XCollisionHelper GetInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_instance  &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            _instance &#x3D; new XCollisionHelper();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return _instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool Check(XRect xRect1,XRect xRect2)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;4;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector2 axis &#x3D; xRect1.GetAxis(i);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取两个矩形在投影轴上的范围</span><br><span class="line">            xRect1.ResetProjection(axis);</span><br><span class="line">            xRect2.ResetProjection(axis);</span><br><span class="line"></span><br><span class="line">            if (xRect1.GetMin() &gt; xRect2.GetMax() || xRect1.GetMax() &lt; xRect2.GetMin())</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; 4; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Vector2 axis &#x3D; xRect2.GetAxis(i);</span><br><span class="line"></span><br><span class="line">            xRect1.ResetProjection(axis);</span><br><span class="line">            xRect2.ResetProjection(axis);</span><br><span class="line"></span><br><span class="line">            if (xRect1.GetMin() &gt; xRect2.GetMax() || xRect1.GetMax() &lt; xRect2.GetMin())</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">﻿using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class XRectItemCtrl : MonoBehaviour, IDragHandler</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public Image imgRect;</span><br><span class="line">    private XRect _xRect &#x3D; new XRect();</span><br><span class="line"></span><br><span class="line">    public XRect GetXRect()</span><br><span class="line">    &#123;</span><br><span class="line">        RectTransform RT &#x3D; transform.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        _xRect.UpdatePoint(RT);</span><br><span class="line"></span><br><span class="line">        if (transform.gameObject.name &#x3D;&#x3D; &quot;Image0&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return _xRect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnDrag(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        RectTransform RT &#x3D; transform.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        RT.localPosition &#x3D; new Vector2(RT.localPosition.x + eventData.delta.x, RT.localPosition.y + eventData.delta.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="其他的一些参考"><a href="#其他的一些参考" class="headerlink" title="其他的一些参考"></a>其他的一些参考</h1><ul>
<li><a href="https://github.com/irixapps/Unity-Line-Triangle-Collision" target="_blank" rel="noopener"></a></li>
<li><a href="https://github.com/dmanning23/CollisionBuddy" target="_blank" rel="noopener"></a></li>
<li><a href="https://github.com/dotnet-ad/Humper" target="_blank" rel="noopener"></a></li>
<li><a href="https://github.com/xiaolangfensi/Collision" target="_blank" rel="noopener"></a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>技能系统</title>
    <url>/unity-2020-02-15-skill-system/</url>
    <content><![CDATA[<p><img src="../../assets/images/2020-02-15-skill-system/20180602102244475.png" alt="img"></p>
<p>从架构上说,主动技能都可以拆分为释放条件检测-&gt;释放-&gt;目标选择-&gt;产生效果<br>但是里面很多细节,比如子弹初始位置设置,做成什么样子组合出更多的设计形式,同时可以兼容更多的有效需求<br>比如一个回合制卡牌游戏,要啥飞行子弹,区域只要相对和绝对位置2大类,然后直接填坐标就好了</p>
<p><strong>示例1:</strong><br>玩家释放技能1-&gt;释放子弹1对自身加免疫buff,释放子弹2在1秒后对身前范围最近1个友方击中-&gt;命中后对自身释放子弹-&gt;命令自身对目标释放技能2<br>释放技能1后选择对身前最近一个友方追加释放技能2</p>
<p><strong>示例2:</strong><br>被动技能-&gt;获得buff-&gt;buff触发器每2秒在自身位置释放单体子弹1清除buff1,aoe子弹击中敌人-&gt;每命中一个敌人对自身叠加1层buff1<br>实际效果:周围敌人越多自身获得越多层buff1</p>
<p><strong>示例3:</strong><br>玩家释放技能1-&gt;释放子弹1对自身周围友方和敌方击中-&gt;对命中的目标释放3个子弹:子弹1筛选敌人产生伤害,子弹2筛选友方30%血以上造成治疗,子弹3筛选敌人血量大于80%命中后产生子弹4对自身添加buff<br>实际效果:对周围友方残血造成治疗,对敌人造成伤害,如果击中的敌人血量较高,自身获得增益</p>
<p><strong>示例4</strong><br>玩家有被动技能获得buff1-&gt;buff触发器效果为暴击击中时若双方距离&gt;300则对目标发射子弹1和子弹2-&gt;子弹1对自身添加buff,子弹2筛选有buff2的敌人<br>技能效果:暴击击中距离自身较远的敌人使自身获得增益,触发时若敌人有buff2,则造成额外效果</p>
<p><strong>示例5</strong><br>玩家释放主动技能-&gt;发射子弹使自身获得6层buff1<br>buff1附带3个触发器<br>触发器1-&gt;释放技能清除所有层数buff1<br>触发器2-&gt;受到攻击失去1层<br>触发器3-&gt;buff1消失时自身获得buff2<br>buff2-&gt;触发器每1秒对自身附近发射子弹筛选1个敌人-&gt;令目标对自身发射子弹添加增益<br>技能效果:主动隐身,受到攻击失去1层,释放技能后解除隐身,隐身结束后一段时间内受到伤害转移给附近一个敌人</p>
<p>基础内容有这么几个部分：<br>1、Actor，这个是角色本身，它不属于技能系统，但是它要给技能系统开放足够的接口，比如播放动画、播放声音、控制位移、造成伤害、添加buff等等<br>2、Skill，这个就是技能本身，它在合适的时机调用脚本中的相应函数，脚本中可以在OnCreate  OnHit  OnDeath  OnHeroDeath  OnSoldierDeath等事件中写相应代码。由于是脚本，所以代码非常灵活，而由于限定了只处理技能相关功能，所以代码也不会很复杂，有经验的策划绝对搞的定。<br>3、Buff，这个是技能效果的核心。它可以是有时限的，也可以是被动无时限的。在它对应的脚本中，定义了这个Buff会影响哪些角色属性（如血量、暴击、攻击力等等）或者角色状态（如眩晕、隐身、沉默等等），同样，buff脚本也支持事件机制，在脚本的相应事件处理其逻辑功能，可以实现非常丰富的效果。<br>4、Modifier，这个是一个技能修改器。技能修改器可以修改技能的流程和效果（比如技能伤害增加、火球击中人会爆炸等等），具体可以参考风暴英雄中的技能天赋系统。技能修改器并没有脚本与之对应，一个技能如果支持某个修改器，需要在脚本中处理相应功能。</p>
<p>技能的基类是RoleSkill，然后分近战和远程两个大类，记得不要根据职业来分，而是根据功能来抽象，近战的技能是通过武器来产生伤害，而远程技能是通过发射物来伤害。近战技能可以继续分为：近距离接触攻击单人，近距离范围内接触攻击多人等；远程技能可以分为：单发射物攻击单人，远距离范围内非接触攻击多人等。</p>
<p><img src="https://github.com/dongweiPeng/SkillSystem/raw/master/Assets/%E6%8A%80%E8%83%BD%E6%B5%81%E7%A8%8B.png" alt="img"></p>
<p>广义的的说，和战斗结算相关的内容都算技能系统，包括技能信息管理、技能调用接口、技能目标查找、技能表现、技能结算、技能创生体（buff/法术场/弹道）管理，此外还涉及的模块包括：AI模块（技能调用者）、动作模块、寻路/移动模块以及人物属性和伤害数值结算等。</p>
<p>先说下技能模块每个部分的职责和原理：</p>
<ul>
<li>技能信息管理：管理unit所拥有的技能以及技能的等级、cd等。在我们游戏中，这里还需要负责管理符文，符文会对技能信息进行修改。</li>
<li>技能调用接口：AI或者UI操作触发技能，触发技能时可能选择了一个目标（AI），也可能并没有目标。</li>
<li>技能流程管理：一个技能可能由多个子技能以移动的执行模式组合而成，而每一个最终执行的技能执行过程也存在一个流程，一般包括：前摇过程-结算点-后摇过程。技能在前摇结束时进入技能真正的结算流程，结算流程可能创建子弹，也可能触发buf或者创建法术场。</li>
<li>技能目标查找：若技能触发时已经设置了技能目标unit(如怪物AI释放技能)，则直接将其作为目标unit，否则需要根据一定的策略选择一个目标。此外，技能释放的时候还需要释放方向和释放位置等信息，也通过这个模块获取。</li>
<li>技能表现：技能释放过程中，需要创建相应的特效以及执行相应的动作。</li>
<li>技能创生体（buf/弹道/法术场）管理：buf挂在unit身上，可能影响unit的一些行为和状态；法术场一般由场景管理，影响场景中某范围内的unit；弹道就是技能创建的一个子弹，这个子弹可能以不同的路线移动（直线／抛物线／直接命中等）</li>
</ul>
<h2 id="0技能表"><a href="#0技能表" class="headerlink" title="0技能表"></a>0技能表</h2><p>首先说下实现技能的基本思路。实现技能的基本思路就是通过策划填写表格，来配制成某些技能，在执行某个技能的时候，分别去根据这些表格中的内容，确定技能如何表现。基本的逻辑是：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> skillTable.<span class="keyword">get</span>(<span class="string">"技能动作"</span>):</span><br><span class="line">     paly 动作</span><br><span class="line"><span class="keyword">if</span> skillTable.<span class="keyword">get</span>(<span class="string">"特效"</span>):</span><br><span class="line">     播放特效</span><br><span class="line"><span class="keyword">if</span> skillTable.<span class="keyword">get</span>(<span class="string">"法术场"</span>):</span><br><span class="line">    创建法术场</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h2 id="1-技能信息管理"><a href="#1-技能信息管理" class="headerlink" title="1 技能信息管理"></a>1 技能信息管理</h2><p>unit创建时，此模块管理unit可使用哪些技能，比如游戏中玩家可以选择使用哪些技能。</p>
<p>游戏中技能的升级、技能加点、技能池管理都在这个模块。</p>
<p>此模块还需要管理技能等级／符文／装备等外部模块对技能参数的修改。</p>
<h2 id="2-技能调用接口"><a href="#2-技能调用接口" class="headerlink" title="2 技能调用接口"></a>2 技能调用接口</h2><p>提供技能调用的接口供AI或玩家操作调用，调用时可以提供一个目标unit，也可以不提供让技能自己查找。</p>
<p>提供三个接口：</p>
<ul>
<li>技能开始skill_enter：开始执行技能，若技能不循环进行，则技能可以自动结束。</li>
<li>技能结束skill_exit：有的技能不能自己结束，比如某些循环技能，对于循环技能玩家可以按住按钮一直释放。当玩家松开按钮，调用技能结束接口，告诉当前技能使其结束，此时技能到达后摇点时，技能不再继续执行。</li>
<li>技能停止skill_stop：当技能被强制打断时，如被攻击、晕眩、蓝不足等，技能会被强制停止。</li>
</ul>
<p>此外，当前一个技能正在执行时新的技能调用启动，此时新的技能调用信息会被保存。一般来说，并不会把所有新的技能调用信息保存下来，那样就成了一个技能执行的序列。我们游戏仅保存一个新的技能调用信息。</p>
<p>总的来说，技能模块提供尽量少的接口供AI/UI等上层逻辑使用，这样可以有效的与AI和UI进行解耦。</p>
<h2 id="3-技能流程管理"><a href="#3-技能流程管理" class="headerlink" title="3 技能流程管理"></a>3 技能流程管理</h2><p>技能流程这里分两点讨论：</p>
<ol>
<li>一个技能可能由多个子技能以一定的模式组合起来。<br> 一个技能常常由多个子技能以一定的模式组合而成，比如三段击、比如冲锋斩（先冲锋、后斩）等，甚至还存在根据不同的环境选择执行不同的子技能。分析策划需求发现，技能可以分成一个树形结构，这个树形结构非常类似行为树，同样可以将节点分为控制节点和执行节点，甚至可以包括condition节点。为此，我们项目引入一个技能树概念来描述这种数据结构。</li>
<li>一个具体的技能（技能树执行节点）也有一个固定的执行流程。这个流程一般为：前摇过程、前摇过程结束=技能结算时间点、后摇时间点。</li>
</ol>
<h3 id="3-1-技能树"><a href="#3-1-技能树" class="headerlink" title="3.1 技能树"></a>3.1 技能树</h3><p>技能树参考传统行为树的设计，使用树形结构控制技能的执行流程。</p>
<p>技能树和行为树在结构上比较类似，但是在运行逻辑上有很大的不同。</p>
<p>首先，技能树的重点并不是根据上下文选择一个合适的节点执行，而是以一定的策略将技能树从头到尾遍历执行一遍。</p>
<p>其次，技能树没有tick的概念，而是基于回调的，比如一个顺序节点，顺序节点中一个子节点执行完毕后，马上通知顺序节点，顺序节点执行下一个子节点，直至顺序节点的最后一个子节点执行完毕，顺序节点就会通知父节点（如果有）它已经执行完毕。</p>
<p>此外，为了完成技能的一些需求，控制节点往往存储更多的控制信息来控制子节点的执行流程。具体的信息根据策划需求设置，比如顺序结点包括原子属性和循环属性。如果一个顺序节点具有原子属性，则这个顺树节点在执行的过程中并不会被end，只有全部子节点执行结束才可以end。</p>
<p>以我们游戏中战士普攻三段击为例：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/36361-5ec18bbce4b863ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/544/format/webp" alt="img"></p>
<p>Paste_Image.png</p>
<p>三段击本身是一个顺序节点，当技能开始时，此节点顺序执行三个子节点。对于第一个子节点，它依然是一个顺序节点，首先冲锋至目标单位身前，然后对目标单位进行挥砍。但是冲锋节点还包括了一个condition，若和目标的距离很近，则跳过冲锋节点，直接挥砍。</p>
<p>普攻是一个循环技能，这个技能只要玩家点着按钮不放开，技能就会一直执行，因此根节点（普攻）是一个具有循环属性的顺序节点。而对于子技能1（控制节点），他是一个具有原子属性的顺序技能，即当单位正在冲锋时，玩家松开按钮，单位也会执行完挥砍后才会推出技能。</p>
<hr>
<p><strong>！关于技能树的使用和思考</strong></p>
<p>技能树开始的设计思路是，有些技能的执行流程和行为树类似，比如以一定的顺序执行一系列子技能，比如根据不同的上下文确定技能的执行流程。简单的说，技能树的引入有以下好处：1.使技能模块可以获得部分AI的能力，从而将和技能强相关的AI逻辑放在技能模块使技能模块和AI模块降低耦合，2.可以清晰的描述技能流程，3.使用树增加拓展性，策划可以设计出各种各样复杂的技能。</p>
<p>关于好处1，举个例子：屠夫boss的勾子技能可以将玩家拉过来，若成功的拉过来，boss会执行一个攻击子技能，否则不执行。通过这样可以将勾人和攻击作为两个子技能构成技能树，攻击子技能有一个condition过程，即判断上一个子技能是否成功。</p>
<p>技能树在使用后慢慢发现一些问题，首先，技能树的同步要求每个树节点都进行同步，增加同步负担，其次，技能本身并不会有太复杂的控制结构。</p>
<p>为此，后来我们对技能树进行了优化：<br> 1.简化同步信息，不再同步所有节点的enter/exit信息（具体参考文章《技能模块的同步》）。<br> 2.取消并行节点，通过拓展表头实现一个技能同时执行多件事情。</p>
<p>最终的技能树基本上是只有顺序／随机两种控制类型节点，节点拥有较轻度的condition功能。</p>
<hr>
<h3 id="3-2-执行节点的技能流程"><a href="#3-2-执行节点的技能流程" class="headerlink" title="3.2 执行节点的技能流程"></a>3.2 执行节点的技能流程</h3><p>一般来说，技能的执行流程包括：</p>
<ul>
<li>前摇时间：技能开始，但是技能真正的结算流程还没开始。技能开始以后，机能相关的特效和动作就开始播放。</li>
<li>前摇时间结束：技能前摇结束时技能开始真正的释放以及结算，等技能前摇结束以后，技能真正的释放并结算。释放包括创建相应的弹道／法术场和buff。</li>
<li>技能后摇点：技能播放到后摇点时间时，技能真正的结束。这时，技能对应的特效以及人物动作可能还会继续播放，但是技能流程已经正式结束了。也就是说，下一个技能可以执行。</li>
</ul>
<h2 id="4-技能目标查找"><a href="#4-技能目标查找" class="headerlink" title="4 技能目标查找"></a>4 技能目标查找</h2><p>技能释放时，目标可能已经由AI传给了技能模块，也有可能没有一个目标，如玩家控制单位。</p>
<p>技能在释放法术场、弹道的时候，重要的是技能的方向而不是技能目标一般来说，技能获得一个目标对象以后，技能的方向就是释法者到目标的方向。</p>
<p>此外，技能方向可能需要一些配置，如前摇锁定（前摇过程中目标移动，技能方向不变），UI可控制（技能释放过程中，玩家可以通过控制UI控制技能的释放方向）。</p>
<h2 id="5技能表现"><a href="#5技能表现" class="headerlink" title="5技能表现"></a>5技能表现</h2><p>技能的表现包括动作、特效、shader、音效等。其中，特效比较复杂，需要配置的内容也比较多。比如，有些特效挂在模型上，有的特效挂在场景里。对于法术场的特效，分别可以分为法术场开始、结算、结束特效，分别在法术场开始时、结算时、结束时显示。对于buff也类似。</p>
<h2 id="6-弹道、法术场和buff等技能创生体"><a href="#6-弹道、法术场和buff等技能创生体" class="headerlink" title="6 弹道、法术场和buff等技能创生体"></a>6 弹道、法术场和buff等技能创生体</h2><p>狭义的来说，技能只是负责技能的执行流程（技能树管理以及技能流程管理），而技能真正的结算主要是由其创生体结算的。当技能前摇结束开始生效时，技能创建相应的弹道和法术场，法术场弹道击中敌人时又有可能产生相应的buff。</p>
<p>一般来说，法术场是一个场景的某块检测区域，每隔一段时间法术场检测此区域的敌人，并对其攻击结算。<br> 弹道是一类子弹移动路径的抽象，创建一个弹道就表示一个子弹特效沿这个弹道移动并检测路径上的敌人。<br> buff就是挂在单位身上的一个具有持续时间的状态，状态对单位产生一些正面或者负面的影响，并且在此段时间内，每隔一段时间进行一次伤害结算 。</p>
<p>对于技能、法术场、buff之间的功能界定并不是很固定，比如技能能否直接对单位造成伤害，法术场能否对单位造成伤害，甚至技能只能创建法术场，法术场只能检测目标不能造成伤害，只能挂buff，而所有的伤害都是通过buff来结算。当然，这样并不一定好，一般来说，技能和法术场都可以对单位造成伤害。</p>
<p>总之，创生体功能的界定需要根据策划需求、效率考虑等因素调整。</p>
<h2 id="6-1-Buff状态"><a href="#6-1-Buff状态" class="headerlink" title="6.1 Buff状态"></a>6.1 Buff状态</h2><p>Buff就是挂在单位身上持续一定时间的有益或者有害的状态，这里状态＝buff。</p>
<p>Buff模块有个需要注意的是Buff之间的相互关系，如排斥（A状态在，B状态挂不上去），清除（A状态挂上去同时导致B状态消失）等。</p>
<p>为了实现以上功能，最简单的方式是在状态A中直接填写状态关系状态字段，如状态A排斥状态B/C/D/E…，A状态清除状态X/Y/Z…。</p>
<p>以上的实现方式有个问题，等游戏做到后期，我们有成千上万个buff状态，那么一个魔法免疫状态，策划需要填表的排斥状态可能成千上万。</p>
<p>为了解决这个问题，可以使用分类的思想解决。定义某类状态和另一类状态之间的规则。<br> 基于以上思想，引入一个叫buff原子状态的概念，原子状态表示一类状态，如减速、禁魔、魔免、悬空、晕眩、变羊等等等。</p>
<p>在给单位挂一个新的buff的之前，查询此buff持有的原子状态和单位身上已经有的原子状态之间的关系，根据单位身上已有的原子状态判定新的原子状态应该使用何种行为处理。</p>
<p>此处的何种行为，代表的就是原子状态之间的规则，如排斥等。这些规则可以让策划填一个名字叫“原子状态关系”的表，此表是一个n*n的二维数组，n为游戏中所有的原子状态的数量。</p>
<p>原子状态的数量远远小于buff的数量，所以可以很容易的定义这些规则。</p>
<h3 id="6-2-法术场"><a href="#6-2-法术场" class="headerlink" title="6.2 法术场"></a>6.2 法术场</h3><p>法术场描述对一块区域的影响，这块区域可以每隔一段时间进行一次检测，检测这块区域内的单位并且对单位进行结算。</p>
<p>法术场需要注意一个问题，就是一个法术场每次结算可能使用不同的参数进行结算，比如一个技能，第一次结算对每个单位进行晕眩，第二次结算对单位进行伤害。</p>
<p>解决这种问题比较直接的方式是技能直接创建两个法术场，每个法术场结算一次，第二个法术场创建具有延迟时间。但是这种方式有个问题，有可能策划需求做一个结算十次而且每次结算的参数都不同的法术场。那么，一个技能以一定的时间间隔创建是个法术场，同时法术场的管理具有一定的成本，从而导致效率的降低。</p>
<p>为解决这个问题，我们优化了法术场结算的实现机制，增加了一种新的法术场：序列法术场。这类法术场策划可以配置法术场每次结算之间的时间间隔以及每次结算所使用的法术场参数。</p>
<p>这里所说的技能模块包括：技能流程、法术场、弹道和buff。</p>
<p>首先介绍authority和proxy的概念，这两个概念是基于单位unit的基础上进行的区分。<br> authority表示单位的主控端，即此单位是由客户端和还是服务端控制。对于玩家avatar，玩家本地的客户端就是主控端。而对于怪物，他们的行为由服务端控制，主控端就是服务端。<br> proxy表示代理端，表示被主控端控制。如对于怪物来说，所有的客户端都是proxy；对于玩家A来说，服务端和其他玩家的客户端都是proxy。</p>
<h2 id="0-技能同步的原则"><a href="#0-技能同步的原则" class="headerlink" title="0 技能同步的原则"></a>0 技能同步的原则</h2><p>1.客户端先行<br> 对于玩家控制的单位来说，玩家点击按钮释放一个技能，客户端首先响应，单位播放动作以及相应的技能特效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">据我了解，有的已上线游戏并没有做客户端先行，而是所有的技能执行请求都发给服务端，然后由服务端发起。</span><br><span class="line">这种模式技能流程控制会比较简单，但是在网络环境差的情况下，体验可能差一些。但是，目测也是可以接受的。</span><br></pre></td></tr></table></figure>

<p>2.技能流程以authority为发起端<br> 玩家单位技能发起是由她的客户端，怪物的技能发起是由AI也就是服务端。<br> 3.技能结算在服务端发起。<br> 技能真正的结算，比如法术场检测、buff结算、伤害结算等，统一在服务端处理。</p>
<h2 id="1-技能执行流程的同步"><a href="#1-技能执行流程的同步" class="headerlink" title="1 技能执行流程的同步"></a>1 技能执行流程的同步</h2><p>这里所说的技能执行流程指的是技能树的一个执行节点的流程。</p>
<p>技能流程负责动作、特效以及技能结算，其中技能结算包括：释放法术场、弹道或buff。</p>
<p>一个技能执行节点的执行流程中，需要同步的有两个时间点：</p>
<ul>
<li>技能开始：技能开始播放动作</li>
<li>技能结算：前摇结束，即能进入结算逻辑。这类同步消息往往并不是由技能本身去同步，而是技能生成了法术场、弹道等，他们去做相应的同步。</li>
</ul>
<p>以玩家点击技能按钮开始释放技能为例介绍技能同步流程，如图所示：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/36361-392299771fc34192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp" alt="img"></p>
<p>Paste_Image.png</p>
<p>1.主控端点击技能按钮，技能开始播放动作，主控端告诉服务端技能开始。<br> 2.服务端广播给所有的客户端(多玩家场景)，告知其他所有的客户端此玩家开始执行技能。其他客户端收到指令后可是播放技能表现。<br> 3.服务端延迟一段时间后，服务端开始进行技能结算，并且将结算结果通知客户端。</p>
<blockquote>
<p>延迟时间=技能前摇时间-上行-下行，下行一半不能确定，所以默认为上行=下行</p>
</blockquote>
<blockquote>
<p>另一种中庸的计算方式是：延迟时间=技能前摇时间-上行，防止要求技能前摇时间过长</p>
</blockquote>
<h3 id="使用此同步流程的表现为："><a href="#使用此同步流程的表现为：" class="headerlink" title="使用此同步流程的表现为："></a>使用此同步流程的表现为：</h3><p>1.要求技能前摇时间&gt;2*网络延迟，若前摇时间短，则延迟时间=0，效果可能差一些<br> 2.authority客户端表现完美。<br> 3.proxy client表现一般，即玩家A看玩家B的效果为：玩家B刚开始执行技能动作，没到前摇时间就进行了技能结算。但是因为玩家一般也不会过分关注其他玩家的动作，所以是可以接受的。</p>
<h2 id="2-技能树的同步"><a href="#2-技能树的同步" class="headerlink" title="2 技能树的同步"></a>2 技能树的同步</h2><p>我上篇文章<a href="https://www.jianshu.com/p/551f02f95727" target="_blank" rel="noopener">技能系统</a>已经介绍，我们游戏使用的是技能树来管理技能流程。那么就面临一个问题，技能树如何同步。</p>
<p>最简单最暴力的方式，是客户端和服务端同时管理技能树，并且将其状态同步。这样，客户端和服务端的技能树状态统一、完备。</p>
<p>后来发现，对于proxy端，并不需要完备的技能树信息，最节省的方式是proxy根本不接受技能树同步信息，只是接受播放动作、技能结算等信息。但这样需要告诉其他proxy播放什么动作、特效等。</p>
<p>在我们系统中，技能同步包括三类同步消息:</p>
<ul>
<li>技能根节点enter (root_enter): 表示一个大技能的进入</li>
<li>技能叶子节点enter(action_enter): 表示一个技能树的执行节点的进入。</li>
<li>根节点exit(root_exit) ：表示大技能结束</li>
</ul>
<p>根节点保存一个完整技能的信息，需要和技能模块外部交互，因此需要知道技能的开始和结束。<br> 叶子节点的执行代表着技能真正的执行逻辑，也需要同步。<br> 而对于其他节点，作为流程控制节点，只需要在主端确保技能流程无误即可</p>
<blockquote>
<p>后来这里进行了进一步的优化，对于纯根节点，主控端（玩家控制的客户端）将信息同步给服务端，服务端不再同步给其他客户端。有的技能树只有一个节点，那么按照叶子节点的策略，主控端同步给服务端，服务端广播给所有的其他客户端。</p>
</blockquote>
<h2 id="3-技能结算的同步"><a href="#3-技能结算的同步" class="headerlink" title="3 技能结算的同步"></a>3 技能结算的同步</h2><p>技能结算包括创建法术场、buff、弹道、技能直接伤害等。</p>
<h4 id="法术场、弹道的同步"><a href="#法术场、弹道的同步" class="headerlink" title="法术场、弹道的同步"></a>法术场、弹道的同步</h4><p>法术场、弹道的同步比较类似，他们都作为一个entity（网络同步单元）在服务端创建，创建以后使用entity管理机制服务端通知客户端他们的创建和销毁。</p>
<p>以法术场为例，法术场的执行和同步流程：</p>
<ol>
<li>服务端发起创建一个法术场，并且通知客户端</li>
<li>法术场每隔一段时间结算一次，注意，法术场结算并不需要同步，每隔一段时间服务端执行检测逻辑，客户端播放结算特效等。两个逻辑互不依赖，也不要求时间一致。</li>
<li>当法术场结算时检测到攻击目标时，服务端计算攻击伤害等信息，并将攻击信息发给客户端。</li>
<li>客户端收到伤害信息，客户端播放相应的表现，如法术场受击特效等。此处还包括属于通用模块的跳字等。</li>
<li>当服务端的法术场时间到了进行destroy时，使用entity的管理机制通知所有客户端destroy法术场。</li>
</ol>
<p>弹道的同步类似，唯一的区别就是法术场在某一位置使用攻击盒检测目标，而弹道是一个移动的子弹，客户端表现是一个特效在飞，而服务端每隔一段时间根据飞行速度等使用胶囊攻击盒去检测目标碰撞。</p>
<p>由以上可以发现，法术场作为一个entity他的管理成本是比较高的，所以若策划想出一些需求需要使用多个法术场实现，一般通过拓展法术场功能使用一个法术场来实现。</p>
<blockquote>
<p>比如，策划要做一个冰火两重天法术场，即法术场在每次结算时使用不同的参数，第一次结算使用火焰，第二次结算是冰霜。若这种需求较少，可以使用两个法术场，但是如果要冰火雷毒水电风魔奥术神圣***N重天，则代价太大。一般可以让法术场支持每次使用不同的结算参数来结算即可。</p>
</blockquote>
<h4 id="buff同步"><a href="#buff同步" class="headerlink" title="buff同步"></a>buff同步</h4><p>buff是附加在unit身上的东西（没有unit就没有buff，但是没有unit可能有法术场），所以不需要使用entity来同步。</p>
<ol>
<li>服务端确定buff是否可以挂在unit上面。</li>
<li>客户端和服务端都维护一个buff管理器，挂buff的消息通知所有客户端，客户端负责表现，服务端负责结算即可。</li>
</ol>
<h2 id="4-伤害、属性的同步"><a href="#4-伤害、属性的同步" class="headerlink" title="4 伤害、属性的同步"></a>4 伤害、属性的同步</h2><p>主要介绍下伤害的同步，顺便附带介绍下属性同步。</p>
<p>对于伤害结算来说，技能、buff、法术场和弹道都可能造成伤害，当服务端发现造成伤害时，服务端首先根据技能信息计算伤害值，计算以后将信息通过技能模块发送给所有客户端，所有客户端接到信息后首先播放技能伤害相关的表现，如受击特效等，然后播放跳字等通用伤害客户端表现。</p>
<p>buff可能修改单位属性，如攻击力、攻击速度等。单位的属性由基础成长属性+装备属性+buff属性构成，前两个属性为面板属性，属于玩家信息。而buff属性只在战斗中有效，在面板中并没有表现。<br> 因此装备属性的同步需要通知逻辑服务器（真正的服务器），而buff并不需要通知逻辑服务器。</p>
<h1 id="技能，说穿了只是一个流程，而不该是一个实体"><a href="#技能，说穿了只是一个流程，而不该是一个实体" class="headerlink" title="技能，说穿了只是一个流程，而不该是一个实体"></a><strong>技能，说穿了只是一个流程，而不该是一个实体</strong></h1><p>1、表的作用实际不是定义流程，而是提供流程中需要的数据。因此不管流程需要数据的是前端还是后端，他们都应该从一个表中调用。<br>2、并不是因为把技能作为实体才导致它的混乱，真正导致混乱是的技能实体的范围扩大化了（从这个意义上说，把技能做为一个流程也没什么错，技能的承载内容应该仅仅是这个流程本身），把后续效果剥离出来会好很多。</p>
<p>我个人的经验，不评价好坏，大概是这样的：技能的表象数据必须要有，技能效果相应的数据应该仅限于这个技能释放条件和它的直接效果（这个与表象共享技能id，所以最好也放在一起）；直接效果之外的触发效果，单独建立BUFF表，为此建立一套单独的流程，供技能调用（也就是技能效果应该是触发了某个buff）</p>
<h2 id="就skill和buff的边界问题，"><a href="#就skill和buff的边界问题，" class="headerlink" title="就skill和buff的边界问题，"></a>就skill和buff的边界问题，</h2><p>恰好新的项目里里面我进行了一个比较新的尝试，就是抹除这个边界。 在这次的项目中，因为技能需求足够复杂，所以采用了以前一直只想没实践的想法，就是取消技能在逻辑中的的概念，或者说在基础逻辑中没有技能的设计，技能只在数据层和讨论的概念中出现。 具体的描述也很简单，所谓的技能我们都理解为 施法者一组行为和数据的组合，它包含了技能的icon，类型，动作等一系列和战斗逻辑有直接关系但没有本质关系的概念与数据的总和，用来在游戏概念中定义一个技能的所有特征。 但是在战斗中，真正发挥作用的是buff，在新的设计中，所有的参与战斗逻辑的实体都是buff。 比如 如果要实现一个火球，那么实现方式是技能数据告诉我会播放什么样的施法动画，同时丢出一个弹道，而这个弹道上附着一个buff，叫做燃烧，该buff附带特效火焰和200点的碰撞伤害（在弹道命中敌人时候）。 而这个一整个流程，在概念里，被定义为 施法者释放了一个技能，映射到现实逻辑，就是某人拿起一个石头，点燃，然后把石头丢出去砸到了某人。 至此，核心的技能结算逻辑里，彻底干掉了skill这个类，技能变成了只在概念讨论里才出现的词汇。战斗结算中，不再存在skill的概念。</p>
<p><strong>表与脚本混合.</strong></p>
<p>又有两种分支,</p>
<p><strong>分支一:主表副脚本,</strong>脚本作为字段绑定于表里.表的某个字段就是技能的脚本路径.技能的主流程,框架逻辑有表的字段来决定.</p>
<p><strong>分支二:主脚本副表</strong>,主逻辑,流程都是有脚本实现.技能的主流程由脚本实现.脚本读表获取数据,进行技能的操作.</p>
<p>优点:增加奇怪技能,很方便,直接写脚本就可以了.</p>
<p>缺点:批量处理工作量大,既要改表,又要改技能.每个技能对应独立的脚本,技能越多,脚本越多.批量处理的时候,工作量大.</p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><p><a href="https://zhuanlan.zhihu.com/p/147681650" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/147681650</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>同步</tag>
        <tag>代理</tag>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏buff系统设计</title>
    <url>/unity-2020-02-16-buff-system/</url>
    <content><![CDATA[<p>内部运算<br>1、是否包含技能效果？（提高/降低 攻击 命中 闪避 移动速度 群体伤害 替换技能ID 等 ）<br>2、是否包含阶段效果？（BUFF分为多个阶段，不同的阶段有不同的效果，比如影之哀伤）<br>3、是否包含计时器？（持续时长计算、叠加时长计算 总之所有关于持续性时间的问题 都丢这里）<br>4、是否包含计数器？（用来计算阶段、剩余生效次数、比如影之哀伤 LOL电刀）<br>5、是否具备分类规则？（魔法效果 诅咒效果 中毒效果 用于进行归类 方便程序进行的 驱散筛选判断）<br>6、是否可以被驱散？ （魔法效果只能用祛除魔法解除 中毒效果只能用解药祛除）<br>7、是否具备优先级？（附加优先级，低等级BUFF会被高等级BUFF替换，低等级BUFF无法附加给高等级怪）<br>8、是否保留母体信息？（比如传染性的DEBUFF，感染者传播一次，母体会获得额外巴拉巴拉。。。多个项）<br>9、是否共享同步规则？（比如多个角色共享一个BUFF状态，一个人的BUFF被祛除则其他人也被祛除）<br>10、以上功能可以进行再补充，没有需求则可以逐个剔除。</p>
<p>外部表现<br>1、是否显示BUFF图标？（传奇里道士的BUFF是不显示图标的）<br>2、是否不同阶段表现不同的图标？<br>3、是否显示计时器？<br>4、是否显示计数器？<br>5、是否显示BUFF文字说明？（对BUFF类型、效果的描述）<br>6、是否改变角色外形？（DNF里的冰冻、WOW里的变形）<br>7、以上表现功能可以进行再补充，同上。</p>
<p>首先我想说的是，这是一套机制，并不是单独的一个系统，所谓机制就是一种从逻辑思想到代码实现的小窍门的组合，只有当你把它运用到一个实际项目中去了，它才能帮助你建立一个系统。我不敢说它是最好的，但这套东西帮我完成了一个又一个项目的制作，我觉得现在可以简单的拿出来和大家分享下思维。事实上这也并不是什么很玄乎的东西，我的Buff的机制更像是Flash的Dispatch机制。更简单的说，你可以把它理解为一种回调机制，在必要的时候进行逻辑回调。我想这一句话应该是可以概括整个机制的工作原理了。</p>
<p>　　举个简单的例子来说明，作为一个设计师，在设计系统的同时应当思考好这个游戏的系统中的各个回调点，而他们也正是Buff系统发挥能量的地方，Buff回调点有哪些（当然我可能会把它歪到WoW，毕竟这最早的设计灵感来自WOW）？我简单列一些：</p>
<p><strong>1，BuffOccur</strong></p>
<p>　　我认为这是最核心的回调点之一，应该说你把这套机制运用在任何游戏中他都必须由这个时间点，就是当任何情况Buff被添加到一个角色身上的时候（可能来自技能、可能来自道具、可能来自GM命令，等等等等），往往他最杰出的作用就是改变角色的属性、或者是被控制状态。之所以说这是机制是思维方式，因为它并不关心你的游戏有哪些状态或者属性，但是这里有一点比较容易搞混的就是初级策划往往会认为昏迷就是一个Buff(debuff)，可是事实上昏迷是一种组合状态，他在LoL里面的形态是剥夺移动能力、剥夺攻击能力、剥夺商店使用能力的组合（我不知道是不是真的，但是我在做起凡三国争霸2的时候是这么做的，这套机制最早运用的游戏就是那个，虽然我离开起凡后这套系统的代码被删除了）。因此在BuffOccur这个回调点，有着很多的事情会需要做，那么同样的，BuffRemoved回调点也就有了同样的职责。</p>
<p><strong>2，BuffOnTick</strong></p>
<p>　　也就是通常我们最常见的，每3秒造成伤害、治疗；或者我们可以做每3秒制造一个AOE，甚至每3秒为自己添加一个护盾等等，他的核心在于没一定时间触发一次，但请你注意不是所有的游戏都适用这个回调点。</p>
<p><strong>3，BuffRemoved</strong></p>
<p>　　在移除Buff的时候，重新计算属性等肯定是需要在这个时间点工作一次的，那么事实上还有很多的效果也可以在这个时间点被调用，典型的是痛苦无常和生命绽放（都来自WOW），痛苦无常是当驱散的时候对驱散者造成伤害并且沉默，因此我们需要传入导致buff终结的人（可能是null）和BuffRemove的时候剩余时间，由此判断是否真的完成了，那么剩余时间越多造成伤害越高也就成了可能的设计；而生命绽放则更加简单，在Removed时候给持有者进行治疗就可以了。</p>
<p><strong>4，BuffBeHurt</strong></p>
<p>　　在受到攻击的时候触发，大多盾类技能由此而生，这个回调点应当Return一个Int或者Float，用于传递给下一环，已获得新的伤害，而当所有的执行完毕之后，造成的最终伤害就会是这个数字，那么把受到的伤害变成治疗是多么简单的事情？可是否应该有，还得看游戏的Patterns。</p>
<p><strong>5，BuffOnHit</strong></p>
<p>　　在攻击的时候产生，虽说字面上是OnHit，你仍然可以把isHit像isCrit一样传给回调函数，战士的压制（老版本）在攻击被闪躲时可以发动，更早的猎人在闪避攻击后可以提高招架？其实都是这个时间点来做的。</p>
<p><strong>6，BuffBeforeKilled</strong></p>
<p>　　很多时候BuffBeHurt并不能完成一些设计，比如说必定能杀死目标的伤害被完全吸收（贼爷爷的假死），这时候我们要确定这个角色原本应该死了，因此就需要设定出这样一个回调点。</p>
<p><strong>7，BuffAfterKilled</strong></p>
<p>　　当杀死一个角色的时候，恢复自身X%的HP，这时候你就需要这个回调点，精确的在角色死亡后发生。</p>
<p>　　机制始终是机制，或者说是思维方式，他真正的运行还是取决于游戏本身，回调点我只是随便举个例子而已，事实上根据游戏不同，完全可以增加或者删除回调点，比如一个MT卡牌游戏他就完全不需要onTick这样的回调点，但他可以有BeforeMove（角色行动前）等回调点，这取决于游戏本身机制。同样的每一个视觉特效都可以在每一个回调点去播放，你可以设计好这样的规则不是吗？</p>
<p>　　接下来，我们就在这个机制的基础上分析一下LoL的一些技能，我印象最深的那些，我已经很久不玩LoL了：</p>
<p>　　1，蛮王的6秒真男人，一个Buff，在BeforeKilled时候调用，Return1作为最后设定的HP，并被写在回调代码的最后。</p>
<p>　　2，盲僧、瑞文的连续技能，事实上这也是你肉眼看不到的Buff（机制正是如此奇妙，未必被直接运用，正如我所说，他是一种思路），当有Buff的时候技能A变成技能B，移除后恢复，OnSkillCast的回调点（往往技能施展中会需要回调点，因此回调点还是根据游戏具体分析出来的）。</p>
<p>　　3，火男的昏迷，火男的法术会为目标添加一个Buff，而法术在OnHit的时候会检查如果存在这个Buff则执行XX效果导致昏迷，否则普通效果。</p>
<p>　　4，安妮的昏迷，你如果有仔细看了2并思考了，这不是问题。</p>
<p>　　5，大嘴的自爆，在角色死亡的时候产生免疫性Buff，Buff结束时产生AOE，如果你这么思考，这会简单很多。</p>
<p>　　这套机制在实际工作中，我们需要如何去分工呢？事实上已经很清晰了：</p>
<p>　　策划：需要设计出所有的回调点，事实上策划如果完全不了解程序的效率等问题是无法设计好的，最好还能大概了解所谓回调机制，因为除了回调点意外，你还需要设计出回调时候传的参数，以及返回给程序的参数及其工作顺序，除此之外一些基础的表象也需要去制作，如buff的名称，那么在做表的时候会有2种风格，在起凡的时候我可以不用太关心，因为每个人都会用Lua写回调函数，但之后的项目中，我是用了我常推荐的Tag机制，比如策划填写一个Buff效果些daze_60之类的我就可以把它分析为60%几率昏迷目标等。在设计这些东西的时候为了更有效地避免夸夸其谈，策划对于实现的了解还是非常重要的，而事实上我们这里已经是策划动手写逻辑代码了，这问题就相对好办些。策划除此之外还应该归纳出特效播放点、数据同步时间点等等和游戏核心机制相结合的东西。这世界上也有很多好的创意，但你必需知道机制士兵不能帮你实现的，更重要的是你要知道自己想做什么和怎么去做，因此设计buff的时候切勿滥用机制，机制用的不好反而弄巧成拙，而合理的拆分Buff的效果也是一个策划的价值所在。</p>
<p>　　程序：程序的工作则是优化好回调点和策划可能滥用到家的循环，这是非常头疼的事情，因此很可能需要更好的机制替他们实现一些该死的逻辑优化，可是这并不是最重要的，最主要的工作还是完成一些底层接口功能，比如在某个绑点上播放某个特效之类的，这些是策划都是即使会写逻辑代码也写不好的东西，也正是程序员强势所在（因此我并不认为游戏程序员非得精通游戏，但必须了解一二，才能大概思考一些优化、渲染的逻辑）。</p>
<p>　　美术：视觉特效肯定少不了你的，搞不好还得弄动作，音乐跑的了音效跑不了，做吧，策划会整理出大量的需求列表的，如果上面说做那就做了。</p>
<p>　　在你了解了Buff的工作机制之后，你才有资格进一步的谈创意，不然都是胡扯蛋，你都不知道怎么去做，你怎么去创造呢？那么假如让我把吕布加入到LoL中，我会给他设计什么样的被动技能呢？就让我们一起YY下（确切的说知道实现方式的YY才是有价值的）：</p>
<p>　　被动：人中吕布，任何普通攻击（我想LoL的普通攻击应该也是有标记的，起凡当时是skillId==28近战、30远程，事实上我不太赞成这样的skillId特殊标记法）的时候会为吕布添加1层“人中吕布”（另外一个buff）<br>“人中吕布”到15层、25层、35层、45层、50层时更换视觉特效(BuffOccur BuffRemoved)。人中吕的特性是15层开始普通攻击有几率造成双倍伤害，25层开始受到伤害有几率减少20%，35层开始释放技能获得导致目标昏迷2秒，45层开始释放技能恢复自身25%生命，50层时技能对20%生命以下目标一击必杀，死亡是损失一半层数(beKilled)。这么牛逼的效果？是啊，中国人当然应该牛逼了。慢来，才YY开始，这算设计好了？早呢，为了这些效果，你需要在“人中吕布”Occur Remove中去根据当前层数添加删除Buff：</p>
<p>　　人中吕布_双倍伤害，普通攻击OnHit投随机数决定是否伤害x2。</p>
<p>　　人中吕布_几率免伤，BeHurt时候投随机数决定是否降低一定的伤害。</p>
<p>　　人中吕布_强力攻击，Onhit判断不是普通攻击则给目标一个2秒的Buff1层。</p>
<p>　　强力攻击_昏迷，Occur携带者昏迷属性为true，Remove就不需要设置false了，因为他可能还有别的buff让他昏迷，但是Remove和Occur的时候都要重新计算一次属性状态就对了。说到这里，这个Buff互相堆叠又是很讨厌的逻辑，2个SS可以给同一个目标释放腐蚀术，产生2个，但是自己却只能对1个目标上1个，等等等等。</p>
<p>　　人中吕布_技能恢复，OnCast的时候（事实上LoL应该只有OnHit，这也可以），判断不是普通攻击则回复生命。</p>
<p>　　人中吕布_斩杀，OnHit判断目标生命比，决定是否造成999999伤害。</p>
<p>其实如你楼下一层说的，这个机制的最大优势在于，它可以实现很多难以预料的功能，如果策划足够给力的话。<br>实际的经验是，一个项目中产生很多沟通问题的本质是，策划并不能归纳出自己想要什么，而程序员更不可能提早知道你想做什么，预判是一道鸿沟，无法跨越，因为我们都不是先知，而年轻的策划很多神奇的想法更是无法预判的，但如果放弃这些想法中的一些精化会非常可惜。因此在项目开发中尽可能去做一些能够更有“包容性”的设计，是非常重要的事情，这解决了后期的很多问题。<br>你可以发现我提倡的很多机制或者想法都具有“包容性”或者说“预判性”，包括Tag机制本身，很多年轻的策划或者程序并不能理解为什么明明我们可以用id数字分段做的事情非要想的如此复杂，但事实是当你需要把你的分段规则详细的说给后来的人知道的时候，你甚至需要花费几周时间，还未必能说清楚，更糟糕的是，也许你自己都忘了当初的约定。<br>Buff机制也是如此，它的优势在于程序员、包括策划自己并不需要一开始就知道我要具体做什么，但是我们可以先把框架搭起来或者说可以开始动手制作项目了，而后期灵感突发的时候，并不是非得“放到下一个项目”的。<br>而技能机制，在我看来反而只是一个辅助的体系，因为它只是一套简单的流程，作为一个入行的新人都应该轻松的完成他的开发，但是很多不太好的做法却是把技能的效果复杂化了，以至于程序员被误导，后期很难对技能维护。因此技能的效果，事实上就是Hp_Dmg（这么多年了我都用这个函数来造成伤害，因为名字很有趣），CreateBuffObj，CreateAoEObj，就是这么简单，一个技能的效果可以同时调用多条这样的功能，但只限于这样的功能。至于花哨的东西，就让Buff系统去完成。<br>因此这里还说了一个重点，对于策划来说，研发最大的技巧就是“拆”，如何把你的想法拆成最基础的元素，这样大家在实现的时候就不会有很多不必要的麻烦，在之后的debug中也会方便很多——比如我说的昏迷插法。一个优秀的程序员（至少我不是）他/她一定是把心思放在读书上，至少在学习计算机编程的时候他/她们非常棒，这也导致了他们不太可能像我们策划一样了解游戏，因此不应该把一些“难以理解”的东西拿来去塞给程序员做（事实上难以理解本身是因为它有太多的“专业名词”和超乎自然的地方，这也是游戏魅力所在），你也许没见过把“沉默”做成了“禁言”功能的程序员，他认为法师释放了一个沉默法术后，对方玩家就不能发送聊天内容了，因为被“沉默”了。<br>降低研发成本，从设计师角度来说主要还是沟通成本，现在已经成为了很多公司必须面对的课题了，明明一个简单到10小时能完成的逻辑，在很多公司居然能花费好几个人用好几十天去做，并且没能完成（因为策划总是在添加和改变想法，而程序员却陪太子读书了）。<br>“猴子”这个称呼并不适合一个200多斤的人<img src="../../assets/images/2020-02-16-buff-system/lol.gif" alt="img">，龙与地下城——欧美人眼中最强的生物和它的巢穴，都是字母D开头中间用and连接，它骨子里是一套分析世界的数学模型，骰子实现了世界上很多所谓运气的东西；猴与花果山，它应该是中国人的DND，猴象征着欧美人眼中的中国人，也是孙悟空的表现，花果山则是孙悟空的住所，Monkey and Mountain，前后2个M，就是巧妙的地方，15年前我想做一套中国人的DnD，但至今没法实现，很多原因导致我们在娱乐方面缺少类似骰子这样的基础文化。</p>
<p>相关链接</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/150812545" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150812545</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>角色状态设计</title>
    <url>/unity-2020-02-17-character-states/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/Renyi-Fan/p/9569090.html" target="_blank" rel="noopener">https://www.cnblogs.com/Renyi-Fan/p/9569090.html</a></p>
<p><a href="https://www.gameres.com/797311.html" target="_blank" rel="noopener">https://www.gameres.com/797311.html</a></p>
<p><img src="../../assets/images/2020-02-17-character-states/20161103213426625" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Attribute</span><br><span class="line">        &#123;</span><br><span class="line">            public int Hp &#123; get; set; &#125;</span><br><span class="line">            public int Mp &#123; get; set; &#125;</span><br><span class="line">            public int HpTotal &#123; get; set; &#125;</span><br><span class="line">            public int MpTotal &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">            private Attribute m_Parent;</span><br><span class="line">            private string m_Name;</span><br><span class="line">            public Attribute(int hp, int mp)</span><br><span class="line">            &#123;</span><br><span class="line">                this.Hp &#x3D; hp;</span><br><span class="line">                this.Mp &#x3D; mp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public Attribute(int hp, int mp, string name) : this(hp, mp)</span><br><span class="line">            &#123;</span><br><span class="line">                this.m_Name &#x3D; name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public abstract void Calc();</span><br><span class="line">            public abstract int ChildCount();</span><br><span class="line">            protected void SetParent(Attribute child)</span><br><span class="line">            &#123;</span><br><span class="line">                child.m_Parent &#x3D; this;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public Attribute GetParent()</span><br><span class="line">            &#123;</span><br><span class="line">                return this.m_Parent;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void Show()</span><br><span class="line">            &#123;</span><br><span class="line">                Calc();</span><br><span class="line">                Console.WriteLine(string.Format(&quot;&#123;0&#125; 属性为： HP &#123;1&#125; MP &#123;2&#125;&quot;,this.m_Name, this.HpTotal, this.MpTotal));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AttributeComponent:Attribute</span><br><span class="line">        &#123;</span><br><span class="line">            private List&lt;Attribute&gt; m_AttributeList &#x3D; new List&lt;Attribute&gt;();</span><br><span class="line"></span><br><span class="line">            public AttributeComponent(int hp, int mp) : base(hp, mp)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public AttributeComponent(int hp, int mp, string name) : base(hp, mp, name) &#123; &#125;</span><br><span class="line"></span><br><span class="line">            public override void Calc()</span><br><span class="line">            &#123;</span><br><span class="line">                this.HpTotal &#x3D; this.Hp;</span><br><span class="line">                this.MpTotal &#x3D; this.Mp;</span><br><span class="line"></span><br><span class="line">                foreach (Attribute item in m_AttributeList)</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F;递归计算属性和</span><br><span class="line">                    if (item.ChildCount() &gt; 0)</span><br><span class="line">                        item.Calc();</span><br><span class="line"></span><br><span class="line">                    this.HpTotal +&#x3D; item.HpTotal;</span><br><span class="line">                    this.MpTotal +&#x3D; item.MpTotal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public override int ChildCount()</span><br><span class="line">            &#123;</span><br><span class="line">                return m_AttributeList.Count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void AddAttribute(Attribute attribute)</span><br><span class="line">            &#123;</span><br><span class="line">                SetParent(attribute);</span><br><span class="line">                this.m_AttributeList.Add(attribute);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            public void RemoveAttribute(Attribute attribute)</span><br><span class="line">            &#123;</span><br><span class="line">                m_AttributeList.Remove(attribute);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public void TestMethod1()</span><br><span class="line">        &#123;</span><br><span class="line">            AttributeComponent basic &#x3D; new AttributeComponent(50, 100, &quot;Ali&quot;);</span><br><span class="line">            AttributeComponent lvUp &#x3D; new AttributeComponent(50, 100, &quot;升级增加&quot;);</span><br><span class="line">            AttributeComponent weapon &#x3D; new AttributeComponent(10, 20, &quot;无级弓&quot;);</span><br><span class="line">            AttributeComponent weaponEnchanting &#x3D; new AttributeComponent(5, 5, &quot;附魔增加&quot;);</span><br><span class="line"></span><br><span class="line">            basic.Show();</span><br><span class="line">            Console.WriteLine(&quot;升级啦&quot;);</span><br><span class="line">            Console.WriteLine(&quot;---------------------------------------------------&quot;);</span><br><span class="line">            lvUp.Show();</span><br><span class="line">            basic.AddAttribute(lvUp);</span><br><span class="line">            basic.Show();</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;装备了武器&quot;);</span><br><span class="line">            Console.WriteLine(&quot;---------------------------------------------------&quot;);</span><br><span class="line">            weapon.Show();</span><br><span class="line">            basic.AddAttribute(weapon);</span><br><span class="line">            basic.Show();</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;武器附魔&quot;);</span><br><span class="line">            Console.WriteLine(&quot;---------------------------------------------------&quot;);</span><br><span class="line">            weaponEnchanting.Show();</span><br><span class="line">            weapon.AddAttribute(weaponEnchanting);</span><br><span class="line">            weapon.Show();</span><br><span class="line">            basic.Show();</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;卸载装备&quot;);</span><br><span class="line">            Console.WriteLine(&quot;---------------------------------------------------&quot;);</span><br><span class="line">            basic.RemoveAttribute(weapon);</span><br><span class="line">            basic.Show();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/alistair_chow/article/details/53029909" target="_blank" rel="noopener">https://blog.csdn.net/alistair_chow/article/details/53029909</a></p>
<p><a href="https://blog.csdn.net/alistair_chow/article/details/53026375" target="_blank" rel="noopener">https://blog.csdn.net/alistair_chow/article/details/53026375</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>理解托管堆</title>
    <url>/unity-2020-02-18-BestPracticeUnderstandingPerformanceInUnity/</url>
    <content><![CDATA[<p>另一个Unity开发者面对的普遍问题是托管堆的意外扩展。在Unity中，托管堆的扩张比收缩更加容易。进一步说，Unity的垃圾回收策略倾向于碎片化内存，这可以防止收缩出来一个大的堆。</p>
<hr>
<h2 id="技术细节：托管堆怎样运行以及为什么它会扩张"><a href="#技术细节：托管堆怎样运行以及为什么它会扩张" class="headerlink" title="技术细节：托管堆怎样运行以及为什么它会扩张"></a>技术细节：托管堆怎样运行以及为什么它会扩张</h2><p>​    托管堆是内存中被项目脚本运行时（Mono或者IL2CPP）的内存管理器自动管理的部分。在托管代码中创造的所有对象必须被分配在托管堆上（请注意：严格的说，所有非空引用类型的对象和所有被装箱的值类型对象都必须被分配到托管堆上）。</p>
<p><img src="../../assets/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_0.png" alt="img"></p>
<p>​    在上面的图表中，白色的方块表示分配到托管堆的内存量，它里面有颜色的方块表示托管堆内存空间中存储的数据值。当另外的值被需要时，将会从托管堆中分配更多空间。</p>
<p>​    垃圾收集器周期运行（请注意：具体时间取决于不同的平台）。会清扫堆上的所有对象，检查那些不再被引用的对象并标记。然后删除没有被引用的对象，释放内存。</p>
<p>​    至关重要的是，Unity的垃圾收集是，采用<a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector" target="_blank" rel="noopener">Boehm GC算法</a>，是非世代和非压缩的。非世代意味着当执行一次收集的时候，GC必须清扫全部的托管堆，并且性能会随着堆的扩张而降低。非压缩意味着内存中的对象不会重新移动位置来使对象间的空隙关闭。</p>
<p><img src="../../assets/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_1.png" alt="img"></p>
<p>​    上面的图显示了一个内存片段的例子。当一个对象被释放时，其内存也会被清空。但是被释放的空间不会变成一个大的可用内存池的一部分。被释放对象两边的对象仍然被使用。由于这个原因，被释放的内存变成了其他内存段中间的空隙（这个空隙在上图中由红圈标明）。这个新释放的空间只能用于存储与它完全相同或者更小大小的对象。 </p>
<p>​    当分配一个对象时，请记住在内存中对象必须总是占用一段连续的空间。</p>
<p>​    这导致了内存碎片的核心问题，虽然堆中的总可用空间是非常大的，但是可能一部分或者所有这些可用空间是被分配对象间的小空隙。在这种情况下，尽管可能会有足够的总空间来容纳一个确定大小的分配，但是托管堆找不到一块足够大的连续内存来适配这次分配。</p>
<p><img src="../../assets/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_2.png" alt="img"></p>
<p>​    然而，如果一个大的对象被分配，并且没有足够的连续空间来容纳这个对象，如同上图所示，那么Unity的内存管理器将执行两个操作。</p>
<p>​    首先，如果垃圾收集器还没有运行，那么它就会运行。尝试释放足够的空间来填充内存分配的需求。</p>
<p>​    如果，GC运行完毕，仍然没有可以满足需求的连续内存空间，那么托管堆将会被扩大。托管堆扩大的具体大小由平台决定；然而，大多数Unity平台将托管堆扩大一倍。</p>
<hr>
<h2 id="托管堆的关键问题"><a href="#托管堆的关键问题" class="headerlink" title="托管堆的关键问题"></a>托管堆的关键问题</h2><p>​    托管堆的核心问题是其扩张是以两倍进行的：</p>
<p>​    ·当托管堆扩张时，Unity并不总是释放分配到托管堆的内存页，它采取一个优化策略，保持扩张的托管堆，即使托管堆大部分是空的。这用来避免当有更大的内存分配发生时需要重新扩大托管堆。</p>
<p>​    ·在大多数平台上，Unity最终会将托管堆上那部分空的内存页释放回操作系统。这个发生的间隔时间是不能保证的，并且也不能被依靠。</p>
<p>​    ·用于托管堆的地址空间（栈）不再会被返还给操作系统。</p>
<p>​    ·对于32位程序来说，如果托管堆扩张收缩多次，这会导致地址空间（栈）耗尽。如果一个程序可用内存的地址空间（栈）被耗尽，操作系统将会终止这个程序。</p>
<p>​    ·对于64位程序来说，地址空间（栈）足够大，这对于运行时间不超过人类平均寿命的程序来说基本不会发生。</p>
<hr>
<h2 id="临时分配"><a href="#临时分配" class="headerlink" title="临时分配"></a>临时分配</h2><p>​    许多Unity项目都发现每帧有几十或几百kb的临时数据分配到托管堆处理。这通常对项目性能是非常有害的。考虑下面的计算：</p>
<p>​    如果一个程序每帧分配1kb的临时内存，运行在每秒60帧的情况下，那么它每秒就会分配60kb的内存。在一分钟之内，这在内存中增加了3.6mb的垃圾。每秒执行一次垃圾回收器会降低性能，但是尝试在低内存设备上运行时每分钟分配3.6mb内存是有问题的。</p>
<p>​    进一步说，考虑到加载操作。如果在一个繁重的资源加载过程中生成了大量的临时对象，并且这些对象被引用到该操作完成，那么垃圾回收器则不能释放这些临时对象并且托管堆需要扩张——即使托管堆中包含的许多这些对象马上就会被释放。</p>
<p><img src="../../assets/images/2020-02-18-BestPracticeUnderstandingPerformanceInUnity/UnderstandingPerformanceinUnity-AssetAuditingSection_image_3.png" alt="img"></p>
<p>​    保持对托管内存分配的追踪非常简单。在Unity的CPU Profiler中，概述写着“GC Alloc”那一列。这一行显示着在某一帧分配到托管堆的比特数。（请注意：这个数字与在制定帧分配的临时比特数不相同。分析器显示的事在特定帧被分配的比特数量，即使这些被分配内存的一些或全部在随后的帧中被复用。）将“Deep Profiling”选项打开，这就可以追踪这些内存分配是在哪些函数中发生的。</p>
<p>​    Unity Profiler不会追踪那些没有发生在主线程的内存分配。因此，“GC Alloc”列就不能用来测量在用户自己创建的线程中的托管内存分配。可以把其他线程中的代码切换到主线程中执行来进行调试，或使用BeginThreadProfiling这个API来在Profiler的TimeLine选项卡中来显示样本。</p>
<p>​    在目标设备上使用开发模式构建可以分析托管内存分配。</p>
<p>​    请注意：一些脚本函数在Editor中运行会导致内存分配，但是当项目构建后就不会再产生内存分配。GetComponent就是最普遍的例子，这个函数在Editor中运行时总是会产生内存分配，但是在构建好的项目中就不会。</p>
<p>​    总体来说，我们强烈的建议所有开发者当项目在交互状态时最小化托管堆内存分配。如果内存分配发生在没有交互操作的时候，比如说场景加载时，问题较少。</p>
<p>​    Jetbrains Resharper这个Visual Studio插件可以帮助定位代码中的内存分配。</p>
<p>​    使用Unity的深度分析模式来定位托管内存分配的特定原因。在深度分析模式，所有的函数的调用都被独立记录，在函数调用树中提供一个清晰界面来显示托管内存分配是在哪里发生的。请注意，深度分析模式不止在编辑器中，也可以使用命令行参数-deepprofiling在安卓和桌面上使用。在分析过程中深度分析器按钮保持灰色。</p>
<hr>
<h2 id="基础内存维护"><a href="#基础内存维护" class="headerlink" title="基础内存维护"></a>基础内存维护</h2><p>​    有一些相对简单的技术来使托管堆内存分配降低。</p>
<hr>
<h4 id="容器和数组重用"><a href="#容器和数组重用" class="headerlink" title="容器和数组重用"></a>容器和数组重用</h4><p>​    当使用C#的容器类或者数组时，如果可能考虑重用或者缓存分配的容器或者数组。容器类暴露了一个Clear函数，当清除容器的值时不会释放分配给容器的内存。</p>
<blockquote>
<p>void Update() {</p>
<p>  List<float> nearestNeighbors = new List<float>();</p>
<p>  findDistancesToNearestNeighbors(nearestNeighbors);</p>
<p>  nearestNeighbors.Sort();</p>
<p>  // … use the sorted list somehow …</p>
<p>}</p>
</blockquote>
<p>​    当给一个复杂计算分配临时的“帮助性”容器时尤其好用。下面的代码是一个非常简单的例子：</p>
<p>​    在这个例子中，nearestNeighbors列表每帧被分配一次，用于存储一些数据点。可以把这个列表非常简单的从这个函数中提出来放入函数所在的类中，这避免了每帧分配一个新的列表：</p>
<blockquote>
<p>List<float> m_NearestNeighbors = new List<float>();</p>
<p>void Update() {</p>
<p>  m_NearestNeighbors.Clear();</p>
<p>  findDistancesToNearestNeighbors(NearestNeighbors);</p>
<p>  m_NearestNeighbors.Sort();</p>
<p>  // … use the sorted list somehow …</p>
<p>}</p>
</blockquote>
<p>​    在这个版本中，每帧列表的内存会被保持和重用。只有当列表需要被扩大时内存才会被分配。</p>
<hr>
<h4 id="闭包和匿名函数"><a href="#闭包和匿名函数" class="headerlink" title="闭包和匿名函数"></a>闭包和匿名函数</h4><p>​    当使用闭包和匿名函数时，有两点需要考虑。</p>
<p>​    首先，所有函数引用在C#中都是引用类型，因此分配到了托管堆。临时内存分配可以通过作为一个参数传递函数引用很简单的创建。这个内存分配不管是使用匿名函数或者是预先定义好的函数来传递都会发生。</p>
<p>​    其次，转换一个匿名函数为闭包显著增加了需要传递闭包到函数接收的内存量。</p>
<p>​    考虑下面的代码：</p>
<blockquote>
<p>List<float> listOfNumbers = createListOfRandomNumbers();</p>
<p>listOfNumbers.Sort( (x, y) =&gt;</p>
<p>(int)x.CompareTo((int)(y/2))</p>
<p>);</p>
</blockquote>
<p>​    这段代码使用了一个简单的匿名函数来控制第一行创建的列表成员的排序方式。可是，如果一个程序员想要重用这段代码，可以考虑使用一个局部变量来代替常量2，像下面这样：</p>
<blockquote>
<p>List<float> listOfNumbers = createListOfRandomNumbers();</p>
<p>int desiredDivisor = getDesiredDivisor();</p>
<p>listOfNumbers.Sort( (x, y) =&gt;</p>
<p>(int)x.CompareTo((int)(y/desiredDivisor))</p>
<p>);</p>
</blockquote>
<p>​    现在匿名函数需要在此函数作用范围之外获取一个变量的状态，所以变成了一个闭包。desiredDivisor变量必须通过某种方式传进闭包中，以便被闭包中的实际代码所使用。</p>
<p>​    为了实现这个需求，C#生成了一个匿名类，用来保存闭包需要的超过作用范围的对象。当闭包被传入Sort函数时，将生成一个此类的副本，并且这个类的副本通过整数desiredDivisor的值来初始化。</p>
<p>​    由于执行闭包需要实例化一个生成它的类的拷贝，在C#中所有类都是引用类型，那么执行一个闭包需要在托管堆中分配一个对象。</p>
<p>​    总体来说，如果可能最好避免在C#中使用闭包。在性能敏感的代码中应该尽量最小化使用匿名函数和函数引用，尤其是在基于每帧执行的代码中。</p>
<hr>
<h4 id="IL2CPP下的匿名函数"><a href="#IL2CPP下的匿名函数" class="headerlink" title="IL2CPP下的匿名函数"></a>IL2CPP下的匿名函数</h4><p>​    目前，检查通过IL2CPP生成的代码，显示简单的声明以及指定一个System.Function类型的变量会分配一个新的对象。无论这个变量是显式（在一个函数或类中声明）或是隐式（作为一个函数的参数声明）都会这样。</p>
<p>​    所以，在IL2CPP脚本后端下所有使用匿名函数的情况都会分配托管堆内存。Mono脚本后端不是这种情况。</p>
<p>​    进一步说，在IL2CPP中，由于函数参数声明方式的不同，会有显著不同的托管堆内存分配量级的不同。正如预期的那样，闭包在每次调用中分配最多的内存。</p>
<p>​    不直观的说，在IL2CPP脚本后端下，当作为一个参数传递预定义的函数时，分配近似于闭包的内存量。匿名函数在托管堆上生成最少量的暂时垃圾，这是通过一个或多个量级的指令实现的。</p>
<p>​    所以，如果一个项目想要在IL2CPP脚本后端上发布，有三的关键点需要注意：</p>
<p>​    ·采取不需要传递函数作为参数的的编码风格</p>
<p>​    ·当这种情况不可避免时，采用匿名函数而不是预定义函数</p>
<p>​    ·避免闭包，不管用什么脚本后端</p>
<hr>
<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>​    装箱是Unity项目中最普遍的意识不到的临时内存分配的原。它发生在当一个值类型被当做引用类型使用时；这通常发生在传递原始的值类型变量（比如int和float）到对象类型的函数中。</p>
<p>​    在这个极度简单的例子中，为了要传递到object.Equals函数中，整数x被装箱，由于object的Equals函数要求传入的是一个object作为参数。</p>
<blockquote>
<p>int x = 1;</p>
<p>object y = new object();</p>
<p>y.Equals(x);</p>
</blockquote>
<p>​    C#的IDE和编译器通常不会对装箱发出警告，即使其导致了无意识的内存分配。这是因为C#语言是在小的临时内存分配会被世代的垃圾回收器和分配大小敏感的内存池有效率处理的假设下开发的。</p>
<p>​    由于Unity的内存分配器使用不区分内存分配大小的内存池，并且Unity的垃圾回收器也不是世代的，因此其不能有效率的清除由装箱带来的小的，频率的临时内存分配。</p>
<p>​    在Unity运行时使用C#编码时，应该尽量避免装箱。</p>
<hr>
<h4 id="识别装箱"><a href="#识别装箱" class="headerlink" title="识别装箱"></a>识别装箱</h4><p>​    基于正在使用的脚本后端，装箱在CPU跟踪数据中显示为一些函数的调用。它们通常采用下面的这些形式之一，<some class>是一些其他类或者结构体的名字，…是一些参数的数量：</p>
<p>​    ·<some class>::Box(…)</p>
<p>​    ·Box(…)</p>
<p>​    ·<some class>_Box(…)</p>
<p>​    它可以通过搜索反编译器或者IL查看器的输出来定位，例如ReSharper中内置的IL查看器或者dotPeek反编译器，IL指令是“box”。</p>
<hr>
<h4 id="字典和枚举"><a href="#字典和枚举" class="headerlink" title="字典和枚举"></a>字典和枚举</h4><p>​    一个普遍的造成装箱的问题是使用枚举类型来作为字典的键。声明一个枚举创建了一个新的值类型，在后台被作为像一个整数来对待，但是在编译时强制执行类型安全原则。</p>
<p>​    默认情况下，调用Dictionary.add(key, value)的结果是调用Object.getHashCode(Object)。这个函数用于为字典的键获得合适的散列码，并且用于所有接受key的函数：Dictionary.tryGetValue, Dictionary.remove等等。</p>
<p>​    Object.getHashCode函数是一个引用类型，但是枚举值始终是一个值类型。因此，对于枚举作为键的字典来说，每次函数调用都会至少一次对键进行装箱。</p>
<p>​    下面的代码片段举出了一个简单的例子展示了装箱的问题：</p>
<blockquote>
<p>enum MyEnum { a, b, c };</p>
<p>var myDictionary = new Dictionary&lt;MyEnum, object&gt;();</p>
<p>myDictionary.Add(MyEnum.a, new object());</p>
</blockquote>
<p>​    要解决这个问题，有必要写一个自定义的类实现IEqualityComparer接口，并且传递这个类的实例到字典的比较器中（请注意：这个对象通常是无状态的，所里可以被不同的字典重用以节省内存）。</p>
<p>​    下面的是一个对上面代片段实现IEqualityComparer的简单例子。</p>
<blockquote>
<p>public class MyEnumComparer : IEqualityComparer<MyEnum> {</p>
<p>  public bool Equals(MyEnum x, MyEnum y) {</p>
<p>​    return x == y;</p>
<p>  }</p>
<p>  public int GetHashCode(MyEnum x) {</p>
<p>​    return (int)x;</p>
<p>  }</p>
<p>}</p>
</blockquote>
<p>​    可以将上面类的实例传递给字典的构造函数。</p>
<hr>
<h4 id="Foreach循环"><a href="#Foreach循环" class="headerlink" title="Foreach循环"></a>Foreach循环</h4><p>​    在Unity版本的Mono的C#编译器中，使用foreach循环会在每次循环结束时强制Unity去装箱一个值（请注意：在每次循环整个结束的时候这个值会被装箱一次。在这个循环中每次迭代不会装箱，所以不论循环两次还是两百次内存使用都是相同的）。这是因为通过Unity的C#编译器生成的IL构造了一个通用的值类型枚举器以迭代值类型的容器。</p>
<p>​    这个枚举器实现的IDisposable接口，其肯定会在循环终止时被调用。然而，在值类型对象（比如结构体和枚举器）上调用接口函数需要把它们装箱。</p>
<p>​    检查下面非常简单的代码例子：</p>
<blockquote>
<p>int accum = 0;</p>
<p>foreach(int x in myList) {</p>
<p>  accum += x;</p>
<p>}</p>
</blockquote>
<p>​    上面的代码，当通过Unity的C#编译器运行时，产生下面的中间语言：</p>
<blockquote>
<p>.method private hidebysig instance void</p>
<p>  ILForeach() cil managed</p>
<p> {</p>
<p>  .maxstack 8</p>
<p>  .locals init (</p>
<p>   [0] int32 num,</p>
<p>   [1] int32 current,</p>
<p>   [2] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<int32> V_2</p>
<p>  )</p>
<p>  // [67 5 - 67 16]</p>
<p>  IL_0000: ldc.i4.0  </p>
<p>  IL_0001: stloc.0   // num</p>
<p>  // [68 5 - 68 74]</p>
<p>  IL_0002: ldarg.0   // this</p>
<p>  IL_0003: ldfld    class [mscorlib]System.Collections.Generic.List`1<int32> test::myList</p>
<p>  IL_0008: callvirt   instance valuetype [mscorlib]System.Collections.Generic.List<code>1/Enumerator&lt;!0/*int32*/&gt; class [mscorlib]System.Collections.Generic.List</code>1<int32>::GetEnumerator()</p>
<p>  IL_000d: stloc.2   // V_2</p>
<p>  .try</p>
<p>  {</p>
<p>   IL_000e: br      IL_001f</p>
<p>  // [72 9 - 72 41]</p>
<p>   IL_0013: ldloca.s   V_2</p>
<p>   IL_0015: call     instance !0/<em>int32</em>/ valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<int32>::get_Current()</p>
<p>   IL_001a: stloc.1   // current</p>
<p>  // [73 9 - 73 23]</p>
<p>   IL_001b: ldloc.0   // num</p>
<p>   IL_001c: ldloc.1   // current</p>
<p>   IL_001d: add     </p>
<p>   IL_001e: stloc.0   // num</p>
<p>  // [70 7 - 70 36]</p>
<p>   IL_001f: ldloca.s   V_2</p>
<p>   IL_0021: call     instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<int32>::MoveNext()</p>
<p>   IL_0026: brtrue    IL_0013</p>
<p>   IL_002b: leave    IL_003c</p>
<p>  } // end of .try</p>
<p>  finally</p>
<p>  {</p>
<p>   IL_0030: ldloc.2   // V_2</p>
<p>   IL_0031: box     valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<int32></p>
<p>   IL_0036: callvirt   instance void [mscorlib]System.IDisposable::Dispose()</p>
<p>   IL_003b: endfinally </p>
<p>  } // end of finally</p>
<p>  IL_003c: ret     </p>
<p> } // end of method test::ILForeach</p>
<p>} // end of class test</p>
</blockquote>
<p>​    最有关系的代码是靠近最后的<strong>finally { … }</strong>语句块。callvirt指令在执行这个函数前在内存中发现IDisposable.Dispose方法的定位，并且要求这个枚举器被装箱。</p>
<p>​    总体来说，在Unity中应该避免使用foreach循环。不全是因为装箱，还有是通过枚举器实现的容器迭代的函数调用消耗比常规的for或者while循环的迭代要慢的多。</p>
<p>​    请注意在Unity5.5中C#编译器有了重大升级，增强了Unity生成IL的能力。特别是，装箱操作已经从foreach循环中消除。然而，由于函数调用的开销，与基于数组的等价代码相比CPU性能差距依旧存在。</p>
<hr>
<h4 id="有数组值的Unity-API-译者已查，在Unity官方文档中，会明确表明这些API有临时内存分配"><a href="#有数组值的Unity-API-译者已查，在Unity官方文档中，会明确表明这些API有临时内存分配" class="headerlink" title="有数组值的Unity API(译者已查，在Unity官方文档中，会明确表明这些API有临时内存分配)"></a>有数组值的Unity API(<em>译者已查，在Unity官方文档中，会明确表明这些API有临时内存分配</em>)</h4><p>​    一个更有害且难于发现的是由于重复使用Unity返回数组的API造成的虚拟的数组内存分配。所有返回数组的Unity的API都会在每次它们被访问时返回一个该数组新的拷贝。在没有必要的情况下经常访问有数组值的Unity的API效果非常不理想。</p>
<p>​    举个例子，下面的代码在vertices数组的每次迭代中虚拟的创造了四份拷贝。内存分配在每次.vertices属性被访问时发生。</p>
<blockquote>
<p>for(int i = 0; i &lt; mesh.vertices.Length; i++)</p>
<p>{</p>
<p>  float x, y, z;</p>
<p>  x = mesh.vertices[i].x;</p>
<p>  y = mesh.vertices[i].y;</p>
<p>  z = mesh.vertices[i].z;</p>
<p>  // …</p>
<p>  DoSomething(x, y, z); </p>
<p>}</p>
</blockquote>
<p>​    这可以通过普通的重构来使其只有一次数组内存分配，不论循环迭代多少次。这是通过在进入循环前存储vertices数组来实现的。</p>
<blockquote>
<p>var vertices = mesh.vertices;</p>
<p>for(int i = 0; i &lt; vertices.Length; i++)</p>
<p>{</p>
<p>  float x, y, z;</p>
<p>  x = vertices[i].x;</p>
<p>  y = vertices[i].y;</p>
<p>  z = vertices[i].z;</p>
<p>  // …</p>
<p>  DoSomething(x, y, z); </p>
<p>}</p>
</blockquote>
<p>​    虽然CPU的消耗在访问一个属性一次时并不是非常高，在持续的循环中重复的访问它们会导致性能热点。进一步来讲，没必要的重复访问会导致托管堆的扩张。</p>
<p>​    这个问题再移动设备上非常普遍，因为Input.touches这个API的行为与上述类似。这在包含下面的类似代码的项目中也非常普遍，内存分配发生在每次访问.touches属性时。</p>
<blockquote>
<p>for ( int i = 0; i &lt; Input.touches.Length; i++ )</p>
<p>{</p>
<p>  Touch touch = Input.touches[i];</p>
<p>  // …</p>
<p>}</p>
</blockquote>
<p>​    然而，现在有很多Unity的API有不会造成内存分配的新版本。当使用这些时，应该是更有利的。</p>
<blockquote>
<p>int touchCount = Input.touchCount;</p>
<p>for ( int i = 0; i &lt; touchCount; i++ )</p>
<p>{</p>
<p>  Touch touch = Input.GetTouch(i);</p>
<p>  // …</p>
<p>}</p>
</blockquote>
<p>​    转换上面的例子到Touch API 无内存分配的版本是非常简单的：</p>
<p>​    请注意：这个属性的访问(Input.touchCount)仍旧要放在循环条件的外面，这是为了节省CPU在执行属性get方法时的消耗。</p>
<hr>
<h4 id="空数组重用"><a href="#空数组重用" class="headerlink" title="空数组重用"></a>空数组重用</h4><p>​    一些团队在一个数组返回值的函数需要返回一个空值时，倾向于用返回一个空数组来代替null。这种编码模式在许多托管语言中非常常见，尤其是C#和Java。</p>
<p>​    总体来说，当一个函数返回一个长度为0的数组时，返回一个预先分配好的长度为0的数组的单例实例比重复创造空数组被认为更有效率。（请注意：当然，一个例外情况要考虑那就是当返回的数组需要改变长度时）</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>Java</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>理解自动内存管理</title>
    <url>/unity-2020-02-19-UnderstandingAutomaticMemoryManagement/</url>
    <content><![CDATA[<p>当创建对象、字符串或数组时，存储它所需的内存将从称为堆的中央池中分配。当项目不再使用时，它曾经占用的内存可以被回收并用于别的东西。在过去，通常由程序员通过适当的函数调用明确地分配和释放这些堆内存块。如今，像Unity的Mono引擎这样的运行时系统会自动为您管理内存。自动内存管理需要比显式分配/释放更少的编码工作，并大大降低内存泄漏（内存被分配但从未随后释放的情况）的可能性。</p>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>当调用一个函数时，它的参数值将被复制到一个保留特定调用的内存区域。只占用几个字节的数据类型可以非常快速方便地复制。然而，对象、字符串和数组要大得多，如果这些类型的数据被定期复制，那将是非常低效的。幸运的是，这是不必要的；大项目的实际存储空间是从堆中分配的，一个小的“指针”值用来记住它的位置。从那时起，只有指针在参数传递过程中需要被复制。只要运行时系统能够定位指针标识的项，就可以经常使用数据的一个副本。<br>在参数传递期间直接存储和复制的类型称为值类型。这些包括整数，浮点数，布尔和Unity的结构类型（例如Color和Vector3）。分配在堆上然后通过指针访问的类型称为引用类型，因为存储在变量中的值仅仅是“引用”到真实数据。引用类型的示例包括对象，字符串和数组。</p>
<h2 id="内存分配和垃圾收集"><a href="#内存分配和垃圾收集" class="headerlink" title="内存分配和垃圾收集"></a>内存分配和垃圾收集</h2><p>内存管理器跟踪它知道未被使用的堆中的区域。当请求一个新的内存块时（例如当一个对象被实例化时），管理器选择一个未使用的区域，从中分配该块，然后从已知的未使用的空间中移除分配的内存。后续请求以相同的方式处理，直到没有足够大的空闲区域分配所需的块大小。在这一点上，从堆中分配的所有内存仍然在使用中是非常不可能的。只要还存在可以找到它的引用变量，就只能访问堆上的引用项。如果对内存块的所有引用都消失了（即，引用变量已被重新分配，或者它们是现在超出范围的局部变量），则它占用的内存可以安全地重新分配。<br>为了确定哪些堆块不再被使用，内存管理器会搜索所有当前活动的引用变量，并将它们所指的块标记为<code>live</code>。在搜索结束时，内存管理器认为这些<code>live</code>块之间的任何空间都是空的，并且可用于后续分配。由于显而易见的原因，定位和释放未使用的内存的过程被称为垃圾回收（或简称GC）。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>垃圾收集对程序员来说是自动的、不可见的，但是收集过程实际上需要大量的CPU时间。如果正确使用，自动内存管理通常会等于或击败手动分配的整体性能。但是，对于程序员来说，重要的是要避免那些比实际需要触发更多次收集器和在执行中引入暂停的错误。有一些臭名昭著的算法，可能是GC噩梦，尽管他们乍一看是无辜的。重复字符串连接是一个典型的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C# script example</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleScript : MonoBehaviour &#123;</span><br><span class="line">    void ConcatExample(int[] intArray) &#123;</span><br><span class="line">        string line &#x3D; intArray[0].ToString();</span><br><span class="line">        </span><br><span class="line">        for (i &#x3D; 1; i &lt; intArray.Length; i++) &#123;</span><br><span class="line">            line +&#x3D; &quot;, &quot; + intArray[i].ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS script example</span><br><span class="line">function ConcatExample(intArray: int[]) &#123;</span><br><span class="line">    var line &#x3D; intArray[0].ToString();</span><br><span class="line">    </span><br><span class="line">    for (i &#x3D; 1; i &lt; intArray.Length; i++) &#123;</span><br><span class="line">        line +&#x3D; &quot;, &quot; + intArray[i].ToString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的关键细节是，新的部分不会被一个接一个地添加到字符串中。实际情况是，每次循环<code>line</code>变量的前一个内容都会变死——一个完整的新字符串被分配到包含原来的部分，再在最后加上新的部分。由于字符串随着<code>i</code>值的增加而变得更长，所以所消耗的堆空间数量也增加了，因此每次调用这个函数时都很容易消耗数百字节的空闲堆空间。如果你需要连接多个字符串，那么一个更好的选择是Mono库的<a href="https://msdn.microsoft.com/en-gb/library/system.text.stringbuilder.aspx" target="_blank" rel="noopener">System.Text.StringBuilder</a>类。然而，即使反复连接也不会引起太多麻烦，除非它被频繁调用，而在Unity中通常意味着帧更新。就像是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C# script example</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleScript : MonoBehaviour &#123;</span><br><span class="line">    public GUIText scoreBoard;</span><br><span class="line">    public int score;</span><br><span class="line">    </span><br><span class="line">    void Update() &#123;</span><br><span class="line">        string scoreText &#x3D; &quot;Score: &quot; + score.ToString();</span><br><span class="line">        scoreBoard.text &#x3D; scoreText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS script example</span><br><span class="line">var scoreBoard: GUIText;</span><br><span class="line">var score: int;</span><br><span class="line"></span><br><span class="line">function Update() &#123;</span><br><span class="line">    var scoreText: String &#x3D; &quot;Score: &quot; + score.ToString();</span><br><span class="line">    scoreBoard.text &#x3D; scoreText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>…每次调用Update将分配新字符串，并不断生成的新垃圾。大多数情况下，只有当分数变化时才更新文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C# script example</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleScript : MonoBehaviour &#123;</span><br><span class="line">    public GUIText scoreBoard;</span><br><span class="line">    public string scoreText;</span><br><span class="line">    public int score;</span><br><span class="line">    public int oldScore;</span><br><span class="line">    </span><br><span class="line">    void Update() &#123;</span><br><span class="line">        if (score !&#x3D; oldScore) &#123;</span><br><span class="line">            scoreText &#x3D; &quot;Score: &quot; + score.ToString();</span><br><span class="line">            scoreBoard.text &#x3D; scoreText;</span><br><span class="line">            oldScore &#x3D; score;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS script example</span><br><span class="line">var scoreBoard: GUIText;</span><br><span class="line">var scoreText: String;</span><br><span class="line">var score: int;</span><br><span class="line">var oldScore: int;</span><br><span class="line"></span><br><span class="line">function Update() &#123;</span><br><span class="line">    if (score !&#x3D; oldScore) &#123;</span><br><span class="line">        scoreText &#x3D; &quot;Score: &quot; + score.ToString();</span><br><span class="line">        scoreBoard.text &#x3D; scoreText;</span><br><span class="line">        oldScore &#x3D; score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数返回数组值时，会发生另一个潜在的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C# script example</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleScript : MonoBehaviour &#123;</span><br><span class="line">    float[] RandomList(int numElements) &#123;</span><br><span class="line">        var result &#x3D; new float[numElements];</span><br><span class="line">        </span><br><span class="line">        for (int i &#x3D; 0; i &lt; numElements; i++) &#123;</span><br><span class="line">            result[i] &#x3D; Random.value;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS script example</span><br><span class="line">function RandomList(numElements: int) &#123;</span><br><span class="line">    var result &#x3D; new float[numElements];</span><br><span class="line">    </span><br><span class="line">    for (i &#x3D; 0; i &lt; numElements; i++) &#123;</span><br><span class="line">        result[i] &#x3D; Random.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建一个充满值的新数组时，这种函数非常优雅和方便。但是，如果反复调用，那么每次都会分配新的内存。由于数组可能非常大，可用空间可能会迅速消耗，从而导致垃圾收集频繁。避免这个问题的一个方法是利用数组是引用类型的事实。作为参数传递给函数的数组可以在该函数内修改，结果将在函数返回后保留。<br>像上面这样的功能通常可以被替换成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C# script example</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleScript : MonoBehaviour &#123;</span><br><span class="line">    void RandomList(float[] arrayToFill) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arrayToFill.Length; i++) &#123;</span><br><span class="line">            arrayToFill[i] &#x3D; Random.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS script example</span><br><span class="line">function RandomList(arrayToFill: float[]) &#123;</span><br><span class="line">    for (i &#x3D; 0; i &lt; arrayToFill.Length; i++) &#123;</span><br><span class="line">        arrayToFill[i] &#x3D; Random.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这只是用新值替换数组的现有内容。虽然这需要在调用代码中完成数组的初始分配（这似乎有些不雅），但是在调用该函数时不会产生任何新的垃圾。</p>
<h2 id="主动请求垃圾收集"><a href="#主动请求垃圾收集" class="headerlink" title="主动请求垃圾收集"></a>主动请求垃圾收集</h2><p>如上所述，最好尽量避免分配。然而，鉴于它们不能被完全消除，您可以使用两种主要策略来最大限度地减少其入侵游戏：</p>
<h3 id="小堆垃圾收集快速可频繁收集"><a href="#小堆垃圾收集快速可频繁收集" class="headerlink" title="小堆垃圾收集快速可频繁收集"></a>小堆垃圾收集快速可频繁收集</h3><p>这个策略通常最适合长期游戏的游戏，其中平滑的帧速率是主要的关注点。这样的游戏通常会频繁地分配小块，但这些块将仅在短时间内使用。在iOS上使用此策略时，典型的堆大小约为200KB，iPhone 3G上的垃圾收集大约需要5ms。如果堆增加到1MB，则收集大约需要7ms。因此，有时候可以以规则的帧间隔请求垃圾回收。这通常会使垃圾收集发生的次数比严格的需要的更多，但是它们将被快速处理，对游戏的影响最小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (Time.frameCount % 30 &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">   System.GC.Collect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，您应该谨慎使用此技术，并检查profiler统计信息，以确保它真正减少了游戏的收集时间。</p>
<h3 id="大堆垃圾收集缓慢且不可频繁收集"><a href="#大堆垃圾收集缓慢且不可频繁收集" class="headerlink" title="大堆垃圾收集缓慢且不可频繁收集"></a>大堆垃圾收集缓慢且不可频繁收集</h3><p>这个策略对于分配（和因此收集）相对不频繁并可以在游戏暂停期间处理的游戏最适用。对于堆来说，尽可能大，而不是因为系统内存太少而导致操作系统杀死你的应用程序。但是，如果可能，Mono运行时会自动避免扩展堆。您可以通过在启动期间预先分配一些占位符空间来手动扩展堆（即，您实例化一个纯粹用于对内存管理器产生影响的“无用”对象）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;C# script example</span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleScript : MonoBehaviour &#123;</span><br><span class="line">    void Start() &#123;</span><br><span class="line">        var tmp &#x3D; new System.Object[1024];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1024; i++)</span><br><span class="line">            tmp[i] &#x3D; new byte[1024];</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; release reference</span><br><span class="line">        tmp &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;JS script example</span><br><span class="line">function Start() &#123;</span><br><span class="line">    var tmp &#x3D; new System.Object[1024];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; make allocations in smaller blocks to avoid them to be treated in a special way, which is designed for large blocks</span><br><span class="line">        for (var i : int &#x3D; 0; i &lt; 1024; i++)</span><br><span class="line">        tmp[i] &#x3D; new byte[1024];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; release reference</span><br><span class="line">        tmp &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个足够大的堆不应该在游戏中的暂停期间完全被填满，这样可以容纳一次收集。当发生这样的暂停时，您可以显式地请求垃圾收集：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">System.GC.Collect();</span><br></pre></td></tr></table></figure>

<p>同样，在使用此策略时应该小心，并注意Profiler统计数据，而不是仅仅假定它具有所期望的效果。</p>
<h2 id="可重复使用的对象池"><a href="#可重复使用的对象池" class="headerlink" title="可重复使用的对象池"></a>可重复使用的对象池</h2><p>很多情况下，只要减少创建和销毁对象的数量，就可以避免生成垃圾。游戏中存在着某些类型的物体，如抛射体，尽管一次只会有少量的物体在游戏中，但它们可能会被反复地遇到。在这种情况下，常常可以重用对象，而不是破坏旧对象，并用新的对象替换它们。</p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>内存管理是一个微妙而复杂的课题，它已经投入了大量的学术研究。如果您有兴趣了解更多信息，那么<a href="http://www.memorymanagement.org/" target="_blank" rel="noopener">memorymanagement.org</a>是一个很好的资源，列出了许多出版物和在线文章。有关对象池的更多信息可以在<a href="https://en.wikipedia.org/wiki/Object_pool_pattern" target="_blank" rel="noopener">维基百科页面</a>和<a href="https://sourcemaking.com/design_patterns/object_pool" target="_blank" rel="noopener">Sourcemaking.com</a>上找到。</p>
<blockquote>
<p>原文链接：<a href="https://docs.unity3d.com/Manual/UnderstandingAutomaticMemoryManagement.html" target="_blank" rel="noopener">Understanding Automatic Memory Management</a></p>
</blockquote>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>unity 移动平台打包丢失shader的问题</title>
    <url>/unity-2020-02-20-shader-lost/</url>
    <content><![CDATA[<p>自己写了个shader，并且是从代码里面来进行加载，编辑器中并没有引用。在编辑器中运行项目没有问题，但是当我发布到iso和android平台之后发现游戏中并不能找到我自己的shader，猜想是unity在打包过程中进行了一些优化，没有用到的shader不会被打到游戏包内。</p>
<p>我找到了2个解决办法</p>
<p>1.随意创建一个物体并添加使用了此shader的材质。并不推荐此方法，正确的方法应该是第二种。</p>
<p>2.在GraphicsSettings中添加上此shader：</p>
<p>选择Edit-&gt;ProjectSettings-&gt;Graphics （不同的unity版本可能有所不同，我的版本是5.6）</p>
<p>将shader拖入到Always Included Shaders数组中：</p>
<p><img src="../../assets/images/2020-02-20-shader-lost/20180309110801448.png" alt="img"></p>
<p><img src="../../assets/images/2020-02-20-shader-lost/20180309110915442.png" alt="img"></p>
<p>这样我们重新打包之后，就可以正常找到shader了。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity的调试相关</title>
    <url>/unity-2020-03-01-unity-debug/</url>
    <content><![CDATA[<h1 id="vs2019-调试unity失效"><a href="#vs2019-调试unity失效" class="headerlink" title="vs2019 调试unity失效"></a>vs2019 调试unity失效</h1><p>s怎么启动调试都无法关联到unity，后来发现自己应该是不小心把attach editor勾选掉了，</p>
<p><img src="../../assets/images/2020-03-01-unity-debug/v2-8a3a1f8d3c6ed7317f18e2ac89620a38_1440w.jpg" alt="img"></p>
<p>注意这里要重启unity才会生效。勾选上之后就可以调试了。</p>
<h1 id="Unity3D-编辑器调试无响应问题"><a href="#Unity3D-编辑器调试无响应问题" class="headerlink" title="Unity3D 编辑器调试无响应问题"></a>Unity3D 编辑器调试无响应问题</h1><p> 使用 VS 在 Unity 编辑器中调试代码，点击 VS 的 <code>附加到 Unity</code>，Unity 编辑器按下 <code>Play</code> 之后，就会一直等待并且无其他响应，只能结束 Unity 进程。</p>
<p><img src="../../assets/images/2020-03-01-unity-debug/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E4%B8%ADUnity%E6%97%A0%E5%93%8D%E5%BA%94.png" alt="img"></p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>经过分析与测试，发现去掉代码中一个单例类的析构方法中的断点即可调试了，具体原因未知。</p>
<p>再测试了一下，在那个单例类的构造、析构方法中分别打断点，如下表：</p>
<table>
<thead>
<tr>
<th>测试</th>
<th>构造</th>
<th>析构</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td></td>
<td>可调试</td>
</tr>
<tr>
<td>2</td>
<td>*</td>
<td></td>
<td>可调试</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>*</td>
<td>无响应</td>
</tr>
<tr>
<td>4</td>
<td>*</td>
<td>*</td>
<td>无响应</td>
</tr>
</tbody></table>
<blockquote>
<p>表中 <code>*</code> 代表打断点</p>
</blockquote>
<p>可发现只要在那个单例类的析构中打断点就会造成 Unity 无响应。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>删除析构方法中的断点，或者所有断点，再调试。</p>
<h1 id="关于如何进行unity远程debugger"><a href="#关于如何进行unity远程debugger" class="headerlink" title="关于如何进行unity远程debugger"></a>关于如何进行unity远程debugger</h1><ul>
<li>首先打开unity的debug模式</li>
</ul>
<p><img src="../../assets/images/2020-03-01-unity-debug/2019-06-21-18-19-45.png" alt=""></p>
<ul>
<li>开启visual sudio中找到attach unity debugger</li>
</ul>
<p><img src="../../assets/images/2020-03-01-unity-debug/2019-06-21-18-20-01.png" alt=""></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>unity启动运行脚本流程</title>
    <url>/unity-2020-03-04-unity-startup/</url>
    <content><![CDATA[<p><strong>性能分析：</strong></p>
<p>所有尝试优化的操作都是从发现问题开始的，在谈论性能时，这是非常重要的。对一个应用进行性能分析，第一步是根据性能分析的结果，找出它的瓶颈。然后再优化项目中的用到的技术和资源的结构。</p>
<p>提示：本节性能分析中出现的方法名称，都是从unity5.3中提取的，方法名可能在以后的Unity版本中发生变化。</p>
<p><strong>工具：</strong></p>
<p>对于unity开发者来说，性能分析的工具有很多种。Unity有一系列的内置工具，比如CPU Profiler，Memory Profiler和5.3中新加的Memory Analyzer。</p>
<p>然而最好的分析数据通常来自于特定平台的工具。其中包括：</p>
<p>IOS:Instruments和XCode Frame Debugger</p>
<p>Android:Snapdragon Profiler</p>
<p>运行因特尔CPU/GPU的平台：VTune和Intel GPA</p>
<p>PS4:Razor系列</p>
<p>Xbox：Pix工具</p>
<p>这些工具通常能分析用IL2CPP打包出来的C++项目。这些本地代码版本中，能清晰的看到堆栈调用和各类方法的执行时间，如果用Mono编译，是做不到这些的。</p>
<p>关于IOS设备上怎么进行性能分析，Unity官方有一个基本的介绍。请看：</p>
<p><a href="https://blogs.unity3d.com/cn/2016/02/01/profiling-with-instruments/%3F_ga%3D2.53202159.65875105.1532310232-165234103.1528100648" target="_blank" rel="noopener">Profiling with Instruments – Unity Blogblogs.unity3d.com!</a></p>
<p><strong>启动流程剖析：</strong></p>
<p>当查看启动流程的时间时，有两个方法需要注意。在那些影响启动时间的配置文件、资源和工程代码中，这两个方法起着重要的作用。</p>
<p>在不同的平台上，启动时间是不同的。在大多数平台上，Splash Image显示的时间，就是启动的时间。</p>
<p><img src="../../assets/images/2020-03-04-unity-startup/v2-e65aeff3106290ff9e3de0580ffa90ab_720w.jpg" alt="img"></p>
<p>上面的截图来自于在iOS设备上运行的一个示例项目。在此平台的startUnity方法中，请注意UnityInitApplicationGraphics和UnityLoadApplication方法。</p>
<p>UnityInitApplicationGraphics执行了大量的内部操作，例如设置图形设备和初始化许多Unity的内部系统。另外，为了初始化Resource系统，它必须加载Resource系统所包含下标的所有文件。每个名为“Resources”的文件夹中的每一个资源文件（注意：这只适用于项目“Assets”文件夹中名为“Resources”的文件夹，以及“Resources”文件夹中的所有子文件夹）都包含在Resource系统的数据中。因此，初始化Resource系统所需的时间与“Resource”文件夹中的文件数量至少呈线性关系。</p>
<p>UnityLoadApplication包含加载和初始化第一个场景的方法。在项目中，这包括把需要在第一个场景里需要显示的所有数据进行反序列化和实例化。比如，编译着色器，上传贴图和实例化GameObjects。另外，第一个场景中，所有继承了MonoBehaviour脚本中的Awake方法都会在这个时候被回调。</p>
<p>这些过程意味着，如果在项目的第一个场景中，在Awake方法中有长时间运行的代码，那么该代码就会增加项目的启动时间。为了避免这一问题，在Awake方法中不能放运行时间长的代码，或者把这些代码放到程序的其他其他生命周期里。</p>
<p><strong>运行时流程分析：</strong></p>
<p>在初始化启动之后的性能分析中，最主要的是PlayerLoop方法。这个是Unity的主循环，并且每一帧都会被执行一次。</p>
<p><img src="../../assets/images/2020-03-04-unity-startup/v2-5c6c95216621d4ab86b26636ff9a019a_720w.jpg" alt="img"></p>
<p>上面的截图来自Unity5.4一个示例项目的性能分析。它展示了PlayerLoop中几个最有趣的方法。请注意，不同Unity版本之间，PlayerLoop中的方法名称可能有所不同。</p>
<p>PlayerRender是运行在Unity渲染系统中的方法。它包括对象剔除，计算动态批次，向GPU提交绘制命令。任何的后处理效果（Image Effects）或基于渲染的脚本回调（比如OnWillRenderObject）也都在这里运行。通常来讲，在具有交互的项目中，这个方法也是最影响GPU性能的。</p>
<p>BaseBehaviourManager调用了三个类型的CommonUpdate方法。它会调用当前场景中，挂在激活的物体上面的Monobehaviours里的特定方法。</p>
<ul>
<li>CommonUpdate<UpdateManager> 回调 Update</li>
<li>CommonUpdate<LateUpdateManager> 回调 LateUpdate</li>
<li>CommonUpdate<FixedUpdateManager> 如果勾选了物理系统，就会回调 FixedUpdate</li>
</ul>
<p>通常，检测BaseBehaviourManager::CommonUpdate<UpdateManager>这类方法是最有趣的，因为它是多数Unity项目脚本运行的入口。</p>
<p>有几个其他的方法也可以注意一下：</p>
<p>如果项目用到了Unity的UI系统，UI::CanvasManager就会回调几个不同的方法。包括Unity UI的批次计算和布局更新，在CanvasManager中，这两个方法也是比较常用并且比较重要的方法。</p>
<p>DelayedCallManager::Update运行协程。这部分内容在之后的”Coroutines”的章节会详细的介绍（如果我能坚持的话，哈哈哈）或者参考官方文档</p>
<p><a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity3.html" target="_blank" rel="noopener">Unity - Manual: Coroutinesdocs.unity3d.com!</a></p>
<p>PhysicsManager::FixedUpdate执行PhysX物理引擎。它主要涉及到执行PhysX的内部代码，并且也手当前场景中物理对象数量的影响。比如Rigidbodies和Colliders。然而，基于物理的回调也会在OnTriggerStay和OnCollisionStay中出现。</p>
<p>如果项目有用到2D物理系统。那么在Physics2DManager::FixedUpdate中也会出现类似的调用。</p>
<p><strong>脚本方法剖析：</strong></p>
<p>当脚本用IL2CPP编译跨平台编译时，找到包含ScriptingInvocation对象这行。这是Unity为了执行脚本代码，从内部代码过渡到运行时脚本的一个时间点（注意：从技术上讲，通过运行IL2CPP，C#和JS脚本也变成了本地代码。然而，这种编译的代码主要通过IL2CPP运行时框架执行方法，这跟手写的C++代码不太相似）。</p>
<p><img src="../../assets/images/2020-03-04-unity-startup/v2-ddde913f040c5de47824f8abaca2e978_720w.jpg" alt="img"></p>
<p>上面的截图来自一个Unity5.4示例项目中的另一个的性能分析。RuntimeInvoker_Void这一行下面的所有方法都是C#脚本编译的，它们每帧都会被执行一次。</p>
<p>分析报告阅读起来比较容易：每一个都是类名+“_”+方法名。在上图中，我们可以看到EventSysten.Update，PlayerShooting.Update和几个其他的Update方法，这些是大多数MonoBehaviours脚本中比较标准的Unity Update回调。</p>
<p>展开这些方法，可以清楚的看到那些正在占用CPU的方法。其中也会包括项目中被用到的Unity API和C#类库的方法。</p>
<p>上图的分析中，也显示了StandaloneInputModule.Process，这个方法会在每一帧都用射线穿过整个UI，为了检测是否有点击事件或者滑动事件触发。这个对性能的主要影响是需要遍历所有的UI元素，并且监测鼠标的位置是否在UI元素的边界内。</p>
<p><strong>资源加载：</strong></p>
<p>资源加载主要是通过SerializedFile::ReadObject方法来实现的。在对CPU性能分析时，就可以找到这个方法。SerializedFile::ReadObject通过Transfer方法，把文件的二进制数据关联到Unity的序列化系统。所有的Asset类型中，都能找到这个Transfer方法，比如Texttures，MonoBehaviours 和Particle Systems。</p>
<p><img src="../../assets/images/2020-03-04-unity-startup/v2-05563390f8cb569523e89841537c0e8f_720w.jpg" alt="img"></p>
<p>在上面的截图中，一个场景正在被加载。SerializedFile::ReadObject下面调用的不同Transfer方法表明了Unity正在读取并且反序列化场景中所有的Assets。</p>
<p>通常，如果运行时遇到了性能问题，在加载资源时帧率下降，并且通过性能分析是由于SerializedFile::ReadObject这个方法造成的。请注意，在多数情况下，只有当通过SceneManager, Resources 或者 AssetBundle API进行同步加载资源时，SerializedFile::ReadObject才会出现在主线程里。</p>
<p>避免出现这种性能问题，常规的做法是：你可以使用异步加载资源（这就把大量的ReadObject操作丢给了工作线程），或者提前加载好比较大的资源。</p>
<p>注意，当克隆objects时，Transfer也会被调用（在性能分析时出现的CloneObject就是）。如果CloneObject方法下面出现了Transfer方法，这说明资源不是正在从储存器上加载，而是在克隆老的对象。这个过程是：Unity先把老对象序列化，再反序列化数据作为新的对象。</p>
<p>本文翻译自Unity官方文档：</p>
<p><a href="https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity1.html" target="_blank" rel="noopener">Unity - Manual: Profilingdocs.unity3d.com!</a></p>
<p><strong>Q1：第一次启动项目会有冷启动时间过长的情况，请问该怎么优化？</strong></p>
<blockquote>
<p>首先肯定是判断游戏在冷启动过程中是在做什么事情消耗了时间，然后针对性地优化。还有就是定义好冷启动的界限，从点击游戏到Unity的闪屏出现这段时间通常定义为冷启动的时间，但是我们项目后来发现在做启动的优化的时候还有很长时间花费在游戏启动之后的一些资源初始化方面。</p>
<p>我在优化启动时间的过程中没有使用什么特别多的工具，主要是基于mlogcat.exe查看设备上输出信息的log，结合自己加入的一些log来做问题的排查。</p>
<p>纯粹的冷启动时间过长，会和Resources目录下的资源有关系，越多越慢。我们是以AssetBundle的方式为主，所以这块注意了下，清理了一些插件引入的确定不需要的资源（直接看打包好的apk里的内容来排查）。另外搜索下还有一些文章说相关问题，可以关注下，这里不赘述。</p>
<p><a href="https://blog.csdn.net/qq_34307432/article/details/84023894" target="_blank" rel="noopener">Unity 冷启动简介</a><br><a href="http://gad.qq.com/article/detail/32076" target="_blank" rel="noopener">Unity3D游戏如何加快冷启动时间</a><br><a href="https://www.zhihu.com/question/55441136" target="_blank" rel="noopener">如何改进Unity3d手游启动速度？</a><br><a href="https://www.jianshu.com/p/4366da6dd4a1" target="_blank" rel="noopener">Unity启动耗时优化</a></p>
<p>说一下我们遇到的游戏启动时间过长时解决过的几个问题。我们定义启动时间是从点击app图标到进入游戏Patch界面（即游戏逻辑接管）这段时间。<br>1）Shader编译时长。如果只有游戏安装之后第一次启动时间过长，一个很大的可能是shader编译，之后游戏启动因为有了Cache所以会快很多。这种情况的话建议查看下Always Include的Shader内容和变体，使用shadervariantcollection等方案替代。</p>
<p>2）Tolua绑定和Lua资源加载。这种是每次游戏启动都会有的，ToLua接口绑定需要一定的时间，我们在确保前期不会使用Lua的情况下采用多线程的方式进行绑定和加载，保证主线程不会卡住。</p>
<p>3）注意设置Web请求的超时时长。我们在游戏启动的时候做了一些hook的事情，会有Web请求，后来我们遇到一个情况是在很多机器上会黑屏等待30s甚至60s这样的时长，后来发现是因为这个Web请求没有设置超时时间，于是使用了机器默认的超时时间，在不同设备上不同，比如红米2A上会有接近1分钟的超时限制。这个很坑，只是因为那个非必须的Web服务没有正确开启，导致排查了很长时间。<br>Native层增加界面，减少黑屏等待，提升玩家体验。这个并不能真正解决问题，只是一种缓解手段，等到优化做到位了，其实也就不需要了。<br>说的内容大都是启动时间而非冷启动，供题主参考。建议题主多看看Unity进程的输出log，可能会有意外发现，通常情况下，不使用Resources的方式的话，在没Bug的情况下冷启动时间应该不会很长，我们因为没怎么用这种方式，所以不是很清楚。这个链接可以参考下：<a href="https://www.jianshu.com/p/4366da6dd4a1" target="_blank" rel="noopener">https://www.jianshu.com/p/4366da6dd4a1</a></p>
</blockquote>
<h2 id="脚本编译顺序"><a href="#脚本编译顺序" class="headerlink" title="脚本编译顺序"></a>脚本编译顺序</h2><p>对于大型项目来说，这确实是大家经常遇到的情况。一般来说，Unity Editor会按照脚本的依赖关系编译代码，其主要分为以下四个步骤：<br>编译Standard Assets、Pro Standard Assets和Plugins文件夹中的Runtime Script；<br>编译以上三个文件夹中Editor文件夹下的Script；<br>编译项目中所有剩余的Runtime Script（Editor文件夹以外Script；<br>编译剩余Script（即Editor文件夹中Script）。<br>知道了Unity编辑器的脚本编译特性后，我们则建议研发团队可以将一些长时间不需要改动的脚本代码（比如各种插件代码）放入到Standard Assets、Pro Standard Assets或Plugins文件夹中，这样这些代码只需要编译一次，后续的时间就都能节省下来。有朋友做过测试，在他们的项目中经过上面的改动，原来项目每次的编译时间从23s下降到7s。想想看，这将节省你和你的团队多少时间！</p>
<p><a href="https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/ScriptCompileOrderFolders.html</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>unity的坐标体系</title>
    <url>/unity-2020-07-01-unity-coordinate/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>刚开始接触 Unity3D 的时候，经常会被 Unity 中各种坐标系搞得昏头转向不知所措，毕竟是一个 3D 兼 2D 游戏开发殷勤，还要把 3D 作品最终发布到 2D 的桌面或者手机系统中，所以熟悉掌握 Unity3D 中的坐标系是非产重要的。</p>
<p>其实如果仅仅只有 3D 坐标系还是很简单的，就目前来说我们所见过的三维建模软件或者游戏开发软件所用的坐标系分两种：左手坐标系和右手坐标系。怎么区别呢？大家看下图就知道了：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/zggtdzunj4.jpeg" alt="zggtdzunj4"></p>
<p>区分坐标系可以按上图方法，这里我也有个简单的判断方法：用手握住 z 轴，大拇指朝向 z 轴正方向，然后用手的四指从 x 轴正方向握拳头，如果是左手 90 度就能把四指握到 y 轴就是左手坐标系，如果是右手 90 度握紧后到了 y 轴就是右手坐标系。</p>
<p>除了 3D 世界中的坐标系，还有其他的几个坐标系也非常常用，比如我们经常要把世界三维坐标系转换成我们最终屏幕中的二维坐标系，或者把手机屏幕的二维坐标系转化成游戏世界中的三维坐标系等，各个坐标系各有特别，不能混用，为了更好的学习 Unity 游戏开发，自己在此总结一下 Unity 当中的坐标系和相关用法，以作备忘和学习。</p>
<h2 id="二、坐标体系"><a href="#二、坐标体系" class="headerlink" title="二、坐标体系"></a>二、坐标体系</h2><p>Unity3D 当中基本的坐标体系主要有下面这四种：</p>
<ol>
<li>世界坐标系 (World Space)</li>
<li>屏幕坐标系 (Screen Space)</li>
<li>视口坐标系 (Viewport Space)</li>
<li>GUI界面坐标系 (GUI System)</li>
</ol>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/7ku2m8quf5.jpeg" alt="7ku2m8quf5"></p>
<p>这四种坐标系可以说没有一个是完全相同的，各个坐标系所代表的意思也可以从字面含义中理解出来，它们之间都是可以相互转换的，不过 GUI 坐标体系除外，它比较特殊，也相对来说是最简单的，那么我们就从最简单的说起吧。 </p>
<p><strong>1. 绘制 GUI 界面的坐标体系</strong></p>
<p>我们在做 Unity 游戏开发的时候，经常会使用内置的 GUI 来做一些测试，比如显示一个按钮控制游戏，画一个文本显示相关信息等。它的代码全部控制在 <code>OnGUI()</code> 函数中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">void</span> OnGUI()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (GUI.Button(<span class="keyword">new</span> Rect(<span class="number">0</span>f, <span class="number">0</span>f, <span class="number">160</span>f, <span class="number">40</span>f), <span class="string">"Click Me"</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//button clicked and do something here...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个按钮 <code>Button</code> 所在的坐标系就是 GUI 绘制坐标系。大家稍微测试一下就知道了，它的原点 <code>(0, 0)</code> 在最左上角，因为屏幕宽度是 <code>Screen.width</code> ，高度是 <code>Screen.height</code> ，所以 GUI 体系右下角的坐标为： <code>(Screen.width, Screen.height)</code> , 这是一个二维的坐标体系，坐标 <code>z</code> 的值都为 0 。大家可以看下图加深理解：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/ojb5jzsb2r.jpeg" alt="ojb5jzsb2r"></p>
<p><strong>2. 视口 Viewport 坐标体系</strong></p>
<p>当我们使用多个相机，在同一个场景中显示多个视口的时候，我们就需要用上视口坐标系了。</p>
<p>视口坐标系对于场景的显示非常重要，对于新手来说我们经常使用一个相机就够了，但是当需要使用到多个视口的时候，我们就必须关注视口坐标体系了，大家可以在相机 <code>Camera</code> 的属性中看到 <code>Viewport Rect</code> 就是视口坐标系的设置：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/x9myhu3k73.jpeg" alt="x9myhu3k73"></p>
<p>一个相机对应一个视口，视口预览（ Camera Preview ）展示了相机所看到的所有物体，很显然，它默认大小是 <code>(width = 1, height = 1)</code> ，位置也是从 0 到 1 ，这个位置就是我们所讨论的坐标系：左下角为 <code>(0, 0)</code> ，右上角是 <code>(1, 1)</code> ，一般视口坐标系主要用在相机显示中，我们简单的进行 <code>Viewport Rect</code> 的设置就可以了。</p>
<p>另外，新手朋友们可以记住这么一个快捷键： <code>Ctrl + Shift + F</code> ，可以快速设置相机视口到当前场景窗口的视口位置。下图是视口坐标系和鼠标在屏幕上的坐标系的转换结果：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/6hkl5q24ft.jpeg" alt="6hkl5q24ft"></p>
<p><strong>3. 屏幕 Screen 坐标体系</strong></p>
<p>嗯，非常重要！不管怎样，最终我们所有的成果都会发布到各个平台（屏幕）上，所以，任何坐标系的坐标和屏幕坐标系的转换都是非常重要的。比如我们经常需要处理鼠标的相关事件（鼠标位置、单击、双击事件等），或者手机上的触摸反馈，这些原始数据都是屏幕坐标系相关的。</p>
<p>虽然重要，其实屏幕坐标系处理起来很简单直接， <code>Input.mousePosition</code> 获取的就是鼠标在屏幕中的位置坐标。大家可以测试一下，屏幕坐标系中原点 <code>(0, 0)</code> 位于左下角，那么右上角必然就是 <code>(Screen.width, Screen.height)</code> ，对了，还有一个 <code>z</code> 呢？都为 0 吗？答案是肯定的，既然是二维坐标系那么 <code>z</code> 肯定是 0 了，和 GUI 坐标系一样，但是话又说回来，屏幕坐标系转换成世界坐标系 <code>z</code> 还是 0 吗？其实不然，屏幕坐标转换成世界坐标后物体的 <code>z</code> 值是取决于相机的，因此： <code>gameObject.z = camera.z</code> ，其实在上面视口坐标系介绍中的图中我已经把 <code>Mouse Point</code> 鼠标位置转换成世界坐标（ <code>World Point</code> ）了，大家应该注意到了吧。</p>
<p>那么，除了坐标系的转换，还有什么值得注意的呢？这里我要告诉大家的是，我们在控制相机的时候，因为屏幕显示的就是相机所看到的内容，而<strong>屏幕的宽高比直接影响了相机的显示</strong>，也就是 <code>Aspect Ratio</code> 的值，大家可以在 Game 面板中轻松地设置 <code>Aspect</code> 宽高比，查看对游戏画面的影响：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/cmpbepr0jw.jpeg" alt="cmpbepr0jw"></p>
<p>如下图，相机的宽高比和屏幕宽高比一致，显示结果也一致：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/a0qyr11woq.jpeg" alt="a0qyr11woq"></p>
<p>如果相机的宽高比设置的和屏幕宽高比不一样的话，显示结果就有点不同了：</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/iadfp03ffu.jpeg" alt="iadfp03ffu"></p>
<p>所以，在游戏开发中，<strong>我们要重视相机的宽高比 <code>Camera.aspect</code> 的值，一般我们会保持相机宽高比不变，然后通过改变相机的视口尺寸 <code>Camera.orthographicSize</code> 来显示场景中需要显示的物体</strong>，关于这个主题我会在我的下一篇文章中提到，大家可以关注我的博客。如何通过宽高比获取摄像机视口尺寸呢？首先可以从上图中知道宽高比的计算方法： <code>aspect = width / height</code> ，当你同时获取到 <code>width</code> 和 <code>height</code> 的时候，你通过 <code>Mathf.Max(height, width / aspect)</code> 来得出最终的尺寸大小（<em>注意这个结果是 2 倍视口尺寸哦</em>）。这个在游戏场景中应用的还是比较多的，比如你有这么个需求：两个玩家移动对战，你的相机要把两个移动的玩家随时放置在屏幕显示中。 </p>
<p><strong>4. 世界 World 三维坐标系</strong></p>
<p>最后，世界坐标系！世界坐标系不是最简单的，但却是我们最常用的坐标系。记住一点，任何情况下： <code>transform.position</code> 都是返回物体的世界坐标值，及时你所使用的是子物体！另外，从上面所讲的屏幕坐标系转换成世界坐标系也是非常简单的，它以当前相机为参考：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> position = Input.mousePosition;</span><br><span class="line"><span class="keyword">var</span> worldPoint = Camera.main.ScreenToWorldPoint(position);</span><br></pre></td></tr></table></figure>

<p>另一方面，我们在游戏开发过程中，经常要处理<strong>子物体</strong>的相对 <code>transform</code> 值，这个时候我们就需要稍微动点脑子了，当然如何转变 Unity 已经帮我们预制好相应的函数方法了，你只要<strong>把父物体当做世界，子物体当做世界中的物体</strong>，使用这些函数，换一下坐标就和处理绝对坐标一样了，不知道大家理解没有。我举个例子，我们在游戏开发中会遇到这种情况，你的相机如果直接放到世界中那么必然会需要调整它的旋转角度才能达到满意的视口位置，如何不让相机产生任何旋转就能把世界中的游戏物体放到合适的视口位置呢？</p>
<p>办法就是：我们<strong>把相机放到一个产生了合适旋转角度的父物体当中！</strong>这样做的效果就是：相机就相当于子物体，父物体旋转了，子物体就不需要额外旋转了，这时候相机的<strong>局部旋转就为 0</strong> 。这在有些场景中使用起来很方便，相机已经是父物体世界中的子物体了。</p>
<p><img src="../../assets/images/2020-07-01-unity-coordinate/cjali0ffbs.jpeg" alt="cjali0ffbs"></p>
<p>怎么计算相对坐标呢？在 Unity 中都有相应的函数，使用比较简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取的是世界坐标</span></span><br><span class="line"><span class="keyword">var</span> childPosition = childObject.transform.position;</span><br><span class="line"><span class="comment">//转化为父物体下的相对坐标，相当于位于父物体世界中</span></span><br><span class="line"><span class="keyword">var</span> relativePosition = parentObject.transform.InverseTransformPoint(childPosition);</span><br><span class="line"><span class="comment">//转化为世界坐标，注意：这里不能传入 childPosition ，因为 childPosition 就是世界坐标</span></span><br><span class="line"><span class="keyword">var</span> worldPosition = parentObject.transform.TransformPoint(relativePosition);</span><br><span class="line"></span><br><span class="line"><span class="comment">//所以，下面结果是相等的！</span></span><br><span class="line">print(childPosition == worldPosition);</span><br></pre></td></tr></table></figure>

<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当然，在使用坐标系过程中我们还要关注其他方方面面，比如欧拉角的旋转，万向锁，平滑过渡视野等等，这些我想我会在后面的文章总结中写道吧。这次就总结介绍了这几个坐标系，看上去有点复杂，总体来说还是挺很好理解的，有什么不对的或者可以加强的请给我留言，谢谢！ </p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>Java</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Mesh renderer 和 Mesh 和 Mesh Filter</title>
    <url>/unity-2020-07-03-unity-mesh/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><strong>Meshes</strong> 是Unity的主要图形基元。 它们定义对象的形状。</li>
<li><strong>Materials</strong> 通过包含对所用纹理的引用、平铺信息、颜色色调等来定义表面应使用的渲染方式。材质的可用选项取决于材质使用的着色器。</li>
<li><strong>Shaders</strong> 是一些包含数学计算和算法的小脚本，根据光照输入和材质配置来计算每个像素渲染的颜色。</li>
<li><strong>Textures</strong> 是位图图像。材质可包含对纹理的引用，因此材质的着色器可在计算游戏对象的表面颜色时使用纹理。除了游戏对象表面的基本颜色（反照率）之外，纹理还可表示材质表面的许多其他方面，例如其反射率或粗糙度。</li>
</ul>
<h2 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h2><p><img src="../../assets/images/2020-07-03-unity-mesh/201808082025438" alt="这里写图片描述"></p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#Default" target="_blank" rel="noopener">Default</a></li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#NormalMap" target="_blank" rel="noopener">Normal Map</a> 法线贴图就是在原物体的凹凸表面的每个点上均作法线，通过RGB颜色通道来标记法线的方向，你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面</li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#Editor" target="_blank" rel="noopener">Editor GUI and Legacy</a> </li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#Sprite" target="_blank" rel="noopener">Sprite (2D and UI)</a></li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#Cursor" target="_blank" rel="noopener">Cursor</a>  光标文件</li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#Cookie" target="_blank" rel="noopener">Cookie</a> 聚光灯贴图</li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#Lightmap" target="_blank" rel="noopener">Lightmap</a>  光照贴图</li>
<li><a href="https://docs.unity3d.com/Manual/TextureTypes.html#SingleChannel" target="_blank" rel="noopener">Single Channel</a></li>
</ul>
<h1 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h1><ul>
<li>顶点坐标（vertex） 顶点坐标数组存放Mesh的每个顶点的空间坐标，假设某mesh有n个顶点，则vertex的size为n</li>
<li>三角形序列（triangle） 每个mesh都由若干个三角形组成，而三角形的三个点就是顶点坐标里的点，三角形的数组的size = 三角形个数 * 3.</li>
<li>法线（normal） 法线数组存放mesh每个顶点的法线，大小与顶点坐标对应，normal[i]对应顶点vertex[i]的法线.它不仅说明了<code>面片的朝向，还可用于计算光照模型</code>。</li>
<li>次法线 (subnormal)</li>
<li>纹理坐标（uv） 它定义了图片上每个点的位置的信息. 这些点与3D模型是相互联系的, 以决定表面纹理贴图的位置. UV就是将<a href="http://baike.baidu.com/view/42116.htm" target="_blank" rel="noopener">图像</a>上每一个点精确对应到模型物体的表面. uv[i]对应vertex[i]</li>
<li>切线 (tangent) 切线是垂直于法线的一条向量，由于垂直于法线的向量有无数条，所以切线最终规定为由UV坐标来决定朝向。</li>
</ul>
<p>例如：左图利用三个点绘制了一个三角形，而右图则通过两个三角形得到了一个四边形：</p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/20190805190859508.png" alt="img"></p>
<p>注：这里需要注意的是，很明显从左图中给定的三个点，有两种方式可以得到三角图元，即</p>
<ul>
<li>顺时针旋转（也称左手螺旋）：p0-&gt;p1-&gt;p2</li>
<li>逆时针旋转（右手螺旋）：p0-&gt;p2-&gt;p1</li>
</ul>
<p>它们的区别在哪里呢？类似于物理中左右手判断法则，拇指指示了三角图元的法线方向。法线其中一个作用是指明了三角图元的方向，如果从反方向看的话，这个图元是不可见的。而unity3d是左手坐标系在渲染时默认只渲染正面，背面是看不见的。</p>
<p>那么要绘制上图中的三角形，即问题在于表达三个点的坐标，也就可以表示为下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector2[] vertices &#x3D; new Vector2[]&#123; </span><br><span class="line">	new Vector2( 0, 0 ),							&#x2F;&#x2F; p0</span><br><span class="line">	new Vector2( 0, 1 ),							&#x2F;&#x2F; p1</span><br><span class="line">	new Vector2( 1, 0 ),							&#x2F;&#x2F; p2</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>而如果要绘制四边形，也就需要六个点的坐标，如下面所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector2[] vertices &#x3D; new Vector2[]&#123; </span><br><span class="line">	&#x2F;&#x2F; 三角图元 0</span><br><span class="line">	new Vector2( 0, 0 ),							&#x2F;&#x2F; p0</span><br><span class="line">	new Vector2( 0, 1 ),							&#x2F;&#x2F; p1</span><br><span class="line">	new Vector2( 1, 0 ),							&#x2F;&#x2F; p2</span><br><span class="line">	&#x2F;&#x2F; 三角图元 1</span><br><span class="line">	new Vector2( 0, 1 ),							&#x2F;&#x2F; p1</span><br><span class="line">	new Vector2( 1, 1 ),							&#x2F;&#x2F; p3</span><br><span class="line">	new Vector2( 1, 0 ),							&#x2F;&#x2F; p2</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>如果单纯使用顶点来表示（绘制）图形，是非常直观的——因为我们知道每一个顶点的位置信息，并且知道每三个点构成一个三角图元。然而从上面绘制四边形的数据中可以发现，三角图元1中有两个顶点的位置信息（p1和p3）和三角图元0是一样的。这也就增加了一些开销。</p>
<p>总而言之，这个额外的存储开销是完全可以去除的，方法就是使用索引（Indices）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector2[] vertices &#x3D; new Vector2[]&#123; </span><br><span class="line">	new Vector2( 0, 0 ),							&#x2F;&#x2F; p0</span><br><span class="line">	new Vector2( 0, 1 ),							&#x2F;&#x2F; p1</span><br><span class="line">	new Vector2( 1, 0 ),							&#x2F;&#x2F; p2</span><br><span class="line"> &#125;;</span><br><span class="line"> int[] indices &#x3D; new indices[]&#123;</span><br><span class="line"> 	0, 1, 2											&#x2F;&#x2F; 表示 0-&gt;1-&gt;2 构成一个三角图元</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>没错，indices就是这么一回事，原来是vertices数组中，每三个顶点表示一个三角图元，现在是indices数组中，每三个整型表示一个图元。这些整形不存储真正的数据，<code>只有用到时才从vertices中取出，也就是所谓的索引了</code>。</p>
<h1 id="SubMesh"><a href="#SubMesh" class="headerlink" title="SubMesh"></a>SubMesh</h1><p>面提到过，MeshRenderer负责对MeshFilter中的Mesh进行绘制，而绘制依赖于着色器，或者说着色器生成的材质（Material）。简单来说，材质具体描述了Mesh中的数据如何进行绘制。<br>Material只负责一个Mesh的一次绘制，但是现在有一个要求是，Mesh的不同部分，要求使用不同的材质。例如上面所绘制的四边形，两个三角面片要求绘制出不同的颜色。这个时候就需要使用SubMesh了。<br>从名字也能看出，SubMesh类似于Mesh，并且Mesh包含SubMesh。但是和Mesh不一样的是，SubMesh只有triangles信息，也就是说SubMesh使用自身的 triangles信息，索引找到 Mesh上的顶点信息（如vertices、 uv、normal等）后进行三角面片的绘制。它们的关系如下图所示：</p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/20190806210636364.png" alt="在这里插入图片描述"></p>
<p>这个设置的过程依赖于Mesh中的API是 SetTriangles，其函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> @parm triangles: 			SubMesh的triangles</span><br><span class="line"> @parm submesh: 			属于Mesh中的第几个submesh</span><br><span class="line"> @parm calculateBounds：	是否计算包围盒，默认为true。设置为false会使用当前存在的包围盒以减少CPU开销</span><br><span class="line"> @parm baseVertex：			triangles中每一个元素的偏移值，默认为0；</span><br><span class="line">*&#x2F;</span><br><span class="line">public void SetTriangles(int[] triangles, int submesh, bool calculateBounds &#x3D; true, int baseVertex &#x3D; 0);</span><br></pre></td></tr></table></figure>

<p>用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector3[] vertices &#x3D; new Vector3[]&#123;</span><br><span class="line">	     new Vector3( 0, 0, 0 ),</span><br><span class="line">	     new Vector3( 0, 1, 0 ),</span><br><span class="line">	     new Vector3( 1, 0, 0 ),</span><br><span class="line">	     new Vector3( 1, 1, 0 ),</span><br><span class="line">	&#125;;</span><br><span class="line">	int[] subTriangles_0 &#x3D; new int[]&#123;</span><br><span class="line">		0, 1, 2</span><br><span class="line">	&#125;;</span><br><span class="line">	int[] subTriangles_1 &#x3D; new int[]&#123;</span><br><span class="line">		1, 3, 2</span><br><span class="line">	&#125;;</span><br><span class="line">	Mesh mesh &#x3D; new Mesh();</span><br><span class="line">	mesh.vertices &#x3D; vertices;</span><br><span class="line">	&#x2F;&#x2F; 告诉 Mesh它将会有两个SubMesh</span><br><span class="line">	mesh.subMeshCount &#x3D; 2;</span><br><span class="line">	mesh.SetTriangles( subTriangles_0 , 0 );</span><br><span class="line">	mesh.SetTriangles( subTriangles_1 , 1 );</span><br><span class="line">	&#x2F;&#x2F; 重新计算normal信息，不然后面的 material会不起作用</span><br><span class="line">	mesh.RecaculateNormals();</span><br><span class="line">	&#x2F;&#x2F; MeshFilter</span><br><span class="line">	MeshFilter meshFilter &#x3D; GetComponent&lt;MeshFilter&gt;();</span><br><span class="line">	if( meshFilter &#x3D;&#x3D; null ) meshFilter &#x3D; gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">	meshFilter.mesh &#x3D; mesh;</span><br><span class="line">	&#x2F;&#x2F; MeshRenderer</span><br><span class="line">	MeshRenderer meshRenderer &#x3D; GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">	if( meshRenderer &#x3D;&#x3D; null ) gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br></pre></td></tr></table></figure>

<p>将上述代码挂载到一个空节点上运行，可以得到以下结果：</p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/20190806223230787.png" alt="img"></p>
<p>嗯？！难不成笔者在骗人，这里明明只有一个三角面片。莫慌，之前不是说过，要求两个三角面片使用不同的材质吗？如果运行时，将MeshRenderer的Material的Size设为2的话，你会发现另外一个三角图元也出现了：</p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/20190806223831570.png" alt="img"></p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/20190806223841210.png" alt="img"></p>
<p>也就是说，有多少个SubMesh，就需要有多少个Material，并且它们的绘制关系是一一对应的。即第一个SubMesh使用第一个<br>Material绘制，第二个SubMesh使用第二个Material绘制，以此类推。为了验证这个，接下来创建两个默认的Material，将它们的Albedo分别设置为红色和绿色，接着运行时将这两个 Material赋给MeshRenderer，将会得到如下图所示的运行结果：</p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/2019080622511158.png" alt="在这里插入图片描述"></p>
<p>另外，如果双击 MeshFilter的 Mesh属性，从下面的预览窗口，也能看到这个Mesh有两个SubMesh：</p>
<p><img src="../../assets/images/2020-07-03-unity-mesh/20190806225353486.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>如何在unity显示线框图<br>选择场景视图在其工具栏左侧的显示模式。前三个选项是阴影线框和阴影线框。</p>
</blockquote>
<h1 id="MeshCombine"><a href="#MeshCombine" class="headerlink" title="MeshCombine"></a>MeshCombine</h1><p>MeshCombine，就是合并网格。</p>
<p>为什么好好的模型要进行网格的合并呢？</p>
<p>如果从应用的角度来看的话，通过网格合并可以实现游戏中的换装，你可能会说，更换的服装例如帽子好好的，为什么要合并到人物模型上？</p>
<p>问题在于，如果游戏中不是所有人物模型都是标准的人型呢？例如魔兽世界中，不同种族的头部模型大小是不一致的，很容易出现穿模。当然可以同一顶帽子制作适配于不同种族的模型，反正这个工作是美术做的（溜）。但是从整体出发的话，这样做无疑增加了游戏容量的大小，也会减慢游戏开发的进度，同时一定程度上影响代码的简洁性。</p>
<p>但是通过网格合并，将帽子的网格合并到人物模型上，并且蒙皮至人物头部的骨骼上。这样以后，由于骨骼的大小、旋转、位移信息会影响顶点，因此一旦这个帽子戴到别的人物模型身上时，由于它们头部骨骼的大小不一样，那么帽子也会自动变大。也就达到了同一个模型，适用于多个人物模型的目的。<br>（关于骨骼、蒙皮、骨骼蒙皮动画，可以参考下面的扩展资料）</p>
<p>关于网格合并，同样Unity在 Mesh提供了相关的API：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> @parm combine: 			要进行合并的CombineInstance实例</span><br><span class="line"> @parm mergeSubMeshes: 		是否将SubMesh进行合并，true为将SubMesh进行合并，false表示以SubMesh的形式存在</span><br><span class="line"> @parm useMatrices: 		是否应用定义在CombineInstance中的transform信息</span><br><span class="line"> @hashLightmapData: 		如果为true，则应用CombineInstance中的lightmapScaleOffset对mesh中的lightmapUV进行偏移</span><br><span class="line">*&#x2F;</span><br><span class="line">public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes &#x3D; true, bool useMatrices &#x3D; true, bool hasLightmapData &#x3D; false);</span><br></pre></td></tr></table></figure>

<p>要使用它也很简单，如下面的代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 收集要合并的物体的所有Mesh信息</span><br><span class="line">       MeshFilter[] childMeshFilters &#x3D; GetComponentsInChildren&lt;MeshFilter&gt;();</span><br><span class="line"></span><br><span class="line">       CombineInstance[] destCombineInstances &#x3D; new CombineInstance[childMeshFilters.Length];</span><br><span class="line">       for ( int i &#x3D; 0; i &lt; childMeshFilters.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           destCombineInstances[i] &#x3D; new CombineInstance();</span><br><span class="line">           destCombineInstances[i].mesh &#x3D; childMeshFilters[i].mesh;</span><br><span class="line">           destCombineInstances[i].transform &#x3D; childMeshFilters[i].transform.localToWorldMatrix;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 隐藏子物体，或者Destory</span><br><span class="line">           childMeshFilters[i].gameObject.SetActive(false);</span><br><span class="line">       &#125;</span><br><span class="line">       Mesh destMesh &#x3D; new Mesh();</span><br><span class="line">       &#x2F;&#x2F; 进行合并</span><br><span class="line">       destMesh.CombineMeshes(destCombineInstances, true);</span><br><span class="line">       destMesh.RecalculateNormals();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 将合并后的mesh赋给当前的MeshFilter</span><br><span class="line">       MeshFilter meshFilter &#x3D; GetComponent&lt;MeshFilter&gt;();</span><br><span class="line">       if (meshFilter &#x3D;&#x3D; null) meshFilter &#x3D; gameObject.AddComponent&lt;MeshFilter&gt;();</span><br><span class="line">       meshFilter.mesh &#x3D; destMesh;</span><br><span class="line"></span><br><span class="line">       MeshRenderer meshRenderer &#x3D; GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">       if( meshRenderer &#x3D;&#x3D; null)</span><br><span class="line">       &#123;</span><br><span class="line">           meshRenderer &#x3D; gameObject.AddComponent&lt;MeshRenderer&gt;();</span><br><span class="line">           &#x2F;&#x2F; 设置MeshRenderer的material</span><br><span class="line">           Material material &#x3D; new Material(Shader.Find(&quot;Standard&quot;));</span><br><span class="line">           meshRenderer.material &#x3D; material;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>





<h2 id="mesh合并的优缺点"><a href="#mesh合并的优缺点" class="headerlink" title="mesh合并的优缺点"></a>mesh合并的优缺点</h2><ul>
<li>静态批处理后，对内存的增加是非常大的，动则就是几十兆的内存</li>
<li>动态批处理，对于合批要求挺多的，同时可能存在，动态合批消耗过大，得不偿失</li>
<li>自己在逻辑代码里面进行动态合批，对于mesh的readwrite属性是要求开启的，这无疑也增大了内存的占用，复杂的合批处理可能会消耗更多的cpu时间</li>
<li>GPU Instancing可以一次渲染(render)相同网格的多个副本，仅使用少量<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Manual/DrawCallBatching.html">DrawCalls</a>。在渲染诸如建筑、树木、草等在场景中重复出现的事物时，GPU Instancing很有用。将这些静态的物件如植被等全部从场景中剔除，而保存其位置、缩放、uv偏移、<em>lightmapindex</em>等相关信息，在需要渲染的时候，根据其保存的信息，通过<strong><em>Instance</em></strong>来渲染，这能够减少那些因为内存原因而不能合批的大批量相同物件的渲染时间</li>
</ul>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/96084686" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96084686</a></li>
<li><a href="https://docs.unity.cn/cn/2018.4/Manual/class-Mesh.html" target="_blank" rel="noopener">https://docs.unity.cn/cn/2018.4/Manual/class-Mesh.html</a></li>
<li><a href="https://docs.unity.cn/cn/2020.1/Manual/Shaders.html" target="_blank" rel="noopener">https://docs.unity.cn/cn/2020.1/Manual/Shaders.html</a></li>
<li><a href="https://learnopengl-cn.github.io/" target="_blank" rel="noopener">https://learnopengl-cn.github.io/</a></li>
<li><a href="https://blog.csdn.net/Arkish/article/details/98482430" target="_blank" rel="noopener">https://blog.csdn.net/Arkish/article/details/98482430</a></li>
<li><a href="https://blog.csdn.net/tw_345/article/details/79771454" target="_blank" rel="noopener">https://blog.csdn.net/tw_345/article/details/79771454</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/96084686" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96084686</a></li>
<li><a href="https://blog.csdn.net/ecidevilin/category_9266800.html" target="_blank" rel="noopener">https://blog.csdn.net/ecidevilin/category_9266800.html</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>游戏开发</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>unity Render Pipeline</title>
    <url>/unity-2020-07-04-unity-render-pipeline/</url>
    <content><![CDATA[<p>Unity官方API中说的渲染管线(Render Pipeline)有三种</p>
<ul>
<li>Built-in Render Pipeline(URP):内置渲染管线，自定义选项有限</li>
<li>Universal Render Pipeline (URP)，可编程的轻量级(通用)渲染管线，前身是Lightweight Render Pipeline简称LWPR，在Unity2019.3版本中正式应用。</li>
<li>High Definition Render Pipeline (HDRP) 可编程的高保真的渲染管线，有硬件要求</li>
<li>sciprttable Render Pipeline (SRP) 名词，是一种实现可编程管线的一种方法(即通过C#代码，调用API来自己定义渲染顺序，相机工作方式顺序，光照特性等很多渲染相关的东西)，通过这种方法写出来的代码文件称之为SRP。</li>
</ul>
<p>相关链接</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/93203710" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/93203710</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>Notch Solution</title>
    <url>/unity-2020-08-29-Notch-Solution/</url>
    <content><![CDATA[<p>Screen.safeArea会返回移动平台安全区的Rect。例如，iPhoneX（2436x1125px）横屏时，Screen.safeArea返回的值为Rect（132，63，2172，1062）。如图：</p>
<p><img src="../../assets/images/2020-08-29-Notch-Solution/v2-2381f8819f70e7cd357662188e2616b6_720w.jpg" alt="img"></p>
<p>适配思路：以界面为单位，打开界面时，获取当前设备的safeArea，调整界面的锚点，进行适配。以下利用SafeArea.cs脚本，对当前window进行适配。主要考虑三种情况：</p>
<p>情况1：UI中没有全屏背景</p>
<p><img src="../../assets/images/2020-08-29-Notch-Solution/v2-b472160ce00e02f830c3e09dd2bc5747_720w.jpg" alt="img"></p>
<p>解决思路：直接调整当前window的锚点，进行适配。</p>
<p>情况2：UI中有全屏背景</p>
<p><img src="../../assets/images/2020-08-29-Notch-Solution/v2-baffbbebb247c6466fcf5f0b9ddd1a95_720w.jpg" alt="img"></p>
<p>解决思路：把背景分离到window之外，只对当前window进行适配，对背景不做处理。为了方便适配，我们可以把背景单独做成window，在UI框架中对window和背景进行分开管理。上图中，蓝色为背景图片，红色为适配的window。</p>
<p>情况3：适配需要靠边的UI(例如侧边的聊天弹窗等)</p>
<p><img src="../../assets/images/2020-08-29-Notch-Solution/v2-bb8467626340c8dac46c81adf176b1c3_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-08-29-Notch-Solution/v2-615a71b2dfd94b07e4bed4d0fbcea2db_720w.jpg" alt="img"></p>
<p>解决思路：把需要靠边的按钮拉伸到屏幕之外，达到适配效果。</p>
<p><a href="https://github.com/jirowang0409/Garena" target="_blank" rel="noopener">jirowang0409/Garena: Projects in Garena (github.com)</a></p>
<h1 id="notch-solution"><a href="#notch-solution" class="headerlink" title="notch solution"></a>notch solution</h1><p>首先分为两个component.</p>
<ul>
<li><a href="https://exceed7.com/notch-solution/components/ui-behaviour/safe-padding.html" target="_blank" rel="noopener">SafePadding</a>Works with <code>RectTransform</code> tree of the uGUI component system.</li>
<li><a href="https://exceed7.com/notch-solution/components/adaptation/safe-adaptation.html" target="_blank" rel="noopener">SafeAdaptation</a>They are based on using <a href="https://docs.unity3d.com/ScriptReference/Playables.Playable.html" target="_blank" rel="noopener">Playables API</a> to control <code>GameObject</code> with animation playables, therefore utilizing <code>Animator</code> and <code>AnimationClip</code> instead of <code>RectTransform</code>.</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Rect SafeAreaRelative</span><br><span class="line">    &#x3D;&gt; NotchSolutionUtility.ShouldUseNotchSimulatorValue ? storedSimulatedSafeAreaRelative : NotchSolutionUtility.ScreenSafeAreaRelative;</span><br></pre></td></tr></table></figure>

<p>我们看这句,如果是使用了模拟器,则使用simulatedSafeAreaRelative</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void INotchSimulatorTarget.SimulatorUpdate(Rect simulatedSafeAreaRelative, Rect[] simulatedCutoutsRelative)</span><br><span class="line">&#123;</span><br><span class="line">    this.storedSimulatedSafeAreaRelative &#x3D; simulatedSafeAreaRelative;</span><br><span class="line">    this.storedSimulatedCutoutsRelative &#x3D; simulatedCutoutsRelative;</span><br><span class="line">    UpdateRectBase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Editor代码中如果改变了模拟器的环境.则会更改该值</p>
<p>而生产环境中则会使用NotchSolutionUtility.ScreenSafeAreaRelative,他也是通过Screen.safeArea进行判断的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal static Rect ScreenSafeAreaRelative</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        Rect absolutePaddings &#x3D; Screen.safeArea;</span><br><span class="line">        cachedScreenSafeAreaRelative &#x3D; ToScreenRelativeRect(absolutePaddings);</span><br><span class="line">        cachedScreenSafeArea &#x3D; absolutePaddings;</span><br><span class="line">        safeAreaRelativeCached &#x3D; true;</span><br><span class="line">        return cachedScreenSafeAreaRelative;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="safepadding"><a href="#safepadding" class="headerlink" title="safepadding"></a>safepadding</h2>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>unity 项目dll检查</title>
    <url>/unity-2020-08-30-unity-dll-check/</url>
    <content><![CDATA[<p>全部的<br><img src="../../assets/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-12-13.png" alt="Snipaste_2020-08-30_02-12-13"></p>
<p>shared模块+contract模块+Odin模块+Json模块+dothassunity模块<br><img src="../../assets/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p.png" alt="Snipaste_2020-08-30_02-16-34--noentity-no-p"></p>
<p>shared模块+contract模块+Odin模块+Json模块<br><img src="../../assets/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity.png" alt="Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity"></p>
<p>shared模块+contract模块+Odin模块<br><img src="../../assets/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json.png" alt="Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json"></p>
<p>shared模块+contract模块<br><img src="../../assets/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin.png" alt="Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin"></p>
<p>只有shared模块</p>
<p><img src="../../assets/images/2020-08-30-unity-dll-check/Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin-no-contract.png" alt="Snipaste_2020-08-30_02-16-34--noentity-no-p-no-dothassunity-no-json-no-odin-no-contract"></p>
<p>空项目<br><img src="../../assets/images/2020-08-30-unity-dll-check/none.png" alt="none"></p>
<p>我们看到包含了form等模块</p>
<p><a href="https://stackoverflow.com/questions/39161798/can-i-remove-system-windows-forms-dll-referenced-by-protobuf-net" target="_blank" rel="noopener">c# - Can I remove System.Windows.Forms.dll referenced by protobuf-net - Stack Overflow (stackoverflow.com)</a></p>
<p>不过不用担心,使用il2cpp都会被切割</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>windows</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>UNITY的垂直同步和帧率</title>
    <url>/unity-2020-09-05-unity-vSyncCount/</url>
    <content><![CDATA[<h1 id="垂直同步"><a href="#垂直同步" class="headerlink" title="垂直同步"></a>垂直同步</h1><p>在显示一帧画面时，显卡先从显示缓冲取数据刷新到显示器存储器上，然后，显示器从左上到右下，逐行显示到屏幕上。</p>
<p>显示器每画完一行发出一个水平同步信号，画完所有行发出一个垂直同步信号。</p>
<p>若显示器刷新率是75，那么发出一个垂直同步信号后会等待1/75秒，然后重新执行上述步骤。</p>
<p>游戏中的开启垂直同步，意思是指显卡等待到一个垂直同步信号后才开始工作，向显示缓冲绘制数据。</p>
<p>如果我们选择等待垂直同步信号（也就是我们平时所说的垂直同步打开），那么在游戏中或许强劲的显卡迅速的绘制完一屏的图像，但是没有垂直同步信号的到达，显卡无法绘制下一屏，只有等75单位的信号到达，才可以绘制。这样FPS自然要受到操作系统刷新率运行值的制约。</p>
<p>   而如果我们选择不等待垂直同步信号（也就是我们平时所说的关闭垂直同步），那么游戏中作完一屏画面，显卡和显示器无需等待垂直同步信号就可以开始下一屏图像的绘制，自然可以完全发挥显卡的实力。但是不要忘记，正是因为垂直同步的存在，才能使得游戏进程和显示器刷新率同步，使得画面更加平滑和稳定。取消了垂直同步信号，固然可以换来更快的速度，但是在图像的连续性上势必打折扣。这也正是很多朋友抱怨关闭垂直后发现画面不连续的理论原因。</p>
<p>开启垂直同步时</p>
<p>　　若游戏的实际显示帧速大于60，显卡就可以在显示器等待的1/60内完成绘制，显示一个无撕裂的画面。此时，游戏的帧速被限制为60。</p>
<p>　　若游戏的实际显示帧速小于60，显卡无法在在显示器等待的1/60内完成绘制，假如游戏帧速50，那么显卡每2个显示器帧才向显示器刷新一次数据，此时，游戏帧速掉为30。</p>
<p>关闭垂直同步时</p>
<p>　　若游戏的实际显示帧速大于60，显卡刷新显示缓冲的速度比显示器快，出现跳帧以及撕裂。</p>
<p> （1）画面撕裂</p>
<p>  假设游戏中有一面黑白相间的栅栏墙高速向左运动，显示器设定的刷新率是100Hz，游戏运行速度为200FPS，则显示器扫描第1帧图像至屏幕垂直方向中点时，显卡已经将第2帧图像送了过来，由于栅栏墙高速向左运动，第2帧图像已经左移了一段距离，最终显示的图像如图（图01）。</p>
<table>
<thead>
<tr>
<th><img src="../../assets/images/2020-09-05-unity-vSyncCount/1520729748.JPG" alt="获得完美游戏效果解析显卡垂直同步设置(2)"></th>
</tr>
</thead>
<tbody><tr>
<td>图1</td>
</tr>
</tbody></table>
<p>  CS 1.5、Quake等大多数PC游戏在关闭垂直同步后都会有这种现象产生。如果你的电脑上装有CS 1.5游戏，不妨自己证实一下：关闭垂直同步后进入游戏，按下键盘上的左箭头”←”让视角匀速转动，是不是看到了”画面撕裂”的现象？打开垂直同步后做相同的测试，画面是不是清爽了许多？</p>
<p>  （2）跳帧</p>
<p>  假如显示器设定的刷新率是80Hz，显卡以100FPS循环显示0-9数字，那么，在开始的0.1秒内，显卡显示了10个数字而显示器只刷新了8次，最终你看到的图像很可能是这样的：（表格如图02）<br>可见，由于显示器刷新率跟不上游戏的FPS，只能舍弃一部分画面，这种现象表现在游戏里就是跳帧。鬼武者3等一些移植到PC上的游戏在关闭垂直同步时通常会出现这种问题。</p>
<table>
<thead>
<tr>
<th><img src="../../assets/images/2020-09-05-unity-vSyncCount/1536901270.JPG" alt="获得完美游戏效果解析显卡垂直同步设置(2)"></th>
</tr>
</thead>
<tbody><tr>
<td>图2</td>
</tr>
</tbody></table>
<p>  通过以上的了解，我们认识到，要想在游戏中获得更好的画质，垂直同步一定要开！正是由于垂直同步的存在，游戏才会有完整、稳速、不跳帧的画面。套用一句广告语来说：”自从开了垂直同步后，画不破了，帧不跳了，头也不眩晕了。”</p>
<h1 id="省电发热优化"><a href="#省电发热优化" class="headerlink" title="省电发热优化"></a>省电发热优化</h1><p>如果你的游戏跑到60帧,手机很热..这个时候首先想到的是降低帧率,</p>
<p>安卓上:</p>
<pre><code>1. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 0 关闭垂直同步..手动设置帧率..    Application.targetFrameRate = 30;  注意这样可能出现跳帧
 2. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 1 这个时候 Application.targetFrameRate无效...每帧等待垂直同步
 3. [QualitySettings](https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html).vSyncCount = 2 这个时候 Application.targetFrameRate无效...每一秒内等待垂直同步??不好翻译..大概意思是如果平台的默认渲染速率是每秒60帧，而vSyncCount设置为2，则游戏将以每秒30帧为目标。</code></pre><p>iOS:</p>
<p>iOS忽略<a href="https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings.html" target="_blank" rel="noopener">QualitySettings</a>.vSyncCount,ios是根据vblank(垂直同步)显示帧(如果有的话)..他的意思就是如果ios的垂直同步是每秒60帧…在刷新垂直同步的时候,如果存在显卡的帧的时候则会显示帧..不存在.则不显示…所以 Application.targetFrameRate是起作用的</p>
<p>以上仅参考文档推测…未进行验证….如有意外概不负责</p>
<ul>
<li><p><a href="https://docs.unity3d.com/2020.2/Documentation/ScriptReference/Application-targetFrameRate.html" target="_blank" rel="noopener">Unity - Scripting API: Application.targetFrameRate (unity3d.com)</a></p>
</li>
<li><p><a href="https://docs.unity3d.com/2020.2/Documentation/ScriptReference/QualitySettings-vSyncCount.html" target="_blank" rel="noopener">Unity - Scripting API: QualitySettings.vSyncCount (unity3d.com)</a></p>
</li>
</ul>
<p>-</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>sync</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>UNITY性能优化流程</title>
    <url>/unity-2020-09-10-optimizing-for-performance/</url>
    <content><![CDATA[<h1 id="资源检查"><a href="#资源检查" class="headerlink" title="资源检查"></a>资源检查</h1><p>首先第一部分.我们要注意在平时工作中需要注意哪些地方养成一套流程规范.避免出现已经被总结出来的问题</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Unity 的垃圾收集（使用 <a href="https://en.wikipedia.org/wiki/Boehm_garbage_collector" target="_blank" rel="noopener">Boehm GC 算法</a>）是非分代的，也是非压缩的。“非分代”意味着 GC 在执行每遍收集时必须扫描整个堆，因此随着堆的扩展，其性能会下降。“非压缩”意味着不会为内存中的对象重新分配内存地址来消除对象之间的间隙。</p>
<p><img src="../../assets/images/2020-09-10-optimizing-for-performance/UnderstandingPerformanceinUnity-AssetAuditingSection_image_1.png" alt="img"></p>
<p>上图为内存碎片化示例。释放对象时，将释放其内存。但是，释放的空间<strong>不会</strong>整合成为整个“可用内存”池的一部分。位于释放的对象两侧的对象可能仍在使用中。因此，释放的空间成为其他内存段之间的“间隙”（该间隙由上图中的红色圆圈指示）。因此，新释放的空间仅可用于存储与释放相同大小或更小的对象的数据。</p>
<p>分配对象时，请注意对象在内存空间中的分配地址必须始终为连续空间块。</p>
<p>这导致了内存碎片化这个核心问题：虽然堆中的可用空间总量可能很大，但是可能其中的部分或全部的可分配空间对象之间存在小的“间隙”。这种情况下，即使可用空间总量高于要分配的空间量，托管堆可能也找不到足够大的连续内存块来满足该分配需求。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ol>
<li><p>Unity 不使用字符串名称对 Animator、Material 和 Shader 属性进行内部寻址。为了加快速度，所有属性名称都经过哈希处理为属性 ID，实际上正是这些 ID 用于寻址属性。<a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Animator.StringToHash.html" target="_blank" rel="noopener">Animator.StringToHash</a> 是用于 Animator 属性名称的对应 API，<a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Shader.PropertyToID.html" target="_blank" rel="noopener">Shader.PropertyToID</a> 是用于 Material 和 Shader 属性名称的对应 API。</p>
</li>
<li><p>将 <a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.RaycastAll.html" target="_blank" rel="noopener">RaycastAll</a> 调用替换为 <a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.RaycastNonAlloc.html" target="_blank" rel="noopener">RaycastNonAlloc</a>，将 <a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.SphereCastAll.html" target="_blank" rel="noopener">SphereCastAll</a> 调用替换为 <a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Physics.SphereCastNonAlloc.html" target="_blank" rel="noopener">SphereCastNonAlloc</a>，以此类推。对于 2D 应用程序，也存在所有 Physics2D 查询 API 的非分配版本。</p>
</li>
<li><p>请避免在紧凑循环中或每帧运行的代码中进行UnityEngine.Object 子类和 Null 比较。Il2cpp中此过程必须执行查找和验证以便将脚本引用转换为对原生代码的引用。</p>
</li>
<li><p>整数数学比浮点数学更快，而浮点数学比矢量、矩阵或四元数运算更快。每当交换或关联算术允许时，请尝试最小化单个数学运算的成本</p>
</li>
<li><p>最好完全避免在生产代码中使用 <code>Object.Find</code> 和 <code>Object.FindObjectOfType</code>。还有<code>Camera.main</code>也使用了<code>FindGameObjectsWithTag</code>,由于此类 API 要求 Unity 遍历内存中的所有游戏对象和组件，因此它们会随着项目规模的扩大而产生性能问题。(除了单例,因为有缓存)</p>
</li>
<li><p>在紧凑循环中尽量少用<code>属性(get,set)</code>和<code>方法</code>,调用的每个方法都必须在内存中找到该方法的地址，并将另一个帧推入栈。所有这些操作都是有成本的，但在大多数代码中，它们都小到可以忽略不计.但是，在紧凑循环中运行较小的方法时，因引入额外方法调用而增加的开销可能会变得非常显著，甚至占主导地位。.例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Accum &#123; get; set; &#125;</span><br><span class="line">Accum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">for(int i &#x3D; 0;</span><br><span class="line">       i &lt; myList.Count;    &#x2F;&#x2F; myList.Count 调用 Count 属性上的 get 方法</span><br><span class="line">       i++) &#123;</span><br><span class="line">    Accum       &#x2F;&#x2F; 通过 set 将加法运算的结果分配给 Accum</span><br><span class="line">+&#x3D;      &#x2F;&#x2F; 通过 get 检索 Accum 的当前值，以便将其传递给加法运算</span><br><span class="line">myList[i];  &#x2F;&#x2F; [] 运算符调用列表的 get_Value 方法来检索列表特定索引位置的项值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除空的MonoBehaviour方法start update awake..理由同上</p>
</li>
<li><p>不要在运行时使用AddComponent将组件添加到GameObjects可能是一项非常昂贵的操作。因为他会先看组件有没有DisallowMultipleComponent的设置,然后又重复上述的检查一次最后还需要调用所有被加入的monobehaviour的awake方法,这些所有步骤都发生在堆内存上</p>
</li>
<li><p>不要使用Texture2D.SetPixels() ,使用Texture2D.SetPixels32() 或者 GetRawTextureData()/Apply() 代替</p>
</li>
<li><p>尽量避免调用Object.Instantiate再经常更新的代码。这里可以使用poolmanager代替</p>
</li>
</ol>
<h3 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h3><ol>
<li>meshreander-&gt;lighting -&gt; cast shadows关闭阴影投射</li>
<li>尽可能少的light,然后只对特定曾有用</li>
<li>过高的分辨率会造成手机发热..可以使用Screen.SetResolution(width,height,false)</li>
<li>启用GPU实例化,<a href="https://docs.unity3d.com/cn/2020.2/Manual/GPUInstancing.html" target="_blank" rel="noopener">GPU 实例化 - Unity 手册 (unity3d.com)</a></li>
</ol>
<h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><ol>
<li>将对象隐藏起来,而不是移动到屏幕外边..因为摄像机依然能看到这些对象,依然会被渲染</li>
<li>如果UI元素改变数值或是位置,会影响批次处理,造成对Gpu发送更多drawcall,所以将更新频率不同的ui分再不同的画布上</li>
<li>同张画布中的ui元素要有一样的z值</li>
<li>ui元素必须拥有一样的材质和纹理</li>
<li>对象拥有一样的clipping rect(矩形裁剪范围)</li>
<li>去掉不需要的Graphic Raycaster,每次当用户点击触发事件时,系统就会遍历所有可能接收输入事件的ui元素,这会造成多次”点落再矩形中”检查,来判断对象是否该做出反应</li>
<li>如果打开了全屏ui,把渲染3d场景的摄像机关掉</li>
<li>如果打开了全屏ui,隐藏其他被遮蔽的ui,如果可以,建议你关闭canvas组件,而不是游戏对象本身,这样能减少画布再次出现的时间.禁用canvase组件会阻止画布向Gpu发起绘图调用,所以该画布不再可见,然后,此时该画布不会丢弃它的顶点缓冲区,它会保留所有网格和顶点,当重新启用时,不会触发重构过程,它只会重新绘制画布内容.此外禁用canvas组件不会触发canvas层级上性能消耗较大的ondisable/onenable回调,禁用子组件时要小心,注意它是否运行性能消耗较大的每帧代码.</li>
<li>尽可能的降低帧率,如果有个静态的ui,就没有必要设置帧率到60</li>
<li>如果texture是中心镂空且切图为九宫格时，可以去除fill center，以减少over draw。</li>
<li>使用Empty4Raycast代替空的image</li>
<li>不要使用ugui的outline和shadow,他时把原来的顶点copy多份进行实现的..可以使用shader进行实现</li>
<li>mask会增加一个drawcall,并且mask里面的图片不会和外面的图片合批,</li>
<li>Scroll Rect 组件对应的Content填加 Canvas 组件 ，因为对应的Mask 子元素依然参与全局的Depth排序，避免因拖动打乱原有的Depth排序，造成合批失败</li>
<li>尽量不要使用layout,因为会从变动节点递归向上调用GetComponents</li>
</ol>
<h4 id="图集整理"><a href="#图集整理" class="headerlink" title="图集整理"></a>图集整理</h4><p>为什么使用图集?</p>
<ol>
<li><p>图片尺寸为2的次幂时，GPU处理起来会快很多，小图自己是做不到每张图都是2的次幂的，但打成一张大图就可以（浪费一点也无所谓）；</p>
</li>
<li><p>CPU在传送资源信息给GPU时，只需要传一张大图就可以了，因为GPU可以在这张图中的不同区域进行采样，然后拼出对应的界面。注意，这就是为什么需要用同一个Source Image图集的原因，是Batch的关键，因为一个Drawcall就把所有原材料传过去了，GPU你画去吧</p>
</li>
</ol>
<p>但是显然把所有图片打成一张图集是不合理的，因为这张图可能非常大，所以就要按照一定规则将图片进行分类。在分类思路上，我们希望做到Drawcall尽可能少，同时资源量也尽可能少（多些重用），但这两者某种程度上是互斥的，所以折衷一下，可以遵循以下思路：</p>
<ul>
<li>设计UI时要考虑重用性，如一些边框、按钮等，这些作为共享资源，放在1~3张大图集中，称为<strong>重用图集</strong>；</li>
<li>其它非重用UI按照功能模块进行划分，每个模块使用1~2张图集，为<strong>功能图集</strong>；</li>
<li>对于一些UI，如果同时用到<strong>功能图集</strong>与<strong>重用图集</strong>，但是其<strong>功能图集</strong>剩下的“空位”较多，则可以考虑将用到的<strong>重用图集</strong>中的元素单独拎出来，合入<strong>功能图集</strong>中，从而做到让UI只依赖于<strong>功能图集</strong>。也就是通过一定的冗余，来达到性能的提升。</li>
</ul>
<h4 id="UGUI层级合并规则与批次生成规则"><a href="#UGUI层级合并规则与批次生成规则" class="headerlink" title="UGUI层级合并规则与批次生成规则"></a>UGUI层级合并规则与批次生成规则</h4><p>UGUI的层叠顺序是按照Hierarchy中的顺序从上往下进行的，也就是越靠上的组件，就会被画在越底部。</p>
<p>所以UI就是这样一层一层地叠上去画出来的。当然这样一个一个地画效率肯定是不能接受的，所以要合并，要Batch，Unity自身就提供了一个算法去决定哪些层应该合并到一起，并以什么样的顺序进行绘制。<strong>所有相邻层的可Batch的UI元素将会在一个Drawcall完成</strong>。接下来就来讨论一下Unity的层级合并与计算算法。</p>
<p>Unity的UI渲染顺序的确定有2个步骤，第一步计算每个UI元素的<strong>层级号</strong>；第二步合并相同<strong>层级号</strong>中可以Batch的元素作为一个<strong>批次</strong>，并对<strong>批次</strong>进行排序；</p>
<p>先从直观的角度来解释<strong>计算层级号的算法</strong>：</p>
<ul>
<li>如果有一个UI元素，它所占的屏幕范围内（通常是矩形），</li>
<li>如果没有任何UI在它的底下，那么它的<strong>层级号</strong>就是0（最底下）；</li>
<li>如果有一个UI在其底下且该UI可以和它Batch，那它的<strong>层级号</strong>与底下的UI层级一样；</li>
<li>如果有一个UI在其底下但是无法与它Batch，那它的<strong>层级号</strong>为底下的UI的层级+1；</li>
<li>如果有多个UI都在其下面，那么按前两种方式遍历计算所有的<strong>层级号</strong>，其中最大的那个作为自己的<strong>层级号</strong>。</li>
</ul>
<p>这里也给一下伪代码，假设所有UI元素（抛弃层级关系）都按从上往下的顺序被装在一个list中，那么每个UI元素对应的<strong>层级号</strong>计算可以参考以下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">CalLayer</span>(<span class="params">List UIEleLst</span>)</span></span><br><span class="line"><span class="function">  <span class="title">if</span>(<span class="params">UIEleLst.Count == <span class="number">0</span> </span>) return</span>;</span><br><span class="line">  <span class="comment">//Initial the first UI Element as layer 0</span></span><br><span class="line">  UIEleLst[<span class="number">0</span>].layer = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span> ~ UIEleLst.Count)&#123;</span><br><span class="line">    <span class="keyword">var</span> IsCollideWithElements = <span class="literal">false</span>; </span><br><span class="line">    <span class="comment">//Compare with all elements beneath</span></span><br><span class="line">    <span class="keyword">for</span>(j = i<span class="number">-1</span> ~ <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//If Element-i collide with Element-j</span></span><br><span class="line">      <span class="keyword">if</span>(UIEleLst[i].Rect.CollideWith(UIEleLst[j].Rect))&#123;</span><br><span class="line">        IsCollideWithElements = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//If Element-i can be batched with Element-j, same layer as Element-j</span></span><br><span class="line">        <span class="keyword">if</span>(UIEleLst[i].QualifyToBatchWith(UIEleLst[j]))&#123;</span><br><span class="line">          UIEleLst[i].layer = UIEleLst[j].layer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">//Or else the layer is larger </span></span><br><span class="line">          UIEleLst[i].layer = UIEleLst[j].layer + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//If not collide with any elements beneath, set layer to 0</span></span><br><span class="line">    <span class="keyword">if</span>(!IsCollideWithElements)</span><br><span class="line">    &#123;</span><br><span class="line">      UIEleLst[i].layer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>有了层级号之后，就要<strong>合并批次</strong>了，</p>
<p>此时，Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个<strong>批次</strong>，</p>
<p><strong>目前已知的排序规则是，Text组件会排在Image组件之前渲染</strong>，而同一类组件的情况下排序规则未知（好像并没什么规则）。</p>
<p><strong>经过以上排序，就可以得到一个有序的批次序列了</strong>。这时，<strong>Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch</strong>。</p>
<p>举个栗子，一个层级为0的ImageA，一个层级为1的ImageB（2个Image可Batch）和一个层级为0的TextC，</p>
<p>Unity排序后的批次为TextC-&gt;ImageA-&gt;ImageB，后两个批次可以合并，所以是2个Drawcall。</p>
<p>再举个栗子，一个层级为0的TextD，一个层级为1的TextE（2个Text可Batch）和一个层级为0的ImageF，</p>
<p>Unity排序后的批次为TextD-&gt;ImageF-&gt;TextE，这时就需要3个Drawcall了！（是不是有点晕，再回顾下黑体字）</p>
<p>以下的伪代码有些偷懒，实在懒得写排序、合并之类的，一长串也不好读，几个步骤列一下，其它诸位看上面那段文字脑补下吧…</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">MergeBatch</span>(<span class="params">List UIEleLst</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//Order the UI Elements by their layers and batch-keys, </span></span><br><span class="line">  <span class="comment">//batch-key is a combination of its component type, </span></span><br><span class="line">  <span class="comment">//texture and material info</span></span><br><span class="line">  UIEleLst.OrderBy(</span><br><span class="line">   (uiElement)=&gt;&#123;<span class="keyword">return</span> <span class="keyword">this</span>.layer &gt; uiElement.layer</span><br><span class="line">   || <span class="keyword">this</span>.BatchKey() &gt; uiElement.BatchKey()&#125; </span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Merge the UI Elements with same layer and batch-key as a batch</span></span><br><span class="line">  <span class="keyword">var</span> BatchLst = UIEleLst.MergeSameElementsAsBatch();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Make adjacent batches with same batch-key merged</span></span><br><span class="line">  BatchLst.MergeAdjacentBatches();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BatchLst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上规则，就可以得出一些“摆UI”的技巧：</p>
<ul>
<li>有相同材质和纹理的UI元素是可以Batch的，可以Batch的UI上下叠在一块不会影响性能，但是如果不能Batch的UI元素叠在一块，就会增加Drawcall开销。</li>
<li>要注意UI元素间的层叠关系，建议用“T”工具查看其矩形大小，因为有些图片透明，但是却叠在其它UI上面了，然后又无法Batch的话，就会无故多许多Drawcall；</li>
<li>UI中出现最多的就是Image与Text组件，当Text叠在Image上面（如Button)，然后Text上又叠了一个图片时，就会至少多2个Drawcall，可以考虑将字体直接印在下面的图片上；</li>
<li>有些情况可以考虑人为增加层级从而减少Drawcall，比如一个Text的层级为0，另一个可Batch的Text叠在一个图片A上，层级为1，那此时2个Text因为层级不同会安排2个Drawcall，但如果在第一个Text下放一个透明的图片（与图片A可Batch），那两个Text的层级就一致了，Drawcall就可以减少一个。</li>
</ul>
<h4 id="UI优化参考"><a href="#UI优化参考" class="headerlink" title="UI优化参考"></a>UI优化参考</h4><ul>
<li><p><a href="https://www.jianshu.com/p/061e67308e5f" target="_blank" rel="noopener">Unity GUI(uGUI)使用心得与性能总结 - 简书 (jianshu.com)</a></p>
</li>
<li><p><a href="https://unity3d.com/how-to/unity-ui-optimization-tips?_ga=2.147783095.1436155110.1558584716-746267689.1557026511" target="_blank" rel="noopener">Some of the best optimization tips for Unity UI - Unity (unity3d.com)</a></p>
</li>
</ul>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><ol>
<li><p>不要再update中重复实例化对象,使用了ecs同样注意,因为他也是执行在update中</p>
</li>
<li><p>不要使用闭包和匿名方法,因为闭包和匿名方法都会都是引用类型(c#将生成一个匿名类)会在堆上进行分配</p>
</li>
<li><p>避免装箱..虽然 Unity 的分配器实际会使用不同的内存池进行小型和大型分配，但 Unity 的垃圾回收器“不是”分代的，因此无法有效清除由装箱生成的小型、频繁的临时分配。</p>
</li>
<li><p>不要用foreach, Unity 的 C# 编译器生成的 IL 会构造一个通用值类型的枚举器来遍历值集合,而且通过枚举器遍历集合的方法调用成本更高，通常比通过 <code>for</code> 或 <code>while</code> 循环进行的手动迭代慢得多。</p>
</li>
<li><p>unityapi.. mesh.vertices和 Input.touches,每次访问 <code>.touches</code> 这些属性时都会发生分配。所以不要在循环和update中使用</p>
</li>
<li><p>避免使用<code>GetComponentsInChildren()</code>,<code>GetComponentsInParent()</code>,而是使用GetComponentsInChildren<T>(bool includeInactive, List<T> result);前者会分配托管内存,后者可以传入一个你保存的数组避免重新分配</p>
</li>
<li><p>不要使用linq因为会分配大量的托管内存</p>
</li>
<li><p>不要使用Texture2D.GetPixels() ,使用<code>Texture2D.GetRawTextureData()</code>代替此方法返回像素数据的NativeArray,前者会有大量的托管内存</p>
</li>
</ol>
<p> 参考 : </p>
<ul>
<li><a href="https://docs.unity3d.com/cn/2020.2/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html" target="_blank" rel="noopener">了解托管堆 - Unity 手册 (unity3d.com)</a></li>
<li><a href="https://docs.unity3d.com/cn/2020.2/Manual/UnderstandingAutomaticMemoryManagement.html" target="_blank" rel="noopener">了解自动内存管理 - Unity 手册 (unity3d.com)</a></li>
<li><a href="https://docs.unity3d.com/cn/2020.2/Manual/BestPracticeUnderstandingPerformanceInUnity7.html" target="_blank" rel="noopener">一般优化 - Unity 手册 (unity3d.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1Tt4y1X7f6" target="_blank" rel="noopener">Unite Now - （中文字幕）性能优化技巧（上）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li>
</ul>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><ol>
<li><p>动画曲线精度过高会增加动画占用内存; 此规则仅面向以文本格式序列化的*.anim文件中的浮点精度Custom Parameters: precision : 5</p>
<p> 用文本编辑器打开.anim动画文件，修改m_EditorCurves::curve::m_Curve下的float值的精度。建议用脚本直接将此文件中所有float精度都调小。</p>
</li>
<li><p>场景中Animator组件的cullingMode是AlwaysAnimate会增加CPU使用率。</p>
</li>
</ol>
<h3 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h3><ul>
<li>如果不需要立体声,将音频文件设置为 Force To Mono,这样能省下一半的磁盘和内存</li>
<li>降低文件比特率</li>
<li>ios下使用adpcm和mp3格式</li>
<li>安卓下使用vorbis格式</li>
<li>如果小型文件&lt;200kb,load type设置成Decompress on Load,</li>
<li>如果中型文件&gt;=200kb,load type 设置成Compressed in Memory</li>
<li>大型文件,如背景音乐,load type设置成streaming</li>
<li>如果时静音模式则销毁audiosourceComponent组件,如果设置成0的话,其实还是会造成不必要的内存与cpu占用</li>
</ul>
<h3 id="EditorSetting"><a href="#EditorSetting" class="headerlink" title="EditorSetting"></a>EditorSetting</h3><ol>
<li>禁用 Accelerometer Frequency 陀螺仪</li>
<li>尝试开启graphicJobs并测试 检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Graphic Jobs(Experimental)*的设置</li>
<li>如果在项目中启用了physics, 可以考虑开启Prebake Collision Meshes选项 检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; PreBake Collision Meshes的设置,这项设置可以减少加载/初始化的时间, 虽然会增加一些构建时间和包体积</li>
<li>在Physics设置中LayerCollisionMatrix中的格子不应该都勾选上,这会增加CPU的负担, 应该取消勾选那些没有必要的格子 检查Editor -&gt; Project Settings -&gt; Physics -&gt; Layer Collision Matrix的设置</li>
<li>在Physics2D设置中LayerCollisionMatrix中的格子不应该都勾选上 同上</li>
<li>检查Graphics中StandardShaderQuality设置,这会增加编译时间和包体积, 除非你想要支持很多性能跨度很大的设备,检查Editor -&gt; Project Settings -&gt; Graphics -&gt; Tiers -&gt; Standard Shader Quality的设置,StandardShaderQuality选项在所有Graphics Tier中应相同</li>
<li>检查Android的ManagedStrippingLevel设置 检查Editor -&gt; Project Settings -&gt; PlayerSettings -&gt; Managed Stripping Level的设置,Android设置中的ManagedStrippingLevel选项应为Medium或者High</li>
</ol>
<h3 id="Mesh"><a href="#Mesh" class="headerlink" title="Mesh"></a>Mesh</h3><ul>
<li>开启mesh compression,来减少磁盘容量</li>
<li>尽量关闭read/write enabled 选项,如果开启unity会存储两份mesh</li>
<li>如果没有使用动画,关闭Rigs,如石头或者房子</li>
<li>如果没有用到Blendshapes,ye关闭</li>
<li>Normals and Tangents..法向量和切线信息,如果材质没用到.也关闭</li>
</ul>
<h3 id="Prefab"><a href="#Prefab" class="headerlink" title="Prefab"></a>Prefab</h3><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><h3 id="Texture"><a href="#Texture" class="headerlink" title="Texture"></a>Texture</h3><p>导入大小需要设置maxsize和compression,否则将导致文件过大.打包的时候会占体积</p>
<ul>
<li>max size 尽可能的设置到最小</li>
<li>pot(大小为2的幂次方) or atlas</li>
<li>移除背景纹理和其他不透明纹理的alpha通道</li>
<li>关闭read/write,以减少内存使用</li>
<li>如果16bit color足够用了就不要使用 32bit</li>
<li>如果不需要使用mipmaps 则禁用,例如 ui和sprites,或者相对于z值不会又任何变化的元素</li>
</ul>
<h3 id="Resources文件夹"><a href="#Resources文件夹" class="headerlink" title="Resources文件夹"></a>Resources文件夹</h3><p>尽量不要使用resources文件夹.它会打包到包体中.且在启动时会全部加载..</p>
<h2 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h2><p>资源包冗余检测</p>
<h1 id="工具检测"><a href="#工具检测" class="headerlink" title="工具检测"></a>工具检测</h1><h2 id="DrawCall"><a href="#DrawCall" class="headerlink" title="DrawCall"></a>DrawCall</h2><p><strong>一、什么是DrawCall？</strong></p>
<p>​    在unity中，每次CPU准备数据并通知GPU的过程就称之为一个DrawCall。</p>
<p>​    具体过程就是：设置颜色–&gt;绘图方式–&gt;顶点坐标–&gt;绘制–&gt;结束，所以在绘制过程中，如果能在一次DrawCall完成所有绘制就会大大提高运行效率，进而达到优化的目的。</p>
<p><strong>二、DrawCall为什么会影响游戏运行效率？</strong></p>
<p>说道为什么会影响效率，就首先要了解一下他的工作原理：为了CPU和GPU可以进行并行工作，就需要一个命令缓冲区，就是由CPU向其中添加命令，然后又GPU从中读取命令，这样就实现了通过CPU准备数据，通知GPU进行渲染。</p>
<p>在每次调用DrawCall之前，CPU需要向GPU发送很多内容，主要是包括数据，渲染状态（就是设置对象需要的材质纹理等），命令等。CPU进行的操作具体就是：</p>
<ul>
<li>准备渲染对象，然后将渲染对象从硬盘加载到内存，然后从内存加载到显存，进而方便GPU高速处理</li>
<li>设置每个对象的渲染状态，也就是设置对象的材质、纹理、着色器等</li>
<li>输出渲染图元，然后向GPU发送DrawCall命令，并将渲染图元传递给GPU</li>
</ul>
<p>所以如果DrawCall数量过多就会导致CPU进行大量计算，进而导致CPU的过载，影响游戏运行效率。</p>
<p><strong>三、批处理</strong></p>
<ol>
<li><p>批处理的目的就是为了减少DrawCall。DrawCall即CPU命令GPU去绘制。</p>
</li>
<li><p>如果我们需要渲染一千个三角形，那么把它们按一千个单独的网格进行渲染所花费的时间要远大于直接渲染一个包含了一千个三角形的网格。</p>
</li>
<li><p>要想使用批处理，需要物体有相同的材质。这是因为，对于使用同一个材质的物体，它们的不同仅仅在于顶点数据的差别，我们可以把这些顶点数据合并在一起，再一起发送给GPU，就可以完成一次批处理。</p>
</li>
<li><p>在unity中，有两种批处理：一是动态批处理，二是静态批处理。</p>
</li>
</ol>
<p>对于动态批处理，unity会自动完成，不需要我们进行操作，而且物体是可以移动的，但是动态批处理有许多限制条件。<br>对于静态批处理，物体不可移动，但是限制条件很少。</p>
<p> <strong>四、动态批处理</strong></p>
<p>原理：每一帧把可以进行批处理的模型网格进行合并，再把合并后模型数据传递给GPU，然后使用同一个材质对其渲染。</p>
<p>限制：</p>
<ol>
<li><p>顶点属性要小于900。例如，如果shader中需要使用顶点位置、法线和纹理坐标这三个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。因此，优化策略就是shader的优化，少使用顶点属性，或者模型顶点数要尽可能少。</p>
</li>
<li><p>多Pass的shader会中断批处理。</p>
</li>
<li><p>在unity5中，动态批处理对于模型缩放的限制已经不存在了。</p>
</li>
<li><p>使用光照纹理的物体需要小心处理。为了让这些物体可以被动态批处理，需要保证它们指向光照纹理中的同一位置。</p>
</li>
</ol>
<p><strong>五、静态批处理</strong></p>
<p>原理：只在运行开始阶段，把需要进行静态批处理的模型合并到一个新的网格中，这意味着这些模型数据不可以在运行时刻被移动。</p>
<p>优点：因为它只需要进行一次合并操作，因此比动态批处理更加高效。</p>
<p>缺点：需要占用更多的内存来存储合并后的几何结构。</p>
<p>操作：将Inspector面板右上角的Static勾选(实际上只需要勾选Batching Static即可)</p>
<p>参考链接:</p>
<ul>
<li><a href="https://connect.unity.com/p/dong-tai-he-pi-yuan-li-ji-ru-he-cheng-gong-he-pi?app=true" target="_blank" rel="noopener">动态合批原理及如何成功合批 - Unity Connect</a></li>
</ul>
<h2 id="渲染统计窗口"><a href="#渲染统计窗口" class="headerlink" title="渲染统计窗口"></a>渲染统计窗口</h2><p><img src="../../assets/images/2020-09-10-optimizing-for-performance/20160721173928287" alt="img"></p>
<p>Batches：相当于DrawCall</p>
<p>Saved by batching：通过批处理节省的DrawCall</p>
<p>SetPass calls：跟Shader中Pass的数量有关，Pass越多这个越大…它大致代表的是摄像机照射范围内，所有GameObject所包含的Material种类数量。（不完全准确，但是这样说易于理解）。假如有30种material，那这个SetpassCall的数值也会离这个30比较接近。这个值越大，肯定会使draw call 越来越大。</p>
<p>影响DrawCall的因素：</p>
<ol>
<li>Pass越多DrawCall越大。可以通过FrameDebugger来查看DrawCall，当然也可以用Profiler，但后者不能查看DrawCall的具体情况。</li>
<li>不同材质的物体，无法通过静态批处理减少DC。但是静态批处理可以通过合并网格来提高性能。</li>
</ol>
<h2 id="Unity-Profiler"><a href="#Unity-Profiler" class="headerlink" title="Unity Profiler"></a><strong>Unity Profiler</strong></h2><p><img src="../../assets/images/2020-09-10-optimizing-for-performance/20180715180958140" alt="img"></p>
<p>在面板的下半部分显示了我们选中的profilers当前帧的详细内容，我们可以通过选择列标题，通过这一列的信息值来排序。<br>在CPU usage profiler中的列表题分别为：<br>Total:当前任务的时间消耗占当前帧cpu消耗的时间比例。<br>Self:任务自身时间消耗占当前帧cpu消耗的时间比例。<br>Calls:当前任务在当前帧内被调用的次数。<br>GC Alloc:当前任务在当前帧内进行过内存回收和分配的次数。   <strong>注意每帧都具有20B以上内存分配的选项 。</strong><br>Time ms:当前任务在当前帧内的耗时总时间。   <strong>注意占用5ms以上的选项</strong><br>Self ms:当前任务自身(不包含内部的子任务)时间消耗。</p>
<p>在 Unity 的 CPU 性能分析器中，Overview 表有一个“GC Alloc”列。此列显示了在特定帧中的托管堆上分配的字节数(4)（<strong>注意：</strong>这与给定帧期间临时分配的字节数不同。性能分析器会显示特定帧中分配的字节数，不考虑在后续帧中是否重用了部分/全部已分配的内存）。启用“Deep Profiling”选项后，可以跟踪执行这些分配的方法。</p>
<p><strong>Unity Profiler 不会跟踪在主线程之外发生的分配。</strong>因此，“GC Alloc”列不能用于统计用户创建的线程中发生的托管分配。请将代码执行从单独线程切换到主线程以进行调试，或使用 <a href="https://docs.unity3d.com/cn/2020.2/ScriptReference/Profiling.Profiler.BeginThreadProfiling.html" target="_blank" rel="noopener">BeginThreadProfiling</a> API 在时间轴性能分析器 (Timeline Profiler) 中显示例程。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>堆栈内存Stack和堆内存Heap</title>
    <url>/unity-2020-09-11-stack-heap/</url>
    <content><![CDATA[<h2 id="堆与栈：有什么不同？"><a href="#堆与栈：有什么不同？" class="headerlink" title="堆与栈：有什么不同？"></a>堆与栈：有什么不同？</h2><p><strong>栈</strong>，或多或少负责跟踪正在程序中运行的代码。</p>
<p><strong>堆</strong>，或多或少负责跟踪程序对象或数据。</p>
<p>栈，把它想像成叠在一起的盒子(像搭积木一样)。每一次调用一个方法就会在最上面叠一个盒子，用来跟踪程序运行情况。我们只能使用栈中叠在最上面的盒子里的东西。当某一最上面的盒子里的代码执行完毕（如方法执行完成），就把它扔掉并继续去使用下一个盒子。</p>
<p>堆，与栈类似，只是它是用来保存信息而不是跟踪执行。所以，堆里的任何信息都可以在任何时间被访问。有了堆，访问信息没有约束，而不像栈只能访问最上面的盒子。</p>
<p>堆的情况就像你把一堆刚洗完的衣服放在床上还没有时间来的及收走，你可以迅速拿到你想要拿的衣服。栈的情况就像你叠在一起的鞋盒子，你需要拿走最上面的盒子才能拿到下一个盒子。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131125031529515" alt="img"></p>
<p>上图并不上真正的内存运行情况，只是为了让大家区分堆和栈。</p>
<p>栈，会自我管理，它有自己的内存管理机制。当最上面的盒子不再使用时，会自动被扔掉。</p>
<p>堆，相反，我们要控制它的垃圾回收(GC)。我们要去管理堆是否干净，就像管理床上的脏衣服。你不手动扔掉它，就会在床上变臭。</p>
<h2 id="什么在堆和栈里"><a href="#什么在堆和栈里" class="headerlink" title="什么在堆和栈里"></a>什么在堆和栈里</h2><p>当程序执行时，我们主要有4种类型的东西放进堆和栈里：值类型，引用类型，指针，指令。</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型:"></a><strong>值类型:</strong></h3><ul>
<li>bool</li>
<li>byte</li>
<li>char</li>
<li>decimal</li>
<li>double</li>
<li>enum</li>
<li>float</li>
<li>int</li>
<li>long</li>
<li>sbyte</li>
<li>short</li>
<li>struct</li>
<li>uint</li>
<li>ulong</li>
<li>ushort</li>
</ul>
<p>它们都衍生于System.ValueType。</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型:"></a><strong>引用类型:</strong></h3><ul>
<li>class</li>
<li>interface</li>
<li>delegate</li>
<li>object</li>
<li>string</li>
</ul>
<p>它们都衍生于System.Object。当然object就是System.Object。</p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针:"></a><strong>指针:</strong></h3><p>第三种被放于内存管理体制中的是类型的引用。这个引用通常被叫作指针。我们并不具体的使用指针，它们由CLR管理。一个指针（引用）是不同于引用类型的。我们定义它是一个引用类型，意味着我们可以通过指针访问它。一个指针占有一小块内存，这块内存指向另一块内存。指针占用在内存中的存储和其它的相同，只是存放的值既不是内存地址也不是空null。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131125034525859" alt="img"></p>
<h2 id="两个黄金规则"><a href="#两个黄金规则" class="headerlink" title="两个黄金规则"></a>两个黄金规则</h2><ol>
<li>引用类型永远存储在堆里。</li>
<li><code>值类型</code>和<code>指针</code>永远存储在它们声明时所在的<code>堆</code>或<code>栈</code>里。</li>
</ol>
<h2 id="栈工作原理"><a href="#栈工作原理" class="headerlink" title="栈工作原理"></a>栈工作原理</h2><p>栈，如第一节所说，在代码运行时负责跟踪每一个线程的所在(什么被调用了)。你可以把它想像成一个线程“状态”，而每一个线程都有它自己的栈。当我们的代码执行一次方法调用，线程开始执行寄存在方法(Method)表里的JIT编译过的指令，并且把该方法的参数存放到当前线程栈里。然后，随着代码的执行每遇见方法中的变量，该变量都会被放到栈的最上面，如此重复把所有变量都放到栈上(当然引用类型只存放指针)。</p>
<p>为了方便理解，让我们看代码与图例。</p>
<p>执行下面的方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddFive</span>(<span class="params"><span class="keyword">int</span> pValue</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result;</span><br><span class="line">    result = pValue + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面是栈里发生的情况.  有必要提醒的是，我们现在假设当前代码产生的栈存储会放到所有既有项(栈里已经存储的数据)之上。一旦我们开始执行该方法，方法参数pValue会被放到栈上（以后的文章里会介绍参数传递）。</p>
<p>注意：方法并不存在栈里，图只是为了阐述原理而放的引用。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126034830281" alt="img"></p>
<p>下一步，控制(线程执行方法)被传递到寄存在方法类型表里的AddFive()方法对应的指令集中。如果方法是第一次被触发，会执行JIT编译。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126035529343" alt="img"></p>
<p>随着方法的执行，栈会分配一块内存给变量result存放。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126035747203" alt="img"></p>
<p>方法执行完成，返回result。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126035907203" alt="img"></p>
<p>该次任务在栈里所占的所有内存将被清理，仅一个指针被移动到AddFive()开始时所在的可用内存地址上。接着会执行栈里AddFive()下面一个方法（图里看不到）。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126040806812" alt="img"></p>
<p>在这个例子当中，变量result被放到了栈里。事实上，方法体内每次定义的值类型变量都会被放到栈里。</p>
<h2 id="值类型会存储在堆里？"><a href="#值类型会存储在堆里？" class="headerlink" title="值类型会存储在堆里？"></a>值类型会存储在堆里？</h2><p>是的，值类型有时候就是会存储在堆里。上一节中介绍的<strong>黄金规则2:值类型和指针永远存储在它们声明时所在的堆或栈里</strong>。如果一个值类型不是在方法中定义的，而是在一个引用类型里，那么此值类型将会被放在这个引用类型里并存储在堆上。</p>
<h2 id="代码图例"><a href="#代码图例" class="headerlink" title="代码图例"></a>代码图例</h2><p>我们定义一个引用类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInt</span></span><br><span class="line">&#123;          </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> MyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>里面包含一个值类型MyValue。</p>
<p>执行下面的方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MyInt <span class="title">AddFive</span>(<span class="params"><span class="keyword">int</span> pValue</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInt result = <span class="keyword">new</span> MyInt();</span><br><span class="line">    result.MyValue = pValue + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>就像上一节介绍的一样，线程开始执行此方法，参数pValue将会被放到当前线程栈上。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126052252140" alt="img"></p>
<p>接下来不同于上一节所介绍的是MyInt是一个引用类型，它将被放到堆上并在栈上放一个指针指向它在堆里的存储。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126052522859" alt="img"></p>
<p>当AddFive()执行完成后，如上一节所讲栈开始清理。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131126052806703" alt="img"></p>
<p>现在是需要C#垃圾回收GC的时候了。当我们的程序所占内存到达临界值时(即将溢出)，我们会需要更多的堆空间，GC就会开始运行。GC停止所有当前运行线程(整体停止)，找到堆里所有主程序不会访问到的对象并删除它们。然后，GC会识别所有堆里剩下的对象并分配内存空间给它们，同时调整堆和栈里指向它们的指针。你可以想像这是非常耗资源的，这会影响到程序的性能。这就是为什么我们需要理解和注意堆栈的使用，进而写出高性能代码。</p>
<h2 id="堆栈原理对代码的影响"><a href="#堆栈原理对代码的影响" class="headerlink" title="堆栈原理对代码的影响"></a>堆栈原理对代码的影响</h2><p>当我们使用引用类型时，我们在和指向引用类型的指针打交道，而不是引用类型本身。</p>
<p>当我们使用值类型时，我们就是在和值类型本身打交道。</p>
<h3 id="代码图例-1"><a href="#代码图例-1" class="headerlink" title="代码图例"></a>代码图例</h3><p>假设执行方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ReturnValue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line">    y = x;      </span><br><span class="line">    y = <span class="number">4</span>;         </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们会得到值 <strong>3</strong>。</p>
<p>使用引用类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> MyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果执行方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ReturnValue2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInt x = <span class="keyword">new</span> MyInt();</span><br><span class="line">    x.MyValue = <span class="number">3</span>;</span><br><span class="line">    MyInt y = <span class="keyword">new</span> MyInt();</span><br><span class="line">    y = x;        </span><br><span class="line">    y.MyValue = <span class="number">4</span>;         </span><br><span class="line">    <span class="keyword">return</span> x.MyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们得到的值是４而不是３！（译外话：这是很简单，但相信还是有很多人不知道原理的）</p>
<p>第一个示例中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ReturnValue</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> y = x;    </span><br><span class="line">    y = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="../../assets/images/2020-09-11-stack-heap/20131128043217031" alt="img"></p>
<p>x就是3，y就是4。操作两个不同对象。</p>
<p>第二个示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ReturnValue2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyInt x;</span><br><span class="line">    x.MyValue = <span class="number">3</span>;</span><br><span class="line">    MyInt y;</span><br><span class="line">    y = x;              </span><br><span class="line">    y.MyValue = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> x.MyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-09-11-stack-heap/20131128043332000" alt="img"></p>
<p>得到的值是4不是3是因为我们操作栈里两个指针并且它们指向堆里同一个对象。</p>
<h2 id="参数，大画面"><a href="#参数，大画面" class="headerlink" title="参数，大画面"></a>参数，大画面</h2><p>下面是当代码运行时会产生的一个详细过程。上几节已经介绍过当一个方法被调用时会产生的基本情况，让我们来看一下更加详细的内容。</p>
<p>当我们调用一个方法时会发生以下情形：</p>
<ol>
<li>栈会分配一块内存空间给程序执行所需要的信息(我们叫它栈结构Stack Frame)。一个栈结构包含方法调用地址(指针)，它以一个GOTO指令的形式存在栈里。因此，当程序执行完方法(method)时，它会知道怎么样返回进而曳继续执行代码。</li>
<li>方法的所有参数将被复制到栈里，这是我们将要更加详细介绍的部分。</li>
<li>控制被传递到JIT编译过的方法里，同时线程开始执行代码。此时，我们将有另一个方法呈现在栈结构的“回调栈”里。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddFive</span>(<span class="params"><span class="keyword">int</span> pValue</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    result = pValue + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>栈像下图所示：</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131128042641203" alt="img"></p>
<p>注意：ReturnValue方法不会存在栈上，图中把ReturnValue作为此栈结构的开始只是为了解释栈原理。</p>
<p>像前几节介绍的，值类型和引用类型在栈里的存储是不同的。栈为任何值类型创建副本，栈也为任何引用类型的指针创建副本。</p>
<h2 id="值类型传递"><a href="#值类型传递" class="headerlink" title="值类型传递"></a><strong>值类型传递</strong></h2><p>下面是值类型传递在栈里的内幕。</p>
<p>首先，当我们传递一个值类型变量时，栈会为它分配一块内存空间并把值类型变量的值存储进去。看下面的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Class1</span>  </span><br><span class="line">&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>     &#123;  </span><br><span class="line">         <span class="keyword">int</span> x = <span class="number">5</span>;  </span><br><span class="line">         AddFive(x);  </span><br><span class="line">         Console.WriteLine(x.ToString());  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">AddFive</span>(<span class="params"><span class="keyword">int</span> pValue</span>)  </span></span><br><span class="line"><span class="function"></span>     &#123;  </span><br><span class="line">         pValue += <span class="number">5</span>;  </span><br><span class="line">         <span class="keyword">return</span> pValue;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当代码执行时，栈为x分配一块内存空间并存储值5</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131127050637031" alt="img"></p>
<p>然后，AddFive()被放到栈上，同时栈分配内存空间给参数pValue并复制x的值给它。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131127051251531" alt="img"></p>
<p>当AddFive()执行完成，线程被传递回Go()。同时因为AddFive()执行完，它的参数pValue也实质上被移除。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131127051718640" alt="img"></p>
<p>所以结果是5是合理的。关键点是任何被传递的值类型参数仅是一个碳复制，因为我们希望保护原始变量的值。</p>
<p>有一点要记住的是，如果我们有一个非常庞大的值类型(如，庞大的struct类型)传递到栈里，当处理器循环复制它并循环占有栈空间时将会非常耗资源。栈没有无限的空间去使用，就像用水杯不断的接水早晚会溢出一样。Struct类型可以变得非常庞大，我们要小心并清醒的使用它。</p>
<p>下面是一个比较大的struct结构类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyStruct  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">long</span> a, b, c, d, e, f, g, h, i, j, k, l, m;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>让我们看看执行下面代码Go()方法时再到DoSomething()方法会发生的情况：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   MyStruct x = <span class="keyword">new</span> MyStruct();  </span><br><span class="line">   DoSomething(x);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">MyStruct pValue</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="comment">// DO SOMETHING HERE....  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="../../assets/images/2020-09-11-stack-heap/20131127054659921" alt="img"></p>
<p>这可能会非常低效。想像一下如果我们传递MyStruct几千次，它会怎么样让程序死掉。</p>
<p>那么，我们怎么才能回避这样的问题呢？那就是仅传递原始值类型的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Go()  </span><br><span class="line">&#123;  </span><br><span class="line">   MyStruct x &#x3D; new MyStruct();  </span><br><span class="line">   DoSomething(ref x);  </span><br><span class="line">&#125;  </span><br><span class="line"> public struct MyStruct  </span><br><span class="line"> &#123;  </span><br><span class="line">     long a, b, c, d, e, f, g, h, i, j, k, l, m;  </span><br><span class="line"> &#125;  </span><br><span class="line"> public void DoSomething(ref MyStruct pValue)  </span><br><span class="line"> &#123;  </span><br><span class="line">          &#x2F;&#x2F; DO SOMETHING HERE....  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>这样就能节省内存并提升内存使用效率</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131127055230375" alt="img"></p>
<p>唯一需要注意的是传递引用时我们在访问原始变量x的值，任可对pValue的改变都会影响到x。</p>
<p>下面的代码会将x改变成”12345”，因为pValue.a实际上指向原始x声明时所在的内存地址。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   MyStruct x = <span class="keyword">new</span> MyStruct();  </span><br><span class="line">   x.a = <span class="number">5</span>;  </span><br><span class="line">   DoSomething(<span class="keyword">ref</span> x);  </span><br><span class="line">   Console.WriteLine(x.a.ToString());  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params"><span class="keyword">ref</span> MyStruct pValue</span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">         pValue.a = <span class="number">12345</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="引用类型传递"><a href="#引用类型传递" class="headerlink" title="引用类型传递"></a><strong>引用类型传递</strong></h2><p>传递引用类型跟上一节所示例中用引用的方式传递值类型相似。</p>
<p>如果使用引用类型（原文可能笔误，写的是值类型）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyInt</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> MyValue;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后调用Go()方法，MyInt会被放到堆里因为它是一个引用类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   MyInt x = <span class="keyword">new</span> MyInt();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img src="../../assets/images/2020-09-11-stack-heap/20131127070913796" alt="img"></p>
<p>如果执行下面代码中的Go()：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   MyInt x = <span class="keyword">new</span> MyInt();  </span><br><span class="line">   x.MyValue = <span class="number">2</span>;  </span><br><span class="line">   DoSomething(x);  </span><br><span class="line">   Console.WriteLine(x.MyValue.ToString());  </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething</span>(<span class="params">MyInt pValue</span>)  </span></span><br><span class="line"><span class="function"></span> &#123;  </span><br><span class="line">     pValue.MyValue = <span class="number">12345</span>;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>会发生这种情况：</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131127071131421" alt="img"></p>
<ol>
<li>开始调用Go()，栈分配一块内存空间给x。</li>
<li>执行行到DoSomething()，栈分配一块内在空间给pValue。</li>
<li>x的值是堆中MyInt对应在栈里的内存地址，复制x给pValue。</li>
</ol>
<p>因此，我们用pValue改变MyInt的MyValue的值时，x最终也会获得这个改变的值”12345“。</p>
<p>如果我们用引用的方式传递一个引用类型变量呢？</p>
<h2 id="用引用的方式传递引用类型"><a href="#用引用的方式传递引用类型" class="headerlink" title="用引用的方式传递引用类型"></a>用引用的方式传递引用类型</h2><p>我们有一个类Thing, 类Animal和Vegetables衍生于Thing：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Thing</span>  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span>:<span class="title">Thing</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Weight;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Vegetable</span>:<span class="title">Thing</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Length;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行下面的Go()方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   Thing x = <span class="keyword">new</span> Animal();  </span><br><span class="line">   Switcharoo(<span class="keyword">ref</span> x);  </span><br><span class="line">    Console.WriteLine(  </span><br><span class="line">      <span class="string">"x is Animal    :   "</span>  </span><br><span class="line">      + (x <span class="keyword">is</span> Animal).ToString());  </span><br><span class="line">    Console.WriteLine(  </span><br><span class="line">        <span class="string">"x is Vegetable :   "</span>  </span><br><span class="line">        + (x <span class="keyword">is</span> Vegetable).ToString());  </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Switcharoo</span>(<span class="params"><span class="keyword">ref</span> Thing pValue</span>)  </span></span><br><span class="line"><span class="function"></span> &#123;  </span><br><span class="line">     pValue = <span class="keyword">new</span> Vegetable();  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>x最终变成Vegetable。</p>
<p>打印结果：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">x is Animal    :</span>   <span class="literal">False</span></span><br><span class="line"><span class="attr">x is Vegetable :</span>   <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p>让我们看看堆栈里到底发生了什么情况</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131127073852765" alt="img"></p>
<ol>
<li>调用Go()方法，栈分配一块内存空间给x。</li>
<li>堆分配一块内存空间给Animal。</li>
<li>开始执行Switcharoo()方法，栈分配一块内存空间给pValue并指向x。</li>
<li><img src="../../assets/images/2020-09-11-stack-heap/20131127074345953" alt="img"></li>
<li>栈分配一块内存空间给Vegetable。</li>
<li>pValue改变了x的值使其指向Vegetable的内在地址。</li>
</ol>
<p>如果我们不是用ref传递的，打印结果正相反。</p>
<h2 id="复制不仅仅是复制"><a href="#复制不仅仅是复制" class="headerlink" title="复制不仅仅是复制"></a>复制不仅仅是复制</h2><p>为了更清晰的阐述这个问题，让我们测试一下在堆中存储值类型变量和引用类型变量时会产生的不同情况。</p>
<h3 id="值类型测试"><a href="#值类型测试" class="headerlink" title="值类型测试"></a>值类型测试</h3><p>首先，我们看一下值类型。下面是一个类和一个结构类型(值类型)，Dude类包含一个Name元素和两个Shoe元素。我们有一个CopyDude()方法用来复制生成新Dude。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dude</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> Shoe RightShoe;</span><br><span class="line">    <span class="keyword">public</span> Shoe LeftShoe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dude <span class="title">CopyDude</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dude newPerson = <span class="keyword">new</span> Dude();</span><br><span class="line">        newPerson.Name = Name;</span><br><span class="line">        newPerson.LeftShoe = LeftShoe;</span><br><span class="line">        newPerson.RightShoe = RightShoe;</span><br><span class="line">        <span class="keyword">return</span> newPerson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Name + <span class="string">" : Dude!, I have a "</span> + RightShoe.Color + <span class="string">" shoe on my right foot, and a "</span> + LeftShoe.Color + <span class="string">" on my left foot."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Dude类是一个复杂类型，因为值 类型结构Shoe是它的成员， 它们都将存储在堆中。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131128023045765" alt="img"></p>
<p>当我们执行下面的方法时：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class1 pgm = <span class="keyword">new</span> Class1();</span><br><span class="line">    Dude Bill = <span class="keyword">new</span> Dude();</span><br><span class="line">    Bill.Name = <span class="string">"Bill"</span>;</span><br><span class="line">    Bill.LeftShoe = <span class="keyword">new</span> Shoe();</span><br><span class="line">    Bill.RightShoe = <span class="keyword">new</span> Shoe();</span><br><span class="line">    Bill.LeftShoe.Color = Bill.RightShoe.Color = <span class="string">"Blue"</span>;</span><br><span class="line">    Dude Ted = Bill.CopyDude();</span><br><span class="line">    Ted.Name = <span class="string">"Ted"</span>;</span><br><span class="line">    Ted.LeftShoe.Color = Ted.RightShoe.Color = <span class="string">"Red"</span>;</span><br><span class="line">    Console.WriteLine(Bill.ToString());</span><br><span class="line">    Console.WriteLine(Ted.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们得到了期望的结果：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">Bill : Dude!, I have a Blue shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Blue <span class="keyword">on</span> my <span class="built_in">left</span> foot.</span><br><span class="line">Ted : Dude!, I have a Red shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Red <span class="keyword">on</span> my <span class="built_in">left</span> foot.</span><br></pre></td></tr></table></figure>

<p>如果我们把Shoe换成引用类型呢？</p>
<h3 id="引用类型测试"><a href="#引用类型测试" class="headerlink" title="引用类型测试"></a>引用类型测试</h3><p>当我们把Shoe改成引用类型时，问题就产生了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>执行同样上面的Main()方法，结果改变了，如下：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">Bill : Dude!, I have a Red shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Red <span class="keyword">on</span> my <span class="built_in">left</span> foot</span><br><span class="line">Ted : Dude!, I have a Red shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Red <span class="keyword">on</span> my <span class="built_in">left</span> foot</span><br></pre></td></tr></table></figure>


<p>这并不是我们期望的结果。很明显，出错了！看下面的图解：</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131128023756781" alt="img"></p>
<p>因为现在Shoe是引用类型而不是值类型，当我们进行复制时仅是复制了指针，我们并没有复制指针真正对应的对象。这就需要我们做一些额外的工作使引用类型Shoe像值类型一样工作。</p>
<p>很幸运，我们有一个接口可以帮我们实现：ICloneable。当Dude类实现它时，我们会声明一个Clone()方法用来产生新的Dude复制类。（译外话：复制类及其成员跟原始类不产生任何重叠，即我们所说的深复制)  看下面代码：<br>ICloneable consists of one method: Clone()</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Here’s how we’ll implement it in the Shoe class:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Shoe : ICloneable</span><br><span class="line">&#123;</span><br><span class="line">    public string Color;</span><br><span class="line">    #region ICloneable Members</span><br><span class="line">    public object Clone()</span><br><span class="line">    &#123;</span><br><span class="line">        Shoe newShoe &#x3D; new Shoe();</span><br><span class="line">        newShoe.Color &#x3D; Color.Clone() as string;</span><br><span class="line">        return newShoe;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在Clone()方法里，我们创建了一个新的Shoe，克隆所有引用类型变量，复制所有值类型变量，最后返回新的对象Shoe。有些既有类已经实现了ICloneable，我们直接使用即可，如String。因此，我们直接使用Color.Clone()。因为Clone()返回object对象，我们需要进行一下类型转换。</p>
<p>下一步，我们在CopyDude()方法里，用克隆Clone()代替复制：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Dude <span class="title">CopyDude</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Dude newPerson = <span class="keyword">new</span> Dude();</span><br><span class="line">    newPerson.Name = Name;</span><br><span class="line">    newPerson.LeftShoe = LeftShoe.Clone() <span class="keyword">as</span> Shoe;</span><br><span class="line">    newPerson.RightShoe = RightShoe.Clone() <span class="keyword">as</span> Shoe;</span><br><span class="line">    <span class="keyword">return</span> newPerson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>再次执行主方法Main()：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class1 pgm = <span class="keyword">new</span> Class1();</span><br><span class="line">    Dude Bill = <span class="keyword">new</span> Dude();</span><br><span class="line">    Bill.Name = <span class="string">"Bill"</span>;</span><br><span class="line">    Bill.LeftShoe = <span class="keyword">new</span> Shoe();</span><br><span class="line">    Bill.RightShoe = <span class="keyword">new</span> Shoe();</span><br><span class="line">    Bill.LeftShoe.Color = Bill.RightShoe.Color = <span class="string">"Blue"</span>;</span><br><span class="line">    Dude Ted = Bill.CopyDude();</span><br><span class="line">    Ted.Name = <span class="string">"Ted"</span>;</span><br><span class="line">    Ted.LeftShoe.Color = Ted.RightShoe.Color = <span class="string">"Red"</span>;</span><br><span class="line">    Console.WriteLine(Bill.ToString());</span><br><span class="line">    Console.WriteLine(Ted.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们得到了期望的结果：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">Bill : Dude!, I have a Blue shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Blue <span class="keyword">on</span> my <span class="built_in">left</span> foot</span><br><span class="line">Ted : Dude!, I have a Red shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Red <span class="keyword">on</span> my <span class="built_in">left</span> foot</span><br></pre></td></tr></table></figure>


<p>下面是图解：</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20131128030404656" alt="img"></p>
<h3 id="整理我们的代码"><a href="#整理我们的代码" class="headerlink" title="整理我们的代码"></a>整理我们的代码</h3><p>在实践中，我们是希望克隆引用类型并复制值类型的。这会让你回避很多不易察觉的错误，就像上面演示的一样。这种错误有时不易被调试出来，会让你很头疼。</p>
<p>因此，为了减轻头疼，让我们更进一步清理上面的代码。我们让Dude类实现IConeable代替使用CopyDude()方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dude</span>: <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> Shoe RightShoe;</span><br><span class="line">    <span class="keyword">public</span> Shoe LeftShoe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Name + <span class="string">" : Dude!, I have a "</span> + RightShoe.Color + <span class="string">" shoe on my right foot, and a "</span> + LeftShoe.Color + <span class="string">" on my left foot."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> ICloneable Members</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Dude newPerson = <span class="keyword">new</span> Dude();</span><br><span class="line">        newPerson.Name = Name.Clone() <span class="keyword">as</span> <span class="keyword">string</span>;</span><br><span class="line">        newPerson.LeftShoe = LeftShoe.Clone() <span class="keyword">as</span> Shoe;</span><br><span class="line">        newPerson.RightShoe = RightShoe.Clone() <span class="keyword">as</span> Shoe;</span><br><span class="line">        <span class="keyword">return</span> newPerson;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在主方法Main()使用Dude.Clone()：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class1 pgm = <span class="keyword">new</span> Class1();</span><br><span class="line">    Dude Bill = <span class="keyword">new</span> Dude();</span><br><span class="line">    Bill.Name = <span class="string">"Bill"</span>;</span><br><span class="line">    Bill.LeftShoe = <span class="keyword">new</span> Shoe();</span><br><span class="line">    Bill.RightShoe = <span class="keyword">new</span> Shoe();</span><br><span class="line">    Bill.LeftShoe.Color = Bill.RightShoe.Color = <span class="string">"Blue"</span>;</span><br><span class="line">    Dude Ted = Bill.Clone() <span class="keyword">as</span> Dude;</span><br><span class="line">    Ted.Name = <span class="string">"Ted"</span>;</span><br><span class="line">    Ted.LeftShoe.Color = Ted.RightShoe.Color = <span class="string">"Red"</span>;</span><br><span class="line">    Console.WriteLine(Bill.ToString());</span><br><span class="line">    Console.WriteLine(Ted.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后得到期望的结果：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">Bill : Dude!, I have a Blue shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Blue <span class="keyword">on</span> my <span class="built_in">left</span> foot.</span><br><span class="line">Ted : Dude!, I have a Red shoe <span class="keyword">on</span> my <span class="built_in">right</span> foot, <span class="keyword">and</span> a Red <span class="keyword">on</span> my <span class="built_in">left</span> foot.</span><br></pre></td></tr></table></figure>

<h3 id="特殊引用类型String"><a href="#特殊引用类型String" class="headerlink" title="特殊引用类型String"></a>特殊引用类型String</h3><p>在C#中有趣的是，当System.String 使用操作符“=”时，实际上是进行了克隆(深复制)。你不必担心你只是在操作一个指针，它会在内存中创建一个新的对象。但是，你一定要注意内存的占用问题(<strong>译外话：比如为什么在一定情况下我们使用StringBuilder代替String+String+String+String…前者速度稍慢初始化耗多点内存但在大字符串操作上节省内存，后者速度稍快初始化简单但在大字符串操作上耗内存</strong>)。如果我们回头去看上面的图解中，你会发现Stirng类型在图中并不是一个针指向另一个内存对象，而是为了尽可能的简单，把它当成值类型来演示了。</p>
<p><strong>绘图Graphing</strong></p>
<p>让我们站在GC的角度研究一下。如果我们负责“扔垃圾”，我们需要制定一个有效的“扔垃圾”计划。显然，我们需要判断哪些是垃圾，哪些不是。</p>
<p>为了决定哪些需要保留，我们假设任何没有正在被使用的东西都是垃圾（如角落里堆积的破旧纸张，阁楼里一箱箱没有用的过时产品,柜子里不用的衣服）。想像一下我们跟两个好朋友生活在一起：JIT 和CLR。<strong>JIT和CLR</strong>不断的跟踪他们正在使用的东西，并给我们一个他们需要保留的东西列表。这个初始列表我们叫它“根(root)”列表。因为我们用它做起点。我们将保持一个主列表去绘制一张图，图中分布着所有我们在房子中需要保留东西。任何与主列表中有关联的东西也被画入图中。如，我们保留电视就不要扔掉电视遥控器，所以电视遥控器也会被画入图中。我们保留电脑就不能扔掉显示器键盘鼠标，同样也把它们画入图中。</p>
<p>这就是GC怎么决定去保留对象的。<strong>GC会保留从JIT和CLR那收到的一个根(root)对象引用列表，然后递归搜索对象引用并决定什么需要保留。</strong></p>
<p>这个根的构成如下：</p>
<ul>
<li>全局/静态 指针。通过以静态变量的方式保持对象的引用，来确保对象不会被GC回收。</li>
<li>栈里的指针。为了程序的执行，我们不想扔掉那些程序线程始终需要的对象。</li>
<li>CPU寄存器指针。托管堆里任何被CPU内存地址指向的对象都需要被保留。</li>
</ul>
<p><img src="../../assets/images/2020-09-11-stack-heap/20190919173037464.png" alt="在这里插入图片描述"><br>在上面的图中，托管堆中的对象1，5被根Roots引用，3被1引用。对象1，5是被直接引用，3是通过递归查询找到。如果关联到我们之前的假设，对象1是我们的电视，对象3则是电视遥控器。当所有对象画完后，我们开始进行下一阶段：垃圾清理。</p>
<p><strong>GC垃圾清理Compacting</strong></p>
<p>现在我们有了一张需要保留对象的关系图，接下来进行GC的清理。<br><img src="../../assets/images/2020-09-11-stack-heap/20190919173106186.png" alt="在这里插入图片描述"><br>图中对象2和4被认定为垃圾将被清理。清理对象2，复制（memcpy ）对象3到2的位置。<br><img src="../../assets/images/2020-09-11-stack-heap/20190919173121251.png" alt="在这里插入图片描述"><br>由于对象3的地址变了，GC需要修复指针（红色箭头）。然后清理对象4，复制（memcpy ）对象5到原来3的位置（译外话：GC原则：堆中对象之间是没有间隙的，以后会有文章专门介绍GC原理）。<br><img src="../../assets/images/2020-09-11-stack-heap/20190919173159935.png" alt="在这里插入图片描述"><br><img src="../../assets/images/2020-09-11-stack-heap/20190919173215230.png" alt="在这里插入图片描述"><br>最后清理完毕，新对象将被放到对象5的上面(译外话：GC对一直管理一个指针指向新对象将被放置的地址，如黄色箭头，以后会有文章专门介绍)。</p>
<p>了解GC原理可以帮助我们理解GC清理(复制memcpy ，指针修复等)是怎么消耗掉很多资源的。很明显，减少托管堆里对象的移动（复制memcpy ）可以提高GC清理的效率。</p>
<p><strong>托管堆之外的终止化队列Finalization Queue和终止化-可达队列Freachable Queue</strong></p>
<p>有些情况下，GC需要执行特定代码去清理非托管资源，如文件操作，数据库连接，网络连接等。一种可行性方案是使用析构函数（终结器）：<br><img src="../../assets/images/2020-09-11-stack-heap/20190919173419800.png" alt="在这里插入图片描述"><br>译外话：析构函数会被内部转换成终结器override Finializer()</p>
<p>有终结器的对象在创建时，同时在Finalization Queue里创建指向它们的指针（更正原文说的把对象放到Finalization Queue里）：</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20190919173504552.png" alt="在这里插入图片描述"><br>上图对象1,4,5实现了终结器，因此在Finalization Queue里创建指向它们的指针。让我们看一下，当对象2和4没有被程序引用要被GC清理时会发生什么情况。<br>对象2会被以常规模式清理掉(见文章开始部分)。GC发现对象4有终结器，则会把Finalization Queue里指向它的指针移到Freachable Queue中，如下图：<br><img src="../../assets/images/2020-09-11-stack-heap/20190919173647141.png" alt="在这里插入图片描述"><br>但是对象4并不被清理掉。有一个专门处理Freachable Queue的线程，当它处理完对象4在Freachable Queue里的指针后，会把它移除。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20190919173729593.png" alt="在这里插入图片描述"><br>这时对象4可以被清理了。当下次GC清理时会把它移除掉。换句话说，至少执行两次GC清理才能把对象4清理掉，显然会影响程序性能。</p>
<p>创建终结器，意味着创建了更多的工作给GC，也就会消耗更多资源影响程序性能。因此，当你使用终结器时一定要确保你确实需要使用它。<br>更好的方法是使用IDisposable接口。</p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20190919173836793.png" alt="在这里插入图片描述"><br>实现IDisposable接口的对象可以使用using关键字：<br><img src="../../assets/images/2020-09-11-stack-heap/20190919173851233.png" alt="在这里插入图片描述"><br>变量rec的作用域是大括号内，大括号外不可访问。</p>
<p><strong>静态变量</strong></p>
<p><img src="../../assets/images/2020-09-11-stack-heap/20190919174039786.png" alt="在这里插入图片描述"></p>
<p>如果你初始化了TryoutRunners，那么它将永远不会被GC清理，因为有静态指针一直指向初始化的对象。一旦调用了Runner里GetStats()方法，因为GetStats()里面没有文件关闭操作，它将永远被打开也不会被GC清理。我们可以看到程序的崩溃即将来临。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-i/" target="_blank" rel="noopener">C# Heap(ing) Vs Stack(ing) In .NET - Part One (c-sharpcorner.com)</a></li>
<li><a href="https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-ii/" target="_blank" rel="noopener">C# Heap(ing) Vs Stack(ing) In .NET - Part Two (c-sharpcorner.com)</a></li>
<li><a href="https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-iii/" target="_blank" rel="noopener">C# Heap(ing) Vs Stack(ing) In .NET - Part Three (c-sharpcorner.com)</a></li>
<li><a href="https://www.c-sharpcorner.com/article/C-Sharp-heaping-vs-stacking-in-net-part-iv/" target="_blank" rel="noopener">C# Heap(ing) Vs Stack(ing) In .NET - Part Four (c-sharpcorner.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1Tt4y1X7f6" target="_blank" rel="noopener">Unite Now - （中文字幕）性能优化技巧（上）_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity的addressables</title>
    <url>/unity-2020-09-12-Addressables/</url>
    <content><![CDATA[<h2 id="Addressables-InitializeAsync"><a href="#Addressables-InitializeAsync" class="headerlink" title="Addressables.InitializeAsync"></a>Addressables.InitializeAsync</h2><p>初始化并填充Addressables.ResourceLocators</p>
<h2 id="IResourceLocator"><a href="#IResourceLocator" class="headerlink" title="IResourceLocator"></a>IResourceLocator</h2><p>资源目录,可以通过 代码加载额外的locator</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var  requestCatalog&#x3D;Addressables.LoadContentCatalogAsync(&quot;http:&#x2F;&#x2F;192.168.100.100:51879&#x2F;catalog_extra.json.json&quot;, providerSuffix);</span><br><span class="line">var locator &#x3D; await requestCatalog.Task;</span><br><span class="line">Addressables.AddResourceLocator(locator);</span><br></pre></td></tr></table></figure>



<p>存储了一个IResourceLocation列表..根据不同的key(label,path)进行存储</p>
<p>比如: 有个资源是ui.prefab,同时又lable<code>enter</code>,<code>main</code>可能就会有三个IResourceLocation</p>
<ul>
<li>enter为key的IResourceLocation</li>
<li>main为key的IResourceLocation</li>
<li><code>Assets/prefabs/ui/ui.prefab</code>为key的IResourceLocation</li>
</ul>
<h2 id="IResourceLocation"><a href="#IResourceLocation" class="headerlink" title="IResourceLocation"></a>IResourceLocation</h2><h3 id="MergeMode"><a href="#MergeMode" class="headerlink" title="MergeMode"></a>MergeMode</h3><p><strong>MergeMode</strong>是什么呢？翻译过来是合并模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum MergeMode</span><br><span class="line">&#123;</span><br><span class="line">    None &#x3D; 0,</span><br><span class="line">    UseFirst &#x3D; 0,</span><br><span class="line">    Union,</span><br><span class="line">    Intersection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 会去先查询每一个地址/标签对应的资源，然后再根据MergeMode进行最终结果的计算。</p>
<p>举个栗子：</p>
<p>比如传入的参数是<code>new List&lt;object&gt;{&quot;cube&quot;, &quot;red&quot;}</code>，根据cube查询出来的资源有A、B、D，根据red查询出来的资源有C、D、E。</p>
<p>那么MergeMode是Node或UseFirst时，会取第一个key查询到的资源：A、B、D；</p>
<p>MergeMode是Union时，会取所有key查询到的资源的<strong>并集</strong>：A、B、C、D、E；</p>
<p>MergeMode是Intersection时，会取所有key查询到的资源的<strong>交集</strong>：D。</p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.15/manual/LoadingAddressableAssets.html" target="_blank" rel="noopener">Addressables.LoadAsset(s)Async | Addressables | 1.15.1 (unity3d.com)</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>sync</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
        <tag>addressable</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏中的向量使用</title>
    <url>/unity-2020-09-13-vector/</url>
    <content><![CDATA[<p>向量和点的区别<br>向量的长度就是和000 点的距离<br>点积的几何意义与游戏中的应用<br>向量的单位向量，就是长度为1时的向量</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UNITY ECS 详解</title>
    <url>/unity-2020-10-15-unity-ecs/</url>
    <content><![CDATA[<p>DOTS面向数据栈编程</p>
<ul>
<li>ecs   在OOP方法中，数据不会被组织起来，而是会分散再整个内存中，这是因为使用了自动内存管理功能。</li>
<li>job system 传统只使用了单线程,配合ecs提供了多线程解决方案</li>
<li>brust compiler 将c#直接转换为汇编</li>
</ul>
<h1 id="ECS核心概念"><a href="#ECS核心概念" class="headerlink" title="ECS核心概念"></a>ECS核心概念</h1><p><img src="../../assets/images/2020-10-15-unity-ecs/ECSBlockDiagram.png" alt="img"></p>
<p>这个图中，System读取了多个实体的<code>Translation</code>和<code>Rotation</code>组件，然后经过计算处理，将结果更新到<code>LocalToWorld</code>组件中。</p>
<p>从图中你可以看到，实体A和B还有Renderer组件，但是C并没有。不过这并不会影响System的计算逻辑，因为这个系统不关心<code>Renderer</code>组件。</p>
<h2 id="原型-Archetypes"><a href="#原型-Archetypes" class="headerlink" title="原型 Archetypes"></a>原型 Archetypes</h2><p>多个组件的组合叫做一个原型。</p>
<p>比如一个3D物体可能会包含用于transform的组件，包括移动、旋转、渲染，每个3D物体对应一个实体，但是他们都有同样的组件，所以ECS会把他们分类成是一类原型。</p>
<p><img src="../../assets/images/2020-10-15-unity-ecs/ArchetypeDiagram.png" alt="img"></p>
<p>在上图中，实体A和B的原型都是M，实体C的原型是N。</p>
<p>你也可以通过在运行时添加或者移除component来改变一个实体的原型。例如：如果将实体B的Renderer组件移除，实体B的原型就会变成N。</p>
<p>一个实体的原型是什么，决定了ECS会将实体的components也就是数据存在什么地方。<strong>ECS按块分配内存，每块用一个<code>ArchetypeChunk</code>对象表示。</strong></p>
<p>一个块只包含一种原型，可以包含的多个实体的数据。如果一个块的内存满了，ECS会分配一个新的块来存储新的实体的components。</p>
<p>如果你修改了实体的组件，那就相当于修改了实体的原型，这时候ECS会将实体的组件数据移到另外一个块中。</p>
<p><img src="../../assets/images/2020-10-15-unity-ecs/ArchetypeChunkDiagram.png" alt="img"></p>
<p>原型和内存块的关系是一对多的关系。这就意味着，如果想查询给定的一组component类型的所有实体，只需要在这些原型中搜索即可。这样会比在所有的实体中查找效率高很多。</p>
<p>ECS在存储实体到内存块中没有特殊的排序，当创建一个实体或者实体的原型发生变化时，ECS会将它放到对应原型的第一个还有空间的内存块中。内存块中的数据会紧密排列。如果一个实体要被移出当前原型的内存块，这时候会有个空位，ECS会把这个内存块最后的实体数据移动到这个空位中。</p>
<p><strong>注意</strong>：原型中的<strong>共享组件</strong>（后面会具体说这是个什么东东）的数据也会影响实体会被存在哪个内存块。同一个内存块中的所有实体的共享组件中的数据值都是相同的。如果你修改了共享组件中的数据，这个实体会被移到另外一个块中，有点类似修改了实体的原型。</p>
<p>将共享组件的实体分到一个内存块中会提高处理他们的速度。比如Hybird Renderer（混合渲染）定义了RenderMesh组件来达成这个目的。</p>
<h2 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体 Entity"></a>实体 Entity</h2><p>在代码层面，你就可以了解到，实体非常非常的简单。它的核心部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Entity</span><br><span class="line">&#123;</span><br><span class="line">  public int Index;</span><br><span class="line">  public int Version; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Index表示这个实体的ID，和身份证一样用于实体与实体之间区分。Version用于描述这个实体的生命周期，由于实体是可以重用的，那么就需要用Version来区分这个Entity是新生实体，还是即将销毁的实体。</p>
<p>ECS中有一个<code>EntityManager</code>类来管理一个World中的所有实体。<code>EntityManager</code>使用列表维护所有实体以及和实体关联的数据，以便达到最优的性能。</p>
<p>虽然entity没有类型，但是可以根据entity关联的component将他们分组，也就是上一节讲的实体原型（EntityArchetype），EntityManager会持续跟踪这些实体原型。你可以使用已有的<code>EntityArchetype</code>来创建entity，也可以提前创建<code>EntityArchetype</code>，以便后面的使用。</p>
<h3 id="创建Entity"><a href="#创建Entity" class="headerlink" title="创建Entity"></a>创建Entity</h3><p>通过以下方法可以一次创建一个Entity：</p>
<ul>
<li>使用ComponentType的数组来创建一个entity</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateEntity(ComponentType[])</span><br></pre></td></tr></table></figure>

<ul>
<li>使用EntityArchetype来创建一个entity</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateEntity(EntityArchetype)</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>EntityManager.Instantiate</code>复制一个已有的entity，包括它里面的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.Instantiate(Entity srcEntity);</span><br><span class="line">EntityManager.Instantiate(NativeArray&lt;Entity&gt; srcEntities, NativeArray&lt;Entity&gt; outputEntities)</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以创建一个空的Entity，在需要的时候在加上components。(您可以立即添加组件，也可以根据需要添加其他组件。)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var entity &#x3D; EntityManager.CreateEntity();</span><br><span class="line">EntityManager.AddComponent(Entity entity, ComponentType componentType)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>你也可以通过下面的方法一次创建多个Entity：</p>
<ul>
<li>使用<code>CreateEntity</code>方法一次性填充多个新的Entity到一个NativeArry中，这些entity用同样的原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateEntity(EntityArchetype archetype, NativeArray&lt;Entity&gt; entities)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>Instantiate</code>方法一次性复制多个entity，包含数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.Instantiate(NativeArray&lt;Entity&gt; srcEntities, NativeArray&lt;Entity&gt; outputEntities)</span><br></pre></td></tr></table></figure>
<ul>
<li>显式创建使用指定数量的实体填充的块，并使用CreateChunk创建给定原型<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateChunk(EntityArchetype, NativeArray&lt;ArchetypeChunk&gt;, Int32)</span><br></pre></td></tr></table></figure>
<h3 id="添加-删除-component"><a href="#添加-删除-component" class="headerlink" title="添加/删除 component"></a>添加/删除 component</h3></li>
</ul>
<p>创建完Entity后，你可以添加或者移除component。注意添加或移除component时，entity的原型会发生变化，这时候EntityManager需要将entity移到其他内存块，并将当前内存块的空位补上。</p>
<p>对实体的更改导致结构性更改-会造成Entity原型变化的操作不能在Job里面执行，比如添加移除component、修改<code>SharedComponentData</code>中的值、销毁entity。你可以将前面说的这几种操作放进<code>EntityCommandBuffer</code>中，在job执行完成后执行这个command buffer。后面还会具体讲解CommandBuffer。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Lifetime : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public byte Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LifetimeSystem : SystemBase</span><br><span class="line">&#123;</span><br><span class="line">    EndSimulationEntityCommandBufferSystem m_EndSimulationEcbSystem;</span><br><span class="line">    protected override void OnCreate()</span><br><span class="line">    &#123;</span><br><span class="line">        base.OnCreate();</span><br><span class="line">        &#x2F;&#x2F; 从World中获取ECS系统并且存起来</span><br><span class="line">        m_EndSimulationEcbSystem &#x3D; World</span><br><span class="line">            .GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 请求一个ECB并且转换成可并行的</span><br><span class="line">        var ecb &#x3D; m_EndSimulationEcbSystem.CreateCommandBuffer().AsParallelWriter();</span><br><span class="line">        Entities</span><br><span class="line">            .ForEach((Entity entity, int entityInQueryIndex, ref Lifetime lifetime) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 检测entity的lifetime，如果为0则销毁它</span><br><span class="line">            if (lifetime.Value &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; 将entityInQueryIndex传给操作，这样ECS回放时能保证正确的顺序</span><br><span class="line">                ecb.DestroyEntity(entityInQueryIndex, entity);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                lifetime.Value -&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).ScheduleParallel();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 保证ECB system依赖当前这个Job</span><br><span class="line">        m_EndSimulationEcbSystem.AddJobHandleForProducer(this.Dependency);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EntityManager也提供了方法用来添加、移除单个entity中的组件，也可以移除一个entity的NativeArray中的组件。后面组件部分会详细说明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.AddComponent(Entity entity, ComponentType componentType)</span><br></pre></td></tr></table></figure>

<h3 id="访问实体数据"><a href="#访问实体数据" class="headerlink" title="访问实体数据"></a>访问实体数据</h3><p>遍历实体和组件最有效的方式时在一个并行化的Job中按顺序处理组件 . 这利用了CPU的多核性能，并避免CPU的缓存丢失</p>
<p>ECS API提供了多种遍历的方式，每个都有自己的性能影响和限制. 下面是方法:</p>
<h4 id="SystemBase-Entities-ForEach"><a href="#SystemBase-Entities-ForEach" class="headerlink" title="SystemBase.Entities.ForEach"></a><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.14/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities" target="_blank" rel="noopener">SystemBase.Entities.ForEach</a></h4><p>使用一个job结构来有效的遍历实体. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entities</span><br><span class="line">    .WithName(&quot;Update_Position&quot;) &#x2F;&#x2F; Shown in error messages and profiler</span><br><span class="line">    .WithAll&lt;LocalToWorld&gt;() &#x2F;&#x2F; Require the LocalToWorld component</span><br><span class="line">    .ForEach(</span><br><span class="line">        &#x2F;&#x2F; Write to Displacement (ref), read Velocity (in)</span><br><span class="line">        (ref Position position, in Velocity velocity) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;Execute for each selected entity</span><br><span class="line">            position &#x3D; new Position()</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; dT is a captured variable</span><br><span class="line">                Value &#x3D; position.Value + velocity.Value * dT</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    .ScheduleParallel(); &#x2F;&#x2F; Schedule as a parallel job</span><br></pre></td></tr></table></figure>
<p><strong>实体查询</strong></p>
<ul>
<li><strong><code>WithAll&lt;T&gt;</code></strong> — 一个实体必须具有所有这些组件类型 (除了在lambda参数列表中找到所有组件类型之外)</li>
<li><strong><code>WithAny&lt;T,U&gt;</code></strong> — 一个实体必须有一个或多个这样的组件类型.注意，允许使用WithAny指定单个组件类型;但是，由于实体必须有一个或多个这样的“可选”组件类型供查询选择，因此使用带有单个类型的WithAny等同于将该类型放在WithAll语句中。</li>
<li><strong><code>WithNone&lt;T&gt;</code></strong> — 实体不能具有任何这些组件类型</li>
<li><strong><code>WithChangeFilter&lt;T&gt;</code></strong> — 只选择子上次 <a href="https://docs.unity3d.com/Packages/com.unity.entities@0.6/api/Unity.Entities.JobComponentSystem.html" target="_blank" rel="noopener">JobComponentSystem</a> 更新以来，特性组件发生变化的实体</li>
<li><strong><code>WithSharedComponentFilter</code></strong> — 只选择拥有特定值的share component的块</li>
<li><strong><code>WithStoreEntityQueryInField</code></strong> — 把Entities.ForEach生成的 <a href="https://docs.unity3d.com/Packages/com.unity.entities@0.6/api/Unity.Entities.EntityQuery.html" target="_blank" rel="noopener">EntityQuery</a> 对象存储在一个 EntityQuery 字段里. 您可以使用这个EntityQuery对象用于获取符合条件的实体的数量.注意，这个函数在创建JobComponentSystem时将EntityQuery实例分配给您的字段. 这意味着您可以在第一次执行lambda函数之前使用查询。</li>
</ul>
<p>不要使用WithAny&lt;T、U&gt;或WithNone<T>向查询添加参数列表中的组件。所有添加到lambda函数参数列表中的组件都会自动添加到实体查询的WithAll列表中;向WithAll列表和WithAny或WithNone列表添加组件会创建一个不合逻辑的查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Entities.WithAll&lt;LocalToWorld&gt;()</span><br><span class="line">    .WithAny&lt;Rotation, Translation, Scale&gt;()</span><br><span class="line">    .WithNone&lt;LocalToParent&gt;()</span><br><span class="line">    .ForEach((ref Destination outputData, in Source inputData) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;* do some work *&#x2F;</span><br><span class="line">    &#125;)</span><br><span class="line">    .Schedule(inputDeps);</span><br><span class="line">    </span><br><span class="line">Entities</span><br><span class="line">    .WithChangeFilter&lt;Source&gt;()</span><br><span class="line">    .ForEach((ref Destination outputData,</span><br><span class="line">    in Source inputData) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    &#x2F;* Do work *&#x2F;</span><br><span class="line">    &#125;)</span><br><span class="line">    .Schedule(inputDeps);</span><br></pre></td></tr></table></figure>



<h4 id="IJobChunk"><a href="#IJobChunk" class="headerlink" title="IJobChunk"></a><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.14/manual/chunk_iteration_job.html" target="_blank" rel="noopener">IJobChunk</a></h4><p>遍历所有符合条件的内存块(called a <em>Chunk</em>)，其中包含的是符合条件的实体 . Job Execute() 方法可以用for循环遍历所有的块中的元素，你可以使用 IJobChunk 来执行比 IJobForEach更复杂的操作,同时保持最高效率.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">struct UpdateJob : IJobChunk</span><br><span class="line">&#123;</span><br><span class="line">    public ComponentTypeHandle&lt;InputA&gt; InputATypeHandle;</span><br><span class="line">    public ComponentTypeHandle&lt;InputB&gt; InputBTypeHandle;</span><br><span class="line">    [ReadOnly] public ComponentTypeHandle&lt;Output&gt; OutputTypeHandle;</span><br><span class="line">    public uint LastSystemVersion;</span><br><span class="line"></span><br><span class="line">    public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        var inputAChanged &#x3D; chunk.DidChange(InputATypeHandle, LastSystemVersion);</span><br><span class="line">        var inputBChanged &#x3D; chunk.DidChange(InputBTypeHandle, LastSystemVersion);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; If neither component changed, skip the current chunk</span><br><span class="line">        if (!(inputAChanged || inputBChanged))</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        var inputAs &#x3D; chunk.GetNativeArray(InputATypeHandle);</span><br><span class="line">        var inputBs &#x3D; chunk.GetNativeArray(InputBTypeHandle);</span><br><span class="line">        var outputs &#x3D; chunk.GetNativeArray(OutputTypeHandle);</span><br><span class="line"></span><br><span class="line">        for (var i &#x3D; 0; i &lt; outputs.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            outputs[i] &#x3D; new Output &#123; Value &#x3D; inputAs[i].Value + inputBs[i].Value &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Manual-iteration"><a href="#Manual-iteration" class="headerlink" title="Manual iteration"></a><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/manual_iteration.html" target="_blank" rel="noopener">Manual iteration</a></h4><p>如果以前的方法不足, 您可以手动遍历实体或块.例如，您可以获得一个包含实体的<code>NativeArray</code>，或者您想要处理的实体的块，使用Job(比如<code>IJobParallelFor</code>)对它们进行遍历。</p>
<p> <a href="https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/ecs_entity_query.html" target="_blank" rel="noopener">EntityQuery</a> 类提供了一个构造一个你数据的视图方法，这个视图仅仅包含你算法或者程序中需要的特定的数据. 上面列表中的许多遍历方法都使用EntityQuery，无论是显式的还是内部的。就是可以通过 <a href="https://docs.unity3d.com/Packages/com.unity.entities@0.1/manual/ecs_entity_query.html" target="_blank" rel="noopener">EntityQuery</a> 来只遍历符合条件的实体或组件</p>
<h2 id="系统-System"><a href="#系统-System" class="headerlink" title="系统 System"></a>系统 System</h2><h3 id="DisableAutoCreation"><a href="#DisableAutoCreation" class="headerlink" title="DisableAutoCreation"></a>DisableAutoCreation</h3><ul>
<li>如果只是单纯的createsystem,不会执行<code>OnStartRunning</code>,<code>OnStopRunning</code>,<code>OnUpdate</code>..但是会执行<code>OnCreate</code>,<code>OnDestroy</code></li>
<li><code>AddSystemToUpdateList</code> 且 Entities.ForEach中的query有结果才会执行<code>OnStartRunning</code>,<code>OnStopRunning</code>,<code>OnUpdate</code></li>
</ul>
<p>所以可以使用<code>DisableAutoCreation</code>,但不<code>AddSystemToUpdateList</code>添加到循环列表中,把一个system当作工具类使用 </p>
<h3 id="实体查询"><a href="#实体查询" class="headerlink" title="实体查询"></a>实体查询</h3><p>一个System根据什么来决定处理哪些实体呢？这时候会用到一个叫实体查询(Entity Query)的东西。实体查询首先需要一些组件类型，然后根据你传入的组件类型的组合，在包含这些组件的原型中查询符合要求的实体。查询时可以指定下面三种类型：</p>
<ul>
<li><strong>All</strong> 必须包含All中所有的组件类型</li>
<li><strong>Any</strong> 必须包含Any中至少一个组件类型</li>
<li><strong>None</strong> 不能包含None中任意一个组件类型</li>
</ul>
<p>一次实体查询的结果会返回所有符合查询要求的内存块，你可以使用<code>IJobChunk</code>来迭代遍历所有的组件</p>
<h3 id="Jobs-作业"><a href="#Jobs-作业" class="headerlink" title="Jobs 作业"></a>Jobs 作业</h3><p>之前说过，ECS配合Job使用才能发挥多线程的威力。ECS提供了<code>SystemBase</code>类，其中包含<code>Entities.ForEach</code>方法，还包含了<code>IJobChunk</code>的<code>Schedule()</code>和<code>ScheduleParallel()</code>方法，可以在子线程中处理数据。<code>Entities.ForEach</code>是最简单的方法，只需要几行代码就能实现。<code>IJobChunk</code>可以用来处理比较复杂的情况。</p>
<p>ECS会在主线程调度Job，根据System的顺序。当job调度后，ECS会追踪哪些job在读写哪些组件。需要读权限的job需要等待前面写权限的job执行完，反之亦然。Job调度器会使用job依赖来决定哪些job可以并行，哪些必须串行。</p>
<h3 id="System的组织"><a href="#System的组织" class="headerlink" title="System的组织"></a>System的组织</h3><p>ECS通过<code>World</code>和<code>group</code>来组织system。默认情况下，ECS会创建一个默认的World，包含一些预定义的group组。它会找到工程中所有的System，实例化他们，并添加到预定义的group中。</p>
<p>你可以指定同一个group中system的Update的执行顺序。Group也是一种system，所以你可以将一个group添加到另外一个group中。如果你没有指定顺序，system的执行顺序会不太确定，并不会按照它们创建的顺序。不过，同一个group中的所有system都会比下一个group中的system先执行。</p>
<p>System的Update是在主线程中执行的，不过可以使用Job将工作分配到子线程中。</p>
<h2 id="组件-Component"><a href="#组件-Component" class="headerlink" title="组件 Component"></a>组件 Component</h2><h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.14/manual/index.html" target="_blank" rel="noopener">Entity Component System 官方文档</a></li>
<li><a href="https://www.bilibili.com/video/BV1sD4y1Q7an" target="_blank" rel="noopener">DOTS从原理到应用</a></li>
<li><a href="https://www.bilibili.com/video/BV18J411t7G8" target="_blank" rel="noopener">Unity DOTS技术详解</a></li>
<li><a href="https://connect.unity.com/u/enthervarope/column" target="_blank" rel="noopener">Unity ECS简单示例</a></li>
<li><a href="https://blog.csdn.net/andrewfan/category_8967683.html" target="_blank" rel="noopener">Unity中的ECS编程</a></li>
<li><a href="https://blog.csdn.net/lrh3025/category_9668656.html" target="_blank" rel="noopener">Unity ECS_翻译</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>UNITY JOB SYSTEM详解</title>
    <url>/unity-2020-10-16-unity-job/</url>
    <content><![CDATA[<h1 id="创建Job"><a href="#创建Job" class="headerlink" title="创建Job"></a>创建Job</h1><p>创建Job需要定义一个结构体，实现<code>IJob</code>接口。实现了<code>IJob</code>接口之后，就可以让这个Job和其他Job并行运行了。</p>
<p>到这呢，就可以给Job一个真正的定义了：Job是一个统称，任何实现了<code>IJob</code>接口的结构体，都可以成为一个Job。</p>
<p>创建Job的步骤如下：<br> 1、创建一个实现<code>IJob</code>接口的结构体<br> 2、给结构体添加所需的成员变量，可以使用blittable类型或者NativeContainer类型。<br> 3、在结构体中添加一个Execute方法，具体执行的任务在这个方法里实现。</p>
<p>当执行Job时，Execute方法会在一个内核上执行完毕。</p>
<p>注意：设计job时，记住job操作的是数据的拷贝，除非使用<code>NativeContainer</code>。所以，在主线程访问job数据的唯一方法就是写入<code>NativeContainer</code>。</p>
<p>实例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个Job的功能：将两个浮点数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyJob</span> :</span> IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result[<span class="number">0</span>] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="调度Job"><a href="#调度Job" class="headerlink" title="调度Job"></a>调度Job</h1><p>创建Job后，如何执行一个Job呢？</p>
<p>这时候需要调度Job，调度Job的步骤如下：<br> 1、实例化Job<br> 2、构造Job的数据<br> 3、调用<code>Schedule</code>方法。</p>
<p>调用<code>Schedule</code>方法会将Job放到Job执行队列的适当位置。一旦安排了Job后，就不能再中断job执行了。</p>
<p><strong>注意</strong>：只能在主线程中调用<code>Schedule</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为1的native array用来存储job执行后的结果</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置job的数据</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Schedule</span></span><br><span class="line">JobHandle handle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待job执行完毕</span></span><br><span class="line">handle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取result中的数据</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一定要释放native array申请的内存</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>

<h1 id="Job的依赖关系"><a href="#Job的依赖关系" class="headerlink" title="Job的依赖关系"></a>Job的依赖关系</h1><p>很多时候，Job并不是独立运行的，需要依赖前一个Job的结果，这时候如何调度呢？</p>
<h2 id="JobHandle"><a href="#JobHandle" class="headerlink" title="JobHandle"></a>JobHandle</h2><p>当调用<code>Schedule</code>方法时，会返回一个<code>JobHandle</code>。你可以使用这个<code>JobHandle</code>作为其他job的依赖项。具体方法就是将第一个job的<code>JobHandle</code>传给第二个job调用<code>Schedule</code>时的参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JobHandle firstJobHandle &#x3D; firstJob.Schedule();</span><br><span class="line">secondJob.Schedule(firstJobHandle);</span><br></pre></td></tr></table></figure>

<p>那如果一个job有多个依赖项怎么办呢？这时候可以用<code>JobHandle.CombineDependencies</code>方法合并他们。具体如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个JobHandle的NativeArray数组</span></span><br><span class="line">NativeArray&lt;JobHandle&gt; handles = <span class="keyword">new</span> NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将多个handles放到数组中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将多个handles合并到一起</span></span><br><span class="line">JobHandle jh = JobHandle.CombineDependencies(handles);</span><br></pre></td></tr></table></figure>

<h1 id="等待Job执行完毕"><a href="#等待Job执行完毕" class="headerlink" title="等待Job执行完毕"></a>等待Job执行完毕</h1><p>在主线程中如何等待Job执行完毕呢？可以调用<code>JobHandle</code>中的<code>Complete</code>方法强制等待。<code>Complete</code>方法执行过后，你就可以在主线程中安全地访问job中使用的<code>NativeContainer</code>了。</p>
<p><strong>注意</strong><br> 当你调用job的Schedule方法后，job并不会立即开始执行。如果你在主线程中等待job执行完毕，并且你需要访问job使用的NativeContainer中的数据时，你可以调用<code>JobHandle.Complete</code>方法。这个方法会启动job的执行。调用JobHandle的Complete方法后，会将job的NativeContainer所有权还给主线程。所以只有调用过JobHandle上的Complete方法后，主线程才能安全的访问NativeContainer中的数据。同理，也可以调用依赖此job的JobHandle上的Complete方法。例如，你可以调用jobA的Complete方法，也可以调用依赖jobA的JobB的Complete方法。这两种情况下，主线程都可以安全访问jobA使用的NativeContainer。</p>
<h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><p>Job代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Job：两个浮点数相加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyJob</span> :</span> IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result[<span class="number">0</span>] = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Job：给一个值加一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddOneJob</span> :</span> IJob</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> NativeArray&lt;<span class="keyword">float</span>&gt; result;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result[<span class="number">0</span>] = result[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建存储结果的NativeArray</span></span><br><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; result = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置job #1</span></span><br><span class="line">MyJob jobData = <span class="keyword">new</span> MyJob();</span><br><span class="line">jobData.a = <span class="number">10</span>;</span><br><span class="line">jobData.b = <span class="number">10</span>;</span><br><span class="line">jobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度job1</span></span><br><span class="line">JobHandle firstHandle = jobData.Schedule();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置job2</span></span><br><span class="line">AddOneJob incJobData = <span class="keyword">new</span> AddOneJob();</span><br><span class="line">incJobData.result = result;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度 job2，依赖job1</span></span><br><span class="line">JobHandle secondHandle = incJobData.Schedule(firstHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待job2执行完毕</span></span><br><span class="line">secondHandle.Complete();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问结果</span></span><br><span class="line"><span class="keyword">float</span> aPlusB = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line">result.Dispose();</span><br></pre></td></tr></table></figure>









<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ul>
<li><a href="https://docs.unity3d.com/cn/2020.2/Manual/JobSystem.html" target="_blank" rel="noopener">C# 作业系统 - Unity 手册 (unity3d.com)</a></li>
<li><a href="https://mp.weixin.qq.com/s/ZOVzDZQYBkfs6gAdrTMJUA" target="_blank" rel="noopener">Job System介绍</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjQ1NTEwOA==&mid=2247495224&idx=1&sn=6da0b515c54aee71ae64166369ae2320&chksm=fe1dda93c96a53851da09775d9c4a8947a26b26dfdc4aba2775685efee3451c026a8d353a851&mpshare=1&scene=23&srcid=1026M4Dnvzb65VokHexArRV2#rd" target="_blank" rel="noopener">深入解读Job System（1） </a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU5MjQ1NTEwOA==&mid=2247495225&idx=1&sn=8c7212a747704da0b85d364529464509&chksm=fe1dda92c96a53848bca7cf95731ce8a9c853c80a4d3e7aa3f249c87d3a50620f30ce85254d6&mpshare=1&scene=23&srcid=1026HlBykd8qHTStfScE4ION#rd" target="_blank" rel="noopener">深入解读Job system（2）</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>运行时打包图集</title>
    <url>/unity-2020-10-17-runtime-spriteatlas/</url>
    <content><![CDATA[<p>不管NGUI还是UGUI，图集都是在制作期间就生成了的，运行时是一张大图，这样做的好处在于我们可以在一定程度上去合并批次，但是图集通常在制作过程中，会分成commonatlas和系统atlas两类，一个界面prefab至少会用到两张图集，就会出现ABA的图集穿插打断合批的情况。还有一种游戏内容多了以后，各种图片也相应的变多，类似图标、commonatlas这种图集，一张2048x2048可能就放不下了，这时候如果用到两张2048x2048，就又出现了之前说的ABA的情况，而且内存上也上去了。这时候就出现了新的解决方案：动态图集。</p>
<p>动态图集其实就是我们在打包的时候，图片是零散的，但是最后运行时，自动生成一张空白大图片，然后将界面上用到的零散的图片绘制在这个大图上，只将这个大图传入到gpu里头，达到合批的效果。由于手机界面制作过程中，标准分辨率往往是低于2048的，所以一张2048的动态图集就能完全解决一个界面的绘制工作了，但是动态图集也是有缺点的，动态图集因为将图集的生成过程延迟到了游戏运行时，所以必然会比静态图集多了图集生成的成本，当然这也是可以优化的。并且在目前的动态图集生成方案中，还没有出现公开的支持压缩的动态图集解决方案，所以动态图集目前看来只能是RGBA32的格式。还有一点，静态图集由于图片在生成过程中是确定的，可以将分配算法做得很好，图集的利用率也能做到很高。动态图集由于图片是动态生成的，在游戏运行过程中也会动态的增减图片，类似操作系统的内存分配算法，图集必然会出现碎片，图集的利用率也不可能做得很高。</p>
<p>说了那么多 就做个demo来看看动态图集的威力吧。</p>
<p>这个demo只是简单的演示一下动态图集的主要思路，图片分配算法也只是将大图片分成128x128的一个一个分区，每个分区采用引用计数开控制是否在使用图片，用于维护整个UI系统的话，这种算法并不适用，但是如果只是用于icon图标的话，由于icon图标是固定尺寸的，所以这套算法就很合适了。下面上源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"> </span><br><span class="line">public class NxSpriteInfo</span><br><span class="line">&#123;</span><br><span class="line">    private int _x;</span><br><span class="line">    private int _y;</span><br><span class="line">    private Sprite _sprite;</span><br><span class="line">    private int _referenceCount;</span><br><span class="line"> </span><br><span class="line">    private int _width;</span><br><span class="line">    private int _height;</span><br><span class="line"> </span><br><span class="line">    public int x &#123; get &#123; return _x; &#125; &#125;</span><br><span class="line">    public int y &#123; get &#123; return _y; &#125; &#125;</span><br><span class="line"> </span><br><span class="line">    public Sprite sprite</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return _sprite; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public NxSpriteInfo(int x, int y, Texture2D mainTexture, int startX, int startY, int width, int height)</span><br><span class="line">    &#123;</span><br><span class="line">        _x &#x3D; x;</span><br><span class="line">        _y &#x3D; y;</span><br><span class="line">        _referenceCount &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">        _width &#x3D; width;</span><br><span class="line">        _height &#x3D; height;</span><br><span class="line"> </span><br><span class="line">        _sprite &#x3D; Sprite.Create(mainTexture, new Rect(startX, startY, width, height), Vector2.one &#x2F; 2f);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public bool IsEmpty()</span><br><span class="line">    &#123;</span><br><span class="line">        return _referenceCount &#x3D;&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void AddReference()</span><br><span class="line">    &#123;</span><br><span class="line">        ++_referenceCount;</span><br><span class="line">        Debug.Log(string.Format(&quot;[AddReference]Sprite:[&#123;0&#125;,&#123;1&#125;] ref:&#123;2&#125;&quot;, x, y, _referenceCount));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void RemoveReference()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_referenceCount &#x3D;&#x3D; 0) return;</span><br><span class="line">        --_referenceCount;</span><br><span class="line"> </span><br><span class="line">        Debug.Log(string.Format(&quot;[RemoveReference]Sprite:[&#123;0&#125;,&#123;1&#125;] ref:&#123;2&#125;&quot;, x, y, _referenceCount));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class DynamicAtlas : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private const int MAX_DYNAMIC_ATLAS_SIZE &#x3D; 1024;</span><br><span class="line">    private const int DYNAMIC_ATLAS_CELL_SIZE &#x3D; 128;</span><br><span class="line">    private const int DYNAMIC_ATLAS_CELL_COUNT &#x3D; MAX_DYNAMIC_ATLAS_SIZE &#x2F; DYNAMIC_ATLAS_CELL_SIZE;</span><br><span class="line"> </span><br><span class="line">    [SerializeField]</span><br><span class="line">    private Texture2D _dynamicAtlasTex;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 策略 分成格子</span><br><span class="line">    private List&lt;NxSpriteInfo&gt; _spriteCacheList;</span><br><span class="line">    private Dictionary&lt;int, int&gt; _spriteRedirectMap &#x3D; new Dictionary&lt;int, int&gt;();</span><br><span class="line"> </span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        _dynamicAtlasTex &#x3D; new Texture2D(MAX_DYNAMIC_ATLAS_SIZE, MAX_DYNAMIC_ATLAS_SIZE, TextureFormat.RGBA32, false);</span><br><span class="line">        _initCacheSprite();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private void _initCacheSprite()</span><br><span class="line">    &#123;</span><br><span class="line">        int cellCount &#x3D; DYNAMIC_ATLAS_CELL_COUNT;</span><br><span class="line"> </span><br><span class="line">        _spriteCacheList &#x3D; new List&lt;NxSpriteInfo&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; cellCount; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; cellCount; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                _spriteCacheList.Add(new NxSpriteInfo(i, j, </span><br><span class="line">                    _dynamicAtlasTex,</span><br><span class="line">                    i * DYNAMIC_ATLAS_CELL_SIZE, j * DYNAMIC_ATLAS_CELL_SIZE,</span><br><span class="line">                    DYNAMIC_ATLAS_CELL_SIZE, DYNAMIC_ATLAS_CELL_SIZE));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Sprite GetOrLoadSprite(Sprite sprite)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 拿缓存</span><br><span class="line">        var spriteInstanceID &#x3D; sprite.GetInstanceID();</span><br><span class="line">        &#x2F;&#x2F;Debug.Log(string.Format(&quot; name: &#123;0&#125; instanceid: &#123;1&#125;&quot;, sprite.name, spriteInstanceID));</span><br><span class="line">        int index &#x3D; -1;</span><br><span class="line">        if (_spriteRedirectMap.TryGetValue(spriteInstanceID, out index))</span><br><span class="line">        &#123;</span><br><span class="line">            var newSprite &#x3D; _spriteCacheList[index];</span><br><span class="line">            newSprite.AddReference();</span><br><span class="line">            return newSprite.sprite;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 检查是不是本身就是动态生成的 如果是的话 什么都不用做</span><br><span class="line">        for (int i &#x3D; 0; i &lt; _spriteCacheList.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            var sp &#x3D; _spriteCacheList[i];</span><br><span class="line">            if (sp.sprite &#x3D;&#x3D; sprite)</span><br><span class="line">            &#123;</span><br><span class="line">                return sprite;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 拿不到缓存就找个空格子新增</span><br><span class="line">        var emptySprite &#x3D; GetEmptySprite();</span><br><span class="line">        if (emptySprite !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; GPU上直接操作 速度快 兼容性差</span><br><span class="line">            Graphics.CopyTexture(sprite.texture, 0, 0, (int)sprite.rect.x, (int)sprite.rect.y, (int)sprite.rect.width, (int)sprite.rect.height,</span><br><span class="line">                                _dynamicAtlasTex, 0, 0, (int)emptySprite.sprite.rect.x, (int)emptySprite.sprite.rect.y);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 这里要先删除上一个的</span><br><span class="line">            index &#x3D; GetIndex(emptySprite);</span><br><span class="line">            foreach (var redirect in _spriteRedirectMap)</span><br><span class="line">            &#123;</span><br><span class="line">                if (redirect.Value &#x3D;&#x3D; index)</span><br><span class="line">                &#123;</span><br><span class="line">                    _spriteRedirectMap.Remove(redirect.Key);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _spriteRedirectMap.Add(spriteInstanceID, GetIndex(emptySprite));</span><br><span class="line">            emptySprite.AddReference();</span><br><span class="line">            emptySprite.sprite.name &#x3D; sprite.name + &quot;(Dynamic)&quot;;</span><br><span class="line">            return emptySprite.sprite;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 找不到空格子就直接返回sprite</span><br><span class="line">        return sprite;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void ReleaseSprite(Sprite sprite)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; _spriteCacheList.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            var sp &#x3D; _spriteCacheList[i];</span><br><span class="line">            if (sp.sprite &#x3D;&#x3D; sprite)</span><br><span class="line">            &#123;</span><br><span class="line">                sp.RemoveReference();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private NxSpriteInfo GetEmptySprite()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; _spriteCacheList.Count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            var sp &#x3D; _spriteCacheList[i];</span><br><span class="line">            if (sp.IsEmpty())</span><br><span class="line">                return sp;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private int GetIndex(NxSpriteInfo sprite)</span><br><span class="line">    &#123;</span><br><span class="line">        return sprite.x * DYNAMIC_ATLAS_CELL_COUNT + sprite.y;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码都在GetOrLoadSprite这个函数里面了，其中最重要的一句就是Graphics.CopyTexture，这个是直接在GPU上操作图片，速度非常快，但是缺点是兼容性不是很好，也用备用方案，直接上内存copy再传到gpu上，会慢一些，demo这里就不做演示了，需要的自行查相关资料，我记得雨松似乎做过类似分享，当时应该是用于角色的贴图合并。</p>
<p>另外配合这个DynamicAtlas，我也做了一个NxImage来配合它，简单继承了一下ugui的image，在awake和ondestory做了引用计数的加减，只是用于功能演示，真正用到项目中，应该会更加注重细节。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"> </span><br><span class="line">public class NxImage : Image</span><br><span class="line">&#123;</span><br><span class="line">    protected override void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        base.Start();</span><br><span class="line"> </span><br><span class="line">        if (Application.isPlaying &amp;&amp; this.sprite !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            var dynamicAtlasGo &#x3D; GameObject.Find(&quot;DynamicAtlas&quot;);</span><br><span class="line">            if (dynamicAtlasGo &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                GameObject go &#x3D; new GameObject();</span><br><span class="line">                go.name &#x3D; &quot;DynamicAtlas&quot;;</span><br><span class="line">                go.AddComponent&lt;DynamicAtlas&gt;();</span><br><span class="line">                dynamicAtlasGo &#x3D; go;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            if (dynamicAtlasGo !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                var dynamicAtlas &#x3D; dynamicAtlasGo.GetComponent&lt;DynamicAtlas&gt;();</span><br><span class="line">                if (dynamicAtlas !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.sprite &#x3D; dynamicAtlas.GetOrLoadSprite(this.sprite);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void SetNewSprite(Sprite sp)</span><br><span class="line">    &#123;</span><br><span class="line">        var dynamicAtlasGo &#x3D; GameObject.Find(&quot;DynamicAtlas&quot;);</span><br><span class="line">        if (dynamicAtlasGo !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            var dynamicAtlas &#x3D; dynamicAtlasGo.GetComponent&lt;DynamicAtlas&gt;();</span><br><span class="line">            if (dynamicAtlas !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                if (this.sprite !&#x3D; null)</span><br><span class="line">                    dynamicAtlas.ReleaseSprite(this.sprite);</span><br><span class="line">                this.sprite &#x3D; dynamicAtlas.GetOrLoadSprite(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected override void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        base.OnDestroy();</span><br><span class="line"> </span><br><span class="line">        if (this.sprite !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            var dynamicAtlasGo &#x3D; GameObject.Find(&quot;DynamicAtlas&quot;);</span><br><span class="line">            if (dynamicAtlasGo !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                var dynamicAtlas &#x3D; dynamicAtlasGo.GetComponent&lt;DynamicAtlas&gt;();</span><br><span class="line">                if (dynamicAtlas !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    dynamicAtlas.ReleaseSprite(this.sprite);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单挂了几个图片上去测试，效果如下：</p>
<p><img src="../../assets/images/2020-10-17-runtime-spriteatlas/20190531235426813.png" alt="img"></p>
<p>运行后：</p>
<p><img src="../../assets/images/2020-10-17-runtime-spriteatlas/20190531235500426.png" alt="img"></p>
<p>可以看到drawcall明显降低了，我们再看看合并后真正用到的图片：</p>
<p><img src="../../assets/images/2020-10-17-runtime-spriteatlas/20190531235616604.png" alt="img"></p>
<p><img src="../../assets/images/2020-10-17-runtime-spriteatlas/20190531235636594.png" alt="img"></p>
<p>以上就是动态生成图集的简单思路 仅供参考</p>
<ul>
<li><a href="https://github.com/DaVikingCode/UnityRuntimeSpriteSheetsGenerator" target="_blank" rel="noopener">DaVikingCode/UnityRuntimeSpriteSheetsGenerator: Unity – generate SpriteSheets at runtime! (github.com)</a></li>
<li><a href="https://github.com/jintiao/RuntimeTextureAtlas" target="_blank" rel="noopener">jintiao/RuntimeTextureAtlas: runtime texture atlas (github.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>unity ecs component</title>
    <url>/unity-2020-10-18-unity-ecs-component/</url>
    <content><![CDATA[<ul>
<li>General Purpose Component</li>
<li>Shared component data    不存储在chunk中,而是存储在sharedComponentManager,而chunk中存的是索引.. 若ForEach中包含了Share Component，那么必须调用WithoutBurst方法和使用Run来执行</li>
<li>Chunk component data    相当于单例…更改后,会更改所有相关实体</li>
<li>System State Components  类似一个标记..但是实体销毁时,并不会回收entity,只有当所有satecomponent移除后</li>
<li>Dynamic buffer components    可以理解为一个数组component</li>
</ul>
<h2 id="General-Purpose-Component（普通用途组件）"><a href="#General-Purpose-Component（普通用途组件）" class="headerlink" title="General Purpose Component（普通用途组件）"></a>General Purpose Component（普通用途组件）</h2><p>这里指的是最普通的组件，可以通过实现 <code>IComponentData</code> 接口来创建。</p>
<p><code>IComponentData</code> 不存储行为，只储存数据。<code>IComponentData</code> 还是一个结构体（Struct）而不是一个类（Class），这意味着被复制时默认是通过值而不是通过引用。</p>
<p>通常我们会用下面的<strong>模式</strong>来修改组件数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var transform &#x3D; group.transform[index]; &#x2F;&#x2F; Read</span><br><span class="line">    </span><br><span class="line">transform.heading &#x3D; playerInput.move; &#x2F;&#x2F; Modify</span><br><span class="line">transform.position +&#x3D; deltaTime * playerInput.move * settings.playerMoveSpeed;</span><br><span class="line"></span><br><span class="line">group.transform[index] &#x3D; transform; &#x2F;&#x2F; Write</span><br></pre></td></tr></table></figure>

<p><code>IComponentData</code> 结构不包含托管对象（managed objects）的引用，所有<code>IComponentData</code> 被存在无垃圾回收的<a href="https://docs.unity3d.com/Packages/com.unity.entities@0.0/manual/chunk_iteration.html" target="_blank" rel="noopener">块内存（chunk memory）</a>中。</p>
<p>你可能还听过一种组件是不包含数据、只用来标记的“Tag”组件（Tag component），其用途也很广，例如我们可以轻易地给实体加标记来区分玩家和敌人，这样系统中能更容易通过组件的类型来筛选我们想要的实体。如果我们给一个内存块（Chunk）中的所有实体都添加”Tag“组件的话，只有内存块中对应的原型会修改，不添加数据，因此官方也推荐利用好”Tag“组件。</p>
<p>See file: /Packages/com.unity.entities/Unity.Entities/IComponentData.cs.</p>
<h2 id="Shared-components（共享组件）"><a href="#Shared-components（共享组件）" class="headerlink" title="Shared components（共享组件）"></a>Shared components（共享组件）</h2><p>Shared components 是一种特殊的组件，你可以把某些特殊的需要共享的值放到 shared component 中，从而在实体中与其他组件划分开。例如有时候我们的实体需要共享一套材质，我们可以为需要共享的材质创建 <code>Rendering.RenderMesh</code>，再放到 shared components 中。原型中也可以定义 shared components，这一点和其他组件是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[System.Serializable]</span><br><span class="line">public struct RenderMesh : ISharedComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public Mesh                 mesh;</span><br><span class="line">    public Material             material;</span><br><span class="line"></span><br><span class="line">    public ShadowCastingMode    castShadows;</span><br><span class="line">    public bool                 receiveShadows;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你为一个实体添加一个 shared components 时， <code>EntityManager</code> 会把所有带有同样 shared components 的实体放到一个同样的内存块中（Chunks）。shared components 允许我们的系统去一并处理相似的（有同样 shared components 的）实体。</p>
<h3 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h3><p><img src="../../assets/images/2020-10-18-unity-ecs-component/5d295d398f62598876.png" alt="img"></p>
<p>每个内存块（Chunk）会有一个存放 shared components 索引的数组。这句话包含了几个要点：</p>
<ol>
<li>对于实体来说，有同样 <code>SharedComponentData</code> 的实体会被一起放到同样的内存块（Chunk）中。</li>
<li>如果我们有两个存储在同样的内存块中的两个实体，它们有同样的 <code>SharedComponentData</code> 类型和值。我们修改其中一个实体的 <code>SharedComponentData</code> 的值，这样会导致这个实体会被移动到一个新的内存块中，因为一个内存块共享同一个数组的 <code>SharedComponentData</code> 索引。事实上，从一个实体中增加或者移除一个组件，或者改变 shared components 的值都会导致这种操作的发生。</li>
<li>其索引存储在内存块而非实体中，因此 <code>SharedComponentData</code> 对实体来说是低开销的。</li>
<li>因为内存块只需要存其索引，<code>SharedComponentData</code> 的内存消耗几乎可以忽略不计。</li>
</ol>
<p>因为上面的第二个要点，我们不能滥用 shared components。滥用 shared components 将让 Unity 不能利用好内存块（Chunk），因此我们要避免添加不必要的数据或修改数据到 shared components 中。我们可以通过 Entity Debugger 来监测内存块的利用。</p>
<p><img src="../../assets/images/2020-10-18-unity-ecs-component/5d295b6d78b7f51832.png" alt="img"></p>
<p>拿上一段 RenderMesh 的例子来说，共享材质会更有效率，因为 shared components 有其自己的 <code>manager</code> 和哈希表。其中 <code>manager</code> 带有一个存储 shared components 数据的自由列表（<a href="https://zh.wikipedia.org/wiki/自由表" target="_blank" rel="noopener">freelist</a>），哈希表可以快速地找到相应的值。内存块里面存的是索引数组，需要找数据的时候就会从 Shared Component Manager 中找。</p>
<h3 id="其他要点"><a href="#其他要点" class="headerlink" title="其他要点"></a>其他要点</h3><ul>
<li><code>EntityQuery</code> 可以迭代所有拥有相同 <code>SharedComponentData</code> 的实体</li>
<li>我们可以用 <code>EntityQuery.SetFilter()</code> 来迭代所有拥有某个特定 <code>SharedComponentData</code> 的实体。这种操作开销十分低，因为 <code>SetFilter</code> 内部筛选的只是 int 的索引。前面说了每个内存块都有一个<code>SharedComponentData</code> 索引数组，因此对于每个内存块来说，筛选（filtering）的消耗都是可以忽略不计的。</li>
<li>怎么样获取 <code>SharedComponentData</code> 的值呢？<code>EntityManager.GetAllUniqueSharedComponentData&lt;T&gt;</code> 可以得到在存活的实体中（alive entities）的所有的泛型 T 类型的<code>SharedComponentData</code> 值，结果以参数中的列表返回，你也可以通过其重载的方法获得所有值的索引。其他获取值的方法可以参考 /Packages/com.unity.entities/Unity.Entities/EntityManagerAccessComponentData.cs。</li>
<li><code>SharedComponentData</code> 是自动引用计数的，例如在没有任何内存块拥有某个<code>SharedComponentData</code> 索引的时候，引用计数会置零，从而知道要删除<code>SharedComponentData</code> 的数据 。这一点就能看出其在 ECS 的世界中是非常独特的存在，想要深入了解可以看这篇文章<a href="https://gametorrahod.com/everything-about-isharedcomponentdata/" target="_blank" rel="noopener">《Everything about ISharedComponentData》</a>。</li>
<li><code>SharedComponentData</code> 应该尽量不去更改，因为更改 <code>SharedComponentData</code> 会导致实体的组件数据需要复制到其他的内存块中。</li>
</ul>
<p>你也可以读读这篇更深入的文章<a href="https://gametorrahod.com/everything-about-isharedcomponentdata/" target="_blank" rel="noopener">《Everything about ISharedComponentData》</a>。</p>
<h2 id="System-state-components（系统状态组件）"><a href="#System-state-components（系统状态组件）" class="headerlink" title="System state components（系统状态组件）"></a>System state components（系统状态组件）</h2><p><code>SystemStateComponentData</code> 允许你跟踪系统（System）的资源，并允许你合适地创建和删除某些资源，这些过程中不依赖独立的回调（individual callback）。</p>
<blockquote>
<p>假设有一个网络同步 System State，其监控一个 Component A 的同步，则我只需要定义一个 SystemStateComponent SA。当 Entity [有 A，无 SA] 时，表示 A 刚添加，此时添加 SA。等到 Entity [无 A，有 SA] 时,表示 A 被删除（尝试销毁Entity 时也会删除 A）。<br><a href="https://zhuanlan.zhihu.com/p/51289405" target="_blank" rel="noopener">《浅入浅出Unity ECS》</a> BenzzZX</p>
</blockquote>
<p><code>SystemStateComponentData</code> 和 <code>SystemStateSharedComponentData</code> 这两个类型与 <code>ComponentData</code> 和 <code>SharedComponentData</code> 十分相似，不同的是前者两个类型都是系统级别的，不会在实体删除的时候被删除。</p>
<h3 id="Motivation（诱因）"><a href="#Motivation（诱因）" class="headerlink" title="Motivation（诱因）"></a>Motivation（诱因）</h3><p>System state components 有这样特殊的行为，是因为：</p>
<ul>
<li>系统可能需要保持一个基于 <code>ComponentData</code> 的内部状态。例如已经被分配的资源。</li>
<li>系统需要通过值来管理这些状态，也需要管理其他系统所造成的的状态改变。例如在组件中的值改变的时候，或者在相关组件被添加或者被删除的时候。</li>
<li>“没有回调”是 ECS 设计规则的重要元素。</li>
</ul>
<h3 id="Concept（概念）"><a href="#Concept（概念）" class="headerlink" title="Concept（概念）"></a>Concept（概念）</h3><p><code>SystemStateComponentData</code> 普遍用法是镜像一个用户组件，并提供内部状态。</p>
<p>上面引用的网络同步的例子中，A 就是用户分配的 <code>ComponentData</code>，SA 就是系统分配的 <code>SystemComponentData</code>。</p>
<p>下面以 FooComponent （<code>ComponentData</code>）和 FooStateComponent（<code>SystemComponentData</code>）做主要用途的示例。前两个用途已经在前面的网络同步例子中呈现过。</p>
<h4 id="检测组件的添加"><a href="#检测组件的添加" class="headerlink" title="检测组件的添加"></a>检测组件的添加</h4><p>如果用户添加 FooComponent 时，FooStateComponent 还不存在。FooSystem 会在 update 中查询，如果实体只有 FooComponent 而没有 FooStateComponent,，则可以判断这个实体是新添加的。这时候 FooSystem 会加上 FooStateComponent 组件和其他需要的内部状态。</p>
<h4 id="检测组件的删除"><a href="#检测组件的删除" class="headerlink" title="检测组件的删除"></a>检测组件的删除</h4><p>如果用户删除 FooComponent 后，FooStateComponent 仍然存在。FooSystem 会在 update 中查询，如果实体没有 FooComponent 而有 FooStateComponent,，则可以判断 FooComponent 已经被删除了。这时候 FooSystem 会给删除 FooStateComponent 组件和修改其他需要的内部状态。</p>
<h4 id="监测实体的删除"><a href="#监测实体的删除" class="headerlink" title="监测实体的删除"></a>监测实体的删除</h4><p>通常 <code>DestroyEntity</code> 这个方法可以用来：</p>
<ol>
<li>找到所有由某个实体 ID 标记的所有组件</li>
<li>删除那些组件</li>
<li>回收实体 ID 以作重用</li>
</ol>
<p>然而，<code>DestroyEntity</code> 无法删除 <code>SystemStateComponentData</code> 。</p>
<p>在你删除实体时，<code>EntityManager</code> <strong>不会</strong>移除任何 system state components，在它们没被删除的时候，<code>EntityManager</code> 也不会回收其实体的 ID 。这样允许系统（System）在一个实体被删除的时候，去整理内部的状态（internal state），也能清理关联着实体 ID 的相关的资源和状态。实体 ID 只会在所有 <code>SystemStateComponentData</code> 被删除的时候才被重用。</p>
<h2 id="Dynamic-Buffers（动态缓冲）"><a href="#Dynamic-Buffers（动态缓冲）" class="headerlink" title="Dynamic Buffers（动态缓冲）"></a>Dynamic Buffers（动态缓冲）</h2><p><code>DynamicBuffer</code> 也是组件的一种类型，它能把一个变量内存空间大小的弹性的缓冲（variable-sized, “stretchy” buffer）和一个实体关联起来。它内部存储着一定数量的元素，但如果内部所占内存空间太大，会额外划分一个堆内存（heap memory）来存储。</p>
<p>动态缓冲的内存管理是全自动的。与 <code>DynamicBuffer</code> 关联的内存由 <code>EntityManager</code> 来管理，这样当<code>DynamicBuffer</code> 组件被删除的时候，所关联的堆内存空间也会自动释放掉。</p>
<p>上面的解释可能略显苍白，实际上 <code>DynamicBuffer</code> 可以看成一个有默认大小的数组，其行为和性能都和 <code>NativeArray</code>（在 ECS 中常用的无 GC 容器类型）差不多，但是存储数据超过默认大小也没关系，上文提到了会创建一个堆内存来存储多的数据。<code>DynamicBuffer</code> 可以通过 <code>ToNativeArray</code> 转成 <code>NativeArray</code> 类型，其中只是把指针重新指向缓冲，不会复制数据。</p>
<p><a href="http://tsubakit1.hateblo.jp/entry/2018/11/07/234502" target="_blank" rel="noopener">【Unity】ECSで配列を格納する Dynamic Buffers</a> 这篇文章中，作者用<code>DynamicBuffer</code> 来储存临近的圆柱体实体，从而更方便地与这些实体交互。</p>
<h3 id="定义缓冲"><a href="#定义缓冲" class="headerlink" title="定义缓冲"></a>定义缓冲</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 8 指的是缓冲中默认元素的数量，例如这例子中存的是 Integer 类型</span><br><span class="line">&#x2F;&#x2F; 那么 8 integers （32 bytes）就是缓冲的默认大小</span><br><span class="line">&#x2F;&#x2F; 64 位机器中则占 16 bytes</span><br><span class="line">[InternalBufferCapacity(8)]</span><br><span class="line">public struct MyBufferElement : IBufferElementData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 下面的隐式转换是可选的，这样可以少写些代码</span><br><span class="line">    public static implicit operator int(MyBufferElement e) &#123; return e.Value; &#125;</span><br><span class="line">    public static implicit operator MyBufferElement(int e) &#123; return new MyBufferElement &#123; Value &#x3D; e &#125;; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每个缓冲元素要存储的值</span><br><span class="line">    public int Value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能有点奇怪，我们要定义缓冲中元素的结构而不是 <code>Buffer</code> 缓冲本身，其实这样在 ECS 中有两个好处：</p>
<ol>
<li>对于 <code>float3</code> 或者其他常见的值类型来说，这样能支持多种 <code>DynamicBuffer</code> 。我们可以重用已有的缓冲元素的结构，来定义其他的 <code>Buffers</code>。</li>
<li>我们可以将 <code>Buffer</code> 的元素类型包含在 <code>EntityArchetypes</code> 中，这样它会表现得像拥有一个组件一样。例如用 <code>AddBuffer()</code> 方法，可以通过 <code>entityManager.AddBuffer&lt;MyBufferElement&gt;(entity);</code> 来添加缓冲。</li>
</ol>
<h2 id="关于prefab到entity"><a href="#关于prefab到entity" class="headerlink" title="关于prefab到entity"></a>关于prefab到entity</h2><ul>
<li><code>IDeclareReferencedPrefabs</code> ： 将prefab引用添加到Conversion World。在<code>IConvertGameObjectToEntity</code>中可以通过GameObjectConversionSystem根据prefab获取entity</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareReferencedPrefabs</span><span class="params">(List&lt;GameObject&gt; referencedPrefabs)</span> </span>=&gt; referencedPrefabs.Add(Prefab);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>IConvertGameObjectToEntity</code>：自动生成一个新的entity，然后自定义对entity的操作。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span><span class="params">(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dstManager.AddComponentData(entity, <span class="keyword">new</span> PeriodicSpawner</span><br><span class="line">        &#123;</span><br><span class="line">            Prefab = conversionSystem.GetPrimaryEntity(Prefab),</span><br><span class="line">            SecondsBetweenSpawns = <span class="number">1</span> / SpawnsPerSecond</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<ul>
<li><a href="https://github.com/Knightmore/MultiWorldBootstrap" target="_blank" rel="noopener">Knightmore/MultiWorldBootstrap: Unity ICustomBootstrap extension for multiple custom world creation in ECS (github.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>源代码分析world的创建</title>
    <url>/unity-2020-10-20-ecs-world/</url>
    <content><![CDATA[<p>Packages/com.unity.entities/Unity.Entities.Hybrid/Injection/AutomaticWorldBootstrap.cs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class AutomaticWorldBootstrap</span><br><span class="line">&#123;</span><br><span class="line">    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]</span><br><span class="line">    static void Initialize()</span><br><span class="line">    &#123;</span><br><span class="line">        DefaultWorldInitialization.Initialize(&quot;Default World&quot;, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Packages/com.unity.entities/Unity.Entities/DefaultWorldInitialization.cs</p>
<p>检查是否有bootstrap没有的话则自动创建world</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Initializes the default world or runs ICustomBootstrap if one is available.</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;defaultWorldName&quot;&gt;The name of the world that will be created. Unless there is a custom bootstrap.&lt;&#x2F;param&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;editorWorld&quot;&gt;Editor worlds by default only include systems with [ExecuteAlways]. If editorWorld is true, ICustomBootstrap will not be used.&lt;&#x2F;param&gt;</span><br><span class="line">        public static World Initialize(string defaultWorldName, bool editorWorld &#x3D; false)</span><br><span class="line">        &#123;</span><br><span class="line">            RegisterUnloadOrPlayModeChangeShutdown();</span><br><span class="line"></span><br><span class="line">            if (!editorWorld)</span><br><span class="line">            &#123;</span><br><span class="line">                var bootStrap &#x3D; CreateBootStrap();</span><br><span class="line">                if (bootStrap !&#x3D; null &amp;&amp; bootStrap.Initialize(defaultWorldName))</span><br><span class="line">                &#123;</span><br><span class="line">                    Assert.IsTrue(World.DefaultGameObjectInjectionWorld !&#x3D; null,</span><br><span class="line">                        $&quot;ICustomBootstrap.Initialize() implementation failed to set &quot; +</span><br><span class="line">                        $&quot;World.DefaultGameObjectInjectionWorld, despite returning true &quot; +</span><br><span class="line">                        $&quot;(indicating the World has been properly initialized)&quot;);</span><br><span class="line">                    return World.DefaultGameObjectInjectionWorld;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var world &#x3D; new World(defaultWorldName, editorWorld ? WorldFlags.Editor : WorldFlags.Game);</span><br><span class="line">            World.DefaultGameObjectInjectionWorld &#x3D; world;</span><br><span class="line"></span><br><span class="line">            var systemList &#x3D; GetAllSystems(WorldSystemFilterFlags.Default, editorWorld);</span><br><span class="line">            AddSystemToRootLevelSystemGroupsInternal(world, systemList, systemList.Count);</span><br><span class="line"></span><br><span class="line">#if !UNITY_DOTSRUNTIME</span><br><span class="line">            ScriptBehaviourUpdateOrder.AddWorldToCurrentPlayerLoop(world);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">            DefaultWorldInitialized?.Invoke(world);</span><br><span class="line">            return world;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>查找可用的bootstrap并实例化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        static ICustomBootstrap CreateBootStrap()</span><br><span class="line">        &#123;</span><br><span class="line">#if !UNITY_DOTSRUNTIME</span><br><span class="line">            var bootstrapTypes &#x3D; TypeManager.GetTypesDerivedFrom(typeof(ICustomBootstrap));</span><br><span class="line">            Type selectedType &#x3D; null;</span><br><span class="line"></span><br><span class="line">            foreach (var bootType in bootstrapTypes)</span><br><span class="line">            &#123;</span><br><span class="line">                if (bootType.IsAbstract || bootType.ContainsGenericParameters)</span><br><span class="line">                    continue;</span><br><span class="line"></span><br><span class="line">                if (selectedType &#x3D;&#x3D; null)</span><br><span class="line">                    selectedType &#x3D; bootType;</span><br><span class="line">                else if (selectedType.IsAssignableFrom(bootType))</span><br><span class="line">                    selectedType &#x3D; bootType;</span><br><span class="line">                else if (!bootType.IsAssignableFrom(selectedType))</span><br><span class="line">                    Debug.LogError(&quot;Multiple custom ICustomBootstrap specified, ignoring &quot; + bootType);</span><br><span class="line">            &#125;</span><br><span class="line">            ICustomBootstrap bootstrap &#x3D; null;</span><br><span class="line">            if (selectedType !&#x3D; null)</span><br><span class="line">                bootstrap &#x3D; Activator.CreateInstance(selectedType) as ICustomBootstrap;</span><br><span class="line"></span><br><span class="line">            return bootstrap;</span><br><span class="line">#else</span><br><span class="line">            throw new Exception(&quot;This method should have been replaced by code-gen.&quot;);</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>





<p>小技巧: 新建一个ICustomBootstrap,在Initialize抛出异常.则能在追踪栈找到代码的入口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Multiple custom ICustomBootstrap specified, ignoring GameBootstrap</span><br><span class="line">UnityEngine.Debug:LogError(Object)</span><br><span class="line">Unity.Debug:LogError(Object) (at Library&#x2F;PackageCache&#x2F;com.unity.entities@0.14.0-preview.18&#x2F;Unity.Entities&#x2F;Stubs&#x2F;Unity&#x2F;Debug.cs:13)</span><br><span class="line">Unity.Entities.DefaultWorldInitialization:CreateBootStrap() (at Library&#x2F;PackageCache&#x2F;com.unity.entities@0.14.0-preview.18&#x2F;Unity.Entities&#x2F;DefaultWorldInitialization.cs:351)</span><br><span class="line">Unity.Entities.DefaultWorldInitialization:Initialize(String, Boolean) (at Library&#x2F;PackageCache&#x2F;com.unity.entities@0.14.0-preview.18&#x2F;Unity.Entities&#x2F;DefaultWorldInitialization.cs:116)</span><br><span class="line">Unity.Entities.AutomaticWorldBootstrap:Initialize() (at Library&#x2F;PackageCache&#x2F;com.unity.entities@0.14.0-preview.18&#x2F;Unity.Entities.Hybrid&#x2F;Injection&#x2F;AutomaticWorldBootstrap.cs:15)</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>unity使用platforms构建</title>
    <url>/unity-2020-10-21-platform/</url>
    <content><![CDATA[<h2 id="BuildConfiguration"><a href="#BuildConfiguration" class="headerlink" title="BuildConfiguration"></a>BuildConfiguration</h2><ul>
<li>他继承于scriptobject,他的扩展名是”.buildconfiguration”导入的时候执行了编辑器脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   [ScriptedImporter(3, new[] &#123; BuildConfiguration.AssetExtension &#125;)]</span><br><span class="line">   sealed class BuildConfigurationScriptedImporter : ScriptedImporter</span><br><span class="line">   &#123;</span><br><span class="line">       public override void OnImportAsset(AssetImportContext context)</span><br><span class="line">       &#123;</span><br><span class="line">           var asset &#x3D; BuildConfiguration.CreateInstance();</span><br><span class="line">           if (BuildConfiguration.DeserializeFromPath(asset, context.assetPath))</span><br><span class="line">           &#123;</span><br><span class="line">               context.AddObjectToAsset(&quot;asset&quot;, asset&#x2F;*, icon*&#x2F;);</span><br><span class="line">               context.SetMainObject(asset);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>再看下他再unity中的编辑器显示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CustomEditor(typeof(BuildConfigurationScriptedImporter))]</span><br><span class="line">    internal sealed class BuildConfigurationScriptedImporterEditor : ScriptedImporterEditor</span><br><span class="line">    &#123;</span><br><span class="line">        static class ClassNames</span><br><span class="line">        &#123;</span><br><span class="line">            public const string BaseClassName &#x3D; nameof(BuildConfiguration);</span><br><span class="line">            public const string Dependencies &#x3D; BaseClassName + &quot;__asset-dependencies&quot;;</span><br><span class="line">            public const string Header &#x3D; BaseClassName + &quot;__asset-header&quot;;</span><br><span class="line">            public const string HeaderLabel &#x3D; BaseClassName + &quot;__asset-header-label&quot;;</span><br><span class="line">            public const string BuildAction &#x3D; BaseClassName + &quot;__build-action&quot;;</span><br><span class="line">            public const string BuildDropdown &#x3D; BaseClassName + &quot;__build-dropdown&quot;;</span><br><span class="line">            public const string AddComponent &#x3D; BaseClassName + &quot;__add-component-button&quot;;</span><br><span class="line">            public const string OptionalComponents &#x3D; BaseClassName + &quot;__optional-components&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        internal struct BuildAction : IEquatable&lt;BuildAction&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            public string Name;</span><br><span class="line">            public Action&lt;BuildConfiguration&gt; Action;</span><br><span class="line"></span><br><span class="line">            public bool Equals(BuildAction other)</span><br><span class="line">            &#123;</span><br><span class="line">                return Name &#x3D;&#x3D; other.Name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>该脚本定义了三个按钮<code>build</code>,<code>run</code>,<code>build and run</code></p>
<ul>
<li>如何建立</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public BuildResult Build()</span><br><span class="line">&#123;</span><br><span class="line">    var pipeline &#x3D; GetBuildPipeline();</span><br><span class="line">    var canUse &#x3D; CanUsePipeline(pipeline);</span><br><span class="line">    if (!canUse.Result)</span><br><span class="line">    &#123;</span><br><span class="line">        return BuildResult.Failure(pipeline, this, canUse.Reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var what &#x3D; !string.IsNullOrEmpty(name) ? $&quot; &#123;name&#125;&quot; : string.Empty;</span><br><span class="line">    using (var progress &#x3D; new BuildProgress($&quot;Building&#123;what&#125;&quot;, &quot;Please wait...&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        return pipeline.Build(this, progress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>从IBuildPipelineComponent组件中获取Pipeline..继承IBuildPipelineComponent接口的组件有<code>ClassicBuildProfile</code>,<code>DotsRuntimeBuildProfile</code></p>
</li>
<li><p>关于platform,我们看下安卓建立的配置,可以看到手动实例化了<code>ClassicBuildProfile</code>,并且设置了platform</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class AndroidMenuItem</span><br><span class="line">&#123;</span><br><span class="line">    const string k_CreateBuildConfigurationAssetClassic &#x3D; BuildConfigurationMenuItem.k_BuildConfigurationMenu + &quot;Android Classic Build Configuration&quot;;</span><br><span class="line">   </span><br><span class="line">    [MenuItem(k_CreateBuildConfigurationAssetClassic, true)]</span><br><span class="line">    static bool CreateBuildConfigurationAssetClassicValidation()</span><br><span class="line">    &#123;</span><br><span class="line">        return Directory.Exists(AssetDatabase.GetAssetPath(Selection.activeObject));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    [MenuItem(k_CreateBuildConfigurationAssetClassic)]</span><br><span class="line">    static void CreateBuildConfigurationAssetClassic()</span><br><span class="line">    &#123;</span><br><span class="line">        Selection.activeObject &#x3D; BuildConfigurationMenuItem.CreateAssetInActiveDirectory(</span><br><span class="line">            &quot;AndroidClassic&quot;,</span><br><span class="line">            new GeneralSettings(),</span><br><span class="line">            new SceneList(),</span><br><span class="line">            new ClassicBuildProfile &#123; Platform &#x3D; new AndroidPlatform() &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</li>
</ol>
<h2 id="BuildPlayerStep"><a href="#BuildPlayerStep" class="headerlink" title="BuildPlayerStep"></a>BuildPlayerStep</h2><ul>
<li>我们看到他的最终执行仍然使用了API, UnityEditor.BuildPipeline.BuildPlayer(buildPlayerOptions);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sealed class BuildPlayerStep : BuildStepBase</span><br><span class="line">    &#123;</span><br><span class="line">        public override Type[] UsedComponents &#123; get; &#125; &#x3D;</span><br><span class="line">        &#123;</span><br><span class="line">            typeof(ClassicBuildProfile),</span><br><span class="line">            typeof(SceneList),</span><br><span class="line">            typeof(GeneralSettings),</span><br><span class="line">            typeof(OutputBuildDirectory)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        public override BuildResult Run(BuildContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            var classicSharedData &#x3D; context.GetValue&lt;ClassicSharedData&gt;();</span><br><span class="line">            var target &#x3D; classicSharedData.BuildTarget;</span><br><span class="line">            if (target &lt;&#x3D; 0)</span><br><span class="line">                return context.Failure($&quot;Invalid build target &#39;&#123;target.ToString()&#125;&#39;.&quot;);</span><br><span class="line">            if (target !&#x3D; EditorUserBuildSettings.activeBuildTarget)</span><br><span class="line">                return context.Failure($&quot;&#123;nameof(EditorUserBuildSettings.activeBuildTarget)&#125; must be switched before &#123;nameof(BuildPlayerStep)&#125; step.&quot;);</span><br><span class="line"></span><br><span class="line">            var embeddedScenes &#x3D; context.GetValue&lt;EmbeddedScenesValue&gt;().Scenes;</span><br><span class="line">            if (embeddedScenes.Length &#x3D;&#x3D; 0)</span><br><span class="line">                return context.Failure(&quot;There are no scenes to build.&quot;);</span><br><span class="line"></span><br><span class="line">            var outputPath &#x3D; context.GetOutputBuildDirectory();</span><br><span class="line">            if (!Directory.Exists(outputPath))</span><br><span class="line">                Directory.CreateDirectory(outputPath);</span><br><span class="line"></span><br><span class="line">            string locationPathName;</span><br><span class="line">            if (context.HasValue&lt;LocationInfo&gt;())</span><br><span class="line">            &#123;</span><br><span class="line">                locationPathName &#x3D; context.GetValue&lt;LocationInfo&gt;().Path;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                var generalSettings &#x3D; context.GetComponentOrDefault&lt;GeneralSettings&gt;();</span><br><span class="line">                locationPathName &#x3D; Path.Combine(outputPath, generalSettings.ProductName + ClassicBuildProfile.GetExecutableExtension(target));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var buildPlayerOptions &#x3D; new BuildPlayerOptions()</span><br><span class="line">            &#123;</span><br><span class="line">                scenes &#x3D; embeddedScenes,</span><br><span class="line">                target &#x3D; target,</span><br><span class="line">                locationPathName &#x3D; locationPathName,</span><br><span class="line">                targetGroup &#x3D; UnityEditor.BuildPipeline.GetBuildTargetGroup(target),</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            buildPlayerOptions.options &#x3D; BuildOptions.None;</span><br><span class="line"></span><br><span class="line">            foreach (var customizer in classicSharedData.Customizers)</span><br><span class="line">                buildPlayerOptions.options |&#x3D; customizer.ProvideBuildOptions();</span><br><span class="line"></span><br><span class="line">            var extraScriptingDefines &#x3D; classicSharedData.Customizers.SelectMany(c &#x3D;&gt; c.ProvidePlayerScriptingDefines()).ToArray();</span><br><span class="line">            buildPlayerOptions.extraScriptingDefines &#x3D; extraScriptingDefines;</span><br><span class="line"></span><br><span class="line">            var report &#x3D; UnityEditor.BuildPipeline.BuildPlayer(buildPlayerOptions);</span><br><span class="line">            context.SetValue(report);</span><br><span class="line"></span><br><span class="line">            return context.FromReport(report);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity rendering order渲染顺序</title>
    <url>/unity-2020-10-22-unity-render-order/</url>
    <content><![CDATA[<h2 id="關於深度緩衝-Depth-buffering-or-z-buffering"><a href="#關於深度緩衝-Depth-buffering-or-z-buffering" class="headerlink" title="關於深度緩衝 (Depth buffering, or z-buffering)"></a>關於深度緩衝 (Depth buffering, or z-buffering)</h2><p>勢必得先回歸電腦繪圖學 (Computer graphics) 的知識，理解 <a href="https://en.wikipedia.org/wiki/Rasterisation" target="_blank" rel="noopener">Rasterization</a> 怎麼透過 <a href="https://en.wikipedia.org/wiki/Z-buffering" target="_blank" rel="noopener">z-buffering</a> ，來解決物體 rendering 可視問題 (visibility problem)，哪些可見那些不可見，這也關係到物件在 rendering result 成像後前後順序。</p>
<p>當物件 rendering 時，每個所生成的 pixel 產生的深度資訊 (z coordinate) 會儲存在 z-buffer (或稱為 depth buffer)，buffer 為二維陣列，其尺寸大小與最後成像尺寸相同。在 Unity shader 中可利用 <code>ZWrite On | Off</code> 來切換是否將深度資訊要寫入到 z-buffer。</p>
<p>如果場景中其他物件 rendering 時，也在同一個 pixel 位置渲染結果時，會檢查 z-buffer 所儲存的深度資訊，是否將渲染結果覆蓋原本的 pixel，並且將新的深度資訊寫入到 z-buffer。通常條件會設定為深度資訊比原本更接近攝影機時，就能夠覆蓋原本結果。在 Unity shader 中可利用 <code>ZTest Less | Greater | LEqual | GEqual | Equal | NotEqual | Always</code> 來調整判斷方式。</p>
<p><strong>有 z-buffering 機制，可不管物件算繪順序 (rendering order)，使得離攝影機越近的物件，永遠都描繪在其他離攝影機越遠的物件之前</strong> (<code>ZTest LEqual</code>)。</p>
<p><a href="https://3.bp.blogspot.com/-xEsBEXX2jiQ/Wv_KFd2e3hI/AAAAAAAAwHY/aMJAzz3UIPkMUZOUqd9sgz_dsKZYN0PmQCHMYCw/s1600/bed-room.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/bed-room.png" alt="房間示意圖"></a></p>
<p>房間示意圖</p>
<p><a href="https://3.bp.blogspot.com/-x6KnmDnIk6o/Wv_KF_uymYI/AAAAAAAAwHc/XyV7-wddP-0QgqxstR_8MGzLGOxMlbUuACHMYCw/s1600/depth-info-bed-room.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/depth-info-bed-room.png" alt="房間的深度資訊，越深色表示離攝影機越近"></a></p>
<p>房間的深度資訊，越深色表示離攝影機越近</p>
<p><a href="https://assetstore.unity.com/packages/3d/props/furniture/pack-gesta-furniture-1-28237" target="_blank" rel="noopener">場景來源</a></p>
<h2 id="Renderer’s-rendering-order"><a href="#Renderer’s-rendering-order" class="headerlink" title="Renderer’s rendering order"></a>Renderer’s rendering order</h2><p>假設 shader 中關閉深度機制的判斷 (<code>ZTest Always</code>)，或者在 render 場景物件的過程中都不寫入深度 (<code>ZWrite Off</code>)，即<strong>沒有 z-buffering 機制，rendering order 會決定成像的結果，越晚畫的物件永遠都在其他較早畫的物件之上</strong>。</p>
<p>而在 SpriteRenderer 直接修改 sorting layer 以及 order in layer 來改變 rendering order，就能調整該物件在算繪結果的物件前後，便是基於此緣故，更多細節可查看 <code>Sprites/Default</code> shader 程式碼。</p>
<p>故整理在 Unity 中，rendering order 是根據以下參數進行排序：<strong>Camera depth &gt; Material type &gt; Sorting layer &gt; Order in layer &gt; Material render queue &gt; Camera order algorithm</strong>。</p>
<ul>
<li><p>Camera depth</p>
<ul>
<li><p>數字越大越晚畫</p>
</li>
<li><p>通常無法搭配 Clear Flags: Don’t Clear，因為不會清除 depth buffer (z-buffer)</p>
</li>
<li><p>程式設定 <code>camera.depth</code></p>
</li>
<li><p>選擇場景中的 camera 編輯</p>
<p><a href="https://3.bp.blogspot.com/-VdjJ2P8mRSw/Wv_KGL2e9kI/AAAAAAAAwHg/bf871Tz0ZCgcM_pTnENDlLA2EVCVEOXgQCHMYCw/s1600/edit-camera-depth-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-camera-depth-unity.png" alt="編輯 depth 參數"></a></p>
<p>編輯 depth 參數</p>
</li>
</ul>
</li>
<li><p>Material type</p>
<ul>
<li>先畫不透明物件 (opaque)，再畫透明物件 (transparent)</li>
<li>根據 material render queue 來決定，數值小於等於 2500 為不透明物件，數值大於 2500 為透明物件</li>
</ul>
</li>
<li><p>Sorting layer</p>
<ul>
<li><p>數字越大越晚畫</p>
</li>
<li><p>大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯（不過自定義編輯器來達成）</p>
</li>
<li><p>程式設定 <code>renderer.sortingLayerID</code></p>
</li>
<li><p>在 Tag Manager 編輯 Sorting layer</p>
<p><a href="https://3.bp.blogspot.com/-HQnwI_JP7dQ/Wv_KG_RuisI/AAAAAAAAwHo/8ecZFCMsknsP2XOd227LgYyr_JsP-k5fwCHMYCw/s1600/edit-sorting-layers-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-sorting-layers-unity.png" alt="編輯 Sorting layers"></a></p>
</li>
<li><p>選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Sorting layer</p>
<p><a href="https://3.bp.blogspot.com/-74IY8tFv9b4/WwAf4mJ-bqI/AAAAAAAAwJQ/xHzyeHjHwP89PPKkCo3Ahp_OrsCdEJNKwCLcBGAs/s1600/edit-sorting-layer-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-sorting-layer-unity.png" alt="編輯 Sorting layer"></a></p>
</li>
</ul>
</li>
<li><p>Order in layer</p>
<ul>
<li><p>數字越大越晚畫</p>
</li>
<li><p>大多數的 renderer 都有支援此參數，但僅有 SpriteRenderder 以及 ParticleSystemRenderer 能在預設的 Inspector 編輯</p>
</li>
<li><p>程式設定 <code>renderer.sortingOrder</code></p>
</li>
<li><p>選擇場景的 SpriteRenderder 或是 ParticleSystemRenderer 編輯 Order in layer</p>
<p><a href="https://3.bp.blogspot.com/-8VZ0pu3-ZdI/WwAfrRVqL9I/AAAAAAAAwJM/89ZAUPkUfUsy9eXQn1bZUW9y_Q8HxBCxwCLcBGAs/s1600/edit-order-in-layer-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-order-in-layer-unity.png" alt="編輯 Order in layer"></a></p>
</li>
</ul>
</li>
<li><p>Material render queue</p>
<ul>
<li><p>數字越大越晚畫</p>
</li>
<li><p>預設值會從 Shader 取得，但可自行定義</p>
</li>
<li><p>不透明物件 (Opaque)、半透明物件 (AlphaTest)、透明物件 (Transparent) 預設值分別 2000、2450、以及 3000</p>
<ul>
<li>通常只有透明物件會關閉 ZWrite</li>
</ul>
</li>
<li><p>程式設定 <code>material.renderQueue</code></p>
</li>
<li><p>選擇專案中的 material 編輯</p>
<p><a href="https://3.bp.blogspot.com/--4-IFurF7lk/Wv_KGSiPZ2I/AAAAAAAAwHk/95Bv8w902lke-HN_CCP1wigeekWuMQknQCHMYCw/s1600/edit-render-queue-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-render-queue-unity.png" alt="編輯 render queue"></a></p>
</li>
</ul>
</li>
<li><p>Camera render algorithm</p>
<ul>
<li><p>無法在預設編輯器修改，使用程式調整</p>
</li>
<li><p>非透明物件排序演算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera.opaqueSortMode</span><br></pre></td></tr></table></figure>

<ul>
<li>Default：在 Unity 2018.1 預設值 FrontToBack</li>
<li>FrontToBack：粗略低由近到遠排序繪製，能使得 GPU rendering 時有更好的效能</li>
<li>NoDistanceSort：關閉排序繪製，能降低 CPU 的使用量</li>
</ul>
</li>
<li><p>透明物件排序演算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">camera.transparencySortMode</span><br></pre></td></tr></table></figure>

<ul>
<li>Default：根據 camera projection mode 調整</li>
<li>Perspective：根據 camera 位置到物件中心 (object center) 的距離排序</li>
<li>Orthographic：根據 view plane 到物件中心 (object center) 的距離排序</li>
<li>CustomAxis：制定 axis 排序，專門用於 2D 遊戲製作，可參考<a href="https://qiita.com/RyotaMurohoshi/items/3f0de2689af72f9b46f9" target="_blank" rel="noopener">這篇文章</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="补充RenderQueue"><a href="#补充RenderQueue" class="headerlink" title="补充RenderQueue"></a>补充RenderQueue</h4><p>nderQueue ，RenderQueue 其实就是shader中tags中的Queue</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">"Queue"</span>=<span class="string">"Geometry"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，Unity会基于对象距离摄像机的远近来排序你的对象。因此，当一个对象离摄像机越近，它就会优先绘制在其他更远的对象上面。对于大多数情况这是有效并合适的，但是在一些特殊情况下，你可能想要自己控制对象的绘制顺序。而使用Tags{}块我们就可以得到这样的控制。</p>
<p>Unity提供给我们一些默认的渲染队列，每一个对应一个唯一的值，来指导Unity绘制对象到屏幕上。这些内置的渲染队列被称为Background, Geometry, AlphaTest, GeometryLast,Transparent, Overlay。这些队列不是随便创建的，它们是为了让我们更容易地编写Shader并处理实时渲染的。</p>
<p>同时需在SubShader中显示声明ZWrite Off，通知Unity我们会重写物体的渲染深度排序。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/15536448-9a2deda21e4f661e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/744/format/webp" alt="img"></p>
<p>好了，最后给出一个最终的总结：<br> 依次按条件先后顺序进行排序渲染处理。先按大项条件排序，后按小项条件排序</p>
<p>1.Camera Depth: 越小越优先<br> 2.RenderQueue 2500以下</p>
<pre><code>1. Sorting Layer/Order in Layer
    1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先
    2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序
    2.RenderQueue 越小越优先
    3.RenderQueue 相等，`由近到远排序优先`</code></pre><p> 3.RenderQueue 2500以上<br>        1. Sorting Layer/Order in Layer<br>        1. 按照Sorting Layer/Order in Layer 设置的值，越小越优先<br>        2. 无此属性，等同于 Sorting Layer=default ,Order in Layer=0 参与排序<br>        2.RenderQueue 越小越优先<br>        3.RenderQueue 相等，<code>由远到近排序优先</code></p>
<p>说明一下：2500是关键值，它是透明跟不透明的分界点，因此我们考虑层级的时候要注意着点：renderqueue &gt; 2500的物体绝对会在renderqueue &lt;= 2500的物体前面，即渲染时renderqueue大的会挡住renderqueue小的，不论它的sortingLayer和sortingOrder怎么设置都是不起作用的。知道了这点，其他的就很好理解了。当两个的RenderQueue都在同一侧时，在SortingLayer高的绝对会在sortingLayer前面，无视renderqueue跟soringOrder，只有在sortingLayer相同的前提下，soringOrder高的会在sortingOrder低的前面，无视renderqueue。当sortingLayer跟sortingOrder相同时，才看renderqueue的高低，高的在前面。特别要注意一下半透明物体的渲染顺序是<code>越远越先渲染</code>，这与不透明物体是相反的。</p>
<p>UGUI中的ui默认使用的是UI/Default 材质，对应的shader中的渲染队列是Transparent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shader &quot;UI&#x2F;Default&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Queue&quot;&#x3D;&quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot;&#x3D;&quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;&#x3D;&quot;Transparent&quot;</span><br><span class="line">            &quot;PreviewType&quot;&#x3D;&quot;Plane&quot;</span><br><span class="line">            &quot;CanUseSpriteAtlas&quot;&#x3D;&quot;True&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="UGUI’s-rendering-order"><a href="#UGUI’s-rendering-order" class="headerlink" title="UGUI’s rendering order"></a>UGUI’s rendering order</h2><p>在 Unity 5.x 推出的 UGUI 系統中，其 rendering order 卻是另外規則，這分成兩個部分探討 Canvas &amp; CanvasRenderer，其概念可想像是 CanvasRenderer 可視為畫在畫布 Canvas 的元件，之後該畫布再畫在最終的畫面上（e.g. render target）。</p>
<p>關於 Canvas 的 rendering order：</p>
<ul>
<li><p>Screen Space - Overlay</p>
<ul>
<li><p>想像該 canvas 由隱藏的 camera 處理，其 depth = 101 (最後才處理)</p>
</li>
<li><p>多個相同的 canvas 使用 Sort Order 來決定描繪順序，數字越大越晚畫</p>
<p><a href="https://3.bp.blogspot.com/-Jwq-GkVy5Pg/Wv_MaxvDuEI/AAAAAAAAwII/8xeKRt-08sw9AtYHAxXbPztqk3rlwMH6QCLcBGAs/s1600/edit-canvas-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-canvas-unity.png" alt="編輯 Canvas&#39;s Sort Order"></a></p>
</li>
</ul>
</li>
<li><p>Screen Space - Camera &amp; World Space</p>
<ul>
<li><p>想像為存在在世界場景的平面</p>
</li>
<li><p>多個相同 canvas 使用 Sorting layer 以及 Order in layer 來決定 rendering order</p>
<p><a href="https://4.bp.blogspot.com/-u-mDDKcRfAY/Wv_NHS9SsZI/AAAAAAAAwIU/Mt_mBRPL8DYo7Xj9Cbh-hOPTFbg6X3UMgCLcBGAs/s1600/edit-canvas-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/edit-canvas-unity.png" alt="編輯 Canvas&#39;s Sorting layer &amp; Order in layer"></a></p>
</li>
</ul>
</li>
</ul>
<p>關於同一個 canvas 下，其 CanvasRenderer 之間的 rendering order：</p>
<ul>
<li><p>Material render queue &gt; Transform order</p>
<ul>
<li><p>Material render queue 同前面說明，看材質球 (material) 的 render queue 參數</p>
</li>
<li><p>Transform order：依照 Transform 階層關係，採 Pre-order 方式排序</p>
<p><a href="https://4.bp.blogspot.com/-fCMusmLKj4k/Wv_NnqL6SXI/AAAAAAAAwIo/suCM_XaddIAEwirQkIibP2wB8Mas3EjagCLcBGAs/s1600/canvas-renderer-rendering-order-unity.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-22-unity-render-order/canvas-renderer-rendering-order-unity.png" alt="Canvas renderer&#39;s rendering order example"></a></p>
</li>
<li><p>注意：當所屬的 Canvas 之 render mode 為 Screen Space - Overlay，則無視 Material render queue</p>
</li>
</ul>
</li>
</ul>
<h2 id="使用實踐情境"><a href="#使用實踐情境" class="headerlink" title="使用實踐情境"></a>使用實踐情境</h2><ul>
<li>3D<ul>
<li>不透明物件 &amp; 半透明物件 (e.g. 草、鐵絲網等等) 依照場景擺放<ul>
<li>不需要特別設定 rendering order</li>
<li>一切交給 z-buffering 機制</li>
</ul>
</li>
<li>透明物件或是粒子特效 (particle system) 可透過 sort layer &amp; order in layer 機制調整 rendering order<ul>
<li>透明物件 shader 通常不會寫 z-buffer (e.g. <code>ZWrite Off</code>)</li>
<li>可 hack inspector 來設定 <code>renderer.sortingLayerID</code> 以及 <code>renderer.sortingOrder</code></li>
</ul>
</li>
</ul>
</li>
<li>2D<ul>
<li>Sprite renderer 使用 sort layer &amp; order in layer 機制來調整 rendering order，以控制 depth</li>
</ul>
</li>
<li>UGUI<ul>
<li>利用 transform hierarchy 來建立 rendering order，因應效能優化可能還得拆成多個 canvas</li>
<li>若採用 Canvas render mode: World space，想讓 UI 與 3D 場景物件的結合，可將 canvas 視為 3D 物件去設計場景架構 (這自己就沒有經驗…)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>关于静态批处理/动态批处理/GPU Instancing /SRP Batcher的详细剖析</title>
    <url>/unity-2020-10-23-unity-optimizing-gpu/</url>
    <content><![CDATA[<h2 id="静态批处理-1"><a href="#静态批处理-1" class="headerlink" title="静态批处理[1]"></a>静态批处理<a href="https://zhuanlan.zhihu.com/p/98642798#ref_1" target="_blank" rel="noopener">[1]</a></h2><ul>
<li><strong>定义</strong></li>
</ul>
<p>标明为 Static 的静态物件，如果在使用<strong>相同材质球</strong>的条件下，在<strong>Build（项目打包）</strong>的时候Unity会自动地提取这些共享材质的静态模型的Vertex buffer和Index buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大Vertex buffer和Index buffer中。并且记录每一个子模型的Index buffer数据在构建的大Index buffer中的起始及结束位置。</p>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-48b948e088a2310817c67c6530637a95_720w.jpg" alt="img"></p>
<p>在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次Draw call分别绘制每一个子模型。</p>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-9e2e1e5df3ad1b37ebe0dc1af4712005_720w.jpg" alt="img"></p>
<p>Static batching并<strong>不减少Draw call的数量（</strong>但是在编辑器时由于计算方法区别Draw call数量是会显示减少了的<a href="https://zhuanlan.zhihu.com/p/98642798#ref_2" target="_blank" rel="noopener">[2]</a>），但是由于我们预先把所有的子模型的顶点变换到了世界空间下，所以在运行时cpu不需要再次执行顶点变换操作，节约了少量的计算资源，并且这些子模型共享材质，所以在多次Draw call调用之间并没有渲染状态的切换，渲染API（Command Buffer）会缓存绘制命令，起到了渲染优化的目的 。</p>
<p>但Static batching也会带来一些性能的负面影响。Static batching会导致应用打包之后体积增大，应用运行时所占用的内存体积也会增大。</p>
<p>另外，在很多不同的GameObject引用同一模型的情况下，如果不开启Static batching，GameObject共享的模型会在应用程序包内或者内存中只存在一份，绘制的时候提交模型顶点信息，然后设置每一个GameObjec的材质信息，分别调用渲染API绘制。开启Static batching，在Unity执行Build的时候，场景中所有引用相同模型的GameObject都必须将模型顶点信息复制，并经过计算变化到最终在世界空间中，存储在最终生成的Vertex buffer中。这就导致了打包的体积及运行时内存的占用增大。例如，在茂密的森林级别将树标记为静态会严重影响内存<a href="https://zhuanlan.zhihu.com/p/98642798#ref_3" target="_blank" rel="noopener">[3]</a>。</p>
<ul>
<li><strong>无法参与批处理情况</strong></li>
</ul>
<ol>
<li>改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。</li>
</ol>
<ul>
<li><strong>相同材质批处理断开情况</strong></li>
</ul>
<ol>
<li>位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。</li>
<li>拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行同批处理（除非他们指向lightmap的同一部分）。</li>
</ol>
<ul>
<li><strong>流程原理</strong></li>
</ul>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-37b225e02afe6dca369647e4a3bf3bd4_720w.jpg" alt="img"></p>
<hr>
<h2 id="动态批处理-4"><a href="#动态批处理-4" class="headerlink" title="动态批处理[4]"></a>动态批处理<a href="https://zhuanlan.zhihu.com/p/98642798#ref_4" target="_blank" rel="noopener">[4]</a></h2><ul>
<li><strong>定义</strong></li>
</ul>
<p>在使用<strong>相同材质球</strong>的情况下，Unity会在运行时对于<strong>正在视野中</strong>的符合条件的动态对象在一个Draw call内绘制，所以<strong>会降低Draw Calls</strong>的数量。</p>
<p>Dynamic batching的原理也很简单，在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中，然后通过一次Draw call绘制多个模型，达到合批的目的。模型顶点变换的操作是由CPU完成的，所以这会带来一些CPU的性能消耗。并且计算的模型顶点数量不宜太多，否则CPU串行计算耗费的时间太长会造成场景渲染卡顿，所以Dynamic batching只能处理一些小模型。</p>
<p>Dynamic batching在降低Draw call的同时会导致额外的CPU性能消耗，所以仅仅在合批操作的性能消耗小于不合批，Dynamic batching才会有意义。而新一代图形API（ Metal、Vulkan）在批次间的消耗降低了很多，所以在这种情况下使用Dynamic batching很可能不能获得性能提升。Dynamic batching相对于Static batching不需要预先复制模型顶点，所以在内存占用和发布的程序体积方面要优于Static batching。但是Dynamic batching会带来一些运行时CPU性能消耗，Static batching在这一点要比Dynamic batching更加高效。</p>
<ul>
<li><strong>无法参与批处理情况</strong></li>
</ul>
<ol>
<li>物件Mesh大于等于900个面。</li>
<li>代码动态改变材质变量后不算同一个材质，会不参与合批。</li>
<li>如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体，否则都无法参与合批。</li>
<li>改变Renderer.material将会造成一份材质的拷贝，因此会打断批处理，你应该使用Renderer.sharedMaterial来保证材质的共享状态。</li>
</ol>
<ul>
<li><strong>批处理中断情况</strong></li>
</ul>
<ol>
<li>位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。</li>
<li>物体如果都符合条件会优先参与静态批处理，再是GPU Instancing，然后才到动态批处理，假如物体符合前两者，此次批处理都会被打断。</li>
<li>GameObject之间如果有镜像变换不能进行合批，例如，”GameObject A with +1 scale and GameObject B with –1 scale cannot be batched together”。</li>
<li>拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。</li>
<li>使用Multi-pass Shader的物体会禁用Dynamic batching，因为Multi-pass Shader通常会导致一个物体要连续绘制多次，并切换渲染状态。这会打破其跟其他物体进行Dynamic batching的机会。</li>
<li>我们知道能够进行合批的前提是多个GameObject共享同一材质，但是对于Shadow casters的渲染是个例外。仅管Shadow casters使用不同的材质，但是只要它们的材质中给Shadow Caster Pass使用的参数是相同的，他们也能够进行Dynamic batching。</li>
<li>Unity的Forward Rendering Path中如果一个GameObject接受多个光照会为每一个per-pixel light产生多余的模型提交和绘制，从而附加了多个Pass导致无法合批，如下图:</li>
</ol>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-177f53a633d2eac753abe07805367d4d_720w.jpg" alt="img">可以接收多个光源的shader，在受到多个光源是无法合批</p>
<ul>
<li><strong>流程原理</strong></li>
</ul>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-8c69d718432ba4045155c700fda6f6b6_720w.jpg" alt="img"></p>
<hr>
<h2 id="GPU-Instancing"><a href="#GPU-Instancing" class="headerlink" title="GPU Instancing"></a>GPU Instancing</h2><ul>
<li><strong>定义</strong></li>
</ul>
<p>在使用<strong>相同材质球、相同Mesh(预设体的实例会自动地使用相同的网格模型和材质)</strong>的情况下，Unity会在运行时对于<strong>正在视野中</strong>的符合要求的所有对象使用<strong>Constant Buffer</strong><a href="https://zhuanlan.zhihu.com/p/98642798#ref_5" target="_blank" rel="noopener">[5]</a>将其位置、缩放、uv偏移、<em>lightmapindex</em>等相关信息保存在显存中的<strong>“统一/常量缓冲器”</strong><a href="https://zhuanlan.zhihu.com/p/98642798#ref_6" target="_blank" rel="noopener">[6]</a>中，然后从中抽取一个对象作为实例送入渲染流程，当在执行DrawCall操作后，从显存中取出实例的部分共享信息与从GPU常量缓冲器中取出对应对象的相关信息一并传递到下一渲染阶段，与此同时，不同的着色器阶段可以从缓存区中直接获取到需要的常量，不用设置两次常量。比起以上两种批处理，GPU Instancing可以<strong>规避合并Mesh导致的内存与性能上升</strong>的问题，但是由于场景中所有符合该合批条件的渲染物体的信息每帧都要被重新创建，放入“统一/常量缓冲区”中，而碍于缓存区的大小限制，每一个Constant Buffer的大小要严格限制（不得大于64k）。详细请阅读：</p>
<p><a href="https://zhuanlan.zhihu.com/p/34499251" target="_blank" rel="noopener">Testplus：U3D优化批处理-GPU Instancing了解一下zhuanlan.zhihu.com<img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-b06a0dbdf07544a4d0687a8917611afd_180x120.jpg" alt="图标"></a></p>
<ul>
<li><strong>无法参与加速情况</strong></li>
</ul>
<ol>
<li>缩放为负值的情况下，会不参与加速。</li>
<li>代码动态改变材质变量后不算同一个材质，会不参与加速，但可以通过将颜色变化等变量加入常量缓冲器中实现<a href="https://zhuanlan.zhihu.com/p/98642798#ref_7" target="_blank" rel="noopener">[7]</a>。</li>
<li>受限于常量缓冲区在不同设备上的大小的上限，移动端支持的个数可能较低。</li>
<li>只支持一盏实时光，要在多个光源的情况下使用实例化，我们别无选择，只能切换到延迟渲染路径。为了能够让这套机制运作起来，请将所需的编译器指令添加到我们着色器的延迟渲染通道中。</li>
</ol>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-5c97567b099e9d98ca9d957282b1922e_720w.jpg" alt="img">当在多个光源开启GPU Instancing</p>
<ul>
<li><strong>批处理中断情况</strong></li>
</ul>
<ol>
<li>位置不相邻且中间夹杂着不同材质的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。</li>
<li>一个批次超过125个物体（受限于常量缓冲区在不同设备上的大小的上限，移动端数量有浮动）的时候会新建另一个加速流程。</li>
<li>物体如果都符合条件会优先参与静态批处理，然后才到GPU Instancing，假如物体符合前者，此次加速都会被打断。</li>
</ol>
<ul>
<li><strong>流程原理</strong></li>
</ul>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-0dde54b930bef9c768c10d3c79126e16_720w.jpg" alt="img"></p>
<hr>
<h2 id="SRP-Batcher-8"><a href="#SRP-Batcher-8" class="headerlink" title="SRP Batcher[8]"></a>SRP Batcher<a href="https://zhuanlan.zhihu.com/p/98642798#ref_8" target="_blank" rel="noopener">[8]</a></h2><ul>
<li><strong>定义</strong></li>
</ul>
<p>在使用LWRP或者HWRP时，开启SRP Batcher的情况下，只要物体的<strong>Shader中变体</strong>一致，就可以启用SRP Batcher加速。它与上文GPU Instancing实现的原理相近，Unity会在运行时对于正在视野中的符合要求的所有对象使用<strong>“Per Object” GPU BUFFER（一个独立的Buffer）</strong> 将其位置、缩放、uv偏移、<em>lightmapindex</em>等相关信息保存在GPU内存中，同时也会将正在视野中的符合要求的所有对象使用<strong>Constant Buffer</strong><a href="https://zhuanlan.zhihu.com/p/98642798#ref_5" target="_blank" rel="noopener">[5]</a>将材质信息保存在保存在显存中的<strong>“统一/常量缓冲器”</strong><a href="https://zhuanlan.zhihu.com/p/98642798#ref_6" target="_blank" rel="noopener">[6]</a>中。与GPU Instancing相比，因为数据不再每帧被重新创建，而且需要保存进“统一/常量缓冲区”的数据排除了各自的位置、缩放、uv偏移、<em>lightmapindex</em>等相关信息，所以缓冲区内有更多的空间可以<strong>动态地</strong>存储场景中所有渲染物体的材质信息。由于数据不再每帧被重新创建，而是动态更新，所以SRP Batcher的本质并不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本。</p>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-7b93309c00f2866639a2f7c529495608_720w.jpg" alt="img">因为不用重新创建Constant Buffer，所以本质上SRP Batcher不会降低Draw Calls的数量，它只会降低Draw Calls之间的GPU设置成本</p>
<ul>
<li><strong>无法参与加速情况</strong></li>
</ul>
<ol>
<li>对象不可以是粒子或蒙皮网格。</li>
<li>Shader中<strong>变体</strong>不一致，如下图两个<strong>相同Shader</strong>的材质，但是因为Surface Options不一致，导致<strong>变体不一样</strong>而无法合并。</li>
</ol>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-b0599861b3304d19979816413cb13a43_720w.jpg" alt="img">变体不同的不同材质</p>
<ul>
<li><strong>批处理中断情况</strong></li>
</ul>
<ol>
<li>位置不相邻且中间夹杂着<strong>不同Shader</strong>，或者<strong>不同变体</strong>的其他物体，不会进行同批处理，这种情况比较特殊，涉及到批处理的顺序，我的另一篇文章有详解。</li>
</ol>
<ul>
<li><strong>流程原理</strong></li>
</ul>
<p><img src="../../assets/images/2020-10-23-unity-optimizing-gpu/v2-6125b513800939912bb07853ae0a1f90_720w.jpg" alt="img"></p>
<hr>
<h2 id="2020年2月13日-更新：-更改对”统一-常量缓冲器“的描述，对SRP-Batcher与GPU-Instancing的实现原理进行了比较大的修改。"><a href="#2020年2月13日-更新：-更改对”统一-常量缓冲器“的描述，对SRP-Batcher与GPU-Instancing的实现原理进行了比较大的修改。" class="headerlink" title="2020年2月13日-更新： 更改对”统一/常量缓冲器“的描述，对SRP Batcher与GPU Instancing的实现原理进行了比较大的修改。"></a><strong><em>2020年2月13日-更新： 更改对”统一/常量缓冲器“的描述，对SRP Batcher与GPU Instancing的实现原理进行了比较大的修改。</em></strong></h2><blockquote>
<p><em>^ ^ 以上只是我工作中的一些小总结</em><br><em>有什么不正确的地方可以在评论告诉我</em><br><em>我的微信号是：sam2b2b</em><br><em>有想一起进步的小伙伴可以加微信逛逛圈</em></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/98642798#ref_1_0" target="_blank" rel="noopener">^</a><a href="https://gameinstitute.qq.com/community/detail/114323" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/114323</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98642798#ref_2_0" target="_blank" rel="noopener">^</a><a href="https://forum.unity.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/" target="_blank" rel="noopener">https://forum.unity.com/threads/regression-feature-not-bug-static-dynamic-batching-combining-v-buffers-but-not-draw-calls.360143/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98642798#ref_3_0" target="_blank" rel="noopener">^</a><a href="https://docs.unity3d.com/Manual/DrawCallBatching.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/DrawCallBatching.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98642798#ref_4_0" target="_blank" rel="noopener">^</a><a href="https://gameinstitute.qq.com/community/detail/114323" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/114323</a></li>
<li>^<a href="https://zhuanlan.zhihu.com/p/98642798#ref_5_0" target="_blank" rel="noopener">a</a><a href="https://zhuanlan.zhihu.com/p/98642798#ref_5_1" target="_blank" rel="noopener">b</a>Constant Buffer <a href="https://zhuanlan.zhihu.com/p/35830868" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35830868</a></li>
<li>^<a href="https://zhuanlan.zhihu.com/p/98642798#ref_6_0" target="_blank" rel="noopener">a</a><a href="https://zhuanlan.zhihu.com/p/98642798#ref_6_1" target="_blank" rel="noopener">b</a>unity将常量存储在4M的缓冲池里，并每帧循环池（这个池子被绑定到GPU上，可以在截帧工具比如XCode或者Snapdragon上看到）</li>
<li><a href="https://zhuanlan.zhihu.com/p/98642798#ref_7_0" target="_blank" rel="noopener">^</a><a href="https://blog.csdn.net/lzhq1982/article/details/88119283" target="_blank" rel="noopener">https://blog.csdn.net/lzhq1982/article/details/88119283</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/98642798#ref_8_0" target="_blank" rel="noopener">^</a>SRP Batcher 官方文档： <a href="https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw</a></li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>unity的ScreenToWorldPoint</title>
    <url>/unity-2020-10-24-ScreenToWorldPoint/</url>
    <content><![CDATA[<p>在使用Camera.main.ScreenToWorldPoint(Input.mousePosition))的時候，有時候會發現取得的是Camera的座標而不是滑鼠的座標。</p>
<p>　　因為事實上是需要提供Z參數的<br>Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, Z));<br>　　Z代表的是Depth，因此如果Z=0的話就會是Camera的transform position了，因為此時nearClip趨近於Camera，不論你畫面中哪個點都會趨近於Camera的position</p>
<p>自己做的參考圖。</p>
<p><a href="http://ref.gamer.com.tw/redir.php?url=http%3A%2F%2F3.bp.blogspot.com%2F-R7XPjFKkYxw%2FU2VzYO6WanI%2FAAAAAAAAAqs%2FFYk7Y6UuSTU%2Fs1600%2F1.png" target="_blank" rel="noopener"><img src="../../assets/images/2020-10-24-ScreenToWorldPoint/1.png" alt="img"></a></p>
<p>　　以Perspective攝影機來看，當我用ScreenToWorldPoint(Input.mousePosition)想要來取得目前滑鼠座標在世界座標的位置的時候，可以看到當設定的Ｚ值不同，不只是取得的Ｚ座標不同連ＸＹ的座標都會不同（上圖的紅點位置，在遊戲視窗中是相同的左上角）。</p>
<p>　　所以假設Ｚ值趨近於0的時候會怎樣，也就是該點座標會趨近於Camera的座標，因此當你沒有設定Ｚ值，而Ｚ值為0的時候，不管你滑鼠在哪都只會取得攝影機的座標。</p>
<p>　　解決辦法：在Perspective攝影機的狀態下Ｚ值不要為0，或是使用Camera.main.nearClipPlane來設定最短的Clip位置。</p>
<p>　　而Orthographic的攝影機呢，反而沒有這個問題，當Ｚ值設定為0的時候還是可以有相對正確的ＸＹ座標。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>URP性能测试</title>
    <url>/unity-2020-10-24-unity-urp-performance/</url>
    <content><![CDATA[<p>2d下z轴对性能的影响<br>多个摄像机对性能的影响</p>
<p>sprites-default和Unlit差不多<br>背景图像不要使用lit,太影响性能<br>大面积的图像不要使用lit</p>
<p>建立spriteatlas测试优化<br>为角色建立动态纹理</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用Unity ECS打造Reactive System？</title>
    <url>/unity-2020-11-11-how-to-build-reactive-systems-with-unity-ecs/</url>
    <content><![CDATA[<h3 id="1-使用SystemStateComponent"><a href="#1-使用SystemStateComponent" class="headerlink" title="1. 使用SystemStateComponent"></a>1. 使用SystemStateComponent</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>所谓State，含义是只能被手动删除的Component，在删除Entity后，依然留下做一些殿后工作，只有被指名要求删除的时候才会被删除。这种特性就让我们可以通过不同的Query去获得结构变化的消息。</p>
<h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol>
<li>假设我们有一个Entity，身上有两个组件，A：IComponentData 与 B: ISystemStateComponentData</li>
<li>当我们添加A组件的时候，通过Filter{ 有A无B }，我们可以在别处得知这个Entity何时被添加。在添加后手动加入B组件。</li>
<li>当我们删除Entity，或者移除A组件的时候，通过Filter { 有B无A }，同理可得知何时这个Entity被移除或是A组件被移除。</li>
</ol>
<p>更具体的实现可以在查看官方对于ParentSystem的设计。</p>
<h3 id="2-查询ComponentVersion"><a href="#2-查询ComponentVersion" class="headerlink" title="2. 查询ComponentVersion"></a>2. 查询ComponentVersion</h3><p>每当出现某Component相关的结构性变化的时候，该Component的版本就会+1 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.GetComponentVersion()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据变化"><a href="#数据变化" class="headerlink" title="数据变化"></a>数据变化</h2><p>顾名思义。方法有三种。</p>
<h3 id="1-Chunk检查"><a href="#1-Chunk检查" class="headerlink" title="1. Chunk检查"></a>1. Chunk检查</h3><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">chunk.DidChange(ArchetypeChunkComponentType, version)</span><br></pre></td></tr></table></figure>

<p>查看其内部实现</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ComponentVer &gt; LastSystemVersion )</span><br></pre></td></tr></table></figure>

<p>什么意思呢？</p>
<ol>
<li>GlobalSystemVersion为记录一个世界所有系统更新信息的版本号。在每一个系统更新<strong>之前</strong>，GSV++。</li>
<li>LastSystemVersion为系统记录自己的版本号。在某系统更新<strong>之后</strong>，它会保存GSV，含义是<strong>上次</strong>运行时的版本号，直到下次某系统更新之后，它的版本号不会更改</li>
<li>每一种Component，在System申请写入权限的时候，都会记录该System的LSV 获取方式为chunk.GetArch</li>
</ol>
<p>因此，if ( ComponentVer &gt; LSV ) 就说明该Component被修改了（有系统获得了写入权限）。翻译成大白话，就是Component是否在提供的版本号之后的时间被更新？在当前系统请求LSV的结果是上一帧该系统的版本号，如果Component被写入时的版本号大于该系统上一帧的版本号，就说明Component在此时至上一帧的某个时间点被写入。</p>
<ul>
<li>由于这个Component只有在遍历的时候申请写入权限时才会记住版本号，因此EntityManager手动更新信息是不会被记录的。</li>
<li>这个信息时效性只有一帧，从上次该系统更新后到这次更新后的一帧，因此在这次更新中，修改Component后查询是否改变，答案是True，反之为False。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ol>
<li>系统的更新顺序为A-&gt;B-&gt;C-&gt;A</li>
<li>那么GSV ：0 -&gt; 1 -&gt; 2 -&gt; 3，每个系统更新之前+1</li>
<li>当数据在B系统被写入，Component就记住了B的GSV = 1</li>
<li>当我们在第二次轮到A系统的时候监测是否Component被改动，DidChange自动使用A系统上次的GSV记录 LSV = 0 与 Component记录的信息CV = 1做对比，发现CV &gt; LSV，得知信息已经被更改了，返回True。</li>
</ol>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chunk.DidChange(InputAType, LastSystemVersion);</span><br></pre></td></tr></table></figure>

<p>注意LSV应从EntityManager.LastSystemVersion取得，并传入Job</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="keyword">struct</span> UpdateJob : IJobChunk</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> ArchetypeChunkComponentType&lt;InputA&gt; InputAType;</span><br><span class="line">   <span class="keyword">public</span> ArchetypeChunkComponentType&lt;InputB&gt; InputBType;</span><br><span class="line">   [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> ArchetypeChunkComponentType&lt;Output&gt; OutputType;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">uint</span> LastSystemVersion;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk, <span class="keyword">int</span> chunkIndex, <span class="keyword">int</span> firstEntityIndex</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">       <span class="keyword">var</span> inputAChanged = chunk.DidChange(InputAType, LastSystemVersion);</span><br><span class="line">       <span class="keyword">var</span> inputBChanged = chunk.DidChange(InputBType, LastSystemVersion);</span><br><span class="line">       <span class="keyword">if</span> (!(inputAChanged || inputBChanged))</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Query自动检查"><a href="#2-Query自动检查" class="headerlink" title="2. Query自动检查"></a>2. Query自动检查</h3><p>在声明Query的时候，特别注明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m_Group.SetFilterChanged(new ComponentType&#123; typeof(InputA), typeof(InputB)&#125;);</span><br></pre></td></tr></table></figure>

<p>这样Query就会把没被修改的ComponentType排除在外。注意，这种检查是Component层级，而不是单个Entity层级的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EntityQuery m_Group;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   m_Group = GetEntityQuery(<span class="keyword">typeof</span>(Output), </span><br><span class="line">                               ComponentType.ReadOnly&lt;InputA&gt;(), </span><br><span class="line">                               ComponentType.ReadOnly&lt;InputB&gt;());</span><br><span class="line">   m_Group.SetFilterChanged(<span class="keyword">new</span> ComponentType&#123; <span class="keyword">typeof</span>(InputA), <span class="keyword">typeof</span>(InputB)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-IJobForEach中使用-ChangeFilter"><a href="#3-IJobForEach中使用-ChangeFilter" class="headerlink" title="3. IJobForEach中使用 [ChangeFilter]"></a>3. IJobForEach中使用 [ChangeFilter]</h3><p>与Query的排除效果类似。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ProcessTendency : IJobForEachWithEntity&lt;HumanState, HumanStock&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">Entity entity, <span class="keyword">int</span> index, [ChangedFilter] <span class="keyword">ref</span> State state</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br></pre></td></tr></table></figure>

<h2 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="Best Practice"></a>Best Practice</h2><p>对自己的系统做了一些单元测试后，我觉得有几点应该记录下来。</p>
<ul>
<li>如果要做一套响应式系统循环触发，慎用EntityManager获取信息。因为EntityManager的Get系列API会直接获取写入权限。</li>
<li>Job有延迟，因此单元测试的时候，如果涉及Version，应该做一些操作“等待”正确的版本号刷新，比如Debug.Log()。</li>
<li>GetEntityQuery会在系统注册，因此在Query里SetFilterChanged即可，毋需在Execute()中再声明一遍。</li>
<li>在主线程获取DynamicBuffer的长度时，Query与EM都不能做到以只读方式做到。因此正确的做法是</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> query    = GetEntityQuery(ComponentType.ReadOnly&lt;T&gt;());</span><br><span class="line"><span class="keyword">var</span> entities  = query.ToEntityArray(Allocator.TempJob);</span><br><span class="line"><span class="keyword">var</span> entity    = entities[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> length   = EntityManager.GetChunk(entity).GetBufferAccessor(GetArchetypeChunkBufferType&lt;Tendency&gt;(<span class="literal">true</span>))[<span class="number">0</span>].Length;</span><br><span class="line">entities.Dispose();</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://link.zhihu.com/?target=https%3A//gametorrahod.com/designing-an-efficient-system-with-version-numbers/">https://gametorrahod.com/designing-an-efficient-system-with-version-numbers/</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.entities%400.0/manual/chunk_iteration_job.html">Using IJobChunk | Package Manager UI website</a></p>
<p><a href="https://medium.com/@icex33/coping-with-change-in-unity3d-ecs-45422fff8dda#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImQ5NDZiMTM3NzM3Yjk3MzczOGU1Mjg2YzIwOGI2NmU3YTM5ZWU3YzEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2MDUxMTkzMDksImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExNTYwNDIyOTcxMDAwNDczMDgwOCIsImVtYWlsIjoiemhlcGFtYUBnbWFpbC5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiMjE2Mjk2MDM1ODM0LWsxazZxZTA2MHMydHAyYTJqYW00bGpkY21zMDBzdHRnLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwibmFtZSI6IuadjuS5neS7mSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vLXlfSnhUTXJkQWk4L0FBQUFBQUFBQUFJL0FBQUFBQUFBQUFBL0FNWnV1Y25xLVNRSGVVR1FRUENfUjJ0Zk93RGh2QzRHbHcvczk2LWMvcGhvdG8uanBnIiwiZ2l2ZW5fbmFtZSI6IuS5neS7mSIsImZhbWlseV9uYW1lIjoi5p2OIiwiaWF0IjoxNjA1MTE5NjA5LCJleHAiOjE2MDUxMjMyMDksImp0aSI6IjQyM2E3NTM3NmE0YTZkNzI3ODgzYmYyZDIyMDljMGNjZTg2NDRjMTUifQ.eicZfv00n72yCqIDVFxy8XOMlWkcjychu8aPN6q9Cj61MvcJfIAAVgdREk1J5t4dpTxqN10FOZnfFxRZBnkbHFjjVLI0Lu1lYr7bE5NhxdRnjaNwbs-WQbuMHAKBeMvdKzIIeqRAswuHNlwtd_ATfON4V0v3aobOlVPOFUz3mgstb5cFhoH2oJIGTfnYj108-1_IVJRUoTo80Eii2gTEsC4frSGweQNZlu2XMnfsfRz3724NqinN7csfXXQ9zZ8vh29zHBgEUYnVh7JNOONr8A9wQY9RxI1v73HEC2YNFekuB87qCjGRpgUKGGFBaUwClpOifr9W-Z30U3t_TSgENw" target="_blank" rel="noopener">Coping with Change in Unity3D ECS | by Maxim Zaks | Medium</a></p>
<p><a href="https://www.effectiveunity.com/ecs/06-how-to-build-reactive-systems-with-unity-ecs-part-1/" target="_blank" rel="noopener">How to build reactive systems with Unity ECS: Part 1 • Effective Unity</a></p>
<p><a href="https://www.effectiveunity.com/ecs/07-how-to-build-reactive-systems-with-unity-ecs-part-2/" target="_blank" rel="noopener">https://www.effectiveunity.com/ecs/07-how-to-build-reactive-systems-with-unity-ecs-part-2/</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中Sprite和UI Image的区别</title>
    <url>/unity-2020-11-12-sprite-image-diff/</url>
    <content><![CDATA[<p>coffeecato写在前面：<br>本文确实不错，作者用以说明自动生成网格的示图非常具有代表性，从drawcall的生成过程分析性能开销的重点，引出了overdraw和达到GPU像素填充率限制的原因，从中也可以看出作者对这个主题的理解颇有深度。查看作者的个人自述，居然是个2012年毕业的小伙子，后生可畏啊！翻译本文对自己也是个考验。<br>英文水平捉急，如果错误请多多指正。</p>
<p><em>原文：<a href="https://rubentorresbonet.wordpress.com/2016/05/26/unity-sprites-spriterenderer-vs-canvasrenderer-ui-image/" target="_blank" rel="noopener">UNITY SPRITES: SPRITERENDERER VS. CANVASRENDERER (UI IMAGE)</a></em><br>翻译已征得原作者同意：<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171116103038856" alt="这里写图片描述"></p>
<p>当在一个公司项目工作时，我被问到关于sprites(SpriteRenderer)和UI image(CanvasRenderer)的区别。我没找到多少相关的信息，所以我决定在公司准备一场介绍来帮助大家把两者的区别搞清楚。本文中你将会看到一个比当时的介绍更完整的版本。运行环境是Unity5.3.4f1.</p>
<p>Sprites本质上是半透明texture，其中texture是在导入时被设置导入为sprites的。它们不是直接被应用于meshes,而是会应用于长方形/多边形（最后，它们始终是meshes，因为没有那么大的区别）。Sprites就是被渲染到2d/3d场景或者其他界面中的图片.</p>
<p><strong>1.用法</strong><br>在Unity中使用sprites很简单。只需将目标图片移动到assets文件夹下然后点击打开inspector settings.将texture type改为sprite(2D and UI),如下图：<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114233841299" alt="这里写图片描述"><br>现在你该决定将图片当成sprite使用还是作为UI Image.但是如果考虑到渲染，你可能并不确定你想要使用哪种方式。我们将会在下一节描述两种方式间的区别；现在我们大概描述一下如何在Unity中创建它们。</p>
<p>如果你想使用SpriteRenderer,将sprite从Project窗口移动到Hierarchy窗口或者Scene窗口。成功创建后的窗口应该像这样：<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114233856654" alt="这里写图片描述"><br>如果你想创建UI Image,在Hierarchy中右键然后create new UI–&gt;Image.这个控件需要canvas,如果没有canvas会自动创建一个。最后，你将看到：<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114233911906" alt="这里写图片描述"></p>
<p><strong>2.对比：SpriteRenderer vs CanvasRenderer</strong></p>
<p>在Hierarchy窗口,你可以把sprites随便放在哪。然而，UI Images不得不放在canvas下面。你可以通过transform移动其他obejcts那样移动sprites,但是images使用RectTransform来在界面系统中移动。</p>
<p>使用默认材质时，Sprites是在”Queue” = “Transparent” “RenderType” = “Geometry”(原文： transparent geometry queue)模式下渲染的。UI Images也是在这种模式下渲染的，除非你使用了Overlay 模式渲染（coffeecato补充：Canvas的Render Mode）,这种情况下它将会通过Canvas.RenderOverlay渲染。你可能会猜到，这样在移动设备上的开销很大。我们稍后会讨论到。</p>
<p>sprites和images的一个最重要的区别在于sprites支持网格的自动构造，而UI Image的网格始终由矩形构成。构造网格的原因将会在下一节讲到；我们将会看到它的重要性及它对性能的重大影响。</p>
<p>最后，两种方式都可以通过使用sprite atlases来减少draw calls.</p>
<p>下面的例子将会帮助看到二者之间的区别：<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114233924452" alt="这里写图片描述"><br>上图中可以看到，UI Image创造了一个紧密的矩形来包裹sprite,而SpriteRenderer创造了一个能更好匹配将要渲染的sprite的网格。看看另一个例子：<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114233938619" alt="这里写图片描述"><br>同样的情况出现这个例子中。但是网格这次看起来更复杂了，为什么呢？Unity尝试去为sprites构造最佳的网格来避免引入太多的多边形。可能有人会说这样的权衡到底是利是弊。</p>
<p>如果我们导入一张拥有孤岛（coffeecato补充：原文是islands）的png，一张图片包含被透明区域分隔开的图形会发生什么情况？<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114233951951" alt="这里写图片描述"></p>
<p>上图中我们看到的情况很有意思，SpriteRenderer创造了两个子网格，一个对应一个孤岛；然后UI Image只是通过扩展矩形来覆盖整个图片。</p>
<p><strong>3.性能</strong></p>
<p>你可能会猜到，上面例子显示的不同处理方式可能会导致性能的差异。当渲染很多对象时，差别会更明显（比如地形中的草，或者粒子特效）。下面我们来分析一下其中的原因。</p>
<p>当渲染texture时，设置好顶点，索引，uv坐标，纹理数据和shader参数，然后向GPU发送数据，这个过程就是著名的draw call.随后，在图片最终显示之前，一些乱七八糟的事情在GPU发生。一个简单的渲染管线通常包括：</p>
<ol>
<li>CPU 发送一个draw命令到GPU</li>
<li>GPU获取到绘制所需的所有信息</li>
<li>几何图形通过顶点着色器和光栅化被转化为像素</li>
<li>每个像素通过片元着色器被转化然后被写入到帧缓存一次或数次</li>
<li>当一帧结束时，图形会显示在你的显示器上</li>
</ol>
<p>回到主题，SpriteRenderer和UI Image之间的区别是什么？显而易见，sprites的开销更大，因为它的几何数据更复杂。但是如果我告诉你顶点操作通常比片元操作开销小的多呢？尤其对于移动设备和半透明对象。</p>
<p>在很多引擎包括Unity中，半透明材质是由后向前渲染的。那意味着，最远的物体（从camera出发）最先渲染，这样alpha混合操作才能像预期那样工作。对于不透明材质，渲染正好反过来这样便于我们剔除不可见物体。</p>
<p>像素着色器会被渲染sprite中的每一个像素都执行，因此，当存在较大的图形时（相对屏幕尺寸），片元着色器将会在很多像素上执行。问题在于，当透明物体在视锥体内时没有很有效的方法将它们剔除，因此你将会渲染所有的半透明物体即使其中的大多数最终都不可见。所以你会发现同一个像素会渲染多次，在帧缓存中也会重写多次。这个问题通常被称为<strong>overdraw</strong>.同样地，由于这种现象带来了<strong>内存带宽</strong>的浪费，会很快达到GPU <strong>像素填充率</strong>的限制，这种情况是移动设备应当极力避免的。这就是问题的关键。</p>
<p>如果你确实理解了上面一段，你将会弄明白SpriteRenderer和CanvasRenderer是多么的不同。前者通过构造网格清除了不必要的透明像素（因此，避免了执行开销巨大的片元着色器，从而避免了overdraw），然而UI Image创建了一个简单的网格很可能会引起很多overdraw。你需要在复杂的几何图形和更多的片操作之间做一个权衡。</p>
<p>你应该会想到使用sprite atlases，因为spritest通常数量很大同时尺寸很小。这会导致绘制sprites有很多drawcall.同样地，对于较大的图形，图形压缩也是不错的方法。<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114234009365" alt="这里写图片描述"></p>
<p>你可以通过Atlas Packer很方便的创建sprite atlas.同时，有时自动构造的网格性能上并不好你也无法控制它，因此你可能会使用一些性能更好的插件比如ShoeBox 或者 TexturePacker.<br><img src="../../assets/images/2020-11-12-sprite-image-diff/20171114234059641" alt="这里写图片描述"></p>
<p><strong>4.结论</strong></p>
<p>当下次再遇到sprites时，不妨考虑下面的建议：</p>
<ol>
<li>如果sprites的数量不多，想用什么用什么。如果拥有上百个sprites，重新读读本文。</li>
<li>使用profiler和frame debugger来搞清楚发生的状况。</li>
<li>避免使用透明，尽量使用不透明的物体替代透明物体。</li>
<li>避免在屏幕上渲染尺寸较大的sprites，这会引起更多的overdraw。你可以通过在Scene View中选择rendering mode为Overdraw来查看overdraw的情况。这对于粒子特效很关键。</li>
<li>选择更复杂的几何体而不是更多的像素，尤其对于移动设备。可以通过选择Scene View中的Shading Mode为shaded wireframe来查看。</li>
<li>如果需要对界面进行较多的位置操作（比如content fitter, vertical groups等）选择UI Images.</li>
<li>减少渲染区域的分辨率来查看性能有没有实质的提升，通过这种方法来判断是否达到了像素填充率的限制。</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>简单保存工具</title>
    <url>/unity-2020-11-13-simple-save/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Newtonsoft.Json;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Security.Cryptography;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace DotHass.Unity</span><br><span class="line">&#123;</span><br><span class="line">    public class SaveService : ISaveService</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your</span><br><span class="line">        &#x2F;&#x2F; encrypted values. This key must be exactly 32 characters long (256 bit).</span><br><span class="line">        public string Key &#x3D; &quot;:&#123;j%6j?E:t#&#125;G10mM%9hp5S&#x3D;%&#125;2,Y26e&quot;;</span><br><span class="line"></span><br><span class="line">        public bool Encrypt &#x3D; false;</span><br><span class="line"></span><br><span class="line">        public SaveService()</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Create a new encryption provider</span><br><span class="line">            SimpleEncryption.provider &#x3D; new RijndaelManaged</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Get the bytes from the supplied string key and use it as the provider&#39;s key</span><br><span class="line">                Key &#x3D; Encoding.ASCII.GetBytes(Key),</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Ensure that the same data is always encrypted the same way when used with the same key</span><br><span class="line">                Mode &#x3D; CipherMode.ECB</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected Task DeleteAsync(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            var fullPath &#x3D; this.GetFullPath(key);</span><br><span class="line">            this.Delete(fullPath);</span><br><span class="line">            return Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected Task SaveAsync(string key, object value)</span><br><span class="line">        &#123;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">            var fullPath &#x3D; this.GetFullPath(key);</span><br><span class="line">            var content &#x3D; JsonConvert.SerializeObject(value);</span><br><span class="line"></span><br><span class="line">            return WriteAsync(fullPath, content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected async Task&lt;T&gt; LoadAsync&lt;T&gt;(string key, T defaultValue)</span><br><span class="line">        &#123;</span><br><span class="line">            var fullPath &#x3D; this.GetFullPath(key);</span><br><span class="line"></span><br><span class="line">            if (this.Exists(fullPath) &#x3D;&#x3D; false)</span><br><span class="line">            &#123;</span><br><span class="line">                return defaultValue;</span><br><span class="line">            &#125;</span><br><span class="line">            return await LoadAsync&lt;T&gt;(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private async Task&lt;T&gt; LoadAsync&lt;T&gt;(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            var fullPath &#x3D; this.GetFullPath(key);</span><br><span class="line">            var content &#x3D; await this.ReadAsync(fullPath);</span><br><span class="line">            return JsonConvert.DeserializeObject&lt;T&gt;(content);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected string GetFullPath(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            return Path.Combine(Application.persistentDataPath, key.ToUpper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public bool Exists(string fullPath)</span><br><span class="line">        &#123;</span><br><span class="line">            return File.Exists(fullPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Delete(string fullPath)</span><br><span class="line">        &#123;</span><br><span class="line">            if (File.Exists(fullPath))</span><br><span class="line">            &#123;</span><br><span class="line">                File.Delete(fullPath);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Directory.Exists(fullPath))</span><br><span class="line">            &#123;</span><br><span class="line">                Directory.Delete(fullPath, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task WriteAsync(string fullPath, string content)</span><br><span class="line">        &#123;</span><br><span class="line">            if (this.Encrypt &#x3D;&#x3D; true)</span><br><span class="line">            &#123;</span><br><span class="line">                content &#x3D; SimpleEncryption.EncryptString(content);</span><br><span class="line">            &#125;</span><br><span class="line">            using (StreamWriter sw &#x3D; new StreamWriter(fullPath, false, Encoding.UTF8))</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;覆盖该文件</span><br><span class="line">                await sw.WriteAsync(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public async Task&lt;string&gt; ReadAsync(string fullPath)</span><br><span class="line">        &#123;</span><br><span class="line">            using (StreamReader sw &#x3D; new StreamReader(fullPath, Encoding.UTF8))</span><br><span class="line">            &#123;</span><br><span class="line">                var fetchedString &#x3D; await sw.ReadToEndAsync();</span><br><span class="line"></span><br><span class="line">                if (this.Encrypt &#x3D;&#x3D; true)</span><br><span class="line">                &#123;</span><br><span class="line">                    fetchedString &#x3D; SimpleEncryption.DecryptString(fetchedString);</span><br><span class="line">                &#125;</span><br><span class="line">                return fetchedString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Security.Cryptography;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;sabresaurus&#x2F;PlayerPrefsEditor&#x2F;blob&#x2F;master&#x2F;Runtime&#x2F;SimpleEncryption.cs</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">namespace DotHass.Unity</span><br><span class="line">&#123;</span><br><span class="line">    public static class SimpleEncryption</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; IMPORTANT: Make sure to change this key for each project you use this encryption in to help secure your</span><br><span class="line">        &#x2F;&#x2F; encrypted values. This key must be exactly 32 characters long (256 bit).</span><br><span class="line">        private static readonly string key &#x3D; &quot;:&#123;j%6j?E:t#&#125;G10mM%9hp5S&#x3D;%&#125;2,Y26C&quot;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cache the encryption provider</span><br><span class="line">        public static RijndaelManaged provider &#x3D; null;</span><br><span class="line"></span><br><span class="line">        private static void SetupProvider()</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Create a new encryption provider</span><br><span class="line">            provider &#x3D; new RijndaelManaged();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Get the bytes from the supplied string key and use it as the provider&#39;s key</span><br><span class="line">            provider.Key &#x3D; Encoding.ASCII.GetBytes(key);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Ensure that the same data is always encrypted the same way when used with the same key</span><br><span class="line">            provider.Mode &#x3D; CipherMode.ECB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Encrypts the specified string using the key stored in SimpleEncryption and returns the encrypted result</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static string EncryptString(string sourceString)</span><br><span class="line">        &#123;</span><br><span class="line">            if (provider &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Encryption provider hasn&#39;t been set up yet, so set it up</span><br><span class="line">                SetupProvider();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Create an encryptor to encrypt the bytes</span><br><span class="line">            ICryptoTransform encryptor &#x3D; provider.CreateEncryptor();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Convert the source string into bytes to be encrypted</span><br><span class="line">            byte[] sourceBytes &#x3D; Encoding.UTF8.GetBytes(sourceString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Encrypt the bytes using the encryptor we just created</span><br><span class="line">            byte[] outputBytes &#x3D; encryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Convert the encrypted bytes into a Base 64 string, so we can safely represent them as a string and return</span><br><span class="line">            &#x2F;&#x2F; that string</span><br><span class="line">            return Convert.ToBase64String(outputBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Decrypts the specified string from its specified encrypted value into the returned decrypted value using the</span><br><span class="line">        &#x2F;&#x2F;&#x2F; key stored in SimpleEncryption</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static string DecryptString(string sourceString)</span><br><span class="line">        &#123;</span><br><span class="line">            if (provider &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; Encryption provider hasn&#39;t been set up yet, so set it up</span><br><span class="line">                SetupProvider();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Create a decryptor to decrypt the encrypted bytes</span><br><span class="line">            ICryptoTransform decryptor &#x3D; provider.CreateDecryptor();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Convert the base 64 string representing the encrypted bytes back into an array of encrypted bytes</span><br><span class="line">            byte[] sourceBytes &#x3D; Convert.FromBase64String(sourceString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Use the decryptor we just created to decrypt those bytes</span><br><span class="line">            byte[] outputBytes &#x3D; decryptor.TransformFinalBlock(sourceBytes, 0, sourceBytes.Length);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Turn the decrypted bytes back into the decrypted string and return it</span><br><span class="line">            return Encoding.UTF8.GetString(outputBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Encrypts the specified float value and returns an encrypted string</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static string EncryptFloat(float value)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Convert the float into its 4 bytes</span><br><span class="line">            byte[] bytes &#x3D; BitConverter.GetBytes(value);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Represent those bytes as a base 64 string</span><br><span class="line">            string base64 &#x3D; Convert.ToBase64String(bytes);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Return the encrypted version of that base 64 string</span><br><span class="line">            return SimpleEncryption.EncryptString(base64);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Encrypts the specified int value and returns an encrypted string</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static string EncryptInt(int value)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Convert the int value into its 4 bytes</span><br><span class="line">            byte[] bytes &#x3D; BitConverter.GetBytes(value);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Represent those bytes as a base 64 string</span><br><span class="line">            string base64 &#x3D; Convert.ToBase64String(bytes);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Return the encrypted version of that base 64 string</span><br><span class="line">            return SimpleEncryption.EncryptString(base64);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; Encrypts the specified bool value and returns an encrypted string</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static string EncryptBool(bool value)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Convert the bool value into its 4 bytes</span><br><span class="line">            byte[] bytes &#x3D; BitConverter.GetBytes(value);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Represent those bytes as a base 64 string</span><br><span class="line">            string base64 &#x3D; Convert.ToBase64String(bytes);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Return the encrypted version of that base 64 string</span><br><span class="line">            return SimpleEncryption.EncryptString(base64);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Decrypts the encrypted string representing a float into the decrypted float</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static float DecryptFloat(string sourceString)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Decrypt the encrypted string</span><br><span class="line">            string decryptedString &#x3D; SimpleEncryption.DecryptString(sourceString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Convert the decrypted Base 64 representation back into bytes</span><br><span class="line">            byte[] bytes &#x3D; Convert.FromBase64String(decryptedString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Turn the bytes back into a float and return it</span><br><span class="line">            return BitConverter.ToSingle(bytes, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Decrypts the encrypted string representing an int into the decrypted int</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static int DecryptInt(string sourceString)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Decrypt the encrypted string</span><br><span class="line">            string decryptedString &#x3D; SimpleEncryption.DecryptString(sourceString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Convert the decrypted Base 64 representation back into bytes</span><br><span class="line">            byte[] bytes &#x3D; Convert.FromBase64String(decryptedString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Turn the bytes back into a int and return it</span><br><span class="line">            return BitConverter.ToInt32(bytes, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">        &#x2F;&#x2F;&#x2F; Decrypts the encrypted string representing a bool into the decrypted bool</span><br><span class="line">        &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">        public static bool DecryptBool(string sourceString)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Decrypt the encrypted string</span><br><span class="line">            string decryptedString &#x3D; SimpleEncryption.DecryptString(sourceString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Convert the decrypted Base 64 representation back into bytes</span><br><span class="line">            byte[] bytes &#x3D; Convert.FromBase64String(decryptedString);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Turn the bytes back into a bool and return it</span><br><span class="line">            return BitConverter.ToBoolean(bytes, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>sync</tag>
        <tag>UNITY</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2020-11-14-netcode</title>
    <url>/unity-2020-11-14-netcode/</url>
    <content><![CDATA[<p>We do not have a PVS (potential visibility set) system in place yet, but we do have distance based importance scaling which mostly solves the bandwidth aspect of it (but no the anit-cheat aspect). It solves it by sending things close by more frequently than things far away rather than not sending things far away.<br>My recommendation would be to start with distance based scaling and see how far it takes you. When we add a PVS solution it will probably be based on segmenting the entities into separate chunks and run the visibility logic per chunk - I guess that is closest to the subworlds you mention.</p>
<p>Distance based importance is used in asteroids and we can scale up to &gt;20.000 active entities with it as long as only a subset of those entities are close by (tested with 20.000 asteroids and 8k x 8k map). I expect it will continue scaling far beyond that but never tried.</p>
<p>The way distance based importance works is that it first segments the entities into different chunks based on a user defined grid. No entities will be in the same chunk unless they are in the same grid cell. Once we have that segmentation we run a user defined importance scaling method per chunk, where the method knows the grid position of the chunk and the grid position of the camera, and it can scale importance based on distance in grid cells.</p>
<p>The code to setup the grid segmentation is in <a href="https://github.com/Unity-Technologies/multiplayer/blob/master/sampleproject/Assets/Samples/Asteroids/GameMain.cs" target="_blank" rel="noopener">https://github.com/Unity-Technologi…eproject/Assets/Samples/Asteroids/GameMain.cs</a> - see the code doing something like entityManager.AddComponentData(grid, new GhostDistanceImportance</p>
<p>We also add a GhostConnectionPosition to all connections when going in-game and there is a system to update the position - see <a href="https://github.com/Unity-Technologies/multiplayer/blob/master/sampleproject/Assets/Samples/Asteroids/Server/Systems/UpdateConnectionPositionSystem.cs" target="_blank" rel="noopener">https://github.com/Unity-Technologi…ver/Systems/UpdateConnectionPositionSystem.cs</a></p>
<p><a href="https://docs.unity3d.com/Packages/com.unity.netcode@0.5/manual/ghost-snapshots.html#distance-based-importance" target="_blank" rel="noopener">Ghost snapshots | Unity NetCode | 0.5.0-preview.5 (unity3d.com)</a></p>
<p><a href="https://forum.unity.com/threads/unity-netcode-0-0-2-preview-1.785558/page-2" target="_blank" rel="noopener">Unity NetCode 0.0.2-preview.1 | Page 2 - Unity Forum</a></p>
<p><a href="https://forum.unity.com/threads/netcode-expected-amount-of-ghosts.790742/" target="_blank" rel="noopener">[NetCode] Expected amount of ghosts? - Unity Forum</a></p>
<p>TileCenter offsets the grid a bit. Say you want 0,0,0 to be at the border of a tile instead of in the center of a tile, you would then set TileCenter to TileSize / 2. Unless you need fine grained control over the grid alignment you can just leave it at 0.</p>
<p>The tile border is related to reducing tile changes when an entity is between two tiles. The tiles are expanded by a border to have some overlap. This overlap means that you have to go a bit (the border size) outside your current tile before you switch to a new one, so if you are the the edge between two tiles and move a little bit back and forth you will not switch tile every frame.</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>ecs中的parent</title>
    <url>/unity-2020-11-15-ecs-parent/</url>
    <content><![CDATA[<h1 id="关于转换系统"><a href="#关于转换系统" class="headerlink" title="关于转换系统"></a>关于转换系统</h1><p>ConvertToEntitySystem运行在默认世界中..每次update的时候会处理ConvertToEntity添加到system中的gameobject</p>
<p>最终调用的时候是使用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GameObjectConversionUtility.Convert(gameObjectWorld);</span><br></pre></td></tr></table></figure>

<p>  然后具体的转换过程会新疆一个转换world主要执行GameObjectConversionMappingSystem,然后转换完成后销毁这个world</p>
<ul>
<li>GameObjectConversionUtility.ConvertGameObjectHierarchy(unitView.gameObject, settings)会转换所有child.</li>
<li>GameObjectConversionMappingSystem.conversion.MappingSystem.AddGameObjectOrPrefab(root);会递归所有child</li>
</ul>
<h1 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h1><p>localtoworld是一个矩阵</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.SetComponentData(myCube, new LocalToWorld</span><br><span class="line">  &#123;</span><br><span class="line">      Value &#x3D; new float4x4(rotation: quaternion.identity, translation:new float3(1,2,3))</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:</p>
<p><img src="../../assets/images/2020-11-15-ecs-parent/v2-1eb72ea2222c31c50554021afecb27d1_1440w.jpg" alt="img"></p>
<p>使用<code>Translation</code>,<code>Rotation</code>,<code>Scale</code>/<code>NonUniformScale</code>组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 <code>Parent</code> 组件指向了父 Entity, 那么最终该 Entity 的 <code>LocalToWorld</code> 值将会和父 Entity的 LocalToWorld 一样.</p>
<p>我们新建一个场景</p>
<p><img src="../../assets/images/2020-11-15-ecs-parent/image-20201116024147417.png" alt="image-20201116024147417"></p>
<p>查看分析器.就能看到如下关系图</p>
<p><img src="../../assets/images/2020-11-15-ecs-parent/image-20201116024105067.png" alt="image-20201116024105067"></p>
<ul>
<li>CUBE   <code>child</code>,<code>physicsCollider</code></li>
<li>SPHER <code>parent</code> ,<code>localtoparent</code> ,<code>previousparent</code></li>
</ul>
<p>由于物理的转化规则,子物体没有physicscollider.</p>
<h2 id="LinkedEntityGroup"><a href="#LinkedEntityGroup" class="headerlink" title="LinkedEntityGroup"></a>LinkedEntityGroup</h2><p><code>LinkedEntityGroup</code>是一个 dynamic buffer , 通常它会影响:</p>
<ul>
<li>调用<code>Instantiate</code>方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的<code>LinkedEntityGroup</code>. 注意实例化并不一定和ECS中的<code>Prefab</code> component 直接关联.</li>
<li>调用<code>DestroyEntity</code>时也会同时销毁 <code>LinkedEntityGroup</code>中的所有 entity. 类似在编辑器中删除<code>GameObject</code></li>
<li>调用 <code>entityManager.SetEnabled</code> 加上的 <code>Disabled</code>component 会告知 ECS 的查询系统忽略它们, 而 <code>LinkedEntityGroup</code> 中的 entity 也会受到同样的影响. 有点类似禁用<code>GameObject</code> 时同时会禁用整个层级树.</li>
</ul>
<p>注意如果buffer 中的 entity 也有<code>LinkedEntityGroup</code>, 系统<strong>不会递归地</strong>执行instantiation/destroy/disabled 过程.</p>
<p>这些过程在具体执行当中也有一些细微不同.<code>Instantiate</code>和<code>SetEnabled</code>只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity <strong>必须要把自己包括在内</strong>才能正常工作<strong>.</strong> 然而<code>DestroyEntity</code>则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.</p>
<p>要注意<code>LinkedEntityGroup</code> 和 <code>Parent</code>并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.</p>
<h2 id="从非-prefab-conversion-中获取LinkedEntityGroup"><a href="#从非-prefab-conversion-中获取LinkedEntityGroup" class="headerlink" title="从非 prefab conversion 中获取LinkedEntityGroup"></a>从非 prefab conversion 中获取LinkedEntityGroup</h2><p>目前, 我们使用<code>ConvertToEntity</code>并不能得到 <code>LinkedEntityGroup</code>. 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. (<code>ConvertToEntity</code>却可以正常得到基于<code>Parent</code> 的层级结构).</p>
<p>如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareLinkedEntityGroup</span>(<span class="params">GameObject gameObject</span>)</span></span><br></pre></td></tr></table></figure>

<p>调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果).</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeConvert</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        conversionSystem.DeclareLinkedEntityGroup(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-11-15-ecs-parent/v2-fe2983f48e754c910758292e0a0dfc91_1440w.jpg" alt="img"></p>
<p>从 debbuger 现在可以看到已经正常添加了<code>LinkedEntityGroup</code>, 目前它已经支持<code>Instantiate</code>和<code>SetEnable</code> 的正常工作了:</p>
<p><img src="../../assets/images/2020-11-15-ecs-parent/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_1440w.jpg" alt="img"></p>
<p>LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.</p>
<h2 id="关于手动添加LinkedEntityGroup"><a href="#关于手动添加LinkedEntityGroup" class="headerlink" title="关于手动添加LinkedEntityGroup"></a>关于手动添加<code>LinkedEntityGroup</code></h2><p>如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:</p>
<p><img src="../../assets/images/2020-11-15-ecs-parent/v2-de0722a0a9b1b64f962e00c0655f6641_1440w.jpg" alt="img"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpecialCube</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject itsChild;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        dstManager.AddComponent&lt;LinkedEntityGroup&gt;(entity);</span><br><span class="line">        <span class="keyword">var</span> leg = dstManager.GetBuffer&lt;LinkedEntityGroup&gt;(entity);</span><br><span class="line">        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-11-15-ecs-parent/v2-50abef20adb51226bd0af6bddba9e8bb_1440w.jpg" alt="img"></p>
<p>这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用.</p>
<p><img src="../../assets/images/2020-11-15-ecs-parent/v2-287469fff9e08d15954ccf00d6b63df5_1440w.jpg" alt="img"> </p>
<h1 id="关于parent和LinkedEntityGroup"><a href="#关于parent和LinkedEntityGroup" class="headerlink" title="关于parent和LinkedEntityGroup"></a>关于parent和<code>LinkedEntityGroup</code></h1><ul>
<li>parent 涉及到localtoworld, 以及一些物理和其他的转换规则</li>
<li>linkedEntityGroup 和 <code>Instantiate</code> <code>SetEnabled</code>  <code>DestroyEntity</code> 有关</li>
</ul>
<p>被disable的组件不会被foreach到,除非主动申请选取disable</p>
<h1 id="最佳的方式去关联entity和prefab"><a href="#最佳的方式去关联entity和prefab" class="headerlink" title="最佳的方式去关联entity和prefab"></a>最佳的方式去关联entity和prefab</h1><p><a href="https://forum.unity.com/threads/hybrid-ecs-best-way-to-handle-convert-and-inject-game-object-prefab.736646/" target="_blank" rel="noopener">[Hybrid ECS] Best way to handle Convert and Inject Game Object Prefab? - Unity Forum</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"> </span><br><span class="line">public class Prefabs : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private static Prefabs m_Instance;</span><br><span class="line"> </span><br><span class="line">    public static GameObject PlayerModel &#x3D;&gt; m_Instance.playerModel;</span><br><span class="line"> </span><br><span class="line">    public GameObject playerModel;</span><br><span class="line"> </span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_Instance &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            m_Instance &#x3D; this;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;Prefab Singleton loaded twice&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Unity.Entities;</span><br><span class="line">using Unity.NetCode;</span><br><span class="line">using Unity.Transforms;</span><br><span class="line">using UnityEngine;</span><br><span class="line"> </span><br><span class="line">[UpdateInGroup(typeof(ClientSimulationSystemGroup))]</span><br><span class="line"> </span><br><span class="line">public class PlayerModelSystem : ComponentSystem</span><br><span class="line">&#123;</span><br><span class="line">    protected override void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        Entities.WithNone&lt;Transform&gt;().ForEach((Entity playerEntity, ref PlayerComponent playerComponent) &#x3D;&gt; &#123;</span><br><span class="line">            if (Prefabs.PlayerModel !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                var playerModel &#x3D; Object.Instantiate(Prefabs.PlayerModel);</span><br><span class="line">                EntityManager.AddComponentObject(playerEntity, playerModel.GetComponent&lt;Transform&gt;());</span><br><span class="line">                EntityManager.AddComponentData(playerEntity, new CopyTransformToGameObject());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://forum.unity.com/threads/unity-tech-where-is-the-simple-bridge-between-monobehaviours-and-ecs.823485/" target="_blank" rel="noopener">Unity Tech - Where is the SIMPLE Bridge Between MonoBehaviours and ECS?? - Unity Forum</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using Unity.Entities;</span><br><span class="line">using Unity.Jobs;</span><br><span class="line">using Unity.Mathematics;</span><br><span class="line">using Unity.Transforms;</span><br><span class="line">using UnityEngine;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Attach to your Game Object to be converted, the GameObjectPrefab is a pure Game Object with no conversion that may contain MonoBehaviour components such as the particle system.</span><br><span class="line">public class GameObjectPrefabAuthoring : MonoBehaviour, IConvertGameObjectToEntity</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject GameObjectPrefab;</span><br><span class="line"> </span><br><span class="line">    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)</span><br><span class="line">    &#123;</span><br><span class="line">        dstManager.AddComponentObject(entity, new GameObjectPrefab</span><br><span class="line">        &#123;</span><br><span class="line">            Value &#x3D; GameObjectPrefab</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class GameObjectPrefab : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject Value;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Instantiate and destroy the referenced prefab when the entity is created or destroyed. You can even pool the Game Object.</span><br><span class="line">public class GameObjectPrefabSystem : JobComponentSystem</span><br><span class="line">&#123;</span><br><span class="line">    public class GameObjectPrefabInstance : ISystemStateComponentData</span><br><span class="line">    &#123;</span><br><span class="line">        public GameObject Value;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    protected override JobHandle OnUpdate(JobHandle inputDeps)</span><br><span class="line">    &#123;</span><br><span class="line">        Entities</span><br><span class="line">            .WithNone&lt;GameObjectPrefabInstance&gt;()</span><br><span class="line">            .ForEach((Entity entity, GameObjectPrefab gameObjectPrefab) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var gameObjectPrefabInstance &#x3D; Object.Instantiate(gameObjectPrefab.Value);</span><br><span class="line"> </span><br><span class="line">                EntityManager.AddComponentData(entity, new GameObjectPrefabInstance</span><br><span class="line">                &#123;</span><br><span class="line">                    Value &#x3D; gameObjectPrefabInstance</span><br><span class="line">                &#125;);</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F; Just an example to make the GameObject Prefab instance follow the entity.</span><br><span class="line">                EntityManager.AddComponentObject(entity, gameObjectPrefabInstance.transform);</span><br><span class="line">                EntityManager.AddComponent&lt;CopyTransformToGameObject&gt;(entity);</span><br><span class="line">            &#125;)</span><br><span class="line">            .WithStructuralChanges()</span><br><span class="line">            .Run();</span><br><span class="line"> </span><br><span class="line">        Entities</span><br><span class="line">            .WithNone&lt;GameObjectPrefab&gt;()</span><br><span class="line">            .ForEach((Entity entity, GameObjectPrefabInstance gameObjectPrefabInstance) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                Object.Destroy(gameObjectPrefabInstance.Value);</span><br><span class="line"> </span><br><span class="line">                EntityManager.RemoveComponent&lt;GameObjectPrefabInstance&gt;(entity);</span><br><span class="line">            &#125;)</span><br><span class="line">            .WithStructuralChanges()</span><br><span class="line">            .Run();</span><br><span class="line"> </span><br><span class="line">        return default;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; A dummy system for testing purposes.</span><br><span class="line">public class DummyEntityWithGameObjectControllerSystem : JobComponentSystem</span><br><span class="line">&#123;</span><br><span class="line">    EntityQuery m_Query;</span><br><span class="line"> </span><br><span class="line">    protected override JobHandle OnUpdate(JobHandle inputDeps)</span><br><span class="line">    &#123;</span><br><span class="line">        var deltaTime &#x3D; Time.DeltaTime;</span><br><span class="line">        var speed &#x3D; 3;</span><br><span class="line">        var direction &#x3D; new float2(Input.GetAxisRaw(&quot;Horizontal&quot;), Input.GetAxisRaw(&quot;Vertical&quot;));</span><br><span class="line">        var destroy &#x3D; Input.GetKeyDown(KeyCode.Delete);</span><br><span class="line"> </span><br><span class="line">        if (destroy)</span><br><span class="line">        &#123;</span><br><span class="line">            EntityManager.DestroyEntity(m_Query);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return Entities</span><br><span class="line">            .WithStoreEntityQueryInField(ref m_Query)</span><br><span class="line">            .WithAll&lt;GameObjectPrefab&gt;()</span><br><span class="line">            .ForEach((ref Translation translation) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                translation.Value +&#x3D; math.normalizesafe(new float3(direction, 0).xzy) * speed * deltaTime;</span><br><span class="line">            &#125;)</span><br><span class="line">            .Schedule(inputDeps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2020-11-16-dotssample</title>
    <url>/unity-2020-11-16-dotssample/</url>
    <content><![CDATA[<h1 id="ability"><a href="#ability" class="headerlink" title="ability"></a>ability</h1><p>首先ability总是和item或者character结合在一起的</p>
<p>以下Authoring 会为ability加上不同的组件</p>
<ul>
<li>AbilityAutoRifleAuthoring  </li>
<li>AbilityMovementAuthoring</li>
<li>AbilitySprintAuthoring</li>
<li>AbilityDeadAuthoring</li>
<li>AbilitySelectSlotAuthoring</li>
<li>AbilityMeleeAuthoring</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateArchetype(</span><br><span class="line">typeof(Ability.AbilityControl),  &#x2F;&#x2F;控制器</span><br><span class="line">typeof(Ability.AbilityTag), &#x2F;&#x2F;技能tag( Melee,Movement,AutoRifle, SelectSlot,Dead,Sprint)</span><br><span class="line">typeof(Ability.AbilityAction),  &#x2F;&#x2F;技能动作(None,PrimaryFire,SecondaryFire,Reloading,Melee,NumActions)会通过Item关联具体值</span><br><span class="line">typeof(settings),  &#x2F;&#x2F; 技能的配置</span><br><span class="line">typeof(state), &#x2F;&#x2F; 技能状态  </span><br><span class="line">typeof(PredictedState),  &#x2F;&#x2F; 预测状态</span><br><span class="line">typeof(InterpolatedState), &#x2F;&#x2F; 插值状态</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="AbilityCollection"><a href="#AbilityCollection" class="headerlink" title="AbilityCollection"></a>AbilityCollection</h2><p><code>AbilityEntry</code>是一个IBufferElementData.存储了多个ability</p>
<p>定义了技能类型,能和什么类型一起运行,会打断什么类型</p>
<p>一个技能可能会有多个触发button,比如一把枪,会有开火键和装弹键</p>
<p>UpdateAbilityOwnership系统.. 填充character的OwnedCollection组件.分别为自己和item</p>
<p>再根据OwnedCollection填充ownedAbilities</p>
<p>PrepareOwnerForAbilityUpdate系统</p>
<p>检查ability是否启用.未启用则删除</p>
<p>SelectActiveBehavior系统</p>
<p>选择激活一个ability</p>
<h1 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateArchetype(</span><br><span class="line">typeof(Item.InputState),  &#x2F;&#x2F;输入状态</span><br><span class="line">typeof(AbilityCollection.State),   &#x2F;&#x2F;存储的是技能拥有者entity</span><br><span class="line">typeof(AbilityCollection.AbilityEntry),&#x2F;&#x2F;一个item可能有多个技能</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>Item.Initialize会查找所有拥有(Inventory.ItemEntry)的实体(就是character)</p>
<p>然后将item添加到character的Inventory.ItemEntry组件的buff中.</p>
<p>将item和character关联起来</p>
<p>Inventory.update系统</p>
<p>比较activeslot和lastactiveinventoryslot.来在item上添加和删除PartOwner.Visible组件</p>
<h1 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateArchetype(</span><br><span class="line">typeof(Settings),  &#x2F;&#x2F;角色设置</span><br><span class="line">typeof(InterpolatedData), &#x2F;&#x2F; 插值数据</span><br><span class="line">typeof(PredictedData),&#x2F;&#x2F;预测数据</span><br><span class="line">typeof(ReplicatedData),&#x2F;&#x2F; 角色类型</span><br><span class="line"></span><br><span class="line">typeof(Player.OwnerPlayerId.Default),&#x2F;&#x2F; 拥有者id</span><br><span class="line">typeof(PlayerControlled.State),&#x2F;&#x2F; 玩家控制器状态</span><br><span class="line">typeof(HitColliderOwner.State),  &#x2F;&#x2F;碰撞器状态</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Inventory</span><br><span class="line">typeof(Inventory.ItemEntry)   &#x2F;&#x2F;一个item的buff</span><br><span class="line">typeof(Inventory.State)   &#x2F;&#x2F;状态..激活的是哪一个item</span><br><span class="line">typeof(Inventory.InternalState)  &#x2F;&#x2F;最后激活的item</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生命和伤害</span><br><span class="line">typeof(HealthStateData),</span><br><span class="line">typeof(DamageEvent), &#x2F;&#x2F;注意是个buff</span><br><span class="line">typeof(DamageHistoryData),  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ability</span><br><span class="line">typeof(AbilityCollection.State),   &#x2F;&#x2F;存储的是技能拥有者entity</span><br><span class="line">typeof(AbilityCollection.AbilityEntry),&#x2F;&#x2F;一个角色可能有多个能力</span><br><span class="line">typeof(AbilityOwner.State),&#x2F;&#x2F;技能拥有者状态</span><br><span class="line">typeof(AbilityOwner.OwnedCollection),&#x2F;&#x2F;技能拥有者是个buff  拥有者有可能是角色也有可能是item</span><br><span class="line">typeof(AbilityOwner.OwnedAbility),&#x2F;&#x2F;拥有的所有技能,包括角色和item的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色控制器数据</span><br><span class="line">typeof(CharacterControllerComponentData),  &#x2F;&#x2F; 一些角色控制器数据</span><br><span class="line">typeof(CharacterControllerInitializationData),   &#x2F;&#x2F;碰撞盒数据</span><br><span class="line">typeof(CharacterControllerVelocity),</span><br><span class="line">typeof(CharacterControllerMoveQuery),</span><br><span class="line">typeof(CharacterControllerMoveResult),</span><br><span class="line">typeof(CharacterControllerGroundSupportData),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>







<h1 id="part"><a href="#part" class="headerlink" title="part"></a>part</h1><p> Part 模块是抽象”部分关系”的一种存在, 不过具体到实现来说, 就是可以用来管理角色模型, 武器模型(以及其LOD), 以角色配置为例说明下述具体用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateArchetype(</span><br><span class="line">typeof(Part.Owner),  &#x2F;&#x2F;部件拥有者</span><br><span class="line">typeof(TerraformerWeaponPart.AutoringData)  &#x2F;&#x2F;声音</span><br><span class="line">typeof(TerraformerWeaponPart.AuthoringClass)  &#x2F;&#x2F;材质,特效之类的</span><br><span class="line">typeof(TerraformerWeaponPart.State)  &#x2F;&#x2F;状态</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>同样的item和character都可以拥有part</p>
<h1 id="local-player"><a href="#local-player" class="headerlink" title="local player"></a>local player</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EntityManager.CreateArchetype(</span><br><span class="line">typeof(Player.State)  </span><br><span class="line">typeof(UserCommand)    &#x2F;&#x2F;是个buff</span><br><span class="line">typeof(LocalPlayer)  </span><br><span class="line">typeof(LocalPlayerCharacterControl.State)</span><br><span class="line"></span><br><span class="line">typeof(AbilityUIElement)</span><br><span class="line">typeof(PresentationElement)</span><br><span class="line">typeof(PlayerCameraControl.State)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>









<p>首先看<code>CharacterAuthoring</code>然后我们就知道.一个character到底有哪些东东了</p>
<p>//Assets/Unity.Sample.Terraformer/Prefabs/Characters/Terraformer/Char_Terraformer.prefab</p>
<p>SpawnCharacter</p>
<p>ItemAuthoring</p>
<h1 id="palyer-实例化流程"><a href="#palyer-实例化流程" class="headerlink" title="palyer 实例化流程"></a>palyer 实例化流程</h1><ol>
<li>客户端连接的时候,服务端PlayerModuleServer.CreatePlayerEntity 创建player实体</li>
<li>服务端根据GameMode,创建角色GameModeSystemServer.Update()</li>
<li>客户端创建localplayer.并根据系统将localplayer和character和player进行绑定</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>unity world time system</title>
    <url>/unity-2020-11-17-unity-ecs-worldtime/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Preserve]</span><br><span class="line">  [UpdateInGroup(typeof(InitializationSystemGroup))]</span><br><span class="line">  public class UpdateWorldTimeSystem : ComponentSystem</span><br><span class="line">  &#123;</span><br><span class="line">      private bool hasTickedOnce &#x3D; false;</span><br><span class="line"></span><br><span class="line">      protected override void OnUpdate()</span><br><span class="line">      &#123;</span><br><span class="line">          var currentElapsedTime &#x3D; Time.ElapsedTime;</span><br><span class="line">          var deltaTime &#x3D; math.min(UnityEngine.Time.deltaTime, World.MaximumDeltaTime);</span><br><span class="line">          World.SetTime(new TimeData(</span><br><span class="line">              elapsedTime: hasTickedOnce ? (currentElapsedTime + deltaTime) : currentElapsedTime,</span><br><span class="line">              deltaTime: deltaTime</span><br><span class="line">          ));</span><br><span class="line">          hasTickedOnce &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal struct WorldTime : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public TimeData Time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">internal struct WorldTimeQueue : IBufferElementData</span><br><span class="line">&#123;</span><br><span class="line">    public TimeData Time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>World.cs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">protected Entity TimeSingleton</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_TimeSingletonQuery.IsEmptyIgnoreFilter)</span><br><span class="line">        &#123;</span><br><span class="line">#if UNITY_EDITOR</span><br><span class="line">            var entity &#x3D; EntityManager.CreateEntity(typeof(WorldTime), typeof(WorldTimeQueue));</span><br><span class="line">            EntityManager.SetName(entity , &quot;WorldTime&quot;);</span><br><span class="line">#else</span><br><span class="line">            EntityManager.CreateEntity(typeof(WorldTime), typeof(WorldTimeQueue));</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return m_TimeSingletonQuery.GetSingletonEntity();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void SetTime(TimeData newTimeData)</span><br><span class="line">&#123;</span><br><span class="line">    EntityManager.SetComponentData(TimeSingleton, new WorldTime() &#123;Time &#x3D; newTimeData&#125;);</span><br><span class="line">    this.Time &#x3D; newTimeData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void PushTime(TimeData newTimeData)</span><br><span class="line">&#123;</span><br><span class="line">    var queue &#x3D; EntityManager.GetBuffer&lt;WorldTimeQueue&gt;(TimeSingleton);</span><br><span class="line">    queue.Add(new WorldTimeQueue() &#123; Time &#x3D; this.Time &#125;);</span><br><span class="line">    SetTime(newTimeData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void PopTime()</span><br><span class="line">&#123;</span><br><span class="line">    var queue &#x3D; EntityManager.GetBuffer&lt;WorldTimeQueue&gt;(TimeSingleton);</span><br><span class="line"></span><br><span class="line">    Assert.IsTrue(queue.Length &gt; 0, &quot;PopTime without a matching PushTime&quot;);</span><br><span class="line"></span><br><span class="line">    var prevTime &#x3D; queue[queue.Length - 1];</span><br><span class="line">    queue.RemoveAt(queue.Length - 1);</span><br><span class="line">    SetTime(prevTime.Time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.</p>
<p>ComponentSystemBase</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; The World in which this system exists.</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;value&gt;The World of this system.&lt;&#x2F;value&gt;</span><br><span class="line">public World World &#x3D;&gt; m_StatePtr !&#x3D; null ? (World)m_StatePtr-&gt;m_World.Target : null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; The current Time data for this system&#39;s world.</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public ref readonly TimeData Time &#x3D;&gt; ref World.Time;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>netcode源代码解读</title>
    <url>/unity-2020-11-18-netcode-sourcecode/</url>
    <content><![CDATA[<h1 id="NetworkStreamReceiveSystem"><a href="#NetworkStreamReceiveSystem" class="headerlink" title="NetworkStreamReceiveSystem"></a>NetworkStreamReceiveSystem</h1><ol>
<li><p>客户端连接服务端  ,服务端创建NetworkIdComponent</p>
</li>
<li><p>客户端添加NetworkStreamInGame组件,并通过rpc 发送GoInGameRequest请求</p>
</li>
<li><p>服务端接收到请求后,实例化player</p>
<ul>
<li>为player添加GhostOwnerComponent</li>
<li>初始化player添加一些其他不需要同步的组件</li>
<li>为connection添加NetworkStreamInGame组件</li>
<li>为connection设置CommandTargetComponent</li>
</ul>
</li>
<li><p>客户端根据player独有的组件特性,查找已经被ghost同步过来的实体</p>
<ul>
<li>比对NetworkIdComponent和GhostOwnerComponent的id,判断是否是localPlayer</li>
<li>对localplayer进行初始化</li>
<li>为connection设置CommandTargetComponent为localplayer</li>
</ul>
</li>
<li><p>客户端使用CommandTargetComponent的targetEntity进行command发送</p>
</li>
<li><p>客户端和服务端对传送的command同时使用PredictedGhostComponent进行预测????</p>
<ul>
<li><p>预测不是发生在客户端的吗???貌似netcode服务端也做了预测</p>
<p>在服务器上，预测循环始终仅运行一次，并且不会更新TimeData结构，因为它已经正确。它仍然设置GhostPredictionSystemGroup.PredictingTick以确保可以在客户端和服务器上运行完全相同的代码。</p>
</li>
</ul>
</li>
</ol>
<p>插值 是针对其他玩家的本地显示…预测是针对自己操作的角色,最后从服务器校正</p>
<p>延迟补偿是服务器在做的一件事情..</p>
<p>GhostReceiveSystem  接收快照</p>
<p>GhostUpdateSystem  应用快照     设置了predictionStartTick和AppliedTick</p>
<p> GhostPredictionSystemGroup   设置了 PredictingTick ,服务端永远为ServerSimulationSystemGroup.servertick</p>
<p>=======================================================================</p>
<p> 客户端的servertick在不同的两帧之间可能是相同的</p>
<p><img src="../../assets/images/2020-11-18-netcode-sourcecode/image-20201206011918426.png" alt="image-20201206011918426"></p>
<p>servertick    235</p>
<p>PredictingTick    230</p>
<p>PredictingTick    231</p>
<p>PredictingTick    232</p>
<p>PredictingTick    233</p>
<p>PredictingTick    234</p>
<p>PredictingTick    235</p>
<p>servertick    240  因为跑预测所以这里可能过了好几帧servertick这里不是236</p>
<p>PredictingTick    240  //自己先跑一下</p>
<p>servertick    240 //又可能tick增长时间还没有过</p>
<p>PredictingTick    238</p>
<p>PredictingTick    239</p>
<p>PredictingTick    240</p>
<p>实际上没多大复杂的事情..客户端发送命令给服务端,服务端处理后将tick和数据同步给客户端…</p>
<p>客户端拿到数据..该预测的预测..该插值的插值…</p>
<p>然后还需要处理这帧的自己的命令…</p>
<p>客户端:</p>
<p>Ghost数据(服务端传送的同步)–预测—输入命令–发送命令给服务端—处理命令—-覆盖同步数据(一般是覆盖自己的)–应用数据(位移,动画等)</p>
<p>服务端:</p>
<p>服务端接收到命令—处理命令—-写入Ghost数据(同步)–应用数据(位移,动画等)</p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>输入的时候, 添加发送给服务器时的servertick , </p>
<p>注意这个servertick和ServerSimulationSystemGroup.servertick没有多大关系.</p>
<p>m_ClientSimulationSystemGroup.ServerTick标记发送给服务器的命令所在的tick,以及用来接收服务器快照后(快照会包含该tick),丢弃执行过的命令,以及预测未执行的命令使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var input &#x3D; default(CubeInput);</span><br><span class="line">input.Tick &#x3D; m_ClientSimulationSystemGroup.ServerTick;</span><br><span class="line">if (Input.GetKey(&quot;a&quot;))</span><br><span class="line">    input.horizontal -&#x3D; 1;</span><br><span class="line">if (Input.GetKey(&quot;d&quot;))</span><br><span class="line">    input.horizontal +&#x3D; 1;</span><br><span class="line">if (Input.GetKey(&quot;s&quot;))</span><br><span class="line">    input.vertical -&#x3D; 1;</span><br><span class="line">if (Input.GetKey(&quot;w&quot;))</span><br><span class="line">    input.vertical +&#x3D; 1;</span><br><span class="line">var inputBuffer &#x3D; EntityManager.GetBuffer&lt;CubeInput&gt;(localInput);</span><br><span class="line">inputBuffer.AddCommandData(input);</span><br></pre></td></tr></table></figure>

<p>客户端使用服务端的快照时,将更新PredictedGhostComponent,可以看到他有两个tick,一个是应用tick,一个是预测开始的tick</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct PredictedGhostComponent : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    public uint AppliedTick;</span><br><span class="line">    public uint PredictionStartTick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端PredictedGhostComponent其中AppliedTick和PredictionStartTick永远为0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UpdateInGroup(typeof(GhostPredictionSystemGroup))]</span><br><span class="line">public class MoveCubeSystem : ComponentSystem</span><br><span class="line">&#123;</span><br><span class="line">    protected override void OnUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        var group &#x3D; World.GetExistingSystem&lt;GhostPredictionSystemGroup&gt;();</span><br><span class="line">        var tick &#x3D; group.PredictingTick;</span><br><span class="line">        var deltaTime &#x3D; Time.DeltaTime;</span><br><span class="line">        Entities.ForEach((DynamicBuffer&lt;CubeInput&gt; inputBuffer, ref Translation trans, ref PredictedGhostComponent prediction) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            if (!GhostPredictionSystemGroup.ShouldPredict(tick, prediction))</span><br><span class="line">                return;</span><br><span class="line">            CubeInput input;</span><br><span class="line">            inputBuffer.GetDataAtTick(tick, out input);</span><br><span class="line">            if (input.horizontal &gt; 0)</span><br><span class="line">                trans.Value.x +&#x3D; deltaTime;</span><br><span class="line">            if (input.horizontal &lt; 0)</span><br><span class="line">                trans.Value.x -&#x3D; deltaTime;</span><br><span class="line">            if (input.vertical &gt; 0)</span><br><span class="line">                trans.Value.z +&#x3D; deltaTime;</span><br><span class="line">            if (input.vertical &lt; 0)</span><br><span class="line">                trans.Value.z -&#x3D; deltaTime;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们看下GhostPredictionSystemGroup的源代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override void OnUpdate()</span><br><span class="line">     &#123;</span><br><span class="line">         &#x2F;&#x2F; If client, go from oldest applied predicted tick to target tick, apply. Allow filtering on latest received tick somehow</span><br><span class="line">         if (isServer)</span><br><span class="line">         &#123;</span><br><span class="line">             &#x2F;&#x2F; If server, apply once</span><br><span class="line">             var simulationSystemGroup &#x3D; World.GetExistingSystem&lt;ServerSimulationSystemGroup&gt;();</span><br><span class="line">             PredictingTick &#x3D; simulationSystemGroup.ServerTick;</span><br><span class="line">             IsFinalPredictionTick &#x3D; true;</span><br><span class="line">             base.OnUpdate();</span><br><span class="line">         &#125;</span><br><span class="line">         else</span><br><span class="line">         &#123;</span><br><span class="line">             if (predictedTickWriters.Length &gt; 1)</span><br><span class="line">             &#123;</span><br><span class="line">                 predictedTickWriters[0] &#x3D; JobHandle.CombineDependencies(predictedTickWriters);</span><br><span class="line">                 predictedTickWriters.ResizeUninitialized(1);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (predictedTickWriters.Length &gt; 0)</span><br><span class="line">                 predictedTickWriters[0].Complete();</span><br><span class="line">             predictedTickWriters.Clear();</span><br><span class="line">             uint oldestAppliedTick &#x3D; 0;</span><br><span class="line">             for (int i &#x3D; 0; i &lt; OldestPredictedTick.Length; ++i)</span><br><span class="line">             &#123;</span><br><span class="line">                 if (OldestPredictedTick[i] !&#x3D; 0)</span><br><span class="line">                 &#123;</span><br><span class="line">                     if (oldestAppliedTick &#x3D;&#x3D; 0 ||</span><br><span class="line">                         SequenceHelpers.IsNewer(oldestAppliedTick, OldestPredictedTick[i]))</span><br><span class="line">                         oldestAppliedTick &#x3D; OldestPredictedTick[i];</span><br><span class="line">                     OldestPredictedTick[i] &#x3D; 0;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             var simulationSystemGroup &#x3D; World.GetExistingSystem&lt;ClientSimulationSystemGroup&gt;();</span><br><span class="line">             var serverTick &#x3D; simulationSystemGroup.ServerTick;</span><br><span class="line">             var targetTick &#x3D; serverTick;</span><br><span class="line"></span><br><span class="line">             if (oldestAppliedTick &#x3D;&#x3D; 0 ||</span><br><span class="line">                 !SequenceHelpers.IsNewer(targetTick, oldestAppliedTick))</span><br><span class="line">                 &#x2F;&#x2F;oldestAppliedTick &#x3D; targetTick - 1;</span><br><span class="line">                 return; &#x2F;&#x2F; Nothing rolled back - nothing to predict</span><br><span class="line">             &#x2F;&#x2F; Do not try to predict more frames than we can have input for</span><br><span class="line">             if (targetTick - oldestAppliedTick &gt; CommandDataUtility.k_CommandDataMaxSize)</span><br><span class="line">                 oldestAppliedTick &#x3D; targetTick - CommandDataUtility.k_CommandDataMaxSize;</span><br><span class="line"></span><br><span class="line">             var previousTime &#x3D; Time;</span><br><span class="line">             var elapsedTime &#x3D; previousTime.ElapsedTime;</span><br><span class="line">             if (simulationSystemGroup.ServerTickFraction &lt; 1)</span><br><span class="line">             &#123;</span><br><span class="line">                 --targetTick;</span><br><span class="line">                 elapsedTime -&#x3D; simulationSystemGroup.ServerTickDeltaTime * simulationSystemGroup.ServerTickFraction;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             for (uint i &#x3D; oldestAppliedTick + 1; i !&#x3D; targetTick+1; ++i)</span><br><span class="line">             &#123;</span><br><span class="line">                 uint tickAge &#x3D; targetTick - i;</span><br><span class="line">                 World.SetTime(new TimeData(elapsedTime - simulationSystemGroup.ServerTickDeltaTime*tickAge, simulationSystemGroup.ServerTickDeltaTime));</span><br><span class="line">                 PredictingTick &#x3D; i;</span><br><span class="line">                 IsFinalPredictionTick &#x3D; (i &#x3D;&#x3D; serverTick);</span><br><span class="line">                 base.OnUpdate();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (simulationSystemGroup.ServerTickFraction &lt; 1)</span><br><span class="line">             &#123;</span><br><span class="line">                 PredictingTick &#x3D; targetTick + 1;</span><br><span class="line">                 IsFinalPredictionTick &#x3D; true;</span><br><span class="line">                 World.SetTime(new TimeData(previousTime.ElapsedTime, simulationSystemGroup.ServerTickDeltaTime *</span><br><span class="line">                                                                     simulationSystemGroup.ServerTickFraction));</span><br><span class="line">                 base.OnUpdate();</span><br><span class="line">             &#125;</span><br><span class="line">             World.SetTime(previousTime);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到从开始值不断的改变PredictingTick进行预测,然后执行了base.OnUpdate()</p>
<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>插值就是将网络玩家显示在过去的某个时刻</p>
<p>假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。</p>
<h3 id="Translation和Rotation的转换"><a href="#Translation和Rotation的转换" class="headerlink" title="Translation和Rotation的转换"></a>Translation和Rotation的转换</h3><p>Unity.NetCode.Editor.GhostAuthoringComponentEditor</p>
<p>中添加了Translation和Rotation的转换,只有被转换的才会被传输..如果不想转换可以在code gen window中勾掉Unity.Transforms..auto compile也勾掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void InitDefaultOverrides()</span><br><span class="line">    &#123;</span><br><span class="line">        GhostDefaultOverrides &#x3D; new Dictionary&lt;string, GhostComponent&gt;();</span><br><span class="line">        AssembliesDefaultOverrides &#x3D; new HashSet&lt;string&gt;(new []&#123;</span><br><span class="line">            &quot;Unity.NetCode&quot;,</span><br><span class="line">            &quot;Unity.Transforms&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        var comp &#x3D; new GhostComponent</span><br><span class="line">        &#123;</span><br><span class="line">            name &#x3D; &quot;Unity.Transforms.Translation&quot;,</span><br><span class="line">            attribute &#x3D; new GhostComponentAttribute&#123;PrefabType &#x3D; GhostPrefabType.All, OwnerPredictedSendType &#x3D; GhostSendType.All, SendDataForChildEntity &#x3D; false&#125;,</span><br><span class="line">            fields &#x3D; new GhostComponentField[]</span><br><span class="line">            &#123;</span><br><span class="line">                new GhostComponentField</span><br><span class="line">                &#123;</span><br><span class="line">                    name &#x3D; &quot;Value&quot;,</span><br><span class="line">                    attribute &#x3D; new GhostFieldAttribute&#123;Quantization &#x3D; 100, Interpolate &#x3D; true&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            entityIndex &#x3D; 0</span><br><span class="line">        &#125;;</span><br><span class="line">        GhostDefaultOverrides.Add(comp.name, comp);</span><br><span class="line">        comp &#x3D; new GhostComponent</span><br><span class="line">        &#123;</span><br><span class="line">            name &#x3D; &quot;Unity.Transforms.Rotation&quot;,</span><br><span class="line">            attribute &#x3D; new GhostComponentAttribute&#123;PrefabType &#x3D; GhostPrefabType.All, OwnerPredictedSendType &#x3D; GhostSendType.All, SendDataForChildEntity &#x3D; false&#125;,</span><br><span class="line">            fields &#x3D; new GhostComponentField[]</span><br><span class="line">            &#123;</span><br><span class="line">                new GhostComponentField</span><br><span class="line">                &#123;</span><br><span class="line">                    name &#x3D; &quot;Value&quot;,</span><br><span class="line">                    attribute &#x3D; new GhostFieldAttribute&#123;Quantization &#x3D; 1000, Interpolate &#x3D; true&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            entityIndex &#x3D; 0</span><br><span class="line">        &#125;;</span><br><span class="line">        GhostDefaultOverrides.Add(comp.name, comp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这里使用了GhostFiled并且将其设置为Interpolate..我们在看下他生成的code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">[MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]</span><br><span class="line">private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ref var snapshotInterpolationData &#x3D; ref GhostComponentSerializer.TypeCast&lt;SnapshotData.DataAtTick&gt;(snapshotData, snapshotStride*i);</span><br><span class="line">        ref var snapshotBefore &#x3D; ref GhostComponentSerializer.TypeCast&lt;Snapshot&gt;(snapshotInterpolationData.SnapshotBefore, snapshotOffset);</span><br><span class="line">        ref var snapshotAfter &#x3D; ref GhostComponentSerializer.TypeCast&lt;Snapshot&gt;(snapshotInterpolationData.SnapshotAfter, snapshotOffset);</span><br><span class="line">        float snapshotInterpolationFactor &#x3D; snapshotInterpolationData.InterpolationFactor;</span><br><span class="line">        ref var component &#x3D; ref GhostComponentSerializer.TypeCast&lt;Unity.Transforms.Translation&gt;(componentData, componentStride*i);</span><br><span class="line">        var deserializerState &#x3D; GhostComponentSerializer.TypeCast&lt;GhostDeserializerState&gt;(stateData, 0);</span><br><span class="line">        deserializerState.SnapshotTick &#x3D; snapshotInterpolationData.Tick;</span><br><span class="line">        component.Value &#x3D; math.lerp(</span><br><span class="line">            new float3(snapshotBefore.Value_x * 0.01f, snapshotBefore.Value_y * 0.01f, snapshotBefore.Value_z * 0.01f),</span><br><span class="line">            new float3(snapshotAfter.Value_x * 0.01f, snapshotAfter.Value_y * 0.01f, snapshotAfter.Value_z * 0.01f),</span><br><span class="line">            snapshotInterpolationFactor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到在读取快照的时候使用了snapshotInterpolationFactor进行插值,SnapshotData类中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public unsafe bool GetDataAtTick(uint targetTick, float targetTickFraction, in DynamicBuffer&lt;SnapshotDataBuffer&gt; buffer, out DataAtTick data)</span><br><span class="line">      &#123;</span><br><span class="line">          data &#x3D; default;</span><br><span class="line">          if (buffer.Length &#x3D;&#x3D; 0)</span><br><span class="line">              return false;</span><br><span class="line">          var numBuffers &#x3D; buffer.Length &#x2F; SnapshotSize;</span><br><span class="line">          int beforeIdx &#x3D; 0;</span><br><span class="line">          uint beforeTick &#x3D; 0;</span><br><span class="line">          int afterIdx &#x3D; 0;</span><br><span class="line">          uint afterTick &#x3D; 0;</span><br><span class="line">          &#x2F;&#x2F; If last tick is fractional before should not include the tick we are targeting, it should instead be included in after</span><br><span class="line">          if (targetTickFraction &lt; 1)</span><br><span class="line">              --targetTick;</span><br><span class="line">          byte* snapshotData;</span><br><span class="line">          &#x2F;&#x2F; Loop from latest available to oldest available snapshot</span><br><span class="line">          for (int slot &#x3D; 0; slot &lt; numBuffers; ++slot)</span><br><span class="line">          &#123;</span><br><span class="line">              var curIndex &#x3D; (LatestIndex + GhostSystemConstants.SnapshotHistorySize - slot) % GhostSystemConstants.SnapshotHistorySize;</span><br><span class="line">              snapshotData &#x3D; (byte*)buffer.GetUnsafePtr() + curIndex * SnapshotSize;</span><br><span class="line">              uint tick &#x3D; *(uint*)snapshotData;</span><br><span class="line">              if (tick &#x3D;&#x3D; 0)</span><br><span class="line">                  continue;</span><br><span class="line">              if (SequenceHelpers.IsNewer(tick, targetTick))</span><br><span class="line">              &#123;</span><br><span class="line">                  afterTick &#x3D; tick;</span><br><span class="line">                  afterIdx &#x3D; curIndex;</span><br><span class="line">              &#125;</span><br><span class="line">              else</span><br><span class="line">              &#123;</span><br><span class="line">                  beforeTick &#x3D; tick;</span><br><span class="line">                  beforeIdx &#x3D; curIndex;</span><br><span class="line">                  break;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (beforeTick &#x3D;&#x3D; 0)</span><br><span class="line">          &#123;</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          data.SnapshotBefore &#x3D; (System.IntPtr)((byte*)buffer.GetUnsafePtr() + beforeIdx * SnapshotSize);</span><br><span class="line">          data.Tick &#x3D; beforeTick;</span><br><span class="line">          if (afterTick &#x3D;&#x3D; 0)</span><br><span class="line">          &#123;</span><br><span class="line">              data.SnapshotAfter &#x3D; data.SnapshotBefore;</span><br><span class="line">              data.InterpolationFactor &#x3D; 0;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              data.SnapshotAfter &#x3D; (System.IntPtr)((byte*)buffer.GetUnsafePtr() + afterIdx * SnapshotSize);</span><br><span class="line">              data.InterpolationFactor &#x3D; (float) (targetTick - beforeTick) &#x2F; (float) (afterTick - beforeTick);</span><br><span class="line">              if (targetTickFraction &lt; 1)</span><br><span class="line">                  data.InterpolationFactor +&#x3D; targetTickFraction &#x2F; (float) (afterTick - beforeTick);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>在其中计算了InterpolationFactor.</p>
<p>无论是插值和预测都是先读取快照.我们看下GhostUpdateSystem</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Execute(ArchetypeChunk chunk, int chunkIndex, int firstEntityIndex, DynamicComponentTypeHandle* ghostChunkComponentTypesPtr, int ghostChunkComponentTypesLength)</span><br><span class="line">           &#123;</span><br><span class="line">               bool predicted &#x3D; chunk.Has(predictedGhostComponentType);</span><br><span class="line">               uint targetTick &#x3D; predicted ? predictedTargetTick : interpolatedTargetTick;</span><br><span class="line">               float targetTickFraction &#x3D; predicted ? 1.0f : interpolatedTargetTickFraction;</span><br></pre></td></tr></table></figure>

<p>预测使用的是predictedTargetTick,插值使用的是interpolatedTargetTick</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interpolatedTargetTick &#x3D; m_ClientSimulationSystemGroup.InterpolationTick,</span><br><span class="line">               interpolatedTargetTickFraction &#x3D; m_ClientSimulationSystemGroup.InterpolationTickFraction,</span><br><span class="line"></span><br><span class="line">               predictedTargetTick &#x3D; m_ClientSimulationSystemGroup.ServerTick,</span><br></pre></td></tr></table></figure>

<p>而他们又都来自m_ClientSimulationSystemGroup,m_ClientSimulationSystemGroup的tick又来自NetworkTimeSystem</p>
<h3 id="ClientServerTickRate"><a href="#ClientServerTickRate" class="headerlink" title="ClientServerTickRate"></a>ClientServerTickRate</h3><p>RpcSetNetworkId</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[BurstCompile]</span><br><span class="line">       [AOT.MonoPInvokeCallback(typeof(RpcExecutor.ExecuteDelegate))]</span><br><span class="line">       private static void InvokeExecute(ref RpcExecutor.Parameters parameters)</span><br><span class="line">       &#123;</span><br><span class="line">           var rpcData &#x3D; default(RpcSetNetworkId);</span><br><span class="line">           var rpcSerializer &#x3D; default(RpcSetNetworkId);</span><br><span class="line">           rpcSerializer.Deserialize(ref parameters.Reader, parameters.DeserializerState, ref rpcData);</span><br><span class="line"></span><br><span class="line">           parameters.CommandBuffer.AddComponent(parameters.JobIndex, parameters.Connection, new NetworkIdComponent &#123;Value &#x3D; rpcData.nid&#125;);</span><br><span class="line">           var ent &#x3D; parameters.CommandBuffer.CreateEntity(parameters.JobIndex);</span><br><span class="line">           parameters.CommandBuffer.AddComponent(parameters.JobIndex, ent, new ClientServerTickRateRefreshRequest</span><br><span class="line">           &#123;</span><br><span class="line">               MaxSimulationStepsPerFrame &#x3D; rpcData.simMaxSteps,</span><br><span class="line">               NetworkTickRate &#x3D; rpcData.netTickRate,</span><br><span class="line">               SimulationTickRate &#x3D; rpcData.simTickRate</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>服务端在同步networkid的时候会一起同步ClientServerTickRate</p>
<p>客户端会比服务端多一个NetworkTimeSystem根据往返时间和最近从服务器收到的快照来计算服务器时间的初始估计</p>
<p>来看下插值tick的计算..他首先是算出predictTargetTick然后减去一个插值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var idiff &#x3D; (uint)currentInterpolationFrames;</span><br><span class="line">           interpolateTargetTick &#x3D; predictTargetTick - idiff;</span><br><span class="line">           var subidiff &#x3D; currentInterpolationFrames - idiff;</span><br><span class="line">           subidiff -&#x3D; subInterpolateTargetTick+subPredictTargetTick;</span><br><span class="line">           if (subidiff &lt; 0)</span><br><span class="line">           &#123;</span><br><span class="line">               ++interpolateTargetTick;</span><br><span class="line">               subidiff &#x3D; -subidiff;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (subidiff &gt; 0)</span><br><span class="line">           &#123;</span><br><span class="line">               idiff &#x3D; (uint)subidiff;</span><br><span class="line">               subidiff -&#x3D; idiff;</span><br><span class="line">               interpolateTargetTick -&#x3D; idiff;</span><br><span class="line">               subidiff &#x3D; 1f-subidiff;</span><br><span class="line">           &#125;</span><br><span class="line">           subInterpolateTargetTick &#x3D; subidiff;</span><br></pre></td></tr></table></figure>

<p>它是根据网络延迟算出一个tick,然后从快照中取出…</p>
<h1 id="补偿"><a href="#补偿" class="headerlink" title="补偿"></a>补偿</h1><h1 id="GhostSendSystem"><a href="#GhostSendSystem" class="headerlink" title="GhostSendSystem"></a>GhostSendSystem</h1><p>以下皆为脑补:</p>
<p>发送的时候根据ghost的设置,来判断发送给该用户的数据(ghosts),其中谁是插值,谁是预测..因为插值和预测的包应该是有区别的..</p>
<p>接收的时候再根据是否预测,还是插值.进行PredictedGhostComponent的设置</p>
<h2 id="GHOST"><a href="#GHOST" class="headerlink" title="GHOST"></a>GHOST</h2><p>GhostAuthoringComponent验证的时候会生成prefabId</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    if (gameObject.transform.parent &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F; The common case is a root object in a prefab, in this case we always validate the guid to detect cloned files</span><br><span class="line">                var prefabStage &#x3D; UnityEditor.Experimental.SceneManagement.PrefabStageUtility.GetPrefabStage(gameObject);</span><br><span class="line">                if (prefabStage !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">#if UNITY_2020_1_OR_NEWER</span><br><span class="line">                    var assetPath &#x3D; prefabStage.assetPath;</span><br><span class="line">#else</span><br><span class="line">                    var assetPath &#x3D; prefabStage.prefabAssetPath;</span><br><span class="line">#endif</span><br><span class="line">                    guid &#x3D; UnityEditor.AssetDatabase.AssetPathToGUID(assetPath);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (UnityEditor.PrefabUtility.GetPrefabAssetType(gameObject) !&#x3D; UnityEditor.PrefabAssetType.NotAPrefab)</span><br><span class="line">                &#123;</span><br><span class="line">                    var path &#x3D; UnityEditor.AssetDatabase.GetAssetPath(gameObject);</span><br><span class="line">                    if (String.IsNullOrEmpty(path))</span><br><span class="line">                        return;</span><br><span class="line">                    guid &#x3D; UnityEditor.AssetDatabase.AssetPathToGUID(path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (guid !&#x3D; prefabId)</span><br><span class="line">            &#123;</span><br><span class="line">                UnityEditor.Undo.RecordObject(this, &quot;&quot;);</span><br><span class="line">                prefabId &#x3D; guid;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>GhostAuthoringConversion,会为prefab根据client和server添加各种组件ghost, Snapshot</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  var ghostType &#x3D; new GhostTypeComponent();</span><br><span class="line">  ghostType.guid0 &#x3D; Convert.ToUInt32(ghostAuthoring.prefabId.Substring(0, 8), 16);</span><br><span class="line">  ghostType.guid1 &#x3D; Convert.ToUInt32(ghostAuthoring.prefabId.Substring(8, 8), 16);</span><br><span class="line">  ghostType.guid2 &#x3D; Convert.ToUInt32(ghostAuthoring.prefabId.Substring(16, 8), 16);</span><br><span class="line">  ghostType.guid3 &#x3D; Convert.ToUInt32(ghostAuthoring.prefabId.Substring(24, 8), 16);</span><br><span class="line">  DstEntityManager.AddComponentData(entity, ghostType);</span><br><span class="line">                  </span><br><span class="line">                  </span><br><span class="line">                  </span><br><span class="line">                  </span><br><span class="line">DstEntityManager.AddComponentData(entity, new GhostComponent());</span><br></pre></td></tr></table></figure>

<p>默认一定会添加的组件:</p>
<p>客户端会添加 snapshotData和snapshotDataBuffer</p>
<p>服务端会添加PredictedGhostComponent,GhostSystemStateComponent,sharedGhostTypeComponent</p>
<p>[GhostComponent(PrefabType=GhostPrefabType.Client)] 可以控制服务端和客户端是否添加该组件</p>
<p>他会同步ghost prefab..根据ghostid..然后客户端.根据ghostid实例化ghost</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct SpawnedGhost : IEquatable&lt;SpawnedGhost&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public int ghostId;</span><br><span class="line">    public uint spawnTick;</span><br><span class="line">    public override int GetHashCode()</span><br><span class="line">    &#123;</span><br><span class="line">        return ghostId;</span><br><span class="line">    &#125;</span><br><span class="line">    public bool Equals(SpawnedGhost ghost)</span><br><span class="line">    &#123;</span><br><span class="line">        return ghost.ghostId &#x3D;&#x3D; ghostId &amp;&amp; ghost.spawnTick &#x3D;&#x3D; spawnTick;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>同步</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>pitch yaw roll是什么</title>
    <url>/unity-2020-11-29-pitch-yaw-roll/</url>
    <content><![CDATA[<p>三维空间的右手笛卡尔坐标如图1所示。</p>
<p><img src="../../assets/images/2020-11-29-pitch-yaw-roll/20140401183456562" alt="img"></p>
<p>图1</p>
<p>在航空中，pitch, yaw, roll如图2所示。</p>
<p>pitch是围绕X轴旋转，也叫做俯仰角，如图3所示。</p>
<p>yaw是围绕Y轴旋转，也叫偏航角，如图4所示。</p>
<p>roll是围绕Z轴旋转，也叫翻滚角，如图5所示。</p>
<p><img src="../../assets/images/2020-11-29-pitch-yaw-roll/20140401183507359" alt="img"></p>
<p>图2</p>
<p><img src="../../assets/images/2020-11-29-pitch-yaw-roll/20140401183518578" alt="img"></p>
<p>图3-pitch是围绕X轴旋转</p>
<p><img src="../../assets/images/2020-11-29-pitch-yaw-roll/20140401183525562" alt="img"></p>
<p>图4-yaw是围绕Y轴旋转</p>
<p><img src="../../assets/images/2020-11-29-pitch-yaw-roll/20140401183537890" alt="img"></p>
<p>图5-roll是围绕Z轴旋转</p>
<p>绕三个轴的旋转值pitch，yaw，roll来自航空界的叫法，翻译为俯仰角，偏航角，翻滚角，非常形象。<br>从英文意思出发，roll:是卷；滚动，转动；辗的意思；<br>yaw是（火箭、飞机、宇宙飞船等）偏航的意思；<br>pitch是坠落；倾斜；投掷的意思；<br>所以，roll的意思是翻滚，就是绕着机身所在的那个轴。yaw是偏航的意思，偏航就是绕着重力方向为轴。pitch倾斜、坠落的意思（头朝地坠落）。</p>
<p>另外值得注意的是，pitch值是不能超过90度，这里牵扯到了万向锁的知识，不再多说，网上很多讨论。</p>
<p>下面这张图是以摄像机的角度来阐述欧拉角的，可以加深理解。</p>
<p><img src="../../assets/images/2020-11-29-pitch-yaw-roll/20151125212621964" alt="img"></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>A Native Collection has not been disposed, resulting in a memory leak. Allocated from:</title>
    <url>/unity-2020-12-20-Collection-has-not-been-disposed/</url>
    <content><![CDATA[<p><img src="../../assets/images/2020-12-20-unity-/20201110091446.png" alt="f:id:sugar_affordance:20201110091446p:plain"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A Native Collection has not been disposed, resulting in a memory leak. Enable Full StackTraces to get more details.</span><br></pre></td></tr></table></figure>

<h3 id="启用堆栈跟踪"><a href="#启用堆栈跟踪" class="headerlink" title="启用堆栈跟踪"></a><a href="http://d.hatena.ne.jp/keyword/%A5%B9%A5%BF%A5%C3%A5%AF%A5%C8%A5%EC%A1%BC%A5%B9" target="_blank" rel="noopener">启用</a>堆栈跟踪</h3><p>单击 Unity 菜单中的 Jobs &gt; Leak Detection &gt; Full Stack Traces 以选中它。还有记得重启unity</p>
<p><img src="../../assets/images/2020-12-20-unity-/20201110091520.png" alt="f:id:sugar_affordance:20201110091520p:plain"></p>
<p>然后，控制台中的错误内容将显示内存<a href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF" target="_blank" rel="noopener">泄漏</a>发生在数据保留位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A Native Collection has not been disposed, resulting in a memory leak. Allocated from:</span><br><span class="line">Unity.Entities.BlobAssetStore:.ctor() (at Library&#x2F;PackageCache&#x2F;com.unity.entities@0.16.0-preview.21&#x2F;Unity.Entities.Hybrid&#x2F;GameObjectConversion&#x2F;BlobAssetStore.cs:26)</span><br><span class="line">CreateEntitySystem:Setup(Transform) (at Assets&#x2F;0_MainAssets&#x2F;Scripts&#x2F;ECS&#x2F;System&#x2F;CreateEntitySystem.cs:116)</span><br></pre></td></tr></table></figure>

<h4 id="关于分配器"><a href="#关于分配器" class="headerlink" title="关于分配器"></a>关于分配器</h4><p>NativeContainer（如 NativeArray）在 Dispose 中未释放内存时，会根据某些条件<a href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF" target="_blank" rel="noopener">检测</a>为内存泄漏。 条件<strong>因分配器</strong>的类型而异，分配器是 Allocator.TempJob，在确保本机 Array 时指定。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">NativeArray&lt;<span class="keyword">float</span>&gt; leakArray = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, Allocator.TempJob);</span><br></pre></td></tr></table></figure>

<p>这是一个详细的解释。</p>
<p><a href="https://docs.unity3d.com/ja/current/Manual/JobSystemNativeContainer.html" target="_blank" rel="noopener">NativeContainer - Unity 手册</a></p>
<p><strong>如果 Allocator.Temp</strong>在函数中没有 Dispose， 否则内存<a href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF" target="_blank" rel="noopener">泄漏</a>，</p>
<p><strong>确定 Allocator.TempJob</strong>必须在<br>4 帧内释放， 否则内存<a href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF" target="_blank" rel="noopener">泄漏确定</a>__Allocator.Persistent 将永久保留，<a href="http://d.hatena.ne.jp/keyword/%A5%E1%A5%E2%A5%EA%A5%EA%A1%BC%A5%AF" target="_blank" rel="noopener">并且不会</a>检测到内存泄漏。</p>
<h3 id="用-using-括起来，确保内存安全"><a href="#用-using-括起来，确保内存安全" class="headerlink" title="用 using 括起来，确保内存安全"></a>用 using 括起来，确保内存安全</h3><p>知道泄漏的位置后，我们只是将变量放在 Dispose 中，但<strong>建议在 using<a href="http://d.hatena.ne.jp/keyword/%A5%B9%A5%C6%A1%BC%A5%C8%A5%E1%A5%F3%A5%C8" target="_blank" rel="noopener">语句</a></strong>中括起来。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (NativeArray&lt;<span class="keyword">float</span>&gt; leakArray = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, Allocator.TempJob)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 処理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当您离开块时，将自动释放变量。<br>当有多个变量时，请并排排列它们。</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (NativeArray&lt;ArchetypeChunk&gt; chunks = AnimationBatcherQuery.CreateArchetypeChunkArray(Allocator.TempJob))</span><br><span class="line"><span class="keyword">using</span> (NativeArray&lt;<span class="keyword">float</span>&gt; leakArray = <span class="keyword">new</span> NativeArray&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, Allocator.TempJob)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 処理</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://d.hatena.ne.jp/keyword/C%23" target="_blank" rel="noopener">从 C#</a>8 开始，您可以在 Coco 中并排编写句点，但 Unity 现在<a href="http://d.hatena.ne.jp/keyword/C%23" target="_blank" rel="noopener">像 C#</a>7.3 一样，将来会起作用吗？</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>使用柏林噪声算法生成地图</title>
    <url>/unity-2021-01-20-Perlin-map/</url>
    <content><![CDATA[<p>柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得<a href="http://mrl.nyu.edu/~perlin/doc/oscar.html" target="_blank" rel="noopener">奥斯卡科技成果奖</a>（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的<a href="http://mrl.nyu.edu/~perlin/noise/" target="_blank" rel="noopener">改进版柏林噪声算法</a>。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。<br>如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。</p>
<p><a href="https://images2015.cnblogs.com/blog/608996/201707/608996-20170721155322355-1352334868.png" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/608996-20170721155322355-1352334868.png" alt="img"></a></p>
<p>正如图所示，柏林噪声算法可以用来模拟许多自然中的噪声现象。接下来让我们从数理上分析算法的实现原理。</p>
<hr>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理#"></a>基本原理#</h1><blockquote>
<p>注意：事先声明，本节内容大多源于<a href="http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html" target="_blank" rel="noopener">this wonderful article by Matt Zucker</a>，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。</p>
</blockquote>
<p>让我们从最基本的柏林噪声函数看起：<br><code>public double perlin(double x, double y, double z);</code></p>
<p>函数接收<code>x,y,z</code>三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值<code>x,y,z</code>的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-bfbbc85ed4afee99.png?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-bfbbc85ed4afee99.png" alt="img"></a><br><em>图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点</em></p>
<p>接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。</p>
<blockquote>
<p>举个例子来理解伪随机，比如我们从圆周率π（3.14159…）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。</p>
</blockquote>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-ad4b0120e857b5d3.png?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-ad4b0120e857b5d3.png" alt="img"></a><br><em>图2：各顶点上的梯度向量随机选取结果</em></p>
<p>请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成：<br><code>(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)</code></p>
<p>采用这些特殊梯度向量的原因在<a href="http://mrl.nyu.edu/~perlin/paper445.pdf" target="_blank" rel="noopener">Ken Perlin’s SIGGRAPH 2002 paper: Improving Noise</a>这篇文章里有具体讲解。</p>
<blockquote>
<p>注意：许多介绍柏林噪声算法的文章都是根据最初版柏林噪声算法来讲解的，预定义的梯度表不是本文所说的这12个向量。如图2所示的梯度向量就是最初版算法所随机出来的梯度向量，不过这两种算法的原理都是一样的。</p>
</blockquote>
<p>接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-6dde06b2b941253d.png?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-6dde06b2b941253d.png" alt="img"></a><br><em>图3:各个距离向量</em></p>
<p>接着，对每个顶点的梯度向量和距离向量做<a href="https://en.wikipedia.org/wiki/Dot_product" target="_blank" rel="noopener">点积</a>运算，我们就可以得出每个顶点的影响值：<br><code>grad.x * dist.x + grad.y * dist.y + grad.z * dist.z</code></p>
<p>这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dot(vec1,vec2) &#x3D; cos(angle(vec1,vec2)) * vec1.length * vec2.length</span><br></pre></td></tr></table></figure>

<p>换句话说，如果两向量指向同一方向，点积结果为：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 * vec1.length * vec2.length</span><br></pre></td></tr></table></figure>

<p>如果两向量指向相反方向，则点积结果为：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 * vec1.length * vec2.length</span><br></pre></td></tr></table></figure>

<p>如果两向量互相垂直，则点积结果为0。</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 * vec1.length * vec2.length</span><br></pre></td></tr></table></figure>

<p>点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。下面通过一副彩色图，直观地看下各顶点的影响值：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-0c7ca0db2126715a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-0c7ca0db2126715a.png" alt="img"></a><br><em>图4：2D柏林噪声的影响值</em></p>
<p>下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Below are 4 influence values in the arrangement:</span><br><span class="line">&#x2F;&#x2F; [g1] | [g2]</span><br><span class="line">&#x2F;&#x2F; -----------</span><br><span class="line">&#x2F;&#x2F; [g3] | [g4]</span><br><span class="line">int g1, g2, g3, g4;</span><br><span class="line">int u, v;   &#x2F;&#x2F; These coordinates are the location of the input coordinate in its unit square.  </span><br><span class="line">            &#x2F;&#x2F; For example a value of (0.5,0.5) is in the exact center of its unit square.</span><br><span class="line"></span><br><span class="line">int x1 &#x3D; lerp(g1,g2,u);</span><br><span class="line">int x2 &#x3D; lerp(g3,h4,u);</span><br><span class="line"></span><br><span class="line">int average &#x3D; lerp(x1,x2,v);</span><br></pre></td></tr></table></figure>

<p>至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数：<strong>fade函数</strong>，通常也被称为<strong>ease curve</strong>(也作为缓动函数在游戏中广泛使用)：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-27f5e6997742a89a.png?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-27f5e6997742a89a.png" alt="img"></a><br><em>图5：ease curve</em></p>
<p>ease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif" alt="img"></a></p>
<p>基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。</p>
<hr>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现#"></a>代码实现#</h1><p>在本节开始前我需要重申一遍，代码实现是C#版本。相比<a href="http://mrl.nyu.edu/~perlin/noise/" target="_blank" rel="noopener">Ken Perlin的Java版本实现</a>做了小小的改动，主要是增加了代码的整洁性和可读性，支持噪声重复（瓦片重复）特性。代码完全开源，可免费使用（考虑到这毕竟不是我原创发明的算法 - Ken Perlin才是！）</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作##"></a>准备工作##</h2><p>第一步，我们需要先声明一个排列表（permutation table），或者直接缩写为<code>p[]</code>数组就行了。数组长度为256，分别随机、无重复地存放了0-255这些数值。为了避免缓存溢出，我们再重复填充一次数组的值，所以数组最终长度为512：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static readonly int[] permutation &#x3D; &#123; 151,160,137,91,90,15,                 &#x2F;&#x2F; Hash lookup table as defined by Ken Perlin.  This is a randomly</span><br><span class="line">    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,    &#x2F;&#x2F; arranged array of all numbers from 0-255 inclusive.</span><br><span class="line">    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,</span><br><span class="line">    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,</span><br><span class="line">    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,</span><br><span class="line">    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,</span><br><span class="line">    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,</span><br><span class="line">    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,</span><br><span class="line">    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,</span><br><span class="line">    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,</span><br><span class="line">    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,</span><br><span class="line">    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,</span><br><span class="line">    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">private static readonly int[] p;                                                    &#x2F;&#x2F; Doubled permutation to avoid overflow</span><br><span class="line"></span><br><span class="line">static Perlin() &#123;</span><br><span class="line">    p &#x3D; new int[512];</span><br><span class="line">    for(int x&#x3D;0;x&lt;512;x++) &#123;</span><br><span class="line">        p[x] &#x3D; permutation[x%256];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>p[]</code>数组会在算法后续的哈希计算中使用到，用于确定一组输入最终挑选哪个梯度向量（从前面所列出的12个梯度向量中挑选）。后续代码会详细展示<code>p[]</code>数组的用法。</p>
<p>接着，我们开始编写柏林噪声函数：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double perlin(double x, double y, double z) &#123;</span><br><span class="line">    if(repeat &gt; 0) &#123;                                    &#x2F;&#x2F; If we have any repeat on, change the coordinates to their &quot;local&quot; repetitions</span><br><span class="line">        x &#x3D; x%repeat;</span><br><span class="line">        y &#x3D; y%repeat;</span><br><span class="line">        z &#x3D; z%repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int xi &#x3D; (int)x &amp; 255;                              &#x2F;&#x2F; Calculate the &quot;unit cube&quot; that the point asked will be located in</span><br><span class="line">    int yi &#x3D; (int)y &amp; 255;                              &#x2F;&#x2F; The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that</span><br><span class="line">    int zi &#x3D; (int)z &amp; 255;                              &#x2F;&#x2F; plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.</span><br><span class="line">    double xf &#x3D; x-(int)x;</span><br><span class="line">    double yf &#x3D; y-(int)y;</span><br><span class="line">    double zf &#x3D; z-(int)z;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码很直观。首先，对输入坐标使用求余运算符%，求出[0,repeat)范围内的余数。紧接着声明<code>xi, yi, zi</code>三个变量。它们代表了输入坐标落在了哪个单元正方形里。我们还要限制坐标在[0,255]这个范围内，避免访问数组<code>p[]</code>时，出现数组越界错误。这也产生了一个副作用：柏林噪声每隔256个整数就会再次重复。但这不是太大的问题，因为算法不仅能处理整数，还能处理小数。最后，我们通过<code>xf, yf, zf</code>三个变量（也就是<code>x,y,z</code>的小数部分值），确定了输入坐标在单元正方形里的空间位置（就是前面所示的小蓝点）。</p>
<h2 id="Fade函数"><a href="#Fade函数" class="headerlink" title="Fade函数##"></a>Fade函数##</h2><p>现在我们需要用代码表示前面所提到的fade函数（图5）。正如上文所提，函数的数学表示：<br><a href="https://upload-images.jianshu.io/upload_images/1797904-05b271d52d2bee24.gif?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-05b271d52d2bee24.gif" alt="img"></a></p>
<p>代码实现如下：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static double fade(double t) &#123;</span><br><span class="line">                                                        &#x2F;&#x2F; Fade function as defined by Ken Perlin.  This eases coordinate values</span><br><span class="line">                                                        &#x2F;&#x2F; so that they will ease towards integral values.  This ends up smoothing</span><br><span class="line">                                                        &#x2F;&#x2F; the final output.</span><br><span class="line">    return t * t * t * (t * (t * 6 - 15) + 10);         &#x2F;&#x2F; 6t^5 - 15t^4 + 10t^3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double perlin(double x, double y, double z) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    double u &#x3D; fade(xf);</span><br><span class="line">    double v &#x3D; fade(yf);</span><br><span class="line">    double w &#x3D; fade(zf);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码所计算得出的<code>u / v / w</code>变量将在后面的插值计算中使用到。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数##"></a>哈希函数##</h2><p>柏林噪声哈希函数用于给每组输入计算返回一个唯一、确定值。哈希函数在维基百科的定义如下：</p>
<blockquote>
<p>哈希函数是一种从任何一种数据中创建小的数字“指纹”的方法，输入数据有任何细微的不同，都会令输出结果完全不一样</p>
</blockquote>
<p>下面代码就是柏林噪声算法所使用的哈希函数。它使用了早前我们声明的<code>p[]</code>数组：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double perlin(double x, double y, double z) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    int aaa, aba, aab, abb, baa, bba, bab, bbb;</span><br><span class="line">    aaa &#x3D; p[p[p[    xi ]+    yi ]+    zi ];</span><br><span class="line">    aba &#x3D; p[p[p[    xi ]+inc(yi)]+    zi ];</span><br><span class="line">    aab &#x3D; p[p[p[    xi ]+    yi ]+inc(zi)];</span><br><span class="line">    abb &#x3D; p[p[p[    xi ]+inc(yi)]+inc(zi)];</span><br><span class="line">    baa &#x3D; p[p[p[inc(xi)]+    yi ]+    zi ];</span><br><span class="line">    bba &#x3D; p[p[p[inc(xi)]+inc(yi)]+    zi ];</span><br><span class="line">    bab &#x3D; p[p[p[inc(xi)]+    yi ]+inc(zi)];</span><br><span class="line">    bbb &#x3D; p[p[p[inc(xi)]+inc(yi)]+inc(zi)];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int inc(int num) &#123;</span><br><span class="line">    num++;</span><br><span class="line">    if (repeat &gt; 0) num %&#x3D; repeat;</span><br><span class="line">    </span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的哈希函数，对包围着输入坐标（小蓝点）的周围8个单元正方形的索引坐标进行了哈希计算。<code>inc()</code>函数用于将输入值增加1，同时保证范围在[0,repeat)内。如果不需要噪声重复，<code>inc()</code>函数可以简化成单纯将输入值增加1。由于哈希结果值是从<code>p[]</code>数组中得到的，所以哈希函数的返回值范围限定在[0,255]内。</p>
<h2 id="梯度函数"><a href="#梯度函数" class="headerlink" title="梯度函数##"></a>梯度函数##</h2><p>我时常认为Ken Perlin的最初版算法里的<code>grad()</code>函数写法过于复杂，令人费解。我们只要明白<code>grad()</code>函数的作用在于计算随机选取的梯度向量以及顶点位置向量的点积。Ken Perlin巧妙地使用了位翻转(bit-flipping)技巧来实现：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static double grad(int hash, double x, double y, double z) &#123;</span><br><span class="line">    int h &#x3D; hash &amp; 15;                                    &#x2F;&#x2F; Take the hashed value and take the first 4 bits of it (15 &#x3D;&#x3D; 0b1111)</span><br><span class="line">    double u &#x3D; h &lt; 8 &#x2F;* 0b1000 *&#x2F; ? x : y;                &#x2F;&#x2F; If the most significant bit (MSB) of the hash is 0 then set u &#x3D; x.  Otherwise y.</span><br><span class="line">    </span><br><span class="line">    double v;                                             &#x2F;&#x2F; In Ken Perlin&#39;s original implementation this was another conditional operator (?:).  I</span><br><span class="line">                                                          &#x2F;&#x2F; expanded it for readability.</span><br><span class="line">    </span><br><span class="line">    if(h &lt; 4 &#x2F;* 0b0100 *&#x2F;)                                &#x2F;&#x2F; If the first and second significant bits are 0 set v &#x3D; y</span><br><span class="line">        v &#x3D; y;</span><br><span class="line">    else if(h &#x3D;&#x3D; 12 &#x2F;* 0b1100 *&#x2F; || h &#x3D;&#x3D; 14 &#x2F;* 0b1110*&#x2F;)  &#x2F;&#x2F; If the first and second significant bits are 1 set v &#x3D; x</span><br><span class="line">        v &#x3D; x;</span><br><span class="line">    else                                                  &#x2F;&#x2F; If the first and second significant bits are not equal (0&#x2F;1, 1&#x2F;0) set v &#x3D; z</span><br><span class="line">        v &#x3D; z;</span><br><span class="line">    </span><br><span class="line">    return ((h&amp;1) &#x3D;&#x3D; 0 ? u : -u)+((h&amp;2) &#x3D;&#x3D; 0 ? v : -v); &#x2F;&#x2F; Use the last 2 bits to decide if u and v are positive or negative.  Then return their addition.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码则是以另一种令人容易理解的方式完成了这个任务（而且在很多语言版本的运行效率都优于前面一种）：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Source: http:&#x2F;&#x2F;riven8192.blogspot.com&#x2F;2010&#x2F;08&#x2F;calculate-perlinnoise-twice-as-fast.html</span><br><span class="line">public static double grad(int hash, double x, double y, double z)</span><br><span class="line">&#123;</span><br><span class="line">    switch(hash &amp; 0xF)</span><br><span class="line">    &#123;</span><br><span class="line">        case 0x0: return  x + y;</span><br><span class="line">        case 0x1: return -x + y;</span><br><span class="line">        case 0x2: return  x - y;</span><br><span class="line">        case 0x3: return -x - y;</span><br><span class="line">        case 0x4: return  x + z;</span><br><span class="line">        case 0x5: return -x + z;</span><br><span class="line">        case 0x6: return  x - z;</span><br><span class="line">        case 0x7: return -x - z;</span><br><span class="line">        case 0x8: return  y + z;</span><br><span class="line">        case 0x9: return -y + z;</span><br><span class="line">        case 0xA: return  y - z;</span><br><span class="line">        case 0xB: return -y - z;</span><br><span class="line">        case 0xC: return  y + x;</span><br><span class="line">        case 0xD: return -y + z;</span><br><span class="line">        case 0xE: return  y - x;</span><br><span class="line">        case 0xF: return -y - z;</span><br><span class="line">        default: return 0; &#x2F;&#x2F; never happens</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的源码可以<a href="http://riven8192.blogspot.com/2010/08/calculate-perlinnoise-twice-as-fast.html" target="_blank" rel="noopener">点击这里</a>查看。无论如何，上面的两种实现并没有实质差别。他们都是从以下12个向量里随机挑选一个作为梯度向量：<br><code>(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)</code></p>
<p>随机挑选结果其实取决于前一步所计算得出的哈希值（<code>grad()</code>函数的第一个参数）。后面3个参数则代表由输入点指向顶点的距离向量（最终拿来与梯度向量进行点积）。</p>
<h2 id="插值整合"><a href="#插值整合" class="headerlink" title="插值整合##"></a>插值整合##</h2><p>经过前面的几步计算，我们得出了8个顶点的影响值，并将它们进行平滑插值，得出了最终结果：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double perlin(double x, double y, double z) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    double x1, x2, y1, y2;</span><br><span class="line">    x1 &#x3D; lerp(    grad (aaa, xf  , yf  , zf),           &#x2F;&#x2F; The gradient function calculates the dot product between a pseudorandom</span><br><span class="line">                grad (baa, xf-1, yf  , zf),             &#x2F;&#x2F; gradient vector and the vector from the input coordinate to the 8</span><br><span class="line">                u);                                     &#x2F;&#x2F; surrounding points in its unit cube.</span><br><span class="line">    x2 &#x3D; lerp(    grad (aba, xf  , yf-1, zf),           &#x2F;&#x2F; This is all then lerped together as a sort of weighted average based on the faded (u,v,w)</span><br><span class="line">                grad (bba, xf-1, yf-1, zf),             &#x2F;&#x2F; values we made earlier.</span><br><span class="line">                  u);</span><br><span class="line">    y1 &#x3D; lerp(x1, x2, v);</span><br><span class="line"></span><br><span class="line">    x1 &#x3D; lerp(    grad (aab, xf  , yf  , zf-1),</span><br><span class="line">                grad (bab, xf-1, yf  , zf-1),</span><br><span class="line">                u);</span><br><span class="line">    x2 &#x3D; lerp(    grad (abb, xf  , yf-1, zf-1),</span><br><span class="line">                  grad (bbb, xf-1, yf-1, zf-1),</span><br><span class="line">                  u);</span><br><span class="line">    y2 &#x3D; lerp (x1, x2, v);</span><br><span class="line">    </span><br><span class="line">    return (lerp (y1, y2, w)+1)&#x2F;2;                      &#x2F;&#x2F; For convenience we bind the result to 0 - 1 (theoretical min&#x2F;max before is [-1, 1])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Linear Interpolate</span><br><span class="line">public static double lerp(double a, double b, double x) &#123;</span><br><span class="line">    return a + x * (b - a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="利用倍频实现更自然的噪声"><a href="#利用倍频实现更自然的噪声" class="headerlink" title="利用倍频实现更自然的噪声#"></a>利用倍频实现更自然的噪声#</h1><p>最后让我们再思考下，除了前面所讲的计算，还有其他办法可以令噪声结果更加自然吗？虽然柏林噪声算法一定程度上模拟了自然噪声，但仍没有完全表现出自然噪声的不规律性。举个现实例子，现实地形会有大段连绵、高耸的山地，也会有丘陵和蚀坑，更小点的有大块岩石，甚至更小的鹅卵石块，这都属于地形的一部分。那如何让柏林噪声算法模拟出这样的自然噪声特性，解决方法也很简单：我们可以使用不同的频率（frequencies）和振幅（amplitudes）参数进行多几次柏林噪声计算，然后将结果叠加在一起。频率是指采样数据的间隔，振幅是指返回值的幅度范围。</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-6f96e55ed8d87b04.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-6f96e55ed8d87b04.png" alt="img"></a><br><em>图6：不同频率和振幅参数下的柏林噪声结果</em></p>
<p>将所有结果叠加在一起，我们就能得到以下结果：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-c69b2bf9e253defb.png?imageMogr2/auto-orient/strip" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-c69b2bf9e253defb.png" alt="img"></a><br><em>图7：图6所有噪声的叠加结果</em></p>
<p>很明显，这样的噪声结果更加令人信服。上面的6组噪声被称之为噪声的不同<strong>倍频(Octave)</strong>。随着倍频增大，噪声对于最终叠加噪声的影响程度变小。当然，倍频组数的增加，会线性地增加代码执行时间，在游戏运行时使用噪声算法，再好不要使用超过几组倍频（比如，当你想在60fps下模拟火焰特效时，最好不要这么干）。然而，做数据预处理时，就很适合使用多组倍频叠加来模拟更自然的噪声（比如用于提前生成游戏地形等）。</p>
<p>那我们应该分别挑选多大的频率和振幅来进行噪声计算呢？这个可以通过<strong>persistence</strong>参数确定。<a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm" target="_blank" rel="noopener">Hugo Elias</a>对persistence的定义使用如下：</p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-b7093e0ea840d56c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-b7093e0ea840d56c.png" alt="img"></a></p>
<p><a href="https://upload-images.jianshu.io/upload_images/1797904-006ffe9e12825253.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240" target="_blank" rel="noopener"><img src="../../assets/images/2021-01-20-Perlin-map/1797904-006ffe9e12825253.png" alt="img"></a></p>
<p>以上公式<code>i</code>的值取决于倍频数量，代码实现也很简单：</p>
<p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public double OctavePerlin(double x, double y, double z, int octaves, double persistence) &#123;</span><br><span class="line">    double total &#x3D; 0;</span><br><span class="line">    double frequency &#x3D; 1;</span><br><span class="line">    double amplitude &#x3D; 1;</span><br><span class="line">    double maxValue &#x3D; 0;  &#x2F;&#x2F; Used for normalizing result to 0.0 - 1.0</span><br><span class="line">    for(int i&#x3D;0;i&lt;octaves;i++) &#123;</span><br><span class="line">        total +&#x3D; perlin(x * frequency, y * frequency, z * frequency) * amplitude;</span><br><span class="line">        </span><br><span class="line">        maxValue +&#x3D; amplitude;</span><br><span class="line">        </span><br><span class="line">        amplitude *&#x3D; persistence;</span><br><span class="line">        frequency *&#x3D; 2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return total&#x2F;maxValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="UNITY"><a href="#UNITY" class="headerlink" title="UNITY"></a>UNITY</h1>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>地图</tag>
        <tag>Java</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>波函数坍塌算法生成地图</title>
    <url>/unity-2021-01-21-wave-collapse-function/</url>
    <content><![CDATA[<h2 id="什么是“波函数坍塌”？"><a href="#什么是“波函数坍塌”？" class="headerlink" title="什么是“波函数坍塌”？"></a>什么是“波函数坍塌”？</h2><p>这个名字看起来是来自量子力学，意思应该是只有在真正观察时，粒子的状态才能被确定，要不然是不确定的，其实并不确定这个解释对不对，物理就够难了，更何况是量子力学。不过呢，很多事物都只是被赋予了高大上的名字，但是实际上根本没有看起来那么复杂。</p>
<p>这里所说的“波函数坍塌”实际上是一种贴图以及模型合成技术（texture synthesize or model synthesize），所谓贴图是指数字动画中被贴在物体表面的图片，模型则是这些物体的模型。在2d里，模型一般就是一个二维的封闭区域，3d则是一个有特定形状的物体。贴图模型合成技术的研究和应用已经有很多年的历史了，只是直到今天才有了一个比较霸气的名字而已。</p>
<p>开发这些模型或者贴图合成技术是为了能使用一块很小的由人工制作的贴图或者模型来生成大量相似的贴图或者模型。这样可以有效的减少人工作业，提升效率。当然可能有人会有这样的疑问，现在基于GAN的AI看起来能够生成又是动画又是图片的，还有这种技术存在的必要吗? 答案当然是有存在的必要，首先GAN需要海量的样本去训练，有生成这么多样本的劲，大概早就做完游戏了，其次是AI生成的不一定能满足业务需求，而且使用者并没有调教的可能性，而在做贴图或者模型合成时，实际上只需要一个样本就可以完成所有的工作了。接下来要简要介绍下基本的原理。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>“波函数坍塌“主要是依赖于样本相邻各点的布局结构，以这些结构作为特征，在一个更大的空间上生成满足样本结构约束的新数据。</p>
<p>以贴图合成为例，假设在输入贴图中有且仅有一点坐标是 x,y，颜色为<img src="../../assets/images/2021-01-21-wave-collapse-function/6.svg" alt="[公式]"> ，上下左右四个点的颜色分别是 <img src="../../assets/images/2021-01-21-wave-collapse-function/5.svg" alt="[公式]"> 。那么在输出贴图中，如果存在一点颜色为 <img src="../../assets/images/2021-01-21-wave-collapse-function/6.svg" alt="[公式]"> ，那么它的上下左右四个点的颜色必须是 <img src="../../assets/images/2021-01-21-wave-collapse-function/5.svg" alt="[公式]"> 。</p>
<p>实际上我们可以建立更复杂的相邻布局约束，比如说以贴图中某个点周围的不仅上下左右，还有对角线上的4个点，总共八个点建立约束条件，甚至是上下左右四个点的上下左右总共12个点。不过本文只会探讨受上下左右四个点约束的情况。</p>
<p>所以我们的算法就是根据输入贴图提供的这种约束关系来生成输出贴图。这是一个搜索的过程，实际上是一个np hard问题，也就是说，只有当我们搜索了所有的可能性时，才一定能获得一个结果，当然这个结果可能是成功合成贴图，也可能是失败了，当对最终生成图片存在外界约束时，会有更大的可能性失败。</p>
<p>虽然以贴图为例来说明，但是本文的初衷是为了能够生2d游戏的地图，所以接下来将仅介绍2d下的离散模型合成技术。在2d游戏开发中，一般会用瓦片（tiles）贴图来构成地图，其中瓦片会有特定的几何形状，然后通过瓦片的放置来完成地图。本文以及提供的代码只会考虑正方形的瓦片，对于正方形瓦片来说就和上面的解释完全一致了。</p>
<p>最后不得不列一下我觉得还蛮重要的公式，该公式描述了上文中提及的一致性约束。</p>
<p>设输入模型为 E，输出模型为 M ，那么当 M与 E 一致时，则对于 M中任意一点 x ，存在 <img src="../../assets/images/2021-01-21-wave-collapse-function/8.svg" alt="[公式]"> ，且 <img src="../../assets/images/2021-01-21-wave-collapse-function/8.svg" alt="[公式]"> 属于 E ，满足：</p>
<p><img src="../../assets/images/2021-01-21-wave-collapse-function/7.svg" alt="[公式]"></p>
<p>其中， x 是 M中一点，而 <img src="../../assets/images/2021-01-21-wave-collapse-function/8.svg" alt="[公式]"> 是 E中一点， <img src="../../assets/images/2021-01-21-wave-collapse-function/9.svg" alt="[公式]"> 则是几何纬度上正负向的单位向量，3维下是 <img src="../../assets/images/2021-01-21-wave-collapse-function/4.svg" alt="[公式]"> ，2维下则是 <img src="../../assets/images/2021-01-21-wave-collapse-function/3.svg" alt="[公式]"> 。</p>
<p>接下来当然是要介绍具体的算法了。但是首先还是需要将问题重新描述一下。</p>
<h2 id="描述问题"><a href="#描述问题" class="headerlink" title="描述问题"></a>描述问题</h2><p>我们需要通过一个样例模型，然后给予一个种子来生成一个更大的模型。在2d情况下，模型会被描述为一个二维矩阵，矩阵中的每个点都是一个非负整数，不同的整数代表一个瓦片的种类，0表示空瓦片。我们需要设定输出模型的大小比如一个10*10的矩阵，然后通过一个特定的种子来生成随机数，根据这个随机数去遍历所有的可能性并找到一个合适的解。</p>
<p>所以我们的程序至少需要做下面几件事：</p>
<ol>
<li>载入瓦片信息，种类编号和瓦片的图片。</li>
<li>载入输入模型信息，即输入模型矩阵，矩阵的值为瓦片种类id，然后分析输入模型，得到约束条件矩阵。</li>
<li>根据约束矩阵，以及随机数去搜索输出模型。</li>
<li>输出（可视化）输出模型。</li>
</ol>
<p>显然，第三步是最为麻烦的，也是最困难的，其次是第二步，我们需要得到一个约束矩阵，然后第一和第四步都是常规操作。</p>
<h2 id="获得约束矩阵"><a href="#获得约束矩阵" class="headerlink" title="获得约束矩阵"></a>获得约束矩阵</h2><p>约束矩阵描述了在输入模型中，相邻点的布局关系。当我们为输出模型布局时，我们可以在某一点填入一个特定的瓦片id，然后当填充这个瓦片相邻的四个瓦片时，通过查询约束矩阵，我们可以知道在当前瓦片id下，它上方的位置只能是特定的几个id。同理就可以推导出其他三个瓦片能够选择的id。</p>
<p>所以当生成一个2d模型时，需要4个约束矩阵，分别代表x轴正向，负向，和y轴正向，负向的约束。每个约束矩阵的长度为总的瓦片id数，宽度也是总的瓦片id数，其值为bool或者是0或1，用来表示当当前点上的瓦片id是某个值时，其相邻对应位置瓦片允许的值。</p>
<p>写个简单的例子，对于输入模型矩阵 <img src="../../assets/images/2021-01-21-wave-collapse-function/2.svg" alt="[公式]"> 的正的右侧，也就是x轴正方向，可以得到如下的约束规则：0-1，1-2，2-3，2-1，1-0，0-0。整理成矩阵也就是 <img src="../../assets/images/2021-01-21-wave-collapse-function/1.svg" alt="[公式]"> ，这个矩阵等于它的转置矩阵，然后我们会有4个类似这样的约束矩阵对应不同方向的邻居，我们使用当前的瓦片id去查询就可以得到相邻瓦片允许填入的瓦片id了。</p>
<h2 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h2><p>搜索算法部分是最为困难的部分了。我们需要保存一个记录矩阵（catalog），该矩阵与最终输出模型大小相同，比如输出模型是10<em>10的这个记录矩阵也是10</em>10的。在这个记录矩阵中，每个元素会是一个集合，表示当前该点可以填入的瓦片id的集合，当该点可填入瓦片id集合为空集时，说明走了一条错误的路径，需要回退。然后我们的搜索算法会按照之前走过来的路径回退到上一个操作点，同时这个记录矩阵也需要回退相应的步数。</p>
<p>对于记录矩阵的回退，需要记录一个类似数据库的ahead log的东西，来记录所有对记录矩阵的操作，当产生回退时，只需要沿着这log向前恢复就可以。</p>
<p>对于搜索算法的前进和回退，在我参考的论文里没有提及具体的方式，经过一段时间的尝试，我建立了一颗树来记录搜索的路径，当产生回退时，树的当前节点会被标记为不可通行，便不会向这片树枝搜索了。</p>
<p><img src="../../assets/images/2021-01-21-wave-collapse-function/v2-37deccf09bca15112c03e8169fc3c525_720w.jpg" alt="img"></p>
<p>如上图所示，灰色的节点表示还没探索到，实际上还不在树里，红色的节点表示需要回退的节点。蓝色的节点表示已探索或者待探索的节点，绿色的箭头表示已经探索的路径。</p>
<p>五边形节点表示根节点，一旦在根节点发生回退说明，搜索失败，并没有找到合适的输出模型。正方形节点表示选择点操作，当游标在正方形节点上时，等于选取该节点记录的点为当前点。圆形节点则表示，为当前点选择了一个特定的瓦片，该瓦片的种类取决于记录矩阵在该点允许的选择，然后会根据约束矩阵，更新记录矩阵，当发现更新后记录矩阵存在空集便会回退。</p>
<p>最终会有如下的搜索过程：</p>
<ol>
<li>建立搜索树，找到所有的点，并将其放在根节点下边，随机选一个节点，将游标移动到该节点，设定该节点对应的点为当前节点，然后根据记录矩阵中的值，随机选择一个瓦片填入，并根据约束矩阵更新记录矩阵。</li>
<li>找到剩余所有没有瓦片的点，将这些节点加入当前节点后面，然后将根据这些点与当前所选中的点的距离，计算一个权重，离得最近的会被最先搜索，如果没有新的节点可以选择，则生成成功。</li>
<li>根据权重和生成的随机数以及选择一个节点，根据记录矩阵在该点的瓦片集合以及随机数为该节点选择一个瓦片，然后根据约束矩阵以及当前选择去更新记录矩阵中相邻点的记录：</li>
<li>如果更新中发现某相邻点可选瓦片为空，则需要回退到上一个圆形节点，与此同时记录矩阵也要回退上一个圆形节点之后的操作，并将该节点标为禁止通行，并返回第2步，如果发现当前节点在根节点，则生成失败。</li>
<li>如果不为空，则根据随机数选择一个瓦片填入，并根据约束矩阵更新记录矩阵，然后返回第2步。</li>
</ol>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&amp;yidian_docid=0M2y2bvM" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66416593?edition=yidianzixun&amp;yidian_docid=0M2y2bvM</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/65495333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65495333</a></li>
<li><a href="https://github.com/mxgmn/WaveFunctionCollapse" target="_blank" rel="noopener">https://github.com/mxgmn/WaveFunctionCollapse</a></li>
<li><a href="https://github.com/BorisTheBrave/DeBroglie" target="_blank" rel="noopener">https://github.com/BorisTheBrave/DeBroglie</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>地图</tag>
        <tag>游戏开发</tag>
      </tags>
  </entry>
  <entry>
    <title>文明6地图生成算法</title>
    <url>/unity-2021-01-22-civ-map/</url>
    <content><![CDATA[<p>作者：哈里叔叔<br>链接：<a href="https://www.zhihu.com/question/52019284/answer/1476187895" target="_blank" rel="noopener">https://www.zhihu.com/question/52019284/answer/1476187895</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="对称性对抗游戏简介"><a href="#对称性对抗游戏简介" class="headerlink" title="对称性对抗游戏简介"></a>对称性对抗游戏简介</h3><p>对称性对抗游戏是指参与游戏的玩家所拥有的资源、交互方式、受制规则、最终目标是相同或相近的，是一种公平、对称的零和游戏。如《英雄无敌》《文明》《卡坦岛》等游戏。</p>
<p>我们参考文明的4X要素<a href="#ref_1">[1]</a>搭建了一个多人回合制战略游戏，如下图所示：地图开始被“战争迷雾”所覆盖。玩家必须派遣探险者进入这片迷雾中，以揭露要扩张的土地，要开发的资源以及要消灭的对手。</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-9c3f623a46a9e27b84fa3bc74cbc54bd_720w.jpg" alt="img"></p>
<h3 id="地图的平衡性指标"><a href="#地图的平衡性指标" class="headerlink" title="地图的平衡性指标"></a>地图的平衡性指标</h3><p>我们参考<a href="#ref_2">[2]</a><a href="#ref_3">[3]</a>两篇参考文献制定出评估对称性对抗游戏地图平衡性的两点指标。</p>
<p><strong>1. 战略特征（Strategic Feature）</strong></p>
<p>战略特征是指玩家在游戏中可以利用的战略资源。 战略特征的平衡是指每一名玩家在一定时间内获得基本相同的资源（包括类型和数量）。</p>
<p>下面两张图显示了两名玩家战略特征不平衡的情况，蓝色玩家初始时可以获得更多的矿产资源，而黄色玩家的出生点附近几乎没有矿产资源，这会导致游戏初期黄色玩家的发展受限。</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-c217513044c65234f7773e83f2aefd8f_720w.jpg" alt="img"></p>
<p><strong>2. 玩家占位符（player placeholder）</strong></p>
<p>玩家初始的出生点占位的分布也会影响游戏的平衡性。</p>
<p>下面两张图显示了玩家初始占位符分布密度不同导致游戏性不平衡的情况。左图的玩家初始分布密集，这会导致这个地区的玩家在游戏前期相互碾压、发展受限；而右图中的黄色玩家在游戏前期缺少竞争，能够更好地发展自身建设。</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-af9bc4a5e3c7c7d7d5c674d76a5510e0_720w.jpg" alt="img"></p>
<p>除了以上两点对游戏平衡性的影响之外，战略游戏地图的随机地图还要考虑到：地图的美观性、根据玩家的偏好定制参数、生成地图的效率等要求。</p>
<h3 id="地图的生成过程"><a href="#地图的生成过程" class="headerlink" title="地图的生成过程"></a>地图的生成过程</h3><p><strong>1. 根据玩家的偏好定制地图参数</strong></p>
<p>在新建游戏之前，我们会让玩家根据自己的喜好定制地图参数，包括地图的尺寸、玩家的总数量、地图的类型（盘古大陆、大洲、海岛群）、水体比例、植被比例、岩石比例与资源的比例等。</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-4a2127dcc15dabf1b2a6da2d5964035d_720w.jpg" alt="img"></p>
<p><strong>2. 生成地图的轮廓：柏林噪声</strong></p>
<p>柏林噪声（Perlin noise）指由Ken Perlin发明的自然噪声生成算法<a href="#ref_4">[4]</a>。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。如下图所示：</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-9666e99f436d9863363e73d8148fabc4_720w.jpg" alt="img"></p>
<p>与椒盐噪声相比，柏林噪声有较好的连续性分布，可以更好的模拟自然界中的地形分布与地表装饰物分布。利用柏林噪声生成自然地图可以参考B站视频：<a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1sJ411e7nt">柏林噪声程序化生成随机地图</a><a href="#ref_5">[5]</a>。</p>
<p>柏林噪声的生成采用伪随机数的生成方式，相同的“随机数种子”会生成相同的地貌。这也是很多随机地图生成器中会暴露“种子”让玩家根据种子生成地图的原因。如果想跟好朋友分享某个生成结果比较好的地图，只需要共享“种子”字符串，就能在随机地图生成器中还原出所生成的地形，而不需要把整个地图文件保存到本地再分享。</p>
<p>Unity官方自带生成柏林函数的函数。我们引用了柏林噪声js库来进行地形的实现。我们利用柏林噪声的采样尺度来决定地图的类型是连续的大陆型地图还是离散的大洲型地图；将随机取到的连续噪声均衡化作为地图的高度图，根据用户设置的水体占比来制定海平面高度，最终生成的地形结果如下图所示： </p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-53f678a81cd6969e60c89f5b8c5318a3_720w.jpg" alt="img"></p>
<p><strong>3. 玩家出生点的选择：米切尔最佳候选算法</strong></p>
<p>为了保证每位玩家两两之间的初始分布不会过近，我们在生成游戏地形后，在陆地上对玩家初始占位符进行均匀采样。为了兼顾效果与效率，我们最终选用米切尔最佳候选 算法（best candidate）。</p>
<p>米切尔最佳候选算法是一种渐进、增量式的均匀采样方法。它每一轮采样都是从多个随机采样点中，保留与之前轮的所有采样点中最小距离最大的点作为本轮的采样结果。更加具体直观的算法解释可以参考:<a href="https://link.zhihu.com/?target=https%3A//bindog.github.io/blog/2014/08/09/visualizing-algorithms/">算法可视化</a><a href="#ref_6">[6]</a>中有关米切尔候选算法的部分</p>
<p>如下图所示：黑色点是之前轮已经确定的采样点，灰色点是本轮随机采样的候选点，每个候选点都选出与之前轮采样点中距离最近的距离，再从中选出最小距离最大的红色点作为本轮采样的结果。</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-fac9f90ba270e0869f56081434f79a4d_720w.jpg" alt="img"></p>
<p>利用这种采样方式采样出玩家的初始占位符，可以避免任意两个玩家之间的距离过近导致游戏平衡性被破坏，如下图所示：</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-3924e3347b5634505b2a19101ddc28f7_720w.jpg" alt="img"></p>
<p><strong>4. 战略资源的分布</strong></p>
<p>采样出玩家的分布之后，我们将地图单元格分为两种类型：每个玩家占位符附近距离N以内的单元格为玩家区域（Player Zones），不隶属于任何玩家区域的单元格被称为隔离区或自然区（Natural Zones）。</p>
<p>为了让每名玩家在游戏初始时具有公平的战略特征，我们对每位玩家的玩家区域内定额分配植被、岩石与矿产资源。根据用户设定的植被、岩石与资源占比分别计算出每位玩家区应当分配到的植被、岩石与资源数量，然后在每个玩家区域内不重不漏地采样出相等数量的植被、岩石与资源单元格。</p>
<p>对于自然区，我们按照玩家设置的参数，采用米切尔候选算法均匀采样每一种资源。这样可以保证每位玩家在游戏初始时能够得到数量一致的战略特征。如下图所示：</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-36f553af401b6bddf8238a387674559b_720w.jpg" alt="img"></p>
<p><strong>5. 边界情况处理</strong></p>
<p>用以上方式生成的地图在某些情况下会产生不好的结果，例如当水体比例过低时生成海岛地形，会导致水体不够划分不出海岛地形；当水体比例过高时，会由于陆地单元格分布不均导致出生在不同规模大小的岛屿上的玩家能够得到的战略资源再度失衡。对于这些边界情况，我们利用种子生长与泛洪填充等启发式生成方法生成地图，优先保证地图类型能够满足用户的需求，并尽可能保证水体与各种战略特征的资源逼近用户的设定。以下是我们在水体占比过低与水体占比过高时生成的地图，可以看出在这两种情况下依然能够保证所生成地图的平衡性：</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-cbd869e4e4aaf2271e96a91adc50208e_720w.jpg" alt="img"></p>
<h3 id="生成地图质量的定量评估"><a href="#生成地图质量的定量评估" class="headerlink" title="生成地图质量的定量评估"></a>生成地图质量的定量评估</h3><p>为了判断我们的生成随机地图算法是否具有良好的平衡性指标，我们设计了一套地图自动扩张算法：每个玩家以出生点占位符为种子，轮流从目前领土所毗邻的无人单元格中抽取一个进行占领以扩张势力范围，直到地图中所有的单元格都被有且只有一个玩家占领；然后我们统计每个玩家占领到的资源数量、距离最近的敌人距离，以及每个玩家与多少数量的玩家领土相邻。如下图所示： </p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-aff4ede9c673351500855f48cadcb4f0_720w.jpg" alt="img"></p>
<p>实验组是我们的算法生成的地图，对照组是根据水体与各种资源的比例随机采样地形、随机采样玩家分布得到的地图。如下方左侧是实验组生成的地图，右侧是对照组生成的地图：</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-17df5c19a246e5bbbef3fa428646a3e8_720w.jpg" alt="img"></p>
<p>实验组与对照组各生成100次地图，统计每个玩家与其他势力最小距离的均值与方差、扩张完成后各资源占有量的均值与方差以及每位玩家潜在冲突势力的均值与方差，统计的结果如下所示：</p>
<p><img src="../../assets/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_hd.jpg" alt="img">)<img src="../../assets/images/2021-01-22-civ-map/v2-32e30c53111a6cc563aa0e1a819f18e3_720w.jpg" alt="img"></p>
<p>通过定量的统计结果可以看出，我们的方法生成的地图，玩家之间有更大的平均极小距离，这说明每位玩家的出生点占位符设置更加平衡；各种资源的分布方差均比对照组小，说明我们的战略特征分配与朴素的随机生成的地图相比更加均衡。</p>
<p>综上所述，我们的地图生成结果能够保证对称性多人对抗战略游戏的平衡性。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>地图</tag>
        <tag>游戏开发</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Spelunky关卡生成</title>
    <url>/unity-2021-01-23-Spelunky-map/</url>
    <content><![CDATA[<h1 id="Part1-创建Solution-path-关卡通路"><a href="#Part1-创建Solution-path-关卡通路" class="headerlink" title="Part1. 创建Solution path - 关卡通路"></a>Part1. 创建Solution path - 关卡通路</h1><p>关卡生成算法的第一部分：生成关卡的critical path（关卡通路），我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。</p>
<p>算法的第一部分是生成关卡的 Critical Path（通路），关卡由 16 个房间按照 4x4 的网格组成。方法是先在第一排随机找到一个起始房间，然后随机使相邻的房间成为通路的一部分，一直到最后一排，生成出口。找到通路之后，连接这些房间，然后再随机补充上非通路部分的房间，打通这些房间。如图顺序所示：</p>
<p><img src="../../assets/images/2021-01-23-Spelunky-map/spelunky-map-generation-steps.gif" alt="img"></p>
<p>然后为这些房间随机选取对应的预定义好的关卡模块。根据 Spelunky 的教学文章<a href="https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/#reference" target="_blank" rel="noopener">[3]</a>，这里有 4 种不同的房间类型：</p>
<p><img src="../../assets/images/2021-01-23-Spelunky-map/8752-1519530045.png" alt="img"></p>
<p>这个关卡由16个房间按照4x4的网格方式组成，这里有4种不同的房间类型：</p>
<ul>
<li>0：不在critical path上，不会产生任何出口（可被忽略的）次要房间 (感谢洋芋君指出之前的翻译问题)</li>
<li>1：左右一定有出口</li>
<li>2：左右下一定有出口，如果有2号room在上方，也一定有上方出口</li>
<li>3：左右上一定有出口</li>
</ul>
<p>第一步在最顶部这行随机选取一格创建一个Start Room，房间类型对开始的房间来说没太大影响。一般来说，Start Room类型我们会选1或者2。</p>
<p>每当一个Room被创建，首先总是类型1(左右)。</p>
<p>然后要决定往哪边走。取一个均匀分布的随机数，从1到5。当1或2时，critical path向左；当3或4时，critical path向右；当5时，path向下。（当critical path碰到屏幕边缘，立即向下移动并同时切换左右方向。）</p>
<p>这有个问题，如果我们向左或右移动，是OK的，因为我们创建的Room是一定有左右出口的。但我们要向下走，我们就得改变我们当前所在的房间了。所以生成器重写房间类型为2，覆盖当前的房间，现在我们可以向下移动了。</p>
<p> 当生成器移到下一个房间，会问我们最后创建的那个房间（也就是刚才我们头顶上那个）类型是不是2（底部有出口）。 如果是2，那么当前这个房间类型一定要是2或3（上方有出口）。因为2、3类型都有左右出口，启动算法从头再来一次。</p>
<p>如果到了底部这一行，我们要尝试向下，那肯定不行了，我们放置一个Exit Room来取代向下的房间。</p>
<p>现在我们已经生成了整个critical path（关卡通路，即图中那些暗红色的格子，游戏中是不显示的，这里只是为了举例）。接下来要做的最后一件事，我们要把4x4的网格中的空余部分放上类型为0的房间，这些房间并不在critical path上。这些房间在任何方向都不一定有出口，所以有时候会生成一些围墙。</p>
<p>如果一列中有3或者4个Room 0，那这一列房间有几率成为一个蛇窝。如果我们要生成蛇窝的话，从上到下，放一列房间，类型为7 8 9，或者7 8 8 9，取决于我们希望这个蛇窝有多深。(这里的蛇和宝石并不像其他敌人那样随机生成，因为它们是这种地形的一部分，所以位置基本是固定出现。）</p>
<p><img src="../../assets/images/2021-01-23-Spelunky-map/8752-1519530075.png_webp" alt="img"></p>
<p><em>蛇窝</em></p>
<h1 id="Part2-创建房间-关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。"><a href="#Part2-创建房间-关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。" class="headerlink" title="Part2. 创建房间 关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。"></a>Part2. 创建房间 关卡生成算法的第二部分：生成Room，我们先不考虑那些障碍物、陷阱、敌人和宝箱什么的。</h1><p><img src="../../assets/images/2021-01-23-Spelunky-map/8752-1519530105.png_webp" alt="img"></p>
<p>Spelunky并不像其他大部分游戏（平台游戏，platformer）在传统的2D tile-base的平台游戏中，你用关卡编辑器做出的地图可能看起来像这样：</p>
<p><img src="../../assets/images/2021-01-23-Spelunky-map/8752-1519530119.png_webp" alt="img"></p>
<p>在这种类型编辑器里，是这样的，比如，在（64,128）这个位置是草的tile。但Spelunky完全不是这样。<br>上一部分我们了解了Spelunky有4种基本房间类型（types）。这每个房间类型有8-16个模板。这些模板具备一个房间的基本布局，包括一些静态和概率tile的组合。<br>Room Templates（房间模板）<br>每个房间类型都有一堆不同的模板。<br><em>译注：Derek Yu使用不同的布局，做了一系列的房间设计。比如你掉出去的房间（DROP）、掉入的房间（LANDING）、可以穿过的走廊（CORRIDOR）、不在关卡通路上的房间（NON-CRITICAL）。</em></p>
<p>房间模板，嗯……看起来就像下面这样：</p>
<blockquote>
<blockquote>
<p>1100000000</p>
</blockquote>
<blockquote>
<p>40L6000000</p>
</blockquote>
<blockquote>
<p>11P0000000</p>
</blockquote>
<blockquote>
<p>11L0000000</p>
</blockquote>
<blockquote>
<p>11L5000000</p>
</blockquote>
<blockquote>
<p>1100000000</p>
</blockquote>
<blockquote>
<p>1100000000</p>
</blockquote>
<blockquote>
<p>1111111111</p>
</blockquote>
</blockquote>
<p>每个模板由10x8 的tile网格组成。”0”表示空，”1”表示100%是砖块，”L”是梯子，”P”是爬梯子上去的平台(platform)。现在你在看这个模板， 嗯，下面一排是地面，左边是2个tile宽的墙，上面有个小缺口，有个梯子可以爬到那。</p>
<p>Static and Probabilistic Tiles( 静态和概率Tile )</p>
<p>static tile就像传统关卡编辑器里一样，你让这里有个砖块，那这就永远是砖块了。</p>
<p>上面模板里的”4” tile，就是probabilistic tile。”4”表示那有25%的几率会是一个能推动的障碍物，出现在梯子的顶部旁边。有经验的Spelunky玩家会一下认出这个：有时你爬到一个梯子顶部，旁边有个障碍物，你得推它，就可以进到下一个房间。有时候爬到梯子顶上旁边就没有这玩意。还有比如“这有33%的几率会出现个尖刺”，或者“这有一半的几率是空的，或者是砖块”。</p>
<p>Obstacle Block( 障碍块）</p>
<p>“5”和”6”就是所谓的Obstacle Block。Obstacle Block由 5x3 的tile网格组成，是个有趣的小结构，会让玩家针对这个障碍来思考自己的策略。Obstacle block本身也会由一些概率tile组成。下面是”5” 这个模板，表示放置在地上（”6”表示放置在空中）:</p>
<blockquote>
<blockquote>
<p>00000</p>
</blockquote>
<blockquote>
<p>00102</p>
</blockquote>
<blockquote>
<p>71177</p>
</blockquote>
</blockquote>
<p>规则和之前的一样，0是空，1是砖块。你能看出来，这是个小台阶。”7”有33%的几率是个尖刺，或者为空。如果运气不好，这里就得跳到那个台阶上面避开尖刺。”2”表示有一半的几率味空，或者是砖块。这就有意思了，有可能有个小砖块让你落脚不用踩到尖刺，也有可能除了小台阶，旁边都是空的，玩家得跳到上面去。你可以看出，这么个小障碍块，如果设计的好的话，游戏自己就会随机生成很多很多有意思的场景。</p>
<p>译于2018-Jan-20</p>
<p>原文链接最好用chrome打开，对，要科学，你懂了</p>
<p><a href="http://tinysubversions.com/spelunkyGen/" target="_blank" rel="noopener">http://tinysubversions.com/spelunkyGen/</a> </p>
<p><a href="http://tinysubversions.com/spelunkyGen2/" target="_blank" rel="noopener">http://tinysubversions.com/spelunkyGen2/</a></p>
<ul>
<li><a href="https://indienova.com/u/root/blogread/5454" target="_blank" rel="noopener">https://indienova.com/u/root/blogread/5454</a></li>
<li><a href="https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/" target="_blank" rel="noopener">https://indienova.com/indie-game-development/the-procedurally-generated-map-of-dead-cells/</a></li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>roguelike地牢生成算法</title>
    <url>/unity-2021-01-23-roguelike-map/</url>
    <content><![CDATA[<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>文章作者：<a href="http://www.roguebasin.com/index.php?title=Mike_Anderson" target="_blank" rel="noopener">Mike Anderson</a></p>
<p>随机生成的地图是 <a href="https://indienova.com/tag/roguelike/" target="_blank" rel="noopener">Roguelike</a> 类游戏最独特的一点，它让游戏变得很有乐趣，因为玩家永远要面对新的挑战。</p>
<p>但是随机地图却不是那么容易生成的。在传统的游戏中，一般你都会有一个地图编辑器，可以自由的创建地图。在任何一款称得上是“Roguelike”的游戏中，开发者都要自己创造一个“虚拟地图编辑器”，这样才能随机创建无限的动态地图，从而让玩家在其中流连忘返。</p>
<p>在这篇文章里，我会将自己在开发一款名为 <a href="http://sourceforge.net/projects/tyrant/" target="_blank" rel="noopener">Tyrant</a> 的 Roguelike 游戏中使用的方法记录下来。我怀疑这可能只能算是一个原型，但是我之前也没有见过什么一本正经讲述生成 Roguelike 地图算法的文章。而且，它工作得还是比较令人满意的，所以，我愿意将它分享给大家。</p>
<h4 id="这款算法的目标"><a href="#这款算法的目标" class="headerlink" title="这款算法的目标"></a>这款算法的目标</h4><p>在写任何代码之前，了解自己的目标总是很重要的，这对编程很有帮助，哪怕你随后会做无数的修改。</p>
<p>一个地牢（<a href="https://indienova.com/tag/dungeon/" target="_blank" rel="noopener">Dungeon</a>）应该包含以下要点：</p>
<ul>
<li>一组相互连通的房间、门和通道</li>
<li>一个入口（向上走的楼梯）</li>
<li>一个出口（向下走的楼梯）</li>
<li>所有的空间必须能够到达</li>
</ul>
<p>最后一点尤其重要。要知道，你的玩家在契而不舍的努力之后，应该能够顺利通过这一层，不要让他们失望。另外，如果放了某个物品到地图上的某个空间，它应该不会被藏在无法到达的地方。</p>
<h4 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h4><p>在我写 Tyrant 的时候，我尝试了很多种不同的算法来生成地图，这里所讲的是我能做到的最好的一个，也是目前游戏中使用的那个。</p>
<p>我的灵感来自于此：“如果我是地下城的一个居民，那么我该怎么去建设我的地牢呢？”</p>
<p>显然，我并不会将我的地下城建造成一个一个看起来不错的小房间，然后在中间用长长的通道连接起来。所以，当我需要为我的小怪物们提供更多空间的时候，我应该是拿起我的斧头，挖一个更大一些的洞。这样当他们有所需要的时候就会增加一些新房间——尽管它们看起来可能杂乱无章。</p>
<p>有些地下城主可能想要用吊桥呀、陷阱呀什么的来守护比较“有趣”的房间，但是这些需求都异曲同工。由一个小的地牢开始，慢慢向四周扩散，直到整个地牢形成。这就是我们的计划。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>在这个算法里面，“元素”代表着某种地图元素，比如：大房间、小房间、通道、圆形竞技场、保险柜等等。</p>
<ol>
<li>将整个地图填满土</li>
<li>在地图中间挖一个房间出来</li>
<li>选中某一房间（如果有多个的话）的墙壁</li>
<li>确定要修建某种新元素</li>
<li>查看从选中的墙延伸出去是否有足够的空间承载新的元素</li>
<li>如果有的话继续，不然就返回第 3 步</li>
<li>从选中的墙处增加新的元素</li>
<li>返回第 3 步，直到地牢建设完成</li>
<li>在地图的随机点上安排上楼和下楼的楼梯</li>
<li>最后，放进去怪兽和物品</li>
</ol>
<p>第 1、2 步很简单。只要你创建好地图就可以去做到。我发现，写一个 <code>fillRect</code> 指令用来填充一个区域是比较有效的做法。</p>
<p>第 3 步麻烦一些。你不能随意的寻找一个方块区域去添加你的元素，因为规则是要将元素添加到当前的地牢当中。这样会使得连接看起来比较不错，也确保了所有的区域都可以到达。Tyrant 的做法是：在地图上随机选择一个方块，直到找到横向或者纵向毗邻一个干净的方块那个。这样做的好处是：它给了你一个近乎公平的方式去选择某一面墙。</p>
<p>第 4 步不太困难。我自己写了一个随机方法来决定建造哪一种元素。你可以自己定义它们，调整某些元素出现的权重，这会让你的地牢有自己的特点和侧重点。一个规划比较好的地牢会有很多规矩的房间，中间有长而且直的走廊连接。而洞穴则可能有一堆打洞以及曲折的小道等等。</p>
<p>第 5 步更复杂一些，而且也是整个算法的核心。针对每一种元素，你需要知道它会占用的空间大小。然后你要去判断它是否和已经有的元素相交。Tyrant 使用了相对简单的一种方法：它会先得到要创建的元素所占用的空间大小，得到这个空间的数据，然后检查是否这个空间由土填满。</p>
<p>第 6 步决定是否创建这个元素。如果这个待确定的空间包含有除了土之外的内容，那么就回到第 3 步继续。注意，大部分元素在这步都会被打回。不过这不是个问题，因为处理时间可以忽略。Tyrant 尝试着将某个元素加入 300 次左右到地牢中去，一般只有 40 次左右会通过这步。</p>
<p>第 7 步会将新元素添加到地图上去。在这步，你还可以增加一些有趣的元素，比如动物、居民、秘道门和财宝什么的。</p>
<p>第 8 步返回去创建更多的房间。确切的次数跟你地牢的尺寸以及其它参数有关。</p>
<p>第 9 步要看个人喜好了。最简单的方法就是随机的去查找方块，直到找到一个空的位置去放置楼梯。</p>
<p>第 10 步就是随机的创建怪兽。Tyrant 在这一步才加入游戏中大多数的怪兽，由少量的特殊怪兽或者生物会在生成房间的时候添加进去。</p>
<p>就这样啦，这里所说的只是算法的规则，具体还要您自己去实现啦。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>好了，在看了半天算法之后，我们来一个例子吧：</p>
<p>Key:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#x3D; 地板</span><br><span class="line">D &#x3D; 门</span><br><span class="line">W &#x3D; 正在考查中的墙</span><br><span class="line">C &#x3D; 宝箱</span><br></pre></td></tr></table></figure>

<p>\1. 第一个房间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####</span><br><span class="line">#####</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\2. 随机选择一面墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####</span><br><span class="line">#####W</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\3. 为新的通道元素进行区域搜索（包括两边的空间）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####**********</span><br><span class="line">#####W*********</span><br><span class="line">#####**********</span><br></pre></td></tr></table></figure>

<p>\4. 是空的，可以添加元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####</span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\5. 选择另外一面墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#####     W</span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\6. 扫描寻找新的房间所占用空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       ******</span><br><span class="line">       ******</span><br><span class="line">       ******</span><br><span class="line">       ******</span><br><span class="line">       ******</span><br><span class="line">#####  ***W**</span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\7. 这个地区也可以，那就添加一个新房间，再往里面扔一个宝箱 C（Chest）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        ####</span><br><span class="line">        ###C</span><br><span class="line">        ####</span><br><span class="line">        ####</span><br><span class="line">#####     D  </span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\8. 跟前面做法一样，我们增加一个新的通道元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             #</span><br><span class="line">             #</span><br><span class="line">        #### #</span><br><span class="line">        ###C #</span><br><span class="line">        #### #</span><br><span class="line">        #### #</span><br><span class="line">#####     D  #</span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\9. 这一次，我们试着为第二个房间增加一个通道元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             #</span><br><span class="line">             #</span><br><span class="line">        #### #</span><br><span class="line">        ###C*******</span><br><span class="line">        ####W******</span><br><span class="line">        ####*******</span><br><span class="line">#####     D  #</span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\10. 扫描失败了，已经被占用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             #</span><br><span class="line">             #</span><br><span class="line">        #### #</span><br><span class="line">        ###C #</span><br><span class="line">        #### #</span><br><span class="line">        #### #</span><br><span class="line">#####     D  #</span><br><span class="line">#####D########</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\11. 比较特别的元素，一个菱形的房间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             #</span><br><span class="line">             #   ###</span><br><span class="line">        #### #  #####</span><br><span class="line">        ###C # #######</span><br><span class="line">        #### #D#######</span><br><span class="line">        #### # #######</span><br><span class="line">#####     D  #  #####</span><br><span class="line">#####D########   ###</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\12. 添加一个隐藏的暗门，以及充满陷阱的通道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">             #</span><br><span class="line">             #   ###</span><br><span class="line">        #### #  #####</span><br><span class="line">        ###C # #######S###T##TT#T##</span><br><span class="line">        #### #D#######</span><br><span class="line">        #### # #######</span><br><span class="line">#####     D  #  #####</span><br><span class="line">#####D########   ###</span><br><span class="line">#####</span><br></pre></td></tr></table></figure>

<p>\13. 继续……</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>好了，这就是我的算法，我希望它对你有用，或者从一个有趣的角度去看如何解决一个问题。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>Java 代码实现</strong><br><a href="http://www.roguebasin.com/index.php?title=Java_Example_of_Dungeon-Building_Algorithm" target="_blank" rel="noopener">Java 代码实现</a><br>你可以通过 <a href="http://openprocessing.org/visuals/?visualID=18822" target="_blank" rel="noopener">Open Processing</a> 在浏览器里面运行它（需要做一些小修改）。它会创建一个图形化的地牢。</p>
<p><strong>Python Curses 代码实现</strong><br><a href="http://www.roguebasin.com/index.php?title=Python_Curses_Example_of_Dungeon-Building_Algorithm" target="_blank" rel="noopener">Python Curses 代码实现</a></p>
<p><strong>C++ 代码实现</strong><br><a href="http://www.roguebasin.com/index.php?title=C%2B%2B_Example_of_Dungeon-Building_Algorithm" target="_blank" rel="noopener">C++ 代码实现</a></p>
<p><strong>C# 代码实现</strong><br><a href="http://www.roguebasin.com/index.php?title=CSharp_Example_of_a_Dungeon-Building_Algorithm" target="_blank" rel="noopener">C# 代码实现</a></p>
<p>原文地址：<a href="http://www.roguebasin.com/index.php?title=Dungeon-Building_Algorithm" target="_blank" rel="noopener">链接</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>游戏</tag>
        <tag>地图</tag>
        <tag>Java</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Unity鼠标坐标点转成世界坐标系坐标点</title>
    <url>/unity-2021-01-24-screentoworld/</url>
    <content><![CDATA[<h2 id="使用射线"><a href="#使用射线" class="headerlink" title="使用射线"></a>使用射线</h2><p>这是一种发射线，获取当前点击的物体（具有碰撞器）的坐标点（也就是碰撞器范围的坐标点）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (Input.GetMouseButtonDown(0))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    RaycastHit hitt &#x3D; new RaycastHit();</span><br><span class="line"></span><br><span class="line">    Ray ray &#x3D;Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">    Physics.Raycast(ray, out hitt);</span><br><span class="line"></span><br><span class="line">    Debug.Log(hitt.point);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Debug.Log(Camera.main.ScreenToWorldPoint(Input.mousePosition));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接转换"><a href="#直接转换" class="headerlink" title="直接转换"></a>直接转换</h2> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line"> 	if(Input.GetMouseButtonDown(0))</span><br><span class="line">  &#123;    </span><br><span class="line">    var  z &#x3D; target.transform.position.z - camera.transform.position.z;</span><br><span class="line">    Debug.Log(TempC.ScreenToWorldPoint(new Vector3(Input.mousePosition.x,Input.mousePosition.y, z)));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>摄像机对游戏世界的渲染范围是一个平截头体，渲染边界是一个矩形，用与near clippingplane或者far clippingplane平行的平面截取这个平截头体，可以获得无数个平行的矩形面，也就是我们看到的屏幕矩形。离摄像机越远，矩形越大，离摄像机越近，矩形越小。所以，同样大小的物体，随着离摄像机越来越远，相对于对应屏幕矩形就越来越小，所看起来就越来越小。</p>
<p>在屏幕上，某个像素点相对于屏幕矩形的位置，可以对应于游戏世界中的点相对于某个截面的位置，关键在于这个点在哪个截面上，也就是说，关键在于这个截面离摄像机有多远！</p>
<p>在ScreenToWorldPoint这个方法中，参数是一个三维坐标，而实际上，屏幕坐标只能是二维坐标。参数中的z坐标的作用就是：用来表示上述平面离摄像机的距离。</p>
<p>也就是说，给定一个坐标（X，Y，Z），</p>
<p>首先截取一个垂直于摄像机Z轴的，距离为Z的平面P，这样不管X，Y怎么变化，返回的点都只能在这个平面上；</p>
<p>然后，X，Y表示像素坐标，根据（X，Y）相对于屏幕的位置，得到游戏世界中的点相对于截面P的位置，我们也就将屏幕坐标转换为了世界坐标。</p>
<p>所以如果要判断是否点中一个目标,则传入的z的值即你想选中的目标到摄像机的距离</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2021-01-25-tilemap</title>
    <url>/unity-2021-01-25-tilemap/</url>
    <content><![CDATA[<h3 id="B站圈毛君翻译教程："><a href="#B站圈毛君翻译教程：" class="headerlink" title="B站圈毛君翻译教程："></a>B站圈毛君翻译教程：</h3><h3 id="The-Basic：https-www-bilibili-com-video-av48965588"><a href="#The-Basic：https-www-bilibili-com-video-av48965588" class="headerlink" title="The Basic：https://www.bilibili.com/video/av48965588/"></a>The Basic：<a href="https://www.bilibili.com/video/av48965588/" target="_blank" rel="noopener">https://www.bilibili.com/video/av48965588/</a></h3><h3 id="Rule-Tile：https-www-bilibili-com-video-av49083381"><a href="#Rule-Tile：https-www-bilibili-com-video-av49083381" class="headerlink" title="Rule Tile：https://www.bilibili.com/video/av49083381/"></a>Rule Tile：<a href="https://www.bilibili.com/video/av49083381/" target="_blank" rel="noopener">https://www.bilibili.com/video/av49083381/</a></h3><h3 id="Prefab-Brush：https-www-bilibili-com-video-av49098444"><a href="#Prefab-Brush：https-www-bilibili-com-video-av49098444" class="headerlink" title="Prefab Brush：https://www.bilibili.com/video/av49098444/"></a>Prefab Brush：<a href="https://www.bilibili.com/video/av49098444/" target="_blank" rel="noopener">https://www.bilibili.com/video/av49098444/</a></h3><h3 id="Tilemap-Collider：https-www-bilibili-com-video-av49115670"><a href="#Tilemap-Collider：https-www-bilibili-com-video-av49115670" class="headerlink" title="Tilemap Collider：https://www.bilibili.com/video/av49115670/"></a>Tilemap Collider：<a href="https://www.bilibili.com/video/av49115670/" target="_blank" rel="noopener">https://www.bilibili.com/video/av49115670/</a></h3><h1 id="TileBase"><a href="#TileBase" class="headerlink" title="TileBase"></a>TileBase</h1><p><code>GetTileData</code> 确定瓦片在瓦片地图上的外观 ,相当于滚动列表中的getdata..获取数据用于显示,,RefreshTile后会触发</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>地图</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity RenderTexture的应用</title>
    <url>/unity-2021-04-11-render-texture/</url>
    <content><![CDATA[<h4 id="1-UGUI上显示模型"><a href="#1-UGUI上显示模型" class="headerlink" title="1. UGUI上显示模型"></a>1. UGUI上显示模型</h4><p><img src="../../assets/images/2021-04-11-render-texture/4276633-05b67353425f7248.png" alt="img"></p>
<p>UGUI上显示模型.png</p>
<ol>
<li>创建拍摄用的摄像机</li>
<li>创建RenderTexture并绑定到摄像机camera.targetTexture上</li>
<li>RenderTexture绑定到rawImage.texture上（rawImage见上图）</li>
<li>创建显示的模型，相机可见</li>
<li>注意Destroy销毁 创建出来的RenderTexture 和相机</li>
<li>注意模型上的粒子特效由于Alpha透明通道，显示会有一点问题，可以通过Shader Blend混合处理，挂载在rawImage上。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateCamera</span>(<span class="params">Vector3 pos, Vector3 rot, <span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">string</span> layerName, <span class="keyword">float</span> size</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建拍摄用的摄像机</span></span><br><span class="line">    GameObject go = <span class="keyword">new</span> GameObject(<span class="string">"ModelCamera"</span>);</span><br><span class="line">    _camera = go.AddComponent&lt;Camera&gt;();</span><br><span class="line">    _camera.clearFlags = CameraClearFlags.SolidColor;</span><br><span class="line">    _camera.transform.position = pos;</span><br><span class="line">    _camera.transform.rotation = Quaternion.Euler(rot);</span><br><span class="line">    _camera.cullingMask = LayerMask.GetMask(layerName);</span><br><span class="line">    _camera.orthographic = <span class="literal">true</span>;</span><br><span class="line">    _camera.orthographicSize = size;</span><br><span class="line">    _camera.backgroundColor = <span class="keyword">new</span> Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建RenderTexture并绑定到摄像机上</span></span><br><span class="line">    _renderTexture = <span class="keyword">new</span> RenderTexture(width, height, <span class="number">8</span>);</span><br><span class="line">    _camera.targetTexture = _renderTexture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_rawImage != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rawImage.texture = _renderTexture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-Camera相机拍照分享，保存为jpg"><a href="#2-Camera相机拍照分享，保存为jpg" class="headerlink" title="2. Camera相机拍照分享，保存为jpg"></a>2. Camera相机拍照分享，保存为jpg</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">CameraPhoto</span>(<span class="params">Camera cam, Rect rect, <span class="keyword">string</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rt == <span class="literal">null</span>) &#123;</span><br><span class="line">        rt = RenderTexture.GetTemporary(renderTextureDesc);</span><br><span class="line">    &#125;</span><br><span class="line">    cam.targetTexture = rt;</span><br><span class="line">    cam.Render();</span><br><span class="line"></span><br><span class="line">    RenderTexture currentActiveRT = RenderTexture.active;</span><br><span class="line">    RenderTexture.active = rt;</span><br><span class="line">    Texture2D screenShot = <span class="keyword">new</span> Texture2D((<span class="keyword">int</span>)rect.width, (<span class="keyword">int</span>)rect.height, TextureFormat.RGB24, <span class="literal">false</span>);</span><br><span class="line">    screenShot.ReadPixels(rect, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    screenShot.Apply();</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    cam.targetTexture = <span class="literal">null</span>;</span><br><span class="line">    RenderTexture.active = currentActiveRT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = screenShot.EncodeToJPG();</span><br><span class="line">    <span class="keyword">string</span> file = Application.dataPath + <span class="string">"/Texture/"</span> + name;</span><br><span class="line">    System.IO.File.WriteAllBytes(file, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Rendertexture的分配和销毁上有一个地方需要注意：<br> 如果频繁的要new一个rt出来，那么不要直接new，而是使用RenderTexture提供的GetTemporary和ReleaseTemporary，它将在内部维护一个池，反复重用一些大小格式一样的rt资源，因为让GPU为你分配一个新的texture其实是要耗时间的。</li>
<li>EncodeToJPG 生成的图片体积更小</li>
<li>有的时候我们想人为的控制每一次渲染，你可以将这个摄像机disable掉，然后手动的调用一次render。</li>
<li></li>
</ol>
<h4 id="3-制作小地图"><a href="#3-制作小地图" class="headerlink" title="3. 制作小地图"></a>3. 制作小地图</h4><p><img src="../../assets/images/2021-04-11-render-texture/17266280-153a6a121210c7f7.png" alt="img"></p>
<p>这里需要新建一个Layer。依次点击菜单项Edit -&gt; Project Settings -&gt; Tags and Layers新建Layer命名为Minimap。</p>
<p><img src="../../assets/images/2021-04-11-render-texture/17266280-f96f6a1a4c01bae2.png" alt="img"></p>
<p>然后新建三个球体。一个设为蓝色代表Unity Chan。将该球体设为Unity Chan的子对象，并将其Layer设为Minimap。</p>
<p><img src="../../assets/images/2021-04-11-render-texture/17266280-dfdc8f16823fbf32.png" alt="img"></p>
<p>对两个机器人进行同样的操作，将球体改为红色。</p>
<p><img src="../../assets/images/2021-04-11-render-texture/17266280-4b34ec3b3279e6aa.png" alt="img"></p>
<p>现在最关键的一步来了！选中Main Camera并确保其Culling Mask中不包括Minimap这一层。</p>
<p><img src="../../assets/images/2021-04-11-render-texture/17266280-1eb8533ebe757f7d.png" alt="img"></p>
<p>然后选中Minimap Camera让其Culling Mask只包括Minimap这一层。</p>
<p><img src="../../assets/images/2021-04-11-render-texture/17266280-e16613658b088db8.png" alt="img"></p>
<p>现在这个小地图看起来就比较完善了！</p>
<p><img src="../../assets/images/2021-04-11-render-texture/17266280-694ef4f538aae2e1.png" alt="img"></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>地图</tag>
        <tag>ugui</tag>
      </tags>
  </entry>
  <entry>
    <title>commandbuff的一些问题</title>
    <url>/unity-2021-05-20-ecs-commandbuff-question/</url>
    <content><![CDATA[<p>component</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct State:IComponentData</span><br><span class="line">&#123;</span><br><span class="line">	public int a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> var PostUpdateCommands &#x3D; World.GetExistingSystem&lt;AbilityUpdateCommandBufferSystem&gt;().CreateCommandBuffer();</span><br><span class="line">Entities</span><br><span class="line">    .ForEach((Entity entity) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    	var state &#x3D; EntityManager.GetComponent&lt;State&gt;(entity);</span><br><span class="line">    	state.a &#x3D; 1111;</span><br><span class="line">    	PostUpdateCommands.SetComponent(entity,state);</span><br><span class="line">    &#125;)</span><br><span class="line">    .WithoutBurst()</span><br><span class="line">    .Run();</span><br></pre></td></tr></table></figure>

<p>b系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Entities</span><br><span class="line">    .ForEach((Entity entity) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    	var state &#x3D; EntityManager.GetComponent&lt;State&gt;(entity);</span><br><span class="line">    	state.a &#x3D; 2222;</span><br><span class="line">    	EntityManager.SetComponentData(entity,state);</span><br><span class="line">    &#125;)</span><br><span class="line">     .WithStructuralChanges()</span><br><span class="line">    .Run();</span><br></pre></td></tr></table></figure>

<p>执行顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A--&gt;B--&gt;AbilityUpdateCommandBufferSystem</span><br></pre></td></tr></table></figure>

<p>这里的结果,我们以为是2222.其实是1111.</p>
<p>所以要么全是使用commandbuff.否则容易造成数据错误</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Edgar源代码解读</title>
    <url>/unity-2021-06-12-edgar-code-read/</url>
    <content><![CDATA[<h3 id="生成类"><a href="#生成类" class="headerlink" title="生成类"></a>生成类</h3><ul>
<li><code>LevelGeneratorBase</code>  最基本的生成方法类包括<code>Generate</code>和<code>GenerateCoroutine</code></li>
<li><code>DungeonGeneratorBase</code> 一般都会继承于该类</li>
</ul>
<h4 id="Generate流程"><a href="#Generate流程" class="headerlink" title="Generate流程"></a><code>Generate</code>流程</h4><ol>
<li>创建playload,即IPipelineTask的上下文</li>
<li>创建pipelineTask,包括三个<code>InputTask</code>,<code>GeneratorTask</code>,<code>PostProcessingTask</code></li>
<li>PipelineRunner执行管道任务,将playload赋值给各个pipelineTask然后执行pipelinetask的<code>Process()</code>函数</li>
</ol>
<h4 id="pipelineTask"><a href="#pipelineTask" class="headerlink" title="pipelineTask"></a>pipelineTask</h4><p>你可以继承<code>LevelGeneratorBase</code>  然后分别覆盖<code>GetInputTask()</code>和<code>GetGeneratorTask()</code>,还有<code>GetPostProcessingTask()</code></p>
<ul>
<li><code>InputTask</code>   一般来说是FixedLevelGraphInputTask,主要是用来设置Payload.LevelDescription </li>
<li><code>GeneratorTask</code>   主要是通过GraphBasedGeneratorGrid2D来设置Payload.GeneratedLevel 和 Payload.GeneratorStats,还有会实例化<code>Generated Level/Room template instances</code>以及下面的房间,参见<code>GeneratorUtils.TransformLayout</code></li>
<li><code>PostProcessingTask</code>  主要是根据PriorityCallbacks按照优先顺序执行回调函数,默认的回调函数,通过配置有以下<ul>
<li>InitializeSharedTilemaps 即实例化<code>GeneratedLevel/Tilemaps</code></li>
<li>CopyTilesToSharedTilemaps 将rooms下的tile复制到SharedTilemaps 下</li>
<li>CenterGrid 将Generated Level下的子对象设置为0,0</li>
<li>DisableRoomTemplatesRenderers    禁用roomtemapltes下的显示</li>
<li>DisableRoomTemplatesColliders  禁用roomtemplates下的碰撞</li>
<li>还可以通过继承DungeonGeneratorPostProcessBase写你自己的后处理函数</li>
</ul>
</li>
</ul>
<h3 id="Door-sockets"><a href="#Door-sockets" class="headerlink" title="Door sockets"></a>Door sockets</h3><p>门锁..就是走廊和房间选中同一个锁,就能匹配的上</p>
<h2 id="对于连接处"><a href="#对于连接处" class="headerlink" title="对于连接处"></a>对于连接处</h2><p>他会按照顺序copy到sharedtilemaps.所以,位于连接处的tile,如果后面的会覆盖前面的</p>
<p><img src="../../assets/images/2021-06-12-edgar-code-read/image-20210630183742467.png" alt="image-20210630183742467"></p>
<p><img src="../../assets/images/2021-06-12-edgar-code-read/image-20210630183825008.png" alt="image-20210630183825008"></p>
<p>最终的合成则是下图</p>
<p><img src="../../assets/images/2021-06-12-edgar-code-read/image-20210630183914172.png" alt="image-20210630183914172"></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>How to Make One Way Platform in unity</title>
    <url>/unity-2021-06-13-How-to-Make-One-Way-Platform/</url>
    <content><![CDATA[<p>Hello Readers, I’ll Show you how to make simple one way platform. It is simple, useful and efficient technique to achieve this result. Here is the procedure –</p>
<ol>
<li>Make a Simple platform using Box collider.</li>
<li>Make a new game object children of the platform and add a box collider just below the original platform as shown in image and tick its ‘is trigger’ checkbox so that we can check player’s collision in it.</li>
</ol>
<p><img src="../../assets/images/2021-06-13-How-to-Make-One-Way-Platform/111-1623584452229.jpg" alt="111"></p>
<ol start="3">
<li>Create a new Script to the game object we create in step 2 and assign the following script –</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;the collider of the main visible platform</span><br><span class="line">var platform : BoxCollider2D;</span><br><span class="line">&#x2F;&#x2F;this variable is true when the players is just below the platform so that its Box collider can be disabled that will allow the player to pass through the platform</span><br><span class="line">var oneway : boolean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Update () &#123;</span><br><span class="line">    &#x2F;&#x2F;Enabling or Disabling the platform&#39;s Box collider to allowing player to pass</span><br><span class="line">    if (oneway)</span><br><span class="line">     platform.enabled&#x3D;false;</span><br><span class="line">     if (!oneway)</span><br><span class="line">     platform.enabled&#x3D;true; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Checking the collison of the gameobject we created in step 2 for checking if the player is just below the platform and nedded to ignore the collison to the platform</span><br><span class="line">function OnTriggerStay2D(other: Collider2D) &#123;</span><br><span class="line">   oneway &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function OnTriggerExit2D(other: Collider2D) &#123;</span><br><span class="line">&#x2F;&#x2F;Just to make sure that the platform&#39;s Box Collider does not get permantly disabled and it should be enabeled once the player get its through</span><br><span class="line">   oneway &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>I’ve made a simple ball game to illustrate the application of the one way platforms. You can download the example project folder below. –</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
      </tags>
  </entry>
  <entry>
    <title>UNITY的渲染顺序</title>
    <url>/unity-2021-06-14-unity-render-order/</url>
    <content><![CDATA[<p>工欲善其事，必先利其器。为了搞清楚 Unity 的渲染顺序，首先我们要准备一个能方便修改 SortingLayer 以及 RenderQueue 的工具，下面这个编辑器脚本可以满足这个需求：</p>
<p><a href="https://gist.github.com/qxsoftware/499135b6482ca57727c69e11b91a12bf" target="_blank" rel="noopener">MeshRendererInspector.cs</a></p>
<p>效果如下：</p>
<p><img src="../../assets/images/2021-06-14-unity-render-order/mesh-renderer-inspector.jpg" alt="img"></p>
<p>如何添加新的 SortingLayer？请通过 <strong>Edit/Project Settings/Tags and Layers</strong> 菜单选项打开：</p>
<p><img src="../../assets/images/2021-06-14-unity-render-order/tags-layers.jpg" alt="img"></p>
<p>然后添加三个 Sorting Layer，如上图所示。注意，Sorting Layer 添加后是可以拖动调整顺序的。</p>
<p>便捷修改 Camera 的 opaqueSortMode 和 transparencySortMode：</p>
<p><a href="https://gist.github.com/qxsoftware/1821915377e333e45f7a632ae07e64aa" target="_blank" rel="noopener">CameraInspector.cs</a></p>
<p>效果如下：</p>
<p><img src="../../assets/images/2021-06-14-unity-render-order/sort-mode.jpg" alt="img"></p>
<h4 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h4><p>测试之前首先明确两点：</p>
<ul>
<li>什么因素影响绘制顺序</li>
<li>深度缓冲区对绘制结果的影响</li>
</ul>
<p>为了弄清楚第一点，什么因素影响绘制顺序，我们需要把 ZWrite 关闭。同时结合 Unity Frame Debugger来观察绘制顺序。</p>
<h5 id="Render-Queue"><a href="#Render-Queue" class="headerlink" title="Render Queue"></a>Render Queue</h5><p>RenderQueue 是材质（Material）的关键属性，当我们在 Unity 中创建一个材质后，Unity 会给这个材质设置一个默认 Shader，然后这个材质的 RenderQueue 被改为其 Shader 中设定的 RenderQueue。如果给这个材质球换了 Shader，Unity 会更新它的 RenderQueue（但是请注意，假如当前材质的 Shader 的 RenderQueue 是 3000，然后你修改 Shader 让其 RenderQueue 变成 3100，对应材质球的 RenderQueue 并不会更新！）。</p>
<p><strong>Unity 最终以 Material 的 RenderQueue 为准。</strong></p>
<p>Unity 内置了几个 RenderQueue 的字面值：</p>
<table>
<thead>
<tr>
<th align="left">RenderQueue</th>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Background</td>
<td align="left">1000</td>
<td align="left">这个渲染队列最先渲染，一般用于渲染背景</td>
</tr>
<tr>
<td align="left">Geometry(默认值)</td>
<td align="left">2000</td>
<td align="left">这个渲染队列是大多数物体的默认队列，用于渲染不透明物体</td>
</tr>
<tr>
<td align="left">AlphaTest</td>
<td align="left">2450</td>
<td align="left">使用了 AlphaTest 的物体在这个队列渲染，当所有的不透明物体都渲染完了再渲染这个，有助于提升性能</td>
</tr>
<tr>
<td align="left">Transparent</td>
<td align="left">3000</td>
<td align="left">在 Geometry 和 AlphaTest 之后、从后往前渲染，所有的半透明物体都应该在这里渲染</td>
</tr>
<tr>
<td align="left">Overlay</td>
<td align="left">4000</td>
<td align="left">在之前的所有渲染队列都渲染完了之后渲染，比如镜头光晕</td>
</tr>
</tbody></table>
<p>可以看到，RenderQueue 越大，渲染越靠后。</p>
<h5 id="Camera-opaqueSortMode"><a href="#Camera-opaqueSortMode" class="headerlink" title="Camera.opaqueSortMode"></a>Camera.opaqueSortMode</h5><p>默认情况下，不透明物体被放在粗略分隔的从前往后排布的桶中，GPU 按照这种方式渲染能节省性能。但是也有部分 GPU 不这么干，比如 PowerVR。Camera.opaqueSortMode 这个值的默认值是 Dafault，根据不同硬件平台，这个值有可能是：OpaqueSortMode.FrontToBack 或者 OpaqueSortMode.NoDistanceSort。我们也可以主动设置这个值为某一种。比如为了减少 CPU 消耗，把这个值设置为 NoDistanceSort。</p>
<p>所以，不透明物体大部分情况下是按照从前往后渲染，也就是离相机越近，越先渲染。</p>
<p>如果是手动选择了 FrontToBack，就是从前往后渲染；如果是 NoDistanceSort，就是从后往前渲染。</p>
<blockquote>
<p>根据实际测试，渲染的顺序并不是完全按照物体几何中心离相机的距离进行排序，而是一个近似的排序。</p>
</blockquote>
<h5 id="Camera-transparencySortMode"><a href="#Camera-transparencySortMode" class="headerlink" title="Camera.transparencySortMode"></a>Camera.transparencySortMode</h5><p>按照我测试用的 Unity5.3.4f1，修改这个值也会影响不透明物体的渲染顺序。所以这个东西很可能不重要，而且有 bug。</p>
<h5 id="SortingLayer"><a href="#SortingLayer" class="headerlink" title="SortingLayer"></a>SortingLayer</h5><p>SortingLayer 拥有最高优先级，如果 SortingLayer 不同，则首先按照 SortingLayer 排序；如果 SortingLayer 相同，再按照 RenderQueue 排序。</p>
<p>如下图所示，有 6 个立方体，分别按顺序在摄像机前排开：</p>
<p><img src="../../assets/images/2021-06-14-unity-render-order/preview.png" alt="img">)<img src="../../assets/images/2021-06-14-unity-render-order/cubes.jpg" alt="img"></p>
<p>其中，g1 组的立方体 SortingLayer 都是 Layer3，RenderQueue 都是 3000；g2 组的立方体 SortingLayer 都是 Layer2，RenderQueue 都是3500，最终渲染顺序是：<strong>g2m1 g2m2 g2m3 g1m1 g1m2 g1m3</strong>。</p>
<p>直观地说，就是 SortingLayer 越大，则物体<strong>层级</strong>越高。SortingLayer 默认只有一个：Default，越往后添加的 SortingLayer 越大。</p>
<p>现在把 g1 组的立方体 SortingLayer 改成 Layer2，RenderQueue 改成 3600，最终渲染顺序还是：<strong>g2m1 g2m2 g2m3 g1m1 g1m2 g1m3</strong>。</p>
<p>直观地说，SortingLayer 相同的前提下，RenderQueue 越大，则物体<strong>层级</strong>越高。</p>
<h5 id="SortingOrder"><a href="#SortingOrder" class="headerlink" title="SortingOrder"></a>SortingOrder</h5><p>如果 SortingLayer 和 RenderQueue 都一样，则 SortingOrder 越大，则物体<strong>层级</strong>越高。</p>
<p>如果只是 SortingLayer 一样，RenderQueue 和 SortingOrder 都不一样，则物体的<strong>层级</strong>由 RenderQueue 和 SortingOrder 之和决定，相加之和越大，<strong>层级</strong>越高。</p>
<blockquote>
<p>以上结论是通过 Frame Debugger 单步执行得出的。</p>
</blockquote>
<h5 id="Camera-depth"><a href="#Camera-depth" class="headerlink" title="Camera.depth"></a>Camera.depth</h5><p>还有一个很常用的调整渲染顺序的选项：摄像机深度。摄像机深度是优先级最高的选项，深度值越大，物体<strong>层级</strong>越高。常用的比如 NGUI 就是用一个单独的相机（深度值比渲染场景的相机大）来渲染 UI，这样就保证 UI 在所有东西上方。</p>
<p>参考资料：</p>
<p><a href="https://jakobknudsen.wordpress.com/2013/07/20/transparency-and-sorting/" target="_blank" rel="noopener">Transparency and sorting in Unity</a></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>GitHub</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
  <entry>
    <title>rpgbuild的一些备注</title>
    <url>/unity-2021-06-15-rpgbuilder/</url>
    <content><![CDATA[<ul>
<li><p>skills   相当于 采矿技能,种植技能 ,制作技能</p>
</li>
<li><p>level templates 只是升级属性..比如角色等级,skill等级.weapon等级</p>
</li>
<li><p>weapontemplates  相当于拳法精通..斧头精通..枪法精通.棍法精通这些..而且有相关的技能和属性</p>
</li>
<li><p>Races  种族,定义了可选职业,以及 weapontemplates  ,以及初始stat等</p>
</li>
<li><p>classes  职业定义了stat以及技能树,和魔法书</p>
</li>
</ul>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Game Object Conversion 和 SubScene 的 DOTS 开发工作流</title>
    <url>/unity-2020-10-19-game-object-conversion-and-subscene/</url>
    <content><![CDATA[<p><em>(译前言: Unity DOTS提出了一套全新的开发技术栈, 但目前少有精讲如何结合现有工作流进行开发的资料, 外网 <a href="https://link.zhihu.com/?target=https%3A//gametorrahod.com/game-object-conversion-and-subscene/">这篇文章 (Game Object Conversion and SubScene)</a> 详细解构了基于 GameObject 和 Subscene 的工作流程和原理, 要求读者对 DOTS/ECS 有基本的了解, 虽然非常之长, 但值得一读)</em></p>
<hr>
<p>游戏基本上就是关于玩家的输入如何改变(设计好的)数据, 并从渲染结果中得到乐趣的过程. 传统上, 这些数据是用 Unity 的所见即所得的编辑器来设计的. 但是基于 GameObject 的数据和 ECS 并不兼容. 如果在设计数据阶段能保留Unity的传统模式同时在 Runtime 阶段使用 ECS 高效处理数据, 那就能完美结合两者的优点.</p>
<h2 id="以前是如何制作游戏的"><a href="#以前是如何制作游戏的" class="headerlink" title="以前是如何制作游戏的"></a>以前是如何制作游戏的</h2><p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-6189e6b1d575c1ad9bbec966f5e99ee4_720w.jpg" alt="img"></p>
<p>如上图, 首先想想为什么方块能在每帧都被正确绘制到屏幕上? 在传统的 GameObject 里, 引擎会编译并排序整个 hierarchy 树, 同时按顺序调用绘制函数(draw call). 每次 Draw call 调用之间引擎需要初始化 material 和 mesh (也即 set pass call, 如果和前一次调用一样则无需初始化). 在内部 Unity 可能尝试合并 mesh 来减少 draw call (dynamic batching 和 static batching), 如果是 Dynamic 对象这步操作会增加一些 CPU 开销, 如果是 static 则会在build 时预先合并.</p>
<p>换句话说, 我们使用 Unity 构建的游戏保存在 YAML格式的 Scene文件中. 尽管游戏并非在 YAML 基础上运行, 在加载 Scene 并解析了方块 .prefab 文件后, 引起会准备一些 C++ 的内存用来存储 Transform, 相应代码则基于此来绘制.</p>
<p>在同一帧中这是同一块操作. 并取决于<strong>数据</strong>本身, 每个方块的<code>Transform</code>和 <code>MeshFilter</code> 告知了我们绘制什么. 不幸的是, 绘制都关注于什么样draw call 顺序能得到的正确的结果, 而所有这些绘制都来自于对于数据某些形式的迭代. (在C++中如果数据排布不佳依然不一定能高效迭代). 大家知道 ECS 擅长数据迭代. 而 Burst 加 ECS 则能帮助数据容易多线程处理, 这是我们为什么要用 ECS 来开发游戏的原因.</p>
<p>另一块操作则是逻辑. 在绘制之前, 比如方块可能有个 Bouncing 组件在持续地改变它的 <code>Transform</code> (好让你的游戏变得更有趣). 在改变用于绘制的数据这方面, ECS 依然能帮到你.</p>
<p>游戏基本上就这些了, 你有一些数据, 然后可能根据玩家的输入等因素来改变, 最后在每一帧中绘制出来.</p>
<p>结合改变数据和对数据的绘制, 玩家应该开始能感受到乐趣了! 事实上这一过程也常常使人放松(比如看着一个球在屏幕上下移动). 从纯数据的角度来审视游戏非常重要, 否则你无法接受基于 DOTS 来开发游戏的方式.</p>
<h2 id="如何在-DOTS-的世界里做游戏"><a href="#如何在-DOTS-的世界里做游戏" class="headerlink" title="如何在 DOTS 的世界里做游戏"></a>如何在 DOTS 的世界里做游戏</h2><p>和<code>GameOjbect</code>不同, 数据在ECS里类似数据库, 设想一下, 因为我们可以使用Jobs或者 SIMD指令来更快地迭代数据, 所以不仅改变数据的逻辑非常高效而且绘制本身也是高效的.</p>
<p>接下来我们直接跳到最后. 我现在已经在使用ECS并且我有3个 transform 矩阵需要绘制(以<code>IcomponentData</code>形式, 所以迭代是线性且快速的) , 外加对应的 <code>Mesh</code> 和 <code>Material</code>.</p>
<p>使用 Unity 的 Graphics Api 我们可以直接绘制这些数据而无需 <code>GameObject</code> 这个数据容器! 参考 <a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/ScriptReference/Graphics.html">Unity - Scripting API: Graphics</a> 以及支持 <code>NativeArray</code> 的 <code>BatchRendererGroup</code>(<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html">https://docs.unity3d.com/2019.3/Documentation/ScriptReference/Rendering.BatchRendererGroup.html</a>). 这时你已经可以直接从数据来绘制了. 只需要用 ECS 的<code>EntityQuery</code>等方法来获取数据并绘制它们.</p>
<p>参考这篇日文博客(<a href="https://link.zhihu.com/?target=https%3A//virtualcast.jp/blog/2019/10/batchrenderergroup/">https://virtualcast.jp/blog/2019/10/batchrenderergroup/</a>), 描述了 BatchRendererGroup 的优势. 尽管 “batches” 数量巨大, 性能依然优异. 要注意 batching 实际上是合并 mesh 的操作, 因此有一定的计算量. 绘制就是重复地调用没有改变的数据,只要你将 NativeArray 的内存留在 <code>BatchRendererGroup</code> 里面, 1000+的 “batches” 一点也不可怕.(较低的”set pass call”展示了在帧间绘制时并没有太多了 material 切换)</p>
<h2 id="Hybrid-Renderer"><a href="#Hybrid-Renderer" class="headerlink" title="Hybrid Renderer"></a>Hybrid Renderer</h2><p>Unity 开发了 Hybrid Renderer (<a href="https://link.zhihu.com/?target=https%3A//docs.unity3d.com/Packages/com.unity.rendering.hybrid%40latest">https://docs.unity3d.com/Packages/com.unity.rendering.hybrid@latest</a>) 来完成上文提到的绘制工作. 如果你有一个关联 <code>LocalToworld</code> 组件(也即Transform矩阵)的 Entity , 且Entity 所在 Chunk 关联了是 <code>ISharedComponentData</code> 的 <code>RenderMesh</code> 组件 (<code>Mesh</code> 和 <code>Material</code> 不在 ECS 框架下), 那么它就会使用 <code>BatchRendererGroup</code> 来绘制数据.</p>
<p>整个 Chunk 基于 <code>LocalToWorld</code> 的数量来绘制的是同样数量的 mesh 和 material. 这已经类似于CPU版本的 GPU instancing 了, 只使用 draw call 是非常快的, 这种粗暴的绘制方式甚至可能比花费 CPU 来每帧合并 mesh 的方式还要快. 由于同一 chunk 使用同样的 <code>Mesh</code> 和 <code>Material</code> , 并非100%无需 set pass call. 如果你的 Material 开启了 GPU instancing, <code>BatchRendererGroup</code> 可以批量绘制可不是快速的重绘.</p>
<p>之所以这种方式称之为 Hybrid 是因为 <code>BatchRendererGroup</code> 是普通的 Unity API 而不是 ECS API. 但是这并不意味着这不是 Data-Oriented. 事实上 <code>BatchRendererGroup</code> 工作的方式非常地 Data-Oriented: 就是由 <code>MaterialPropertyBlock</code> 和 Transform 矩阵构成的 <code>NativeArray</code> 数据. 所以别害怕使用它(Hybrid Renderer) 除非你知道如何使用 Graphics API 或者使用 <code>BatchRendererGroup</code>构建你自己的渲染模式. (或许可以去掉非必须的步骤比如 culling).</p>
<h2 id="让我们用纯数据来做个游戏吧"><a href="#让我们用纯数据来做个游戏吧" class="headerlink" title="让我们用纯数据来做个游戏吧"></a>让我们用纯数据来做个游戏吧</h2><p>既然已经接受了游戏就是改变数据和展示数据, 使用 Hybrid Renderer 我们就可以来做游戏了. 我们假设这就是关于一个上下弹跳的方块的游戏, 按住空格的时候让它跳的更疯狂, 这可能对于小孩子来讲非常有趣.</p>
<p>首先要解决的问题, 如何获取到我们需要的 <code>Mesh</code> 和 <code>Material</code>. 我想我会使用 <code>Rensources.Load</code>来加载一个引用了相关 asset 的 prefab:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AssetHolder</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Mesh myMesh;</span><br><span class="line">    <span class="keyword">public</span> Material myMaterial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-2fd0d4674c7f066e2e1059dd48558882_720w.jpg" alt="img"></p>
<p>下面的 System 用来创建Hybrid Renderer 要使用的数据.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> Unity.Rendering;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(SimulationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeGameSystem</span> : <span class="title">JobComponentSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnCreate();</span><br><span class="line">        <span class="keyword">var</span> myCube = EntityManager.CreateEntity(</span><br><span class="line">            ComponentType.ReadOnly&lt;LocalToWorld&gt;(),</span><br><span class="line">            ComponentType.ReadOnly&lt;RenderMesh&gt;()</span><br><span class="line">        );</span><br><span class="line">        EntityManager.SetComponentData(myCube, <span class="keyword">new</span> LocalToWorld</span><br><span class="line">        &#123;</span><br><span class="line">            Value = <span class="keyword">new</span> float4x4(rotation: quaternion.identity, translation:<span class="keyword">new</span> float3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> ah = Resources.Load&lt;GameObject&gt;(<span class="string">"AssetHolder"</span>).GetComponent&lt;AssetHolder&gt;();</span><br><span class="line">        EntityManager.SetSharedComponentData(myCube, <span class="keyword">new</span> RenderMesh</span><br><span class="line">        &#123;</span><br><span class="line">            mesh = ah.myMesh,</span><br><span class="line">            material = ah.myMaterial</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> JobHandle <span class="title">OnUpdate</span>(<span class="params">JobHandle inputDeps</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>瞧, 我的 data-oriented 方块坐标位于 (1, 2, 3)!</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-e531723f584b5747646fc3340dc937ef_720w.jpg" alt="img"></p>
<p>可以看到 Hierarchy 窗口里什么都没有, 但是方块却出现了. 编辑器窗口里也无法选中它, 它仅仅是被绘制了而已. 事实上编辑器里之所以可以选中是因为 <code>GameObject</code> 容器连接了绘制的内容和其他编辑的内容.</p>
<p>如果现在检查 Entity Debugger, 你会注意到 Hybrid Renderer 又添加了一些别的东西. 它会在提交数据到 <code>BatchRendererGroup</code> 之前剔除掉无法被看到的东西.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-218f24f57c5b783f8d52064804a8e977_720w.jpg" alt="img"></p>
<p>以上意味着: “你拥有 1 个chunk, 该 chunk 能容纳 128 个 Entity ( 1 个 Entity占用 125 字节, 1 个 chunk 16kb), 你已经使用了该 chunk 其中 1 个位置, 你还能添加 127 个方块. Hybrid Renderer 把方块 <code>LocalToWorld</code> 数据喂给 <code>BatchRendererGroup</code> 时, 这些数据在内存中都是连续排列的.</p>
<h2 id="Transform-systems"><a href="#Transform-systems" class="headerlink" title="Transform systems"></a>Transform systems</h2><p>现在你有一个数据并且绘制了, 接下来我们加点玩法.</p>
<p>如果人肉单纯修改 LocalToWorld 这个 4x4 Transform 矩阵将会无比痛苦, 所以 Unity 帮我们实现了一堆有用的系统来修改它:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-1eb72ea2222c31c50554021afecb27d1_720w.jpg" alt="img"></p>
<p>使用<code>Translation</code>,<code>Rotation</code>,<code>Scale</code>/<code>NonUniformScale</code>组件将会极大简化我们的操作, 上图这些系统 会将这些组件的改动反应到 LocalToWorld 中.你甚至可以使用 Parent 来实现层级结构. 比如一个 Entity 的 Transform 为 0, 但同时有一个 <code>Parent</code> 组件指向了父 Entity, 那么最终该 Entity 的 <code>LocalToWorld</code> 值将会和父 Entity的 LocalToWorld 一样.</p>
<p>接下来我们添加 Translation 给方块. 玩法系统现在就可以通过修改 Translation 而不是 LocalToWorld了. 我同时添加了 Cube 组件作为 Tag, 这样子代码会更加清晰:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myCube = EntityManager.CreateEntity(</span><br><span class="line">    ComponentType.ReadOnly&lt;Translation&gt;(),</span><br><span class="line">    ComponentType.ReadOnly&lt;Cube&gt;(), <span class="comment">//Tag</span></span><br><span class="line">    ComponentType.ReadOnly&lt;LocalToWorld&gt;(),</span><br><span class="line">    ComponentType.ReadOnly&lt;RenderMesh&gt;()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>接下来实现弹跳. 我们使用 <code>Time .ElapsedTime</code> 作为余弦函数的输入, 会返回一个从 0 到 1来回的值.</p>
<p>注意, ECS 妙的一点在于你可以不断地添加新系统来实现代码的”横向地”以构建更多玩法. 模式则是从 ECS 快速的数据库里查询数据, 然后修改, 再存回去. 你可能对这种每次都查询-修改都要增加新 System 的模式觉得有些不安, 但这种模式提升了代码的扩展性. 而 Unity ECS 则确保了重复的数据查询是高效的, 因此在代码中有大量逻辑简单的 System 是完全可行的.</p>
<p>我们的弹跳系统先在主线程检查空格是否按下, 并声明相关变量, 最后在 Lambda jobs 中捕获这些变量, 并根据此并行修改查询到的 Cube 的 <code>Translation</code> 值, 其中每一个线程会运行时会使用 1 个 chunk 的 Cube 和 <code>Translation</code> 数据. <code>Time</code> 是由 ECS 库维护的一个属性, 它每帧都会从传统的 <code>UnityEngine.Time</code> 获取相应的数据</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Mathematics;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(SimulationSystemGroup))</span>]</span><br><span class="line">[<span class="meta">UpdateBefore(typeof(TransformSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeBouncingSystem</span> : <span class="title">JobComponentSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> JobHandle <span class="title">OnUpdate</span>(<span class="params">JobHandle inputDeps</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> multiplier = Input.GetKey(KeyCode.Space) ? <span class="number">100</span> : <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">var</span> elapsedTime = Time.ElapsedTime;</span><br><span class="line">        </span><br><span class="line">        JobHandle jh = Entities.WithAll&lt;Cube&gt;().ForEach((<span class="keyword">ref</span> Translation t) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            float3 <span class="keyword">value</span> = t.Value;</span><br><span class="line">            <span class="keyword">value</span>.y = math.cos((<span class="keyword">float</span>) elapsedTime * multiplier);</span><br><span class="line">            t.Value = <span class="keyword">value</span>;</span><br><span class="line">        &#125;).Schedule(inputDeps);</span><br><span class="line">        <span class="keyword">return</span> jh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f23943863e0ab8ec8907f242579a0884_b.jpg" alt="img"></p>
<p>Worker 线程现在已经在工作了. 当你用这种方式构建游戏, 最终几乎每个 Worker 线程都会来回使用以避免闲置:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f116b2bea7e7ca411112bc9e82265c54_720w.jpg" alt="img"></p>
<h2 id="可是这样构建游戏实在是太痛苦了"><a href="#可是这样构建游戏实在是太痛苦了" class="headerlink" title="可是这样构建游戏实在是太痛苦了"></a>可是这样构建游戏实在是太痛苦了</h2><p>你应该已经注意到, 正儿八经的游戏要改成 data-oriented 并不容易. (除了上文的弹跳球这样的简单场景). 甚至现在你都没法使用所见即所得的编辑器了. 整个游戏如果按照这种方式获取 LTW + Mesh + Material 将会是噩梦般的开发旅程. 虽然整个游戏按照这样的方式构建非常恐怖, 但性能确实是会非常好. 有点倒退回 Cocos2D 时代的感觉. 自然你是想要在编辑器中快速地迭代玩法/美术相关内容.</p>
<p>但记住这个方块绘制效率极高, 如果你添加更多的方块, 它们都会打包喂给<code>BatchRendererGroup</code> 因为在同一个 chunk 内存里 <code>LocalToWorld</code> 已经被连续排列好了. 而复制一个方块也不再是复制<code>GameObject</code>这样昂贵的操作, 只需要添加更多 Entity 以及相应的组件.</p>
<p>同样的, 一个 Entity 将数据转存回 <code>GameObject</code> 也不是什么好主意 (<code>GameObjectEntity</code> 就做了这样的事儿), 我们想要运行时的 pure ECS , 而不是桥接回 <code>MonoBehaviour</code> 的 ECS.</p>
<p>简言之, 你想要 ECS 的高性能, 但不想要按这样的方式来开发游戏.</p>
<h2 id="Conversion-workflow"><a href="#Conversion-workflow" class="headerlink" title="Conversion workflow"></a>Conversion workflow</h2><p>所以 Unity 团队采用了常规的 GameObject 来仅实现<strong>编辑操作(authoring),</strong> 而在运行时, 则将这些 GameObject <strong>转换(convert)</strong>为纯粹的 ECS data.</p>
<p>我之所以之前介绍 renderer 和 transform, 是因为转换过程实际上是将编辑时方便的 GameObject 对象转换为高性能 transform 和 renderring 系统支持的 entity.</p>
<p><strong>Component object</strong></p>
<p>在进阶之前, 我假设你已经知道了 component objects. 这不仅是可以添加到 Entity 上的 <code>IComponentData</code> 组件, 你甚至可以使用 <code>MonoBehaviour</code> 类型.</p>
<p>只不过你无法在 jobs 使用这些类型, 很多有 <code>IComponentData</code> 约束的泛型 API 也无法被使用. 但是这种类型的组件确实是关联到 Entity 上的, 也有相关的 API 可以使用. 以下是一些支持 component objects API 例子:</p>
<ul>
<li><code>EntityManager</code>:<code>AddComponentObject</code>,<code>GetComponentObject</code>. 如果添加不存在的组件, 你在获取时会得到一个 null.</li>
<li><code>ComponentType</code>: 你可以创建 <code>&lt;T&gt;</code> (如<code>MonoBehaviour</code>)类型的 <code>ComponentType</code></li>
<li><code>system.GetEntityQuery</code>,<code>em.CreateArchetype</code>: 因此你可以使用<code>MonoBehaviour</code>类型的 <code>ComponentType</code> 来创建组件的查询.</li>
<li><code>EntityQuery</code>:<code>ToComponentArray</code>会返回 <code>T[]</code>. 这会返回以托管数组方式存储托管组件的结果, 而不是<code>ToComponentDataArray</code>那样返回 <code>NativeArray&lt;T&gt;</code></li>
</ul>
<h2 id="Conversion-world-destination-world-primary-entity"><a href="#Conversion-world-destination-world-primary-entity" class="headerlink" title="Conversion world, destination world, primary entity"></a>Conversion world, destination world, primary entity</h2><p>在内部, 转换过程是创建特定目的的 World, 并在其中运行特定的 <strong>conversion systems</strong> (这样你会得到一个新的 <code>EntityManager</code>, 以及存储entities 的数据库). 这被称为 <strong>conversion world</strong>. conversion world 同时也知晓用于存储转换结果的 <strong>destination world.</strong></p>
<p>因为conversion world is一个 ECS World, 我们可以从 Entity 出发来而不是仅仅是 Hierarchy 中的 <code>GameObject</code>. 由于前文所提到的 component object 的存在, 从<code>Gamebject</code> <strong>importing</strong> 的过程也非常容易, 所以你也可以得到一堆完整复刻 <code>Gameobject</code>原有层级关系和组件的 Entity (使用 class 类型组件). 也就是说, 让每个 entity 也拥有 Unity 传统的 <code>Transform</code>, <code>RectTransform</code>, <code>MeshFilter</code> 或者 <code>LineRenderer</code> 组件.</p>
<p>这些拥有component object 的 entity 并不优秀, 我们更希望得到更优的基于 <code>IComponentData</code> 的组件.</p>
<p>通过<strong>单次调用</strong> conversion world 的 <code>update</code> 方法, 其中的特定 system 也会 update 单次, 这会导入 component object entity 并将结果存入 destination world. 至少, 这会为每一个conversion world 中找到的 <code>Transform</code> 组件创建一个空的 Entity.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-bff28dd360d229c6ba16b991033abf0d_720w.jpg" alt="img"></p>
<p>上图中, destination world 的 Entity A 被成为 <code>GameObject A</code>的 “primary entity”. 之所以没有被称为 “resulting entity”, 是因为这转换过程并非是一对一的过程. 比如 A 可能在 destination world 中构建出 A1 和 A2 两个 entity, 这种情况, 其中一个将成为 primary entity.</p>
<p>另一个<strong>在 conversion world 工作时</strong>的特点是你可以通过原始的 <code>GameObject</code> 获取 primary entity(当然也可以传入任一 <code>MonoBehaviour</code> 来获取, 内部将会调用<code>MonoBehaviour</code>的 <code>.gameObject</code>来替代). 比如上图 A 的<code>Transform</code> 也可以用于获取 primary entity, 这在更复杂的转换过程中可能有用.</p>
<p>最后, 包含那些并不高效的 Entity 的 conversion world 将会被 <strong>destroy</strong> 掉.</p>
<h2 id="GameObjectConversionSystem"><a href="#GameObjectConversionSystem" class="headerlink" title="GameObjectConversionSystem"></a>GameObjectConversionSystem</h2><p>被标记了如下 attribute 的 system 将在 conversion world 中被调用:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">WorldSystemFilter(WorldSystemFilterFlags.GameObjectConversion)</span>]</span><br></pre></td></tr></table></figure>

<p>这个 attribute 是可继承的, 因此更推荐的方法是直接继承ECS库里已提供的<code>GameObjectConversionSystem</code>.</p>
<p>拿 <code>TransformConversion</code> system 为例. 它会在 conversion world 里面寻找 <code>Transform</code> 组件, 依此来构建 destination world 中 entity 的<code>LocalToWorld</code>和<code>Translate</code>/<code>Rotation</code>/<code>NonUniformScale</code>组件, 它甚至知道在<code>Transform</code>的 scale 为<code>(1,1,1)</code>时不添加<code>NonUniformScale</code>!</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-48b3c53e12f6c638b561e55ad6b095cb_720w.jpg" alt="img"></p>
<p>另一个值得看的例子是 <code>MeshRendererConversion</code>. 这是<code>MeshFilter</code>和<code>MeshRenderer</code>转换为<code>RenderMesh</code> 加 <code>Mesh</code> 和 <code>Material</code> 的地方</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-acf0da5e1a80bd23ba69b1bf80870973_720w.jpg" alt="img"></p>
<h2 id="Conversion-的顺序"><a href="#Conversion-的顺序" class="headerlink" title="Conversion 的顺序"></a>Conversion 的顺序</h2><p>conversion systems 都是被扫描以及归集到一起的, 因此顺序并没有被清晰地定义. 假设你想要转换过程中 “get primary entity” 并获取到 <code>LocalToWorld</code> 组件, 执行顺序就变得很重要了, 因为你要确保你的 conversion system 在 Unity 的 <code>TransformConversion</code>之后执行.</p>
<p><code>UpdateInGroup</code>依然排得上用场. 在 conversion world, 有如下一些 groups:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectDeclareReferencedObjectsGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectBeforeConversionGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectConversionGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectAfterConversionGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectExportGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>如非特别指定, 你的 system 将运行在 <code>GameObjectConversionGroup</code>中. 因此如果你想要在Unity内置的 conversion system 之后做事情, 你得确保你的 system 运行在其后. 要注意的是你不能使用<code>[UpdateAfter(typeof(TransformConversion))]</code>因为<code>TransformConversion</code>不是<code>public</code>的. 从前文截图你可以看到它运行在 before group 中, 因此你的默认运行在<code>GameObjectConversionGroup</code> 中的 system 是可以获取到 <code>LocalToWorld</code>等组件的. <code>MeshRendererConversion</code> 则运行在 <code>GameObjectConversionGroup</code> 中, 因此如果你想要获取到 RenderMesh, 则需要将你的 system 放在其后.</p>
<p>declare 和 export Group 很特殊, 因为它们运行在特定的过程的前后, 而中间三个 Group则是一紧挨着运行, 因此, 你如果要放在这两个 Group 内运行, 一定得明白它们前后都做了些什么事儿(后文会讲).</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">???</span><br><span class="line">GameObjectDeclareReferencedObjectsGroup.Update()</span><br><span class="line">???</span><br><span class="line">GameObjectBeforeConversionGroup.Update()</span><br><span class="line">GameObjectConversionGroup.Update()</span><br><span class="line">GameObjectAfterConversionGroup.Update()</span><br><span class="line">???</span><br><span class="line">GameObjectExportGroup.Update()</span><br></pre></td></tr></table></figure>

<h2 id="GameObjectConversionMappingSystem"><a href="#GameObjectConversionMappingSystem" class="headerlink" title="GameObjectConversionMappingSystem"></a>GameObjectConversionMappingSystem</h2><p>conversion world 还有一个非常特别的系统附加在所有可用的 <code>GameObjectConversionSystem</code> 里, 就是<code>GameObjectConversionMappingSystem</code>. (下文称之为 mapping system). 该系统是所有 conversion world 的 boss, 奇迹发生之地.</p>
<p>首先这是一个纯粹的 “tooling system”, 意思是它只有一个空的 <code>OnUpdate</code> 函数, 完全是用来被其他系统获取, 并在它们的<code>OnUpdate</code>中使用的工具.(这种设计也适用于你自己的游戏.)</p>
<p>这里你可以执行<code>GetPrimaryEntity</code> 来与 destination world 沟通, 或者创建更多的 entity. 当你想执行 conversion, 你需要显式地指定 destination world. 这个 world 用来当作 mapping system 的 constructor.</p>
<p>在你的 conversion system 里面, 你可以 <code>GetOrCreateSystem</code> 来获取 mapping system, 但如果你继承了<code>GameObjectConversionSystem</code>, 则可以直接通过相应的<code>protected</code> 方法获取到.</p>
<h2 id="让我们使用-ConvertToEntity-来convert吧"><a href="#让我们使用-ConvertToEntity-来convert吧" class="headerlink" title="让我们使用 ConvertToEntity 来convert吧"></a>让我们使用 ConvertToEntity 来convert吧</h2><p>现在已经有足够的知识来执行转换过程了. 目前我们仅仅使用 Unity 内置的 conversion system. 也即<code>TransformConversion</code>和<code>MeshRendererConversion</code> , 因此确保你的输入拥有<code>Transform</code>,<code>MeshFilter</code>和<code>MeshRenderer</code> 来得到结果.</p>
<p>要在scene里面选择 game objects导入 conversion world, 我们可以使用<code>ConvertToEntity</code>组件. 在 <code>Awake</code> 里面, 它会基于一些标准来选择导入什么. 所以若如下图附加到<code>GameObject</code>上, 那么在 conversion world里, 我会得到这些ECS的 <strong>component objects:</strong> <code>Transform</code>,<code>Hello</code>.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-a96ebb838511e15934a42fd1b2000b1c_720w.jpg" alt="img"></p>
<p>当进入 play mode 时, <code>Awake</code> 被调用的瞬间后你得到:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-dcece28b71a8313f75f0e4fd6ca7667c_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-87122268425b7052676a0b7cce6c8cc8_720w.jpg" alt="img"></p>
<p>当前状态当然还没准备好绘制, 因为还没有 <code>RenderMesh</code>, 但是你可以看到<code>TransformConversion</code>发现了<code>Transform</code>component object 然后就在conversion world 被销毁之前, 在 Primary entity 上构建了 LTW/TR .</p>
<p>如果我修改一下 scale:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-84dbdfe15794ce27a4b4957f7480abcb_720w.jpg" alt="img"></p>
<p>转换的结果:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-6d131a5073402ee6700baf5c1c9a7829_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-bf7ebc16e636d69937377796cc12a334_720w.jpg" alt="img"></p>
<p>因为 <code>TransformConversion</code> conversion system 的代码发现了 <code>Transform</code>有非 1 的 scale, 于是决定加上额外的组件到 primary entity 上.</p>
<p>接下来看看<code>MeshRendererConversion</code>在我们添加了 <code>MeshFilter</code>和<code>MeshRenderer</code> 后做些什么:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-2cc3d708a668ecd3a34776ae9860b433_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-adeb3de47a701bf36a971fa9baeaae97_b.jpg" alt="img"></p>
<p>我得到了一个正确转换且拥有纯粹ECS数据后的方块! 另外 conversion world 也可以分配 entity name, 因为 conversion world 知晓 <code>Transform</code> 的存在, 所以可以在 conversion world 被销毁前通过<code>.gameObject.name</code> 来追踪其名字.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-992e31a0522e8183fcbee75cf061ec4b_720w.jpg" alt="img"></p>
<p><code>ConvertToEntity</code>组件里”and destroy” 选项并非 conversion world 流程里的内容, 由该MonoBehaviour 组件自行完成. 因为它并不觉得你想要复制出同样的结果, 如果我不销毁掉原对象, 那么我就会得到两个方块, 一个来自<code>MeshFilter</code>和<code>MeshRenderer</code> , 另一个来自Hybrid Renderer 渲染的<code>RenderMesh</code>和<code>LocalToWorld</code> .</p>
<p>如果你不想要默认的行为, 你可以使用<code>GameObjectConversionUtility.ConvertGameObjectHierarchy</code>手工转换. 后文会细讲.</p>
<h2 id="Hierarchy-conversion"><a href="#Hierarchy-conversion" class="headerlink" title="Hierarchy conversion"></a>Hierarchy conversion</h2><p><code>ConvertToEntity</code> 实际上提交了所有子 <code>GameObject</code> 给 conversion world, 除非你在子对象中使用 <code>ConvertToEntity (Stop)</code>.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-3ecf0a5ef86786b295197e8b9af42d3e_720w.jpg" alt="img"></p>
<p>上图的结构中, conversion world 最后会得到: A B E F G H. 每一个元素的 component objects 都会和最初的类似. <code>Transform</code>component object 是关键点, 因为它有<code>.parent</code>属性, 这样 conversion world 才能基于此构建出整个层级树.</p>
<p>给 D 添加 <code>ConvertToEntity</code>是不会有效果的(在C处转换就停止了), 因此会抛出警告. 而添加<code>ConvertToEntity</code>给 B 则没有警告, 但也不会有额外的作用, 因为 A 处隐含了 B也将被纳入层级的事实.</p>
<p>ECS 里有一个<code>Parent</code>组件, 该组件仅有一个<code>Entity</code>字段用来表示 transform 的层级关系.<code>LocalToWorld</code>的计算总是基于<code>Parent</code>组件. 如果 <code>Translation</code>是 0, 那么 <code>LocalToWorld</code> 矩阵的结果并不是在行1 2 3 和 列4为0, 而是直接复制<code>Parent</code>所指示Entity的<code>LocalToWorld</code> 的值.</p>
<p>而负责计算<code>Parent</code>的正是 <code>TransformConversion</code>, 让我们看看结果:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-cf1b98c0bfc171a75faaeb1708bb6807_720w.jpg" alt="img"></p>
<p>我们先猜猜A B E F G H 会占用多少 chunk? (不管转换过程中有多少魔法, 我们永远得关注数据本身!) 先假设我们这些对象的 scale 都为1 (这样就不会产出<code>NonUniformScale</code>组件).</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-b03840ef2f4026f8171dd5a0981ab1f5_b.jpg" alt="img"></p>
<p>为何有 3 个chunk?</p>
<p>你可能会猜测所有 chunk 都会有 <code>Parent</code> 而对于根部的 A, 其<code>Parent</code>则可以是一个 <code>Entity.Null</code> , 但是 Unity 并没有选择这样做, 因为在复杂一些的游戏里, 查询时使用<code>ComponentType.Exclude</code> 会相对更加高效一点. (你可以想象成如果没有parent组件, transform systems 可以忽略掉一些矩阵运算.)</p>
<ul>
<li>没有 Parent, 但有 child : A</li>
<li>Parent 和 Child 都有: F</li>
<li>叶子节点, 仅有 Child: B E H G</li>
</ul>
<p>你可以看到还有一些 component 被添加了: <code>LocalToParent</code>,<code>Child</code>,<code>PreviousParent</code>.目前还无需关心它们, 总之它们会最终参与<code>LocalToWorld</code>的计算.</p>
<p>注意到 conversion 过程中有多少个不同的 Archetype 产生有时候很有用. 比如当你有个巨大的 game objects 层级树, 且其中有些对象仅仅是用来组织结构的空对象, 有些则真正拥有<code>MeshFilter</code>and<code>MeshRenderer</code>, 这样你最终可能会至少得到 6 个 chunk. (3个前述chunk, 以及3个包含<code>RenderMesh</code> 的chunk). 因为<code>RenderMesh</code>是<code>ISharedComponentData</code>, 如果你有更多的 mesh 和 materials, 那么 chunk 的数量还会继续增加. 总之, 这类的思想也出现在dynamic/static batching, GPU instancing, 或 SRP batchers 之中, 而不是 ECS 独有. 使用Entity Debugger 可以清楚地看到 chunks 是如何被组织的.</p>
<p>“and destroy” 的行为在 stop 时也会有一些变化, 被 stop 的对象之下的层级会被单独摘出来并保留(因为 Unity 猜测既然那里你没有相应的 entity, 那么就为你保留 gameobject)</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-ad321f404c9cc350778236f78db75bab_720w.jpg" alt="img"></p>
<h2 id="Disabled-与-GameObject-conversion"><a href="#Disabled-与-GameObject-conversion" class="headerlink" title="Disabled 与 GameObject conversion"></a>Disabled 与 GameObject conversion</h2><p>被 disabled 了的<code>GameObject</code>会被加上一个 ECS 中的<code>Disabled</code>component, 如下所示, Convert and destroying 顶部的 Cube, 你会得到 5 个 Entity, 其中 3 个关联 <code>Disabled</code>component:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-aa8d98f0c436030e2833da7985bb4f51_720w.jpg" alt="img"></p>
<p>当然你依然可以在层级任何位置添加 Convert To Entity (Stop), 其行为不会发生变化. 比如我在 Cube(1) 和 Cube(4) 上添加 stop, 那么我最终将得到 3 个 Entity: Cube(2) , 有<code>Disabled</code>的Cube(3), 没有<code>Disabled</code>Cube .</p>
<h2 id="Convert-and-inject-模式"><a href="#Convert-and-inject-模式" class="headerlink" title="Convert and inject 模式"></a>Convert and inject 模式</h2><p>假如:</p>
<ul>
<li>你想保留原始的 game object</li>
<li>同时想在 conversion world 销毁之前导出 <strong>component objects</strong> 给 primary entity. (当然也包含转换过程中新增的 components)</li>
</ul>
<p>如前文中提到的, 我有<code>Hello</code>和<code>LineRenderer</code>会被带进 conversion world , 但由于并没有conversion system会处理<code>Hello</code>和<code>LineRenderer</code>, 因此会在 conversion world 被销毁时也同时被销毁.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-310140196c94a5d298a09d2551b3382f_720w.jpg" alt="img"></p>
<p>但在”Convert and inject”模式下, 这两者就可以被保留:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-3a5a13b66d3362a1fbf6e30aa20a6223_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-b635d5f273e58223e298b87a1edebc82_720w.jpg" alt="img"></p>
<p>这样, 我像之前一样正常得到了<code>LocalToWorld</code> , 但同时我也得到了<code>Transform</code> <code>Hello</code>和<code>LineRenderer</code>, 这意味着你得到了一个可以追溯回原始 GameObject 的 Entity. 如果我们在别处 destroy 这个 GameObject, 那么 ECS 侧的<code>em.GetComponentObject&lt;Transform/LineRenderer&gt;</code> 也相应回返回 <code>null</code>.</p>
<p>现在你应该明白了, 销毁或者不销毁原始 Gameobject 两种模式都有各自的意义 (前者是为了避免重复, 后者为了访问 component objects).</p>
<p>这意味着如果我有一个关联<code>MeshRenderer</code>和<code>MeshFilter</code>的方块同时又选择了inject模式, 我会得到渲染在同一位置的两个方块. 如下图, 一个方块是 2 * 6 * 2 = 24个 tris(额外 2个 tris是蓝色的背景所占用的), 如果使用 convert and destroy, 我依然会得到 26 个 tris并被Hybrid Renderer所用, 在但 inject 模式下, 会变为 50 个 tris, 因为转换前后的对象都被保留了:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-689301524050755bbcf6ed29b45330f0_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-3b37442f567073f3500c401bdadc285a_720w.jpg" alt="img"></p>
<p>上面这个例子并不是 inject 模式的预期用法, 该模式是用于当你需要在 conversion 的结果上面回溯原有对象的情况下才有用, 而 Hybrid Renderer 显然无需回溯.</p>
<h2 id="使用-ECS-的System-来管理传统的-MonoBehaviour"><a href="#使用-ECS-的System-来管理传统的-MonoBehaviour" class="headerlink" title="使用 ECS 的System 来管理传统的 MonoBehaviour"></a>使用 ECS 的System 来管理传统的 MonoBehaviour</h2><p>inject 模式最酷的在于, 从现在开始, 你就可以制作 hybrid ECS 游戏了. 你可以把 inject 模式视作将对象转化为 ECS system 可访问的对象, 甚至在你没有 conversion system 的时候. 仅仅是保留 component objects 以及是非常有用了. 你完全可以用 <code>MonoBehaviour</code>进行组件的开发, 然后用 system 来控制它们.</p>
<p>你可以在 <code>GameObject</code> 上就如同<code>IComponentData</code>一般添加 <code>MonoBehaviour</code>, “tag 用途的<code>MonoBehaviour</code>“ 也是完全可行的. 不过过去常见的<code>MonoBehaviour</code>继承模式在ECS的世界里, 你可能需要考虑用组合模式来替代了, 一如 ECS 里常用的<code>struct</code> 并不能继承.</p>
<p>虽然并没有性能上的提升, 但是依托 ECS 的查询能力可以获得 system 设计上极佳的灵活性.</p>
<p>或许你过去常常使用一种”manager优化”手段, 就是你去掉移除对象的<code>Update</code> 方法, 然后让一个 Manager 来追踪该对象的<code>List</code>来统一地 <code>update</code>.</p>
<p>而用于操作 component object (monobehaviour) 的 system 正是和上述优化一模一样的玩意儿! 而且 ECS 在查询上更加灵活. 你可以不断添加查询不同种类 component object 的 system. 这样对于在团队中分割工作量更容易. 也可以通过 <code>UpdateBefore/After</code> 调整执行顺序, 而不是过去地狱般的 script execution order.</p>
<p>举一个 UGUI 按钮的例子. 我想要用 system 来添加一段逻辑: 改变<code>interactable</code>时按钮会在正常和禁用状态之间闪烁.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-691223f5e1d1debbb595f47a4b38c2ed_720w.jpg" alt="img"></p>
<p>所有按钮都使用 convert and inject, 其中一个缺少<code>BlinkingButton</code>“tag”<code>GameObject</code>. 目前还没有任何实际代码, 不过我想要用这些类型来进行查询.</p>
<p>来看看 conversion 后的结果, 我们得到 2个 chunk, 其中一个有3个 entity (橙色的竖条往右边移动了一点, 意味着其包含 3/160 个 entity), 另一个则有一个 entity.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f6a2d6ad3e349d49a3b6ef3d34b2aa44_720w.jpg" alt="img"></p>
<p>下面的 system 则能自动到 ECS 的数据库里面查询 scene 里面所有带有 blinking 组件的按钮. 这种”凭空”查询<code>GameObject</code>的能力让声明<code>GameObject[]</code>成为了过去时. 即便你对 ECS 毫无兴趣, 这种查询能力也让其成为非常便捷的 Unity 开发工具.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(PresentationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlinkingButtonSystem</span> : <span class="title">JobComponentSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    EntityQuery blinkingButtonQuery;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnCreate();</span><br><span class="line">        blinkingButtonQuery = GetEntityQuery(</span><br><span class="line">            ComponentType.ReadOnly&lt;Button&gt;(),</span><br><span class="line">            ComponentType.ReadOnly&lt;BlinkingButton&gt;()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//It is not a good idea to have data in system!</span></span><br><span class="line">    <span class="keyword">float</span> collectTime;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">on</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> JobHandle <span class="title">OnUpdate</span>(<span class="params">JobHandle inputDeps</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        collectTime += Time.DeltaTime;</span><br><span class="line">        <span class="keyword">if</span> (collectTime &gt; <span class="number">0.2f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            collectTime -= <span class="number">0.2f</span>;</span><br><span class="line">            <span class="keyword">on</span> = !<span class="keyword">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Button[] buttons = blinkingButtonQuery.ToComponentArray&lt;Button&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> b <span class="keyword">in</span> buttons)</span><br><span class="line">        &#123;</span><br><span class="line">            b.interactable = <span class="keyword">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-5ed751beea434345f9972273619f2ed2_b.jpg" alt="img"></p>
<p><code>Entities.ForEach</code>也可以使用 component objects, 只不过这时候不能使用<code>ref</code>或<code>in</code>关键字, 同时为了防止使用 Burst, 你需要用<code>Run</code>来替代<code>Schedule</code>.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Entities.WithAll&lt;BlinkingButton&gt;()</span><br><span class="line">  .ForEach((Button b) =&gt; &#123; b.interactable = <span class="keyword">on</span>; &#125;).WithoutBurst().Run();</span><br></pre></td></tr></table></figure>

<p>这样完全或者部分移植到 ECS 的游戏, 也可以自由使用 system 了, 只需要 inject 模式, 你便拥有了基于 Entity 的查询能力.</p>
<h2 id="Inject-模式的-conversion-规则"><a href="#Inject-模式的-conversion-规则" class="headerlink" title="Inject 模式的 conversion 规则"></a>Inject 模式的 conversion 规则</h2><p>上文例子中将所有的<code>Button</code>转换到 ECS 了, 那<code>Button</code> 里的<code>Text</code>怎么办呢?</p>
<p>和会将所有子层级提交到 conversion world 的 destroy 模式<strong>不同</strong>, 这时所有的子层级将被忽略(即便你为它们添加了inject模式的<code>ConvertToEntity</code>组件). 仅有顶层对象会正常convert and inject. 所以 ECS 不会为创建关联<code>Text</code>component object的<code>Entity</code>.</p>
<p>为了更清晰地说明这条规则, 我试着 convert 更上层的<code>Canvas</code>:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-44014cd244f3d5aa39e4c0cf8d534e47_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-5b8285a1bdd4c30a3aa57bf7c8cd3f7f_720w.jpg" alt="img"></p>
<p>这下我的 Button 并没出现在 ECS 的世界里, 而只得到了 Canvas, 如果我把模式切回 destroy, 则得到一堆 pure 的 entity 而不带任何 component objects:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-e573126980ccfb5cf19b281e234acbb4_720w.jpg" alt="img"></p>
<p>可以看到, 所有在conversion world 中的 component objects 最终都被销毁了.</p>
<h2 id="IConvertGameObjectToEntity"><a href="#IConvertGameObjectToEntity" class="headerlink" title="IConvertGameObjectToEntity"></a>IConvertGameObjectToEntity</h2><p>实现 conversion system(通过继承<code>GameObjectConversionSystem</code>)可以让你自由控制conversion 的过程. 但如果你想按照具体类型来转换呢? 每当转换执行时, 应当相应地执行一些代码.</p>
<p>Unity 内置了另一种名为<code>ConvertGameObjectToEntitySystem</code> 的 conversion system. 该 system 会迭代 conversion world 中所有的<code>GameObject</code>, 接着使用<code>GetComponents</code> 并判断是否实现<code>IConvertGameObjectToEntity</code> 接口, 然后再调用该接口的<code>.Convert</code> 方法. 你可以把任何逻辑都放在这里:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlinkingButton</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>entity</code>参数是 <code>GameObject</code>产生的 primary entity. 回忆一下前文提到”primary entity”与<code>GameObject</code> 以及相应<code>MonoBehaviour</code> 关联. <code>dstManager</code>参数则是 destination world 里的 <code>EntityManager</code>. 在这里你可以做任何相关联的事儿, 比如为每个<code>BlinkingButton</code>添加 500 个屁用没有的 Entity?当然可以!</p>
<p>你可以利用这里的机会来使用<code>dstManager.Add / SetComponentData</code>来初始化更多数据. 要注意这里有一丝”遥控” destination world 的味道(因为实际上你工作在 conversion world 层面). 所以重视这个参数名字, 因为确实有另一个属于 conversion world 的 manager.</p>
<p>单独创建 conversion system 并使用<code>Entities.ForEach</code>来初始化数据也许会更高效一些(因为你在这里使用 Burst 和 jobs). 但是 Convert 方法运行你获取到<code>MonoBehaviour</code>中序列化的字段, 这样更加随心的修改每个 entity 关联的数据.</p>
<p><code>conversionSystem</code>参数则是调用<code>Convert</code>方法的<code>ConvertGameObjectToEntitySystem</code>本体, 但是强制被转换成了<code>GameObjectConversionSystem</code> 类型(小心名称有点易混). 其目的是让你可以使用 mapping system 中的方法.</p>
<h2 id="LinkedEntityGroup"><a href="#LinkedEntityGroup" class="headerlink" title="LinkedEntityGroup"></a>LinkedEntityGroup</h2><p><code>LinkedEntityGroup</code>是一个 dynamic buffer , 通常它会影响:</p>
<ul>
<li>调用<code>Instantiate</code>方法时, 会同时实例化所有 buffer 中的 entity, 同时也会创建相同的<code>LinkedEntityGroup</code>. 注意实例化并不一定和ECS中的<code>Prefab</code> component 直接关联.</li>
<li>调用<code>DestroyEntity</code>时也会同时销毁 <code>LinkedEntityGroup</code>中的所有 entity. 类似在编辑器中删除<code>GameObject</code></li>
<li>调用 <code>entityManager.SetEnabled</code> 加上的 <code>Disabled</code>component 会告知 ECS 的查询系统忽略它们, 而 <code>LinkedEntityGroup</code> 中的 entity 也会受到同样的影响. 有点类似禁用<code>GameObject</code> 时同时会禁用整个层级树.</li>
</ul>
<p>注意如果buffer 中的 entity 也有<code>LinkedEntityGroup</code>, 系统<strong>不会递归地</strong>执行instantiation/destroy/disabled 过程.</p>
<p>这些过程在具体执行当中也有一些细微不同.<code>Instantiate</code>和<code>SetEnabled</code>只要检测到 buffer 便在所有成员上一次性执行, 不会做其他更多事. 这意味着关联该 buffer 的 entity <strong>必须要把自己包括在内</strong>才能正常工作<strong>.</strong> 然而<code>DestroyEntity</code>则无所谓, 因为它会先销毁传入的entity, 然后再迭代 buffer 中的 entity 进行销毁.</p>
<p>要注意<code>LinkedEntityGroup</code> 和 <code>Parent</code>并不一样 (虽然它们经常同时出现). 后者是递归地工作, 循环依赖也是不允许的.</p>
<h2 id="从非-prefab-conversion-中获取LinkedEntityGroup"><a href="#从非-prefab-conversion-中获取LinkedEntityGroup" class="headerlink" title="从非 prefab conversion 中获取LinkedEntityGroup"></a>从非 prefab conversion 中获取LinkedEntityGroup</h2><p>目前, 我们使用<code>ConvertToEntity</code>并不能得到 <code>LinkedEntityGroup</code>. 所以当销毁转换后的 entity时, 并不能连锁地销毁相关联的entity(比如Child/Parent), 不管你是否认同, 目前这是默认的行为. (<code>ConvertToEntity</code>却可以正常得到基于<code>Parent</code> 的层级结构).</p>
<p>如果你需要该 buffer 正常添加, 在 mapping sysytem 中有一个方法可以使用:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareLinkedEntityGroup</span>(<span class="params">GameObject gameObject</span>)</span></span><br></pre></td></tr></table></figure>

<p>调用后 primary entity 会得到该 buffer, 并包含所有子对象(递归地查询, 线性排列的结果).</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeConvert</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        conversionSystem.DeclareLinkedEntityGroup(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-fe2983f48e754c910758292e0a0dfc91_720w.jpg" alt="img"></p>
<p>从 debbuger 现在可以看到已经正常添加了<code>LinkedEntityGroup</code>, 目前它已经支持<code>Instantiate</code>和<code>SetEnable</code> 的正常工作了:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-7d3ddcf06ebfd7b410dc38b6dd0d336a_720w.jpg" alt="img"></p>
<p>Unity 也在其他一些地方执行这一过程, 比如在转换 prefab <strong>asset</strong> 的时候.(后文会讲)</p>
<h2 id="尺寸警告"><a href="#尺寸警告" class="headerlink" title="尺寸警告!"></a>尺寸警告!</h2><p>你可能觉得每个 chunk 16KB 非常多了, 你最多可以放进去 2000个 entity. 一旦你开始转换层级结构, <code>LinkedEntityGroup</code>和它那些朋友们(比如 <code>Child</code> )会很快耗光这些预算, 每一个 buffer 里的元素都是一个 8 bytes 的 <code>Entity</code>.</p>
<p>下图中 12 个 chunks 中, 每个只能容纳 45 个 <code>Entity</code> , 哪怕只是非常简单的层级结构和非常少量的 component, 远达不到我们的千个级别.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-398058d78c2ab70ef17a48f705fe5195_720w.jpg" alt="img"></p>
<p>在 entities-0.5.1版本里, <code>TypeManager.cs</code> 源码中可看到, 任何没有<code>[InternalBufferCapacity]</code> 的buffer 类型都会默认 <code>128/size</code> 的容量. <code>LinkedEntityGroup</code>里面装的是 entity, 因此其容量是 <code>128/8 = 16</code> .</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-fe0be3a9fca17f9a89108d85d8ba961c_720w.jpg" alt="img"></p>
<p>这意味着:</p>
<ul>
<li><strong>每个 Entity</strong> 关联的<code>LinkedEntityGroup</code>(或者其他未指定 capacity 的buffer) 将占据 128 bytes. 这是 chunk 容积变小的原因.</li>
<li>层级中超过16个子对象并不是什么好事, 一旦超过这个数量, 这些 linked entities 不得不从排列良好的 chunk 内存中挪到堆内存中. 可能 Unity 认为 16 是一个不太可能达到的值, 而 8 又太过于常见.</li>
<li>除非显式调用, <code>LinkedEntityGroup</code>仅仅在 prefab 的 conversion 过程中被自动创建, 因此你只需要注意你的 prefab 里面嵌套的 <code>GameObject</code> 数量</li>
<li>在运行时, 所有嵌套 prefab 和 prefab variant 工作流并不受影响, 系统内部只把它们看过一个单独的 prefab. 你无法把嵌套 prefab 从父 prefab 中拿出来, 并期望<code>LinkedEntityGroup</code>正常工作.</li>
</ul>
<p>最后, 16kb 一个 chunk 意味着 1MB 大概包含 60 个 chunk. 如上例, 你能在 1MB 存储大约 2700 个转换后的GameObject , 这样看来或许45 的 chunk 容量也不用太担心了(当然具体情况具体分析).</p>
<h2 id="创建额外的-entity"><a href="#创建额外的-entity" class="headerlink" title="创建额外的 entity"></a>创建额外的 entity</h2><p>一个常见的情况是一个 GameObject 对应一个 Entity, 也即 “primary entity”. 在 mapping system 里面, 调用 CreateAdditionalEntity(gameObject)来创建更多的Entity .这些 entity 现在属于这个 game object 的 “secondary entity”.</p>
<p>设想我们的新设计是每当CubeMultiple 转换时将会创建额外的两个 entity:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeMultiple</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Entity additional1 = conversionSystem.CreateAdditionalEntity(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        dstManager.SetName(additional1, <span class="string">$"<span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span>_Add1"</span>);</span><br><span class="line">        Entity additional2 = conversionSystem.CreateAdditionalEntity(<span class="keyword">this</span>.gameObject);</span><br><span class="line">        dstManager.SetName(additional2, <span class="string">$"<span class="subst">&#123;<span class="keyword">this</span>.name&#125;</span>_Add2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意Convert调用是递归的, ConvertToEntity 附加在顶部的 CubeHead 上.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-9cbab2ea04976cef1e61cc2b365e71af_720w.jpg" alt="img"></p>
<p>要注意额外的entity都是新增的, 且没有为它们添加 components, 这不像那些被默认转换的component objects (如 Transform), 注意下方拥有 2008 容量的 chunk:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f1a5fb905599fc0439e0a6764dd09072_720w.jpg" alt="img"></p>
<p>你可能意识的到使用 destination entity manager 的 dstManager.CreateEntity() 来做同样的事情, 下文你会看到这不只是处理方式的问题.</p>
<h2 id="从单一源得到-entity"><a href="#从单一源得到-entity" class="headerlink" title="从单一源得到 entity"></a>从单一源得到 entity</h2><p>要这样做, 需要在 mapping system 里, 调用GetEntities(gameObject/component). 因为我们增加了额外的 entity, 让 conversion world 知道这些 entity 来自特定的东西, 这样让我们可以查询到它们. 比如, 如果我有一个GameObject CubeMultiple 的引用, 那么使用GetEntities 我就能得到 primary entity 和另外两个新增的 entity.</p>
<p>你无需担心它们是否已经被创建了或者担心Convert 顺序, 因为这类调用会例行调用Convert . (这一点同样适用于GetPrimaryEntity )</p>
<h2 id="如何影响-linked-entity-group"><a href="#如何影响-linked-entity-group" class="headerlink" title="如何影响 linked entity group"></a>如何影响 linked entity group</h2><p>回忆一下DeclareLinkedEntityGroup. 通过正确增加额外的 entity, conversion system 知道它们如何关联至 GameObject. 这些结果也会添加进 linked entity group.</p>
<p>前面 CubeHead 的例子在自己身上调用DeclareLinkedEntityGroup , 结果是已经把额外增加的 entity 包含进来了:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-549d3983b0e3532643b81a2a3cecf79a_720w.jpg" alt="img"></p>
<p>而只是单纯地通过dstManager 来创建 entity 则不会有这样的效果. 这样看起来转换CubeMultiple 更像是带着一些添加更多 Entity 到 destination world 的”副作用”, 而不是它变成了多个 entity. 而这种模式也能配合 live link 的工作. (后文会解释)</p>
<h2 id="声明-Asset"><a href="#声明-Asset" class="headerlink" title="声明 Asset"></a>声明 Asset</h2><p>或许你也想通过 asset 而不仅仅是 scene 来生成 entity, 好消息是 primary entity 可以关联到 asset 上, 不只是GameObject (或MonoBehaviour), 如果你调用GetPrimaryEntity 时传入 asset, 最后会在 mapping system 里面注册, 并得到正确的 entity.</p>
<p>因为你无法将ConvertToEntity放置到 asset 文件上, 你需要在 conversion 后某种”声明”它们是 entity的方法.</p>
<p><strong>什么时候声明?</strong></p>
<p>答案是在 conversion 真实发生之前. 这被称之为 discovering 过程. 如果你在这个conversion过程之中试图添加, 声明的 API 就会报错. 在声明之后, 在 conversion 过程中, 你就可以使用 GetPrimaryEntity来传入 asset 的 primary entity了. 如果你不这样做, 那么查询它们将会有点困难.</p>
<p><strong>IDeclareReferencedPrefabs</strong></p>
<p>在 discovering 阶段, 首先, 实现了IDeclareReferencedPrefabs组件接口的GameObject会被扫描, 在这里你可以通过添加 prefab asset (目前只支持 prefab 文件) 到相应的 list 中来进行声明. 你可以在inspector里通过序列化的 GameObject 字段来引用它们.</p>
<p><strong>在conversion systems里面声明</strong></p>
<p>在扫描了接口之后, 回忆一下我们前面提到的GameObjectExportGroup. 所有运行在第一个 GameObjectDeclareReferencedObjectsGroup 中的 conversion system 会被 update. 在这里, 你有另一个声明 asset 的机会, 这里支持 prefab 和<strong>其他任意类型的 assets.</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectDeclareReferencedObjectsGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectBeforeConversionGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectConversionGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectAfterConversionGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObjectExportGroup</span> : <span class="title">ComponentSystemGroup</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>使用 conversion system 意味着你手边可以使用 mapping system. 其中有几个方法可以用来声明 asset. 接下来你将如何在 system 代码中获取到这些 asset 引用呢? 你可以在conversion world 中查询任意可能链接了 asset 的 component object (比如通过在可以在 inspector 中添加的字段). 当然可能某个时间点你会意识到不如最开始就使用IDeclareReferencedPrefabs , 因为反正你都得实现某种”占位”机制. 所以, 如非必要, 尽可能使用 IDeclareReferencedPrefabs 吧.</p>
<p>接下来到了正常 conversion 的时候, 这时候你可以结合 IConvertGameObjectToEntity 来获取已经被转换好的 asset/prefab 的 Entity, 传入之前一样的引用即可:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BlinkingButton</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDeclareReferencedPrefabs</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject myPrefab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//This first</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareReferencedPrefabs</span>(<span class="params">List&lt;GameObject&gt; referencedPrefabs</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        referencedPrefabs.Add(myPrefab);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// |</span></span><br><span class="line">    <span class="comment">// V</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Then GameObjectDeclareReferencedObjectsGroup &lt;- last chance to declare stuff</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Then GameObjectBeforeConversionGroup</span></span><br><span class="line">    <span class="comment">//Then GameObjectConversionGroup, which contains ConvertGameObjectToEntitySystem that run the following Convert</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//Get primary entity of the prefab asset, to assign to primary entity converted from this component.</span></span><br><span class="line">        Entity prefabAssetEntity = conversionSystem.GetPrimaryEntity(myPrefab);</span><br><span class="line">        <span class="comment">//Remember it, etc.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// |</span></span><br><span class="line">    <span class="comment">// V</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Then GameObjectAfterConversionGroup</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意 IConvertToGameObjectToEntity 的 Convert 被调用时你依然有机会使用 mapping system. (添加额外 entity, 遍历其他 primary entity 等等) 但如果你这时候使用 mapping system 来声明更多东西就太晚了会报错.</p>
<p>以下就是完整的过程:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ??? &lt;- IDeclareReferencedPrefabs 调用.</span></span><br><span class="line">GameObjectDeclareReferencedObjectsGroup.Update()</span><br><span class="line"><span class="comment">// ??? &lt;- discovery 阶段结束, 无法再声明更多 asset.</span></span><br><span class="line">GameObjectBeforeConversionGroup.Update()</span><br><span class="line">GameObjectConversionGroup.Update()</span><br><span class="line">GameObjectAfterConversionGroup.Update()</span><br><span class="line"><span class="comment">// ???</span></span><br><span class="line">GameObjectExportGroup.Update()</span><br></pre></td></tr></table></figure>

<p>顺便一提声明截至仅仅针对 asset/prefab, 你依然可以在conversion 过程中调用DeclareLinkedEntityGroup.</p>
<p><strong>声明任意 asset</strong></p>
<p>在 mapping system 里 使用DeclareReferencedAsset , <strong>在 conversion world 里</strong>, 你会得到一个关联 Asset conponent , 外加一个你声明的 asset 类型的 component object 的 Entity (注意并非 destination world).</p>
<p>例如我可以通过DeclareReferencedAsset(mySpriteAtlas).来创建一个Entity+Asset+SpriteAtlas , 这时候 destination world 的 primary entity 依然是空的, 目前还不明白这个系统设计的目的, 也许是为了让你自己处理Asset的转换过程.</p>
<p><strong>声明 prefab asset</strong></p>
<p>添加进IDeclareReferencedPrefabs 里的 list 就行. 对于 GameObjectDeclareReferencedObjectsGroup 里的 system 来讲, 则是使用 mapping system 的DeclareReferencedPrefab 方法.</p>
<p>不过这一次和AssetandGameObject component object 不一样, 你会在 destination world 中得到一个真正的 <strong>prefab engity</strong> (而不是前面说到的空结果).</p>
<p>接下来简单解释下什么是 Entityprefab. 如果你添加一个 Prefab 组件到任何 Entity, 除非你显式指定, 那么它将在默认 query 中隐身, 和Disabled组件的行为很相似. 使用 Instantiate方法则会将实例化出的 entity 将该prefab组件删掉. (毕竟你不太可能想要实例化另一个 prefab 出来…)</p>
<p>不过该行为的目的又有所不同, 之所以在 query 中隐藏它们是并非主观上想要让它们处于 “inactive” 状态, 而是它们本就该是 “inactive”. 它们只不过是用来快速创建新数据的蓝图. 因此, 在创建 query 时有两个不同的参数模式: “include disabled” 和 “include prefabs”. 使用时注意语义上的区别 (如不要使用 Prefab 来隐藏 Entity).</p>
<p>结合前面提到的LinkedEntityGroup , 现在ECS的实例化已经和传统 Unity 的实例化感觉一样了!</p>
<p>通过声明 prefab asset, 你便同时添加了Prefab和LinkedEntityGroup 到目标primary entity上.</p>
<p>要注意ConvertToEntity只是转换对象为普通的 Entity, 因为 scene 里的层级结构并不是 <strong>asset.</strong> 无论它们是不是蓝色的(即在scene里被实例化的 prefab), 我们都无法得到Prefab或LinkedEntityGroup.</p>
<p>Prefab 本身则属于 asset 文件, 你无法在 Project panel 中粘贴ConvertToEntity运行. ECS 库通过查看它是不是位于 scene 中来决定它是不是一个 prefab, 显然可以粘贴ConvertToEntity 则意味着对象在 scene 中.</p>
<h2 id="Prefab-asset-conversion-过程"><a href="#Prefab-asset-conversion-过程" class="headerlink" title="Prefab asset conversion 过程"></a>Prefab asset conversion 过程</h2><p>上面的声明过程实际上会调用 convert 过程. 接下来我说说和转换 scene 中GameObject在细节上有哪些不同. 只要在 scene 层级中, 是否从 prefab 实例化就无关紧要, 只有在从 Project panel 处声明的 asset 被实例化时才会有区别:</p>
<p><strong>为实例化准备的自动 LinkedEntityGroup</strong></p>
<p>如下所示的 prefab asset 设置:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-de0722a0a9b1b64f962e00c0655f6641_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-968dbba1c2b6b1579f9cd5d7b1083d42_720w.jpg" alt="img"></p>
<p>要意识到 CubeHead 是一个 asset, 而不是 scene 对象.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> PrefabConversion : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity prefab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会得到:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-eca8ecacce32b7cb618f690308873ba7_720w.jpg" alt="img"></p>
<ul>
<li>如果我们 convert 位于 scene 中的 CubeHead, 我们无法获取到LinkedEntityGroup. 该行为仅仅针对 prefab asset, 其目的显然是为了实例化. (链锁销毁行为也一样)</li>
<li>LinkedEntityGroup 包含层级树下的所有对象以及自己, 包括 cube 3 和 cube 4. Conversion过程让 prefab “线性化”了, 实例化过程就无需递归调用了, 是需要遍历 LinkedEntityGroup即可.</li>
<li>前文提到过, 之所以LinkedEntityGroup包含它自己是因为 SetEnable 可以一次性完成工作, 而不是一个接一个的调用.</li>
<li>所有转换后的 entity 都会添加 Prefab组件, 但是我们只需要使用最顶层的那个 Entity 用于实例化. 事实上, 实例化过程没有Prefab 什么事儿, 主要是用LinkedEntityGroup 来完成工作. 实际上你可以实例化任何 entity.</li>
</ul>
<p><strong>为禁用功能准备的自动LinkedEntityGroup</strong></p>
<p>前文解释过 prefab 的顶层对象会得到LinkedEntityGroup 是因为需要实例化.</p>
<p>额外地, 如果在 prefab 的任何位置发现了被禁用的GameObject,该位置的对象也会得到包含所有子级对象的LinkedEntityGroup .</p>
<p>该行为的目的是为了你可以在已经被实例化的 Entity 上使用SetEnable 时能高效地添加 Disabled组件. 当然Disabled的 conversion 过程依然遵循相同的规则: 当 convert 一个非 asset 的GameObject , 会自动添加LinkedEntityGroup.</p>
<p><strong>Can’t stop won’t stop</strong></p>
<p>你不能在 prefab 中使用 Convert To Entity (Stop), 没用.</p>
<p><strong>来点小测验吧.</strong></p>
<p>依照目前这些 conversion 的规则, 来检查一下你是否能推算出上面例子正确的结果吧: Parent(还记得这是为 transform systems准备的么),Prefab,Disabled,LinkedEntityGroup(以及里面的 entity).Child和相关组件会根据Parent组件在一轮 transform systems 的update 之后被添加.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-081c8f1dcb6bece2eeb25a3e11620da6_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cube : Prefab, LinkedEntityGroup (Cube,1,2,3,4)</span><br><span class="line">1    : Prefab, Parent (Cube)</span><br><span class="line">2    : Prefab, Parent (Cube)</span><br><span class="line">3    : Prefab, Parent (2)</span><br><span class="line">4    : Prefab, Parent (2)</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f0ecb3bdbdef8bdba3b8ec63f994015c_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cube : Prefab, Prefab, LinkedEntityGroup (Cube,1,2,3,4)</span><br><span class="line">1    : Prefab, Parent (Cube)</span><br><span class="line">2    : Prefab, Parent (Cube), Disabled, LinkedEntityGroup (2,3,4)</span><br><span class="line">3    : Prefab, Parent (2), Disabled</span><br><span class="line">4    : Prefab, Parent (2), Disabled</span><br></pre></td></tr></table></figure>

<p>要记住LinkedEntityGroup 总是会包含它自己, 包括 disable 这种情况. 因此如果你在叶子对象上禁用了 GameObject , 你也会得到包含它自己的LinkedEntityGroup.(也许你觉得这无所谓, 但实际上这会让 chunks 的碎片变多).</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-8abf5ccdb436f84aa87e0982f3eba30b_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cube : </span><br><span class="line">1    : Parent (Cube)</span><br><span class="line">2    : Parent (Cube)</span><br><span class="line">3    : Parent (2)</span><br><span class="line">4    : Parent (2)</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-43536999ecd92ac2b1f1788ba43257c8_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cube : </span><br><span class="line">1    : Parent (Cube)</span><br><span class="line">2    : Parent (Cube)</span><br><span class="line">3    : Parent (2)</span><br><span class="line">4    : Parent (2)</span><br></pre></td></tr></table></figure>

<p>是否蓝色名字(说明它连接这 prefab asset)无所谓, 它不是 asset, 不会遵循LinkedEntityGroup的conversion 规则.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-9b32027c1ea133d6cc35ff6861ff544a_720w.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cube : </span><br><span class="line">1    : Parent (Cube)</span><br><span class="line">2    : Parent (Cube), Disabled</span><br><span class="line">3    : Parent (2), Disabled</span><br><span class="line">4    : Parent (2), Disabled</span><br></pre></td></tr></table></figure>

<p>注意, 这时候你无法通过Cube (2) 连锁地禁用 Cube (3) 和 (4), 因为没有自动生成LinkedEntityGroup, 但你可以人工声明它.</p>
<p><strong>prefab 实例化时的 Remapping 过程</strong></p>
<p>当在拥有LinkedEntityGroup的entity上调用Instantiate时, 会发生 <strong>entity remap</strong> 过程. (这里阅读更多内容: <a href="https://link.zhihu.com/?target=https%3A//gametorrahod.com/entity-remapping/">https://gametorrahod.com/entity-remapping/</a>) 目前你只需要知道 convert 一个 prefab <strong>asset</strong> 让LinkedEntityGroup 能工作, 就行了.</p>
<p><em>(译注: entity id 在一个 world 当中是不可重复也不可被外部修改的, 当序列化存储 entity 时, 反序列化过程会因版本问题丢失掉 entity id 引用, 这一问题同样影响实例化过程, 而 entity remap 过程就为了解决这一问题而出现的)</em></p>
<p>所以, “烘焙” Entity 值到 prefab entity 的 conversion 结果中是可行的, 当实例化时, 这些烘焙好的值又会”活了过来”.</p>
<p>在前例的情况中, 如果我添加了一个 conversion script 到 SpecialCube, 它的Convert 方法会在 CubeHead 被转换时调用, 该代码意图在于记住 Cube(3) 的 Entity:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-de0722a0a9b1b64f962e00c0655f6641_720w.jpg" alt="img"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpecialCube</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject itsChild;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        dstManager.AddComponent&lt;LinkedEntityGroup&gt;(entity);</span><br><span class="line">        <span class="keyword">var</span> leg = dstManager.GetBuffer&lt;LinkedEntityGroup&gt;(entity);</span><br><span class="line">        leg.Add(conversionSystem.GetPrimaryEntity(itsChild));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-50abef20adb51226bd0af6bddba9e8bb_720w.jpg" alt="img"></p>
<p>这时我们检查一下conversion 的Prefab entity 的结果(烘焙对于单个 Entity 或者 Entity buffer 都有效), 我们期望我们人工添加的 LinkedEntityGroup 包含对于 Prefab 同级的引用.</p>
<p>![img](data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='1832' height='564'></svg>)</p>
<p>当你调用Instantiate时, 一旦它发现可以被 Remap 的情况(如LinkedEntityGroup) Remapping 就会发生. 因此在 conversion 把它变成 Prefab 之前, “连接” Entity 引用是非常有用的, 这样一旦你Instantiate 它, 里面包含的 Entity 关系就已经可用了.</p>
<p>没有LinkedEntityGroup则 Remapping不会发生, 因为在那种情况下就没有同级对象需要 remapping Entity 的值了.</p>
<p><strong>GameObjectExportGroup 是什么?</strong></p>
<p>前面 4 个我们都介绍了它们的作用, 来看看最后这一个. 前面介绍的过程你也许会发现不仅仅可以将 conversion 结果用作运行时, 也可以用来<strong>导出</strong>. 通常 export group 是不包含在conversion 流程中的, 仅当我们显式要求时才导出.</p>
<p>如果你的 conversion system 运行在这里, 那么所有的 conversion 都已经完成, LinkedEntityGroup Prefab都已经准备就绪, 当然你不能在这时候继续 convert 了.</p>
<p>目前究竟什么是”导出(export)”依然是个谜, 或许得等 Unity 团队写点我能看懂的文档. 目前你可以认为这个 Group 在你日常的 conversion 中用不太上. 而且猜想它一定和 Assetentity有某些关系.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ??? &lt;- IDeclareReferencedPrefabs 调用.</span></span><br><span class="line">GameObjectDeclareReferencedObjectsGroup.Update()</span><br><span class="line"><span class="comment">// ??? &lt;- discovery 阶段结束, 无法再声明更多 asset.</span></span><br><span class="line">GameObjectBeforeConversionGroup.Update()</span><br><span class="line">GameObjectConversionGroup.Update()</span><br><span class="line">GameObjectAfterConversionGroup.Update()</span><br><span class="line"><span class="comment">// ??? &lt;- LinkedEntityGroup + Prefab 都已就绪.</span></span><br><span class="line">GameObjectExportGroup.Update()</span><br></pre></td></tr></table></figure>

<p><strong>mapping system 上的 DeclareDependency 是啥</strong></p>
<p>我们还漏掉了一个”声明”. 但是我不清楚这是什么, 它看起来像是 live link 会用到的东西. (后文会解释 live link).</p>
<h2 id="声明和使用-prefab-asset-的示例"><a href="#声明和使用-prefab-asset-的示例" class="headerlink" title="声明和使用 prefab asset 的示例"></a>声明和使用 prefab asset 的示例</h2><p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-88397d41a933c41fecc23cfdf0ca8e74_720w.jpg" alt="img"></p>
<p>如果我 convert and destroy 上面这些 cubes 的 MeshFilter和MeshRenderer, 我会得到两个 chunk:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-7b1b82fa14a9c96763edcd0cc98fe34c_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-84ff4d8fe1120763c200837ec2c6e6fb_720w.jpg" alt="img"></p>
<p>现在我将把它变成 prefab asset, 并从 scene 中删掉, 接着我会把该 prefab 转换为隐藏的 Prefab entity 以用于后面的 Instantiate.</p>
<p>下面是我的计划: 做一个 SpawnHere 用于存储实例化位置 (“tag” 性质的MonoBehaviour).</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-b92b5408db5a1d0c1b57c3bc876c1b63_720w.jpg" alt="img"></p>
<p>不用担心上图中有3个GameObject声明了同一个 prefab, conversion system 知道如何处理重复情况, 下面是代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections.Generic;</span><br><span class="line">using Unity.Entities;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class SpawnHere : MonoBehaviour, IConvertGameObjectToEntity, IDeclareReferencedPrefabs</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject forDeclare;</span><br><span class="line">    </span><br><span class="line">    public void DeclareReferencedPrefabs(List&lt;GameObject&gt; referencedPrefabs)</span><br><span class="line">    &#123;</span><br><span class="line">        referencedPrefabs.Add(forDeclare);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Convert(Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 discovery 阶段 asset 的 primary entity 已经被创建了且包含了Prefab和LinkedEntityGroup, 能够正常用于实例化. (由于 Prefab 的存在, 虽然拥有 RenderMesh和LocalToWorld组件, 但 Cube entity 是对于查询隐藏的, 因此也没有在画面中显示)</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-61b91e13ae93422ebf600817a3d04dd2_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-32ab362213045eb4e7f2b0e5668928d0_720w.jpg" alt="img"></p>
<p>conversion 之后, 我就可以获取Prefab在 SpawnHere 所在的位置进行实例化了, 因为LocalToWorld或Translation很多 entity 都包含, 被销毁的SpawnHere 是无法被区分的.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-fcc91ab4bc4773a9cea287ca4ef89419_720w.jpg" alt="img"></p>
<p>因此我们添加 SpawnHereEcs 当作 Tag 来使用:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SpawnHereEcs : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpawnHere</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span>, <span class="title">IDeclareReferencedPrefabs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject forDeclare;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareReferencedPrefabs</span>(<span class="params">List&lt;GameObject&gt; referencedPrefabs</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        referencedPrefabs.Add(forDeclare);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        dstManager.AddComponent&lt;SpawnHereEcs&gt;(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外, 我们可以直接在 SpawnHereEcs 里面加上 prefab entity 的引用, 而获取该 entity 的方式就是前文提到的声明过程:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SpawnHereEcs : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity thatPrefabEntity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpawnHere</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span>, <span class="title">IDeclareReferencedPrefabs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject forDeclare;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareReferencedPrefabs</span>(<span class="params">List&lt;GameObject&gt; referencedPrefabs</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        referencedPrefabs.Add(forDeclare);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);</span><br><span class="line">        dstManager.AddComponentData&lt;SpawnHereEcs&gt;(entity, <span class="keyword">new</span> SpawnHereEcs &#123;thatPrefabEntity = prefabEntity&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们的 system 将查询SpawnHereEcsentity 并在这些位置执行实例化, 之后再销毁SpawnHereEcs以避免重复实例化.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> [<span class="meta">UpdateInGroup(typeof(SimulationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpawnSystem</span> : <span class="title">JobComponentSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> JobHandle <span class="title">OnUpdate</span>(<span class="params">JobHandle inputDeps</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Entities.ForEach(</span><br><span class="line">                (Entity e, <span class="keyword">in</span> Translation t, <span class="keyword">in</span> SpawnHereEcs she) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    Entity instantiated = EntityManager.Instantiate(she.thatPrefabEntity);</span><br><span class="line">                    <span class="comment">//Set to the same translation.</span></span><br><span class="line">                    EntityManager.SetComponentData(instantiated, t);</span><br><span class="line">                    EntityManager.RemoveComponent&lt;SpawnHereEcs&gt;(e);</span><br><span class="line">                &#125;)</span><br><span class="line">            .WithStructuralChanges().Run();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以按照 chunk 来批量RemoveComponent , 使用WithStoreEntityQueryInField 来导出 lambda 定义的 EntityQuery, 然后在 ForEach 之后使用 EntityManager.RemoveComponent 传入该EntityQuery.</p>
<p>以下是我们的结果:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-a9888335c0aec5a24d809d2d49fd372c_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-d2fe910f9e5023e20a942675396ee977_720w.jpg" alt="img"></p>
<p>和Prefab 一样我们实例化的结果也拥有LinkedEntityGroup, 你还可以注意到 debugger 现在支持 select 按钮来选中 entity.</p>
<p>那么有没有可能在 conversion 阶段就能预先实例化呢? 这样我们就无需 SpawnHereEcstag 了, 因为我们知道TransformConversion完成的确切时间, 所以我们已经可以利用其 primary entity 来获取位置. 然后利用 dstManager来完成实例化. 看起来就像是SpawnHere MonoBehaviour<strong>直接转化</strong>成了 prefab 实例, 而不是在运行时分开来完成这一切.</p>
<p>你可以思考一下为什么这种方法无法正确工作然后再继续往下看</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpawnHere</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span>, <span class="title">IDeclareReferencedPrefabs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject forDeclare;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareReferencedPrefabs</span>(<span class="params">List&lt;GameObject&gt; referencedPrefabs</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        referencedPrefabs.Add(forDeclare);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Entity prefabEntity = conversionSystem.GetPrimaryEntity(forDeclare);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> spawnPosition = dstManager.GetComponentData&lt;Translation&gt;(entity);</span><br><span class="line"></span><br><span class="line">        Entity instantiated = dstManager.Instantiate(prefabEntity);</span><br><span class="line">        dstManager.SetComponentData&lt;Translation&gt;(instantiated, spawnPosition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-aa979cae836c032b9353451a6c1b3f31_720w.jpg" alt="img"></p>
<p><strong>几乎</strong>能够工作, 但是结果是只有三个cubes. 从图中可以知道, GetPrimaryEntity显然是能够正常工作的, 因为已经度过了 discovery 阶段. GetComponentData<Translation> 也能正常工作, 因为Transform会在 GameObjectBeforeConversionGroup 阶段转换完成.</p>
<p>但是回忆一下LinkedEntityGroup和Prefab 所涉及的声明过程:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ??? &lt;- IDeclareReferencedPrefabs 调用.</span></span><br><span class="line">GameObjectDeclareReferencedObjectsGroup.Update()</span><br><span class="line"><span class="comment">// ??? &lt;- discovery 阶段结束, 无法再声明更多 asset.</span></span><br><span class="line">GameObjectBeforeConversionGroup.Update()</span><br><span class="line">GameObjectConversionGroup.Update() &lt;-- 你的 Convert 方法在这时运行</span><br><span class="line">GameObjectAfterConversionGroup.Update()</span><br><span class="line"><span class="comment">// ??? &lt;- LinkedEntityGroup + Prefab 都已就绪.</span></span><br><span class="line">GameObjectExportGroup.Update()</span><br></pre></td></tr></table></figure>

<p>LinkedEntityGroup和Prefab 并未就绪! 缺乏LinkedEntityGroup导致我们最终的结果里仅仅实例化了最顶层的那个 cube. 因此在conversion过程中你无法这样使用刚刚声明的 Prefab. 如果你不清楚 conversion 流程, 很难知道为什么会有这样的结果.</p>
<h2 id="GenerateAuthoringComponent"><a href="#GenerateAuthoringComponent" class="headerlink" title="[GenerateAuthoringComponent]"></a>[GenerateAuthoringComponent]</h2><p>SpawnHere-&gt;SpawnHereEcs 这种模式要求你有一个 MonoBehaviourcomponent 在 inspector 中暴露一些字段, 然后在 conversion 后转换为等价的数据. 我们把这个MonoBehaviour称为 <strong>authoring component.</strong></p>
<p>我们当然可以创建GameObjectConversionSystem来完成相同的工作. 但是使用IConvertGameObjectToEntity无疑是更精简的方式.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The real ECS</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyData : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> data1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> data3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//For authoring</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDataOnScene</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ugly duplicated code</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> data1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> data3;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        dstManager.AddComponentData&lt;MyData&gt;(entity, <span class="keyword">new</span> MyData</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Tedious work</span></span><br><span class="line">            data1 = data1,</span><br><span class="line">            data2 = data2,</span><br><span class="line">            data3 = data3,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-35431ad3689e54c311b7c1256e5cbe7f_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-4a05be4b1b63bd7fc675c8a697d36565_720w.jpg" alt="img"></p>
<p>更棒的是, ECS 还有 IL 黑魔法来帮助你完成这个过程:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyData : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> data1;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> data2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> data3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-29e1525831cf721dcee0618eff79b2ec_720w.jpg" alt="img"></p>
<p>注意我们这里并没有定义 MonoBehaviour, 我们自动获取到了名为”My Data Authoring” 的组件, 甚至 “My Data” 也可以作为相同结果来添加. 这部分生成代码会和我们手写有类似 Convert 过程, 由于你无法查看生成的代码是什么, 这基本相当于魔法.</p>
<p>目前要施放该魔法, ECS 字段必须定义为 public, 下面这样的代码并无法按你所设想的那样工作:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyData : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">internal</span> <span class="keyword">float</span> data1;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="keyword">int</span> data2;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">public</span> <span class="keyword">bool</span> data3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-babbcac3eb118386ffd7120ee87295d2_720w.jpg" alt="img"></p>
<p>还有一个小技巧是可以生成 “声明 prefab asset” 模式功能的代码 (前面SpawnHereEcs的例子), <strong>仅需定义一个 Entity字段即可.</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyData : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity magic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-e3e22ca2eab52093ca323900d9d4ddd7_720w.jpg" alt="img"></p>
<p>以上和以下代码是完全等同的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[GenerateAuthoringComponent]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyData : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity magic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDataAuthoring</span> : <span class="title">MonoBehaviour</span>, <span class="title">IDeclareReferencedPrefabs</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject magic;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DeclareReferencedPrefabs</span>(<span class="params">List&lt;GameObject&gt; referencedPrefabs</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        referencedPrefabs.Add(magic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Entity primaryEntityOfDeclaredPrefab = conversionSystem.GetPrimaryEntity(magic);</span><br><span class="line">        dstManager.AddComponentData&lt;MyData&gt;(entity, <span class="keyword">new</span> MyData</span><br><span class="line">        &#123;</span><br><span class="line">            magic = primaryEntityOfDeclaredPrefab</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然, 你可以正常混搭Entity或float字段在一起.</p>
<h2 id="混用ConvertToEntity的-destroy-和-inject-模式"><a href="#混用ConvertToEntity的-destroy-和-inject-模式" class="headerlink" title="混用ConvertToEntity的 destroy 和 inject 模式"></a>混用ConvertToEntity的 destroy 和 inject 模式</h2><p>inject 模式会产生太多的 component objectes, 而且也不能访问整个层级树. 同样的, destroy 模式也不能清晰完整地转换整个层级到 ECS 中去. 你可能会想要介于二者之间部分地”inject”. “stop” 组件并没有满足需求 (因为你并不是要跳过转换).</p>
<p>举个例子, 如果我用Transform,MeshFilter, 和MeshRenderer建造一个飞船, ConvertToEntity 在 destroy 模式下会被转换成LocalToWorld+RenderMesh</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-64c6e9c8dcf9a4cbd9b6565c3308d9cf_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-c65c039ba549ed6676f01af4d00dd49c_720w.jpg" alt="img"></p>
<p>之前我们的 bouncing system 对 Cube和 Translation有效, 如果添加Cube到飞船的根对象上, 应该也能工作. 当然我们可以继续使用魔法生成代码:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Cube : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-ead555ad6345028ebcfebc0546bbb150_b.jpg" alt="img"></p>
<p>如果我们在排气孔位置增加一个粒子效果对象, 我想要的结果粒子随着飞船能上下弹跳:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-cc2adc78e27b72b13f67732d1cbab225_720w.jpg" alt="img"></p>
<p>destroy 模式下, 当 ParticleSystem 这个 component object 进入 conversion world 后, 最终是会被销毁的.</p>
<p>如果我添加 ConvertToEntity (Stop) 给它, 那么该对象会变成完全和 ECS 无关的东西.</p>
<p>那么如果在 destroy 模式里面的子对象上添加 inject 模式呢? 这样做我确实会得到一个包含 ParticleSystem的 Entity . 但它是否和 destroy模式转换的飞船能关联起来呢?</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-3c54d97e347fd5a0a340eba132b883bb_720w.jpg" alt="img"></p>
<p>结果并不如我们所期望那样:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-291facdfb1aa6949c491128d172ea9ef_b.jpg" alt="img"></p>
<p>但从 Entity Debugger 中我们可以看到, 这个对象确实是有destroy 模式下转换后的Parent和LocalToParent , 同时也有inject 模式下添加的ParticleSystem这个 component object. 你现在已经实现混用两种模式了!</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-5e0a38c25b41d2feb69bbfcff52db36c_720w.jpg" alt="img"></p>
<p>就我们目前所知, Parent会帮助我们计算最终的 LocalToWorld , 但是粒子没有上下弹跳是因为没有什么其他系统在使用它的LocalToWorld, 所以我们可以将它的值复制回原Transform 组件, 这可以通过copy transform to game object proxy 组件来实现, 这个组件同时也需要你添加 GameObjectEntity :</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-a9447ea8f2906a1127dd652ceb9a313f_b.jpg" alt="img"></p>
<p>注意如果飞船以 prefab asset 形式被实例化, 那么结果将会像仅使用了 destroy 模式, 也即这里的 <strong>particle system 会缺失</strong>.</p>
<h2 id="Companion-Game-Object"><a href="#Companion-Game-Object" class="headerlink" title="Companion Game Object"></a>Companion Game Object</h2><p>前文所述的方案听起来像是 hack. Particle System 依然存在于 Hierachy 中, 像是它被”胶粘”在被转换后的 Entity 上进行移动.</p>
<p>Companion game object 是一种更加”干净”的混合转换方式, 它会创建一个新的 game object 来<strong>“伴随”(companion)</strong>被转换的数据, 并用它来选择你想保留的组件. 这让它<strong>看起来像</strong>是被完美 conversion 了.</p>
<p>我们使用 mapping system 来实现该模式. 如下代码所示, 我没有增加太多非 ECS 内容, 只不过修改了一下转换相关的代码:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Ship</span> : <span class="title">MonoBehaviour</span>, <span class="title">IConvertGameObjectToEntity</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ParticleSystem particleCompanion;</span><br><span class="line">    <span class="keyword">public</span> ParticleSystemRenderer rendererCompanion;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Convert</span>(<span class="params">Entity entity, EntityManager dstManager, GameObjectConversionSystem conversionSystem</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        conversionSystem.AddHybridComponent(particleCompanion);</span><br><span class="line">        conversionSystem.AddHybridComponent(rendererCompanion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然这模式的名称叫 companion game object, 但你需要配置的其实是<strong>components.</strong> AddHybridComponent 调用不仅指定了哪个GameObject应该”伴随”, 同时也指定哪些组件会被保留.(primary entity 是按照组件来识别的). 因此我定义了组件的 public 字段而不是 GameObject字段.</p>
<p>在下面这个 ParticleSystem 的例子里, 还隐含着一个 ParticleSystemRenderer, 如果缺失了 renderer, 那么最终的 companion game object 里就只有ParticleSystem 从而导致不会渲染结果. (但是 CPU 依然会运行粒子模拟)</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-7fdcefe0ddf7884e12d264419ca52a92_720w.jpg" alt="img"></p>
<p>可以看到, 之前那些 Hack 的内容现在全都不在了! (去掉了ConvertToEntity inject 模式, 去掉了 copy proxy, 去掉了 GameObjectEntity), 现在conversion 完全正常工作!</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-9654b7da425abca92137e2cd44ff6e70_b.jpg" alt="img"></p>
<p>可以看到现在 Hierarchy 窗口里没有 Particle System 了, 但在 Game view 窗口却正常显示着, 所以它是哪里来的?</p>
<p>先来看看它对应的 primary entity 的 conversion 结果:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-2bc082bdb4447fc2ed9e59a18799f81f_720w.jpg" alt="img"></p>
<p>调用AddHybridComponent方法让 companion 相关的组件自动添加到了GameObject的 primary entity (也即 Particle System entity) 上, 同时也加上了指定的ParticleSystem和ParticleSystemRenderer.</p>
<p>其实这些 component object 仍然关联到 scene 中的对象, 只不过这些对象使用了HideFlags.HideInHierarchy 来隐藏自己. 而CompanionLink组件则指向了这个隐藏对象, 接下来 CompanionGameObjectUpdateTransformSystem 则负责将 transform 复制到 game object 当中.</p>
<p>和我们上面的 hack 几乎是一致的过程, 但是更加简洁和官方, 和 conversion system 的衔接也更加无缝.</p>
<p><strong>同时也兼容 prefab !</strong></p>
<p>Companion 的另一个好处是, 它完全支持 Prefab 转换流程, 并能<strong>正常地实例化.</strong></p>
<p>这意味着每次实例化时, 从 MeshFilter和MeshRenderer 中得到RenderMesh会被高效地处理, 而遇到 CompanionLink指定的 component object 则创建有HideFlag的 game object. 并关联好相应的 Entity</p>
<p>基本上, 这感觉就和 EntityManager.Instantiate 一样, 完美地实现了 ECS 版本的ParticleSystem.</p>
<p>具体来说, 我们将飞船先变成一个 prefab asset. 然后在 Ship 组件正常引用子对象里的组件即可.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-393b0c8128a558d1a8cf9825bb89a609_720w.jpg" alt="img"></p>
<p>我继续使用前面说到的魔法:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"></span><br><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ShipAndCo : IComponentData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity shipPrefab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-c25ff43a9da4a6adce9ec3ae6f5d6d89_720w.jpg" alt="img"></p>
<p>进入 play mode 时, 我已经在 ShipAndCo上拥有一个 就绪的Prefabentity了, 由于我知道ShipAndCo是一个 singleton, 我们用如下系统来玩一玩: 每次我按下 A 键, 在0~10之间的随机位置上实例化该 Entity.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Transforms;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> Random = Unity.Mathematics.Random;</span><br><span class="line"></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(SimulationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ShipAndCoSpawnerSystem</span> : <span class="title">JobComponentSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    Random randomizer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">base</span>.OnCreate();</span><br><span class="line">        RequireSingletonForUpdate&lt;ShipAndCo&gt;();</span><br><span class="line">        randomizer = <span class="keyword">new</span> Random();</span><br><span class="line">        randomizer.InitState(seed: <span class="number">12345</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> JobHandle <span class="title">OnUpdate</span>(<span class="params">JobHandle inputDeps</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> sac = GetSingleton&lt;ShipAndCo&gt;();</span><br><span class="line">            Entity prefabEntity = sac.shipPrefab;</span><br><span class="line">            Entity instantiated = EntityManager.Instantiate(prefabEntity);</span><br><span class="line">            EntityManager.SetComponentData&lt;Translation&gt;(instantiated, <span class="keyword">new</span> Translation</span><br><span class="line">            &#123;</span><br><span class="line">                Value = randomizer.NextFloat3() * <span class="number">10</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我得到了一个正常支持 Entity 实例化的 companion particle systems, 很酷吧:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-97834b5340ef86b4326a2390efef9da6_b.jpg" alt="img"></p>
<p>截止到这里, companion game object 可以说是 conversion 过程的最后一块拼图了.</p>
<h2 id="GameObjectConversionUtility"><a href="#GameObjectConversionUtility" class="headerlink" title="GameObjectConversionUtility"></a>GameObjectConversionUtility</h2><p>如果前述的 convert and destroy 或者 convert and inject 规则你都不喜欢, 你完全可以使用下述static方法自行 convert.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Entity <span class="title">ConvertGameObjectHierarchy</span>(<span class="params">GameObject root, GameObjectConversionSettings settings</span>)</span></span><br></pre></td></tr></table></figure>

<p>但你得先拿到 GameObject才行. ConvertToEntity之所以方便是因为你添加时就选择了该对象, 另外还有它的子层级(根据模式的不同). 而现在你只能传入<strong>一个</strong>GameObject 参数到这个方法中.</p>
<p>root 自然是你想要 convert 的对象, 方法名字有 “hierarchy”, 它知道如何处理这些情况:</p>
<ul>
<li>如果root 是 prefab asset, 那么你得到的结果和前述在 conversion 中声明 prefab 的结果一样. 如果你不喜欢声明和创建 prefab entity 绑定在一起, 那么你可以一个一个来.</li>
<li>如果root 是 scene 中的对象, 它会和ConvertToEntity的工作模式类似, 要注意这个方法同时也会执行LinkedEntityGroup过程.</li>
</ul>
<p>settings可以通过 destination world 来获得:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GameObjectConversionSettings <span class="title">FromWorld</span>(<span class="params">World destinationWorld, BlobAssetStore blobAssetStore</span>)</span></span><br></pre></td></tr></table></figure>

<p>如非特殊, Destination world 通常是 World.DefaultGameObjectInjectionWorld. ConvertToEntity就会在内部默认使用该值.</p>
<p>BlobAssetStore我猜测是当你需要产生某些有BlobAssetReference字段的component时需要用到的东西, 目前你可以传入 null 或者 new BlobAssetStore , 但是记得要Dispose.</p>
<p><strong>GameObjectConversionUtility 其他有趣的方法</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConvertScene</span>(<span class="params">Scene scene, GameObjectConversionSettings settings</span>)</span></span><br></pre></td></tr></table></figure>

<p>和ConvertGameObjectHierarchy几乎一样, 只不过针对的是 scene 中所有的东西. 它不会添加LinkedEntityGroupbuffer, 除非scene中有被禁用的对象. (禁用行为参考前文).</p>
<p>这个方法比给每个 scene 对象都加上ConvertToEntity 要高级一些, 后者你无法得到disabled entity 作为结果. 有 ConvertToEntity且被禁用的GameObject 的 Awake 方法不会被调用, 也就完全不会有 conversion 过程.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> World <span class="title">ConvertIncrementalInitialize</span>(<span class="params">Scene scene, GameObjectConversionSettings settings</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ConvertIncremental</span>(<span class="params">World conversionWorld, IEnumerable&lt;GameObject&gt; gameObjects, ConversionFlags flags</span>)</span></span><br></pre></td></tr></table></figure>

<p>这两个方法是什么? 第一个返回 World, 看起来像是 scene 中的内容可能会变化, 你可以用还未销毁的 conversion world 增量地 convert scene中新增的内容.</p>
<p>这两个方法在 live link 系统中有被用到, 后文会解释.</p>
<h2 id="Subscene"><a href="#Subscene" class="headerlink" title="Subscene"></a><strong>Subscene</strong></h2><p>因为 subscene 还处于开发中, 用法随时可能改变, 所以我计划先写到这里, 不过我会大致解释一下, 然后等 entities package 正式发布.</p>
<p>现在你已经可以使用 GameObject 来编辑游戏, 在 ECS 的环境里运行了, 那么还缺点啥?</p>
<ul>
<li>你可能想要在<strong>编辑模式</strong>时查看 conversion 的结果, 无论你多么小心地设计 conversion 过程都有可能出错.</li>
<li>你太懒了, 不想复制粘贴ConvertToEntity, 或者使用 utility 里的 Scene 方法.</li>
<li>你想在发布游戏时, 游戏能预先转换好(<strong>pre-converted</strong>). 当加载 scene 时你就可以不用再重新运行转换过程, 而是加载 chunk 内存直接使用.</li>
<li>你懒得点”序列化 ECS 内存” 按钮来保存play mode下的内存供运行时使用, 更懒得添加内存加载的代码.</li>
<li>在 play mode 时, 你不想让这些 pure Entity 从 Hierarchy 窗口消失. (当然你也不想使用 inject 模式来实现, 这会导致重复绘制对象的问题). 在 inspector 快速查看和修改运行时的对象非常有用.</li>
</ul>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-c924c16e23d2b941e4058ae2a720f115_b.jpg" alt="img"></p>
<ul>
<li>你可能想要一边修改内容, 一边实时 convert 这些数据. (比如调整Transform后里面更新到 LocalToWorld/Translation)</li>
</ul>
<p>好消息是, 以上内容在 Subscene 里都是可行的! subscene 并不是比scene “少” 些东西, 而是被设计为可以嵌套进普通 scene 中的工具. 它的能力甚至比普通的 scene 要更强.</p>
<p>让我们开始吧, 先创建一个 GameObject并添加Subscenecomponent. 这时候你会被告知需要添加一个新的 Scene asset 用来存放 subscene 的内容.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-6d07337664d2fd541b8d1742f070e5e2_720w.jpg" alt="img"></p>
<p>你可以点击 “Edit” 来添加内容, 或者双击 scene asset 来打开 scene 进行修改 (这和常规的 scene 操作是一样的). 这里我添加了 2 个cube GameObject , 不过我不再需要ConvertToEntity了, scene 中的所有内容偶会被自动 convert (甚至还会警告你把已经没用的 ConvertToEntity 删掉).</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-cf47b079fde25956965c75cfafd062e8_720w.jpg" alt="img"></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-6ca9f8540a1bf57028c0878103a3d4d6_720w.jpg" alt="img"></p>
<p>现在当你进入 play mode, 两个”世界”的好处都能获得. Hybrid Renderer负责渲染, tris 数量正常, 没有重复的对象出现.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-b1487642fdc3ba9a7ab3fc3698c1d27b_720w.jpg" alt="img"></p>
<p>而且, 它们是<strong>可被选中</strong>的. 这意味着尽管已经被convert 并 <strong>destroy</strong> 了, 但不知为何点击 Hierarchy 的对象依然可以选中转换前的状态.</p>
<p>相应地, 如果你点击 scene view 你也可以选中 Hierarchy 中的对象!</p>
<p>你可能注意到上图中橙色的轮廓线不见了, 这时因为我开启了下面的选项:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-720ebb51d4072e9b804c87a57b1bf758_720w.jpg" alt="img"></p>
<p><strong>SceneView : Live Game State</strong> 意思是让 scene view 里面显示已经 convert 过的内容. 因此这时候 scene view 在使用 Hybrid Renderer 来渲染结果, 也无法显示那些橙色的轮廓线.</p>
<p><strong>SceneView: Editing State</strong> 则是让 scene view 在 play mode 时依然保持在 edit mode 时的状态, 这时候橙色轮廓线就能够显示了. 当然 cube 依然和 MeshFilter+MeshRenderer=RenderMesh设计地那样一样绘制. 但是如果 conversion 过程中将cube 染成了绿色, scene view 中将无法感知这一修改, cube 依然呈灰色.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-a1038be6c110edc989089a85047257eb_720w.jpg" alt="img"></p>
<p>最上面的 <strong>Live Conversion in Edit Mode</strong> 指示在 edit mode 时的行为, 你可以选中它然后在 edit mode 看到 convert 的状态. <strong>SceneView: Live Game State</strong> 开启而 <strong>Live Conversion in Edit Mode</strong> 保持禁用这种情况没什么用, 因为你本想要在scene view + edit mode 查看实时的游戏状态, 而同时你又禁止它这样做.</p>
<p>如果你在 play mode 时移动 scene 中的 Transform (很可能因为 subscene 用预先转换的状态保持了 Hierarchy 的完整), 则会通过增量地重新转换(reconverted, diff-ed)无缝地更新到新状态, 这套机制就是 <strong>live link.</strong></p>
<p><strong>比较 ConvertToEntity 和 Subscene</strong></p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-00f0364648daf575b2595c3583779473_720w.jpg" alt="img"></p>
<p>下面两图中, 前者是通过 Subscene 进行转换, 后者则通过ConvertToEntity. 两者都是 destroy 模式, 所以MeshFilter这样的 component object 会被销毁:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f669be4df96944af4b995954d229e5b7_720w.jpg" alt="img">Subscene, 上方是 CubeInside, 下方是 Cube</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-a1d3fdd0f7bf0aa49578990dc5109b99_720w.jpg" alt="img">ConvertToEntity, 上下同理</p>
<p>EditorRenderData,EntityGuid,SceneSection,SceneTag是这里最大的区别. 除了EntityGuid, 其他三者都是 ISharedComponentData. 所以基本不用操心 chunk 碎片的问题, 基本上所有 subscene 里的对象都会得到同样的结果.</p>
<p>ConvertToEntity或 subscene 都不会为层级结构添加LinkedEntityGroupbuffer, 但是因为 subscene 与 ConvertScene 方法的规则相同, 因此如果有被 disabled 的对象时, 它会添加LinkedEntityGroup.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-fa31f3d1c34e5328ea654b88792039bd_720w.jpg" alt="img"></p>
<p><strong>不是一次 conversion, 而是一个 scene!</strong></p>
<p>Unity 并不希望传达出”subscene 是一堆ConvertToEntity的结果”这样的观念, 这是一个真正的 scene.</p>
<p>包括在调用SceneManager.LoadScene 时. 下面的例子中, GO 有一个ConvertToEntity, InSubScene1什么都没有但是位于 subscene 中:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-d03443f3982058272989d61a6fda8259_720w.jpg" alt="img"></p>
<p>当进入 play mode 时, 两者都按照期望被转换了, Subscene 和ConvertToEntity 这时是等价的.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-0dd4504f76658d822b0c78eee4606300_720w.jpg" alt="img"></p>
<p>但如果我们 SceneManager.LoadScene 改变当前的 scene:</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-f26e95d0237f8cfb9753c38397a681d8_720w.jpg" alt="img"></p>
<p>可以看到 subscene 里的 entity 同样被删除了, 但是正如ConvertToEntity名字所隐含的意义, 转换后就和 scene 没什么关系了, GO 依然存在. 这对于 entity 的生命周期管理很有帮助. ( 在进入 scene 前, 相关 system 无需做无用功)</p>
<p>我猜想 DeclareDependency 应该对这个功能有所帮助.</p>
<p><img src="../../assets/images/2020-10-19-game-object-conversion-and-subscene/v2-36bbe1659c6b2da765b54421090f2319_720w.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>Win</tag>
        <tag>C</tag>
        <tag>游戏</tag>
        <tag>Unity</tag>
        <tag>UNITY</tag>
        <tag>proxy</tag>
        <tag>ugui</tag>
        <tag>mesh</tag>
      </tags>
  </entry>
</search>
